// Instantiate the object
var I18n = I18n || {};

// Set default locale to english
I18n.defaultLocale = "en";

// Set default handling of translation fallbacks to false
I18n.fallbacks = false;

// Set default separator
I18n.defaultSeparator = ".";

// Set current locale to null
I18n.locale = null;

// Set the placeholder format. Accepts `{{placeholder}}` and `%{placeholder}`.
I18n.PLACEHOLDER = /(?:\{\{|%\{)(.*?)(?:\}\}?)/gm;

I18n.isValidNode = function(obj, node, undefined) {
    return obj[node] !== null && obj[node] !== undefined;
}

I18n.lookup = function(scope, options) {
  var options = options || {}
    , lookupInitialScope = scope
    , translations = this.prepareOptions(I18n.translations)
    , messages = translations[options.locale || I18n.currentLocale()]
    , options = this.prepareOptions(options)
    , currentScope
  ;

  if (!messages){
    return;
  }

  if (typeof(scope) == "object") {
    scope = scope.join(this.defaultSeparator);
  }

  if (options.scope) {
    scope = options.scope.toString() + this.defaultSeparator + scope;
  }

  scope = scope.split(this.defaultSeparator);

  while (scope.length > 0) {
    currentScope = scope.shift();
    messages = messages[currentScope];

    if (!messages) {
      if (I18n.fallbacks && !options.fallback) {
        messages = I18n.lookup(lookupInitialScope, this.prepareOptions({ locale: I18n.defaultLocale, fallback: true }, options));
      }
      break;
    }
  }

  if (!messages && this.isValidNode(options, "defaultValue")) {
    messages = options.defaultValue;
  }

  return messages;
};

// Merge serveral hash options, checking if value is set before
// overwriting any value. The precedence is from left to right.
//
//   I18n.prepareOptions({name: "John Doe"}, {name: "Mary Doe", role: "user"});
//   #=> {name: "John Doe", role: "user"}
//
I18n.prepareOptions = function() {
  var options = {}
    , opts
    , count = arguments.length
  ;

  for (var i = 0; i < count; i++) {
    opts = arguments[i];

    if (!opts) {
      continue;
    }

    for (var key in opts) {
      if (!this.isValidNode(options, key)) {
        options[key] = opts[key];
      }
    }
  }

  return options;
};

I18n.interpolate = function(message, options) {
  options = this.prepareOptions(options);
  var matches = message.match(this.PLACEHOLDER)
    , placeholder
    , value
    , name
  ;

  if (!matches) {
    return message;
  }

  for (var i = 0; placeholder = matches[i]; i++) {
    name = placeholder.replace(this.PLACEHOLDER, "$1");

    value = options[name];

    if (!this.isValidNode(options, name)) {
      value = "[missing " + placeholder + " value]";
    }

    regex = new RegExp(placeholder.replace(/\{/gm, "\\{").replace(/\}/gm, "\\}"));
    message = message.replace(regex, value);
  }

  return message;
};

I18n.translate = function(scope, options) {
  options = this.prepareOptions(options);
  var translation = this.lookup(scope, options);

  try {
    if (typeof(translation) == "object") {
      if (typeof(options.count) == "number") {
        return this.pluralize(options.count, scope, options);
      } else {
        return translation;
      }
    } else {
      return this.interpolate(translation, options);
    }
  } catch(err) {
    return this.missingTranslation(scope);
  }
};

I18n.localize = function(scope, value) {
  switch (scope) {
    case "currency":
      return this.toCurrency(value);
    case "number":
      scope = this.lookup("number.format");
      return this.toNumber(value, scope);
    case "percentage":
      return this.toPercentage(value);
    default:
      if (scope.match(/^(date|time)/)) {
        return this.toTime(scope, value);
      } else {
        return value.toString();
      }
  }
};

I18n.parseDate = function(date) {
  var matches, convertedDate;

  // we have a date, so just return it.
  if (typeof(date) == "object") {
    return date;
  };

  // it matches the following formats:
  //   yyyy-mm-dd
  //   yyyy-mm-dd[ T]hh:mm::ss
  //   yyyy-mm-dd[ T]hh:mm::ss
  //   yyyy-mm-dd[ T]hh:mm::ssZ
  //   yyyy-mm-dd[ T]hh:mm::ss+0000
  //
  matches = date.toString().match(/(\d{4})-(\d{2})-(\d{2})(?:[ T](\d{2}):(\d{2}):(\d{2}))?(Z|\+0000)?/);

  if (matches) {
    for (var i = 1; i <= 6; i++) {
      matches[i] = parseInt(matches[i], 10) || 0;
    }

    // month starts on 0
    matches[2] -= 1;

    if (matches[7]) {
      convertedDate = new Date(Date.UTC(matches[1], matches[2], matches[3], matches[4], matches[5], matches[6]));
    } else {
      convertedDate = new Date(matches[1], matches[2], matches[3], matches[4], matches[5], matches[6]);
    }
  } else if (typeof(date) == "number") {
    // UNIX timestamp
    convertedDate = new Date();
    convertedDate.setTime(date);
  } else if (date.match(/\d+ \d+:\d+:\d+ [+-]\d+ \d+/)) {
    // a valid javascript format with timezone info
    convertedDate = new Date();
    convertedDate.setTime(Date.parse(date))
  } else {
    // an arbitrary javascript string
    convertedDate = new Date();
    convertedDate.setTime(Date.parse(date));
  }

  return convertedDate;
};

I18n.toTime = function(scope, d) {
  var date = this.parseDate(d)
    , format = this.lookup(scope)
  ;

  if (date.toString().match(/invalid/i)) {
    return date.toString();
  }

  if (!format) {
    return date.toString();
  }

  return this.strftime(date, format);
};

I18n.strftime = function(date, format) {
  var options = this.lookup("date");

  if (!options) {
    return date.toString();
  }

  options.meridian = options.meridian || ["AM", "PM"];

  var weekDay = date.getDay()
    , day = date.getDate()
    , year = date.getFullYear()
    , month = date.getMonth() + 1
    , hour = date.getHours()
    , hour12 = hour
    , meridian = hour > 11 ? 1 : 0
    , secs = date.getSeconds()
    , mins = date.getMinutes()
    , offset = date.getTimezoneOffset()
    , absOffsetHours = Math.floor(Math.abs(offset / 60))
    , absOffsetMinutes = Math.abs(offset) - (absOffsetHours * 60)
    , timezoneoffset = (offset > 0 ? "-" : "+") + (absOffsetHours.toString().length < 2 ? "0" + absOffsetHours : absOffsetHours) + (absOffsetMinutes.toString().length < 2 ? "0" + absOffsetMinutes : absOffsetMinutes)
  ;

  if (hour12 > 12) {
    hour12 = hour12 - 12;
  } else if (hour12 === 0) {
    hour12 = 12;
  }

  var padding = function(n) {
    var s = "0" + n.toString();
    return s.substr(s.length - 2);
  };

  var f = format;
  f = f.replace("%a", options.abbr_day_names[weekDay]);
  f = f.replace("%A", options.day_names[weekDay]);
  f = f.replace("%b", options.abbr_month_names[month]);
  f = f.replace("%B", options.month_names[month]);
  f = f.replace("%d", padding(day));
  f = f.replace("%e", day);
  f = f.replace("%-d", day);
  f = f.replace("%H", padding(hour));
  f = f.replace("%-H", hour);
  f = f.replace("%I", padding(hour12));
  f = f.replace("%-I", hour12);
  f = f.replace("%m", padding(month));
  f = f.replace("%-m", month);
  f = f.replace("%M", padding(mins));
  f = f.replace("%-M", mins);
  f = f.replace("%p", options.meridian[meridian]);
  f = f.replace("%S", padding(secs));
  f = f.replace("%-S", secs);
  f = f.replace("%w", weekDay);
  f = f.replace("%y", padding(year));
  f = f.replace("%-y", padding(year).replace(/^0+/, ""));
  f = f.replace("%Y", year);
  f = f.replace("%z", timezoneoffset);

  return f;
};

I18n.toNumber = function(number, options) {
  options = this.prepareOptions(
    options,
    this.lookup("number.format"),
    {precision: 3, separator: ".", delimiter: ",", strip_insignificant_zeros: false}
  );

  var negative = number < 0
    , string = Math.abs(number).toFixed(options.precision).toString()
    , parts = string.split(".")
    , precision
    , buffer = []
    , formattedNumber
  ;

  number = parts[0];
  precision = parts[1];

  while (number.length > 0) {
    buffer.unshift(number.substr(Math.max(0, number.length - 3), 3));
    number = number.substr(0, number.length -3);
  }

  formattedNumber = buffer.join(options.delimiter);

  if (options.precision > 0) {
    formattedNumber += options.separator + parts[1];
  }

  if (negative) {
    formattedNumber = "-" + formattedNumber;
  }

  if (options.strip_insignificant_zeros) {
    var regex = {
        separator: new RegExp(options.separator.replace(/\./, "\\.") + "$")
      , zeros: /0+$/
    };

    formattedNumber = formattedNumber
      .replace(regex.zeros, "")
      .replace(regex.separator, "")
    ;
  }

  return formattedNumber;
};

I18n.toCurrency = function(number, options) {
  options = this.prepareOptions(
    options,
    this.lookup("number.currency.format"),
    this.lookup("number.format"),
    {unit: "$", precision: 2, format: "%u%n", delimiter: ",", separator: "."}
  );

  number = this.toNumber(number, options);
  number = options.format
    .replace("%u", options.unit)
    .replace("%n", number)
  ;

  return number;
};

I18n.toHumanSize = function(number, options) {
  var kb = 1024
    , size = number
    , iterations = 0
    , unit
    , precision
  ;

  while (size >= kb && iterations < 4) {
    size = size / kb;
    iterations += 1;
  }

  if (iterations === 0) {
    unit = this.t("number.human.storage_units.units.byte", {count: size});
    precision = 0;
  } else {
    unit = this.t("number.human.storage_units.units." + [null, "kb", "mb", "gb", "tb"][iterations]);
    precision = (size - Math.floor(size) === 0) ? 0 : 1;
  }

  options = this.prepareOptions(
    options,
    {precision: precision, format: "%n%u", delimiter: ""}
  );

  number = this.toNumber(size, options);
  number = options.format
    .replace("%u", unit)
    .replace("%n", number)
  ;

  return number;
};

I18n.toPercentage = function(number, options) {
  options = this.prepareOptions(
    options,
    this.lookup("number.percentage.format"),
    this.lookup("number.format"),
    {precision: 3, separator: ".", delimiter: ""}
  );

  number = this.toNumber(number, options);
  return number + "%";
};

I18n.pluralize = function(count, scope, options) {
  var translation;

  try {
    translation = this.lookup(scope, options);
  } catch (error) {}

  if (!translation) {
    return this.missingTranslation(scope);
  }

  var message;
  options = this.prepareOptions(options);
  options.count = count.toString();

  switch(Math.abs(count)) {
    case 0:
      message = this.isValidNode(translation, "zero") ? translation.zero :
                this.isValidNode(translation, "none") ? translation.none :
                this.isValidNode(translation, "other") ? translation.other :
                this.missingTranslation(scope, "zero");
      break;
    case 1:
      message = this.isValidNode(translation, "one") ? translation.one : this.missingTranslation(scope, "one");
      break;
    default:
      message = this.isValidNode(translation, "other") ? translation.other : this.missingTranslation(scope, "other");
  }

  return this.interpolate(message, options);
};

I18n.missingTranslation = function() {
  var message = '[missing "' + this.currentLocale()
    , count = arguments.length
  ;

  for (var i = 0; i < count; i++) {
    message += "." + arguments[i];
  }

  message += '" translation]';

  return message;
};

I18n.currentLocale = function() {
  return (I18n.locale || I18n.defaultLocale);
};

// shortcuts
I18n.t = I18n.translate;
I18n.l = I18n.localize;
I18n.p = I18n.pluralize;
var I18n = I18n || {};
I18n.translations = {"en":{"date":{"formats":{"default":"%Y-%m-%d","short":"%b %d","long":"%B %d, %Y"},"day_names":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"abbr_day_names":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"month_names":[null,"January","February","March","April","May","June","July","August","September","October","November","December"],"abbr_month_names":[null,"Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"order":["year","month","day"]},"time":{"formats":{"default":"%a, %d %b %Y %H:%M:%S %z","short":"%d %b %H:%M","long":"%B %d, %Y %H:%M","date":"%Y-%m-%d"},"am":"am","pm":"pm"},"support":{"array":{"words_connector":", ","two_words_connector":" and ","last_word_connector":", and "}},"number":{"format":{"separator":".","delimiter":",","precision":3,"significant":false,"strip_insignificant_zeros":false},"currency":{"format":{"format":"%u%n","unit":"$","separator":".","delimiter":",","precision":2,"significant":false,"strip_insignificant_zeros":false}},"percentage":{"format":{"delimiter":",","format":"%n%"}},"precision":{"format":{"delimiter":","}},"human":{"format":{"delimiter":",","precision":3,"significant":true,"strip_insignificant_zeros":true},"storage_units":{"format":"%n %u","units":{"byte":{"one":"Byte","other":"Bytes"},"kb":"KB","mb":"MB","gb":"GB","tb":"TB"}},"decimal_units":{"format":"%n %u","units":{"unit":"Unit","thousand":"Thousand","million":"Million","billion":{"one":"Billion","other":"Billion"},"trillion":"Trillion","quadrillion":{"one":"Quadrillion","other":"Quadrillion"}}}}},"errors":{"format":"%{attribute} %{message}","messages":{"inclusion":"is not included in the list","exclusion":"is reserved","invalid":"is invalid","confirmation":"not equal with confirmation","accepted":"must be accepted","empty":"can't be empty","blank":"can't be blank","present":"must be blank","too_long":{"one":"is too long (maximum is 1 character)","other":"is too long (maximum is %{count} characters)"},"too_short":{"one":"is too short (minimum is 1 character)","other":"is too short (minimum is %{count} characters)"},"wrong_length":{"one":"is the wrong length (should be 1 character)","other":"is the wrong length (should be %{count} characters)"},"not_a_number":"is not a number","not_an_integer":"must be an integer","greater_than":{"one":"must be greater than %{count}","other":"must be greater than %{count}"},"greater_than_or_equal_to":{"one":"must be greater than or equal to %{count}","other":"must be greater than or equal to %{count}"},"equal_to":{"one":"must be equal to %{count}","other":"must be equal to %{count}"},"less_than":{"one":"must be less than %{count}","other":"must be less than %{count}"},"less_than_or_equal_to":{"one":"must be less than or equal to %{count}","other":"must be less than or equal to %{count}"},"other_than":{"one":"must be other than %{count}","other":"must be other than %{count}"},"odd":"must be odd","even":"must be even","taken":"has already been taken","already_confirmed":"was already confirmed, please try signing in","confirmation_period_expired":"needs to be confirmed within %{period}, please request a new one","expired":"has expired, please request a new one","invalid_date":"is not a valid date","not_found":"not found","not_locked":"was not locked","not_saved":{"one":"1 error prohibited this %{resource} from being saved:","other":"%{count} errors prohibited this %{resource} from being saved:"},"readonly":"readonly","record_invalid":"Validation failed: %{errors}","restrict_dependent_destroy":{"many":"Cannot delete record because dependent %{record} exist","one":"Cannot delete record because a dependent %{record} exists"},"in_between":"must be in between %{min} and %{max}","spoofed_media_type":"has contents that are not what they are reported to be"},"template":{"body":"There were problems with the following fields:","header":{"one":"1 error prohibited this %{model} from being saved","other":"%{count} errors prohibited this %{model} from being saved"}},"unavailable_session":"Session %{id} is is no longer available in memory.\n\nIf you happen to run on a multi-process server (like Unicorn or Puma) the process\nthis request hit doesn't store %{id} in memory. Consider turning the number of\nprocesses/workers to one (1) or using a different server in development.\n","unacceptable_request":"A supported version is expected in the Accept header.\n","connection_refused":"Oops! Failed to connect to the Web Console middleware.\nPlease make sure a rails development server is running.\n"},"activerecord":{"errors":{"messages":{"record_invalid":"Record is invalid %{errors}","restrict_dependent_destroy":{"one":"Cannot delete record because a dependent %{record} exists","many":"Cannot delete record because dependent %{record} exist"},"accepted":"has to be accepted","blank":"required","confirmation":"not equal","empty":"required","equal_to":{"one":"must be equal to %{count}","other":"must be equal to %{count}"},"even":"must be even","exclusion":"not available","greater_than":{"one":"must be greater than %{count}","other":"must be greater than %{count}"},"greater_than_or_equal_to":{"one":"must be greater or equal %{count}","other":"must be greater or equal %{count}"},"inclusion":"invalid","invalid":"invalid","invalid_date":"is not a valid date","less_than":{"one":"must be smaller than %{count}","other":"must be smaller than %{count}"},"less_than_or_equal_to":{"one":"must be smaller or equal than %{count}","other":"must be smaller or equal than %{count}"},"not_a_number":"not a number","not_an_integer":"not an integer","odd":"must be odd","taken":"already taken","too_long":{"one":"too long (only %{count} chars allowed)","other":"too long (only %{count} chars allowed)"},"too_short":{"one":"too short (minimum of %{count} chars required)","other":"too short (minimum of %{count} chars required)"},"validation":"has to be at least 5 chars and to contain one decimal","wrong_length":{"one":"wrong length (must be exactly %{count} chars)","other":"wrong length (must be exactly %{count} chars)"},"invalid_event":"cannot transition when %{state}","invalid_transition":"cannot transition via \"%{event}\""}},"attributes":{"admin_user":{"created_at":"Created at","current_sign_in_at":"Current sign in at","current_sign_in_ip":"Current IP-Address","email":"Email","encrypted_Password":"Encrypted password","id":"ID","last_sign_in_at":"Last sign-in at","last_sign_in_ip":"Last sign-in IP","remember_created_at":"Remember password since","reset_password_sent_at":"Password reset instructions sent at","reset_password_token":"Passwort reset token","sign_in_count":"Sign-in count","updated_at":"Updated at"},"pageflow/account":{"created_at":"Created at","default_file_rights":"Default file credits","default_theming":"Default theming","entries_count":"# Entries","landing_page_name":"Landing page","name":"Name","users_count":"# Users"},"pageflow/audio_file":{"duration":"Duration","format":"Format"},"pageflow/chapter":{"display_parent_page_button":"Display 'Parent Page'-Button","navigation_bar_mode":"Navigation Bar","parent_page_perma_id":"Parent Page","title":"Title"},"pageflow/entry":{"account":"Account","author":"Author","created_at":"Created at","credits":"Credits","edited_at":"Updated at","emphasize_chapter_beginning":"Emphasize chapter beginning","emphasize_new_pages":"Emphasize new pages","first_published_at":"First published at","home_button_enabled":"Show 'Home' button","home_url":"'Home' Button URL","keywords":"Keywords","locale":"Language","manual_start":"Show Instruction-Overlay","overview_button_enabled":"Show 'Overview' button","published?":"Publication state","published_at":"Published since","published_revision_published_at":"Published since","publisher":"Publisher","share_image_id":"Social Sharing Image","share_url":"Social Sharing URL","summary":"Summary","title":"Title","updated_at":"Updated at","url":"Permalink","with_publication_state":"Publication state"},"pageflow/folder":{"account":"Account","name":"Name"},"pageflow/image_file":{"dimensions":"Dimensions"},"pageflow/membership":{"created_at":"Member since","entry":"Story","user":"Editor"},"pageflow/page":{"additional_description":"Infobox Description","additional_title":"Infobox Title","allow_full_screen":"Allow fullscreen","atmo_audio_file_id":"Atmo Audio","atmo_during_playback":"Atmo during playback","audio_file_id":"Audio","auto_change_page_on_ended":"Go to next page on end","autoplay":"Autoplay","background_image_id":"Background-Image","background_video_id":"Background-Video","delayed_text_fade_in":"Fade in text after delay","description":"Description (Overview)","display_in_navigation":"Show in navigationbar","emphasize_in_navigation":"Emphasize in navigationbar","gradient_opacity":"Gradient opacity","hide_title":"Hide titles","invert":"Invert colors","linked_page_ids":"Link pages","linked_pages_layout":"Hero","mobile_poster_image_id":"Posterimage (mobile)","poster_image_id":"Posterimage","scroll_indicator_mode":"Visible scroll indicators","scroll_indicator_orientation":"Scroll indicator orientation","subtitle":"Subtitle","tagline":"Tagline","template":"Pagetype","text":"Text","text_position":"Textposition","thumbnail_image_id":"Thumbnail","title":"Title","transition":"Transition effect","video_file_id":"Video","linked_external_site_perma_ids":"External Sites","after_image_id":"Right image","before_image_id":"Left image","control_bar_text":"Start-button caption","image_description":"Image caption","inline_text_position":"Text block position","invert_text":"Invert text area colors","invert_title":"Invert title area colors","prevent_fullscreen":"Disable fullscreen","sticky_inline_image":"Sticky image position","text_coverage":"Text coverage","text_image_id":"Inline image","text_titel":"Title","text_title":"Text title","title_position":"Title position","topasset_dim":"Header fade effect","topasset_parallax":"Header parallax effect","embedded_video_id":"Video URL","full_width":"Full width","video_caption":"Caption","scraped_site_id":"Chart URL"},"pageflow/revision":{"created_at":"Created at","created_with":"Created by","creator":"Created by","frozen_at":"Effective","published_at":"Published at","published_until":"Published until","updated_at":"Updated at"},"pageflow/theming":{"additional_cnames":"Additional CNAMES","cname":"CNAME","copyright_link_label":"Copyright link Text","copyright_link_url":"Copyright link URL","default_author":"Default author","default_keywords":"Default keywords","default_publisher":"Default publisher","home_button_enabled_by_default":"'Home'-Button enabled by default","home_url":"Redirect URL","imprint_link_label":"Legal notice link label","imprint_link_url":"Legal notice link URL","theme_name":"Theme"},"pageflow/video_file":{"dimensions":"Dimensions","duration":"Duration","format":"Format"},"user":{"account":"Account","admin":"Administrator","admin?":"Administrator","created_at":"Registered at","current_password":"Current password","current_sign_in_at":"Signed in at","email":"Email address","entry":"Story","first_name":"First name","full_name":"Full name","last_name":"Last name","last_sign_in_at":"Last signed in at","locale":"Language","membership":"Membership","password":"Password","password_confirmation":"Password confirmation","role":"Role","sign_in_count":"# of sign ins","suspended?":"Suspended","unconfirmed_email":"Unconfirmed Email"},"pageflow/external_links/site":{"description":"Description","open_in_new_tab":"Open in new tab","thumbnail":"Thumbnail","title":"Title","url":"Target URL"},"pageflow/linkmap_page/area":{"link_description":"Link decription text","link_title":"Link description title","marker":"Link display","name":"Label","page_transition":"Page transition","target_id":"Target","target_type":"Area type","inverted":"Invert"}},"models":{"account":{"one":"Account","other":"Accounts"},"admin_user":{"one":"Administrator","other":"Administrators"},"entry":{"one":"Story","other":"Stories"},"folder":{"one":"Folder","other":"Folders"},"membership":{"one":"Membership","other":"Memberships"},"pageflow/account":{"one":"Account","other":"Accounts"},"pageflow/entry":{"one":"Story","other":"Stories"},"pageflow/folder":{"one":"Folder","other":"Folders"},"pageflow/membership":{"one":"Membership","other":"Memberships"},"pageflow/revision":{"one":"Version","other":"Versions"},"pageflow/theming":{"one":"Theming","other":"Themings"},"revision":{"one":"Version","other":"Versions"},"theming":{"one":"Theming","other":"Themings"},"user":{"one":"User","other":"Users"}},"values":{"pageflow/chapter":{"navigation_bar_mode":{"all":"All pages","current_chapter":"Current chapter only","inherit_from_parent":"Inherit from parent chapter","non":"Hide","same_parent_chapter":"Chapters with same parent chapter only","same_parent_page":"Chapters with same parent page only"}},"pageflow/entry":{"publication_states":{"not_published":"Not published","published_with_password_protection":"Published with password protection","published_without_password_protection":"Published without password protection"}},"pageflow/page":{"atmo_during_playback":{"mute":"Mute","play":"Keep playing","turn_down":"Keep playing at lower volume"},"delayed_text_fade_in":{"long":"Long delay","medium":"Medium delay","no_fade":"No fade in","short":"Short delay"},"linked_pages_layout":{"default":"(none)","hero_top_left":"Top left","hero_top_right":"Top right"},"scroll_indicator_mode":{"all":"Forwards and Backwards","non":"Non","only_back":"Backwards only","only_next":"Forwards only"},"scroll_indicator_orientation":{"horizontal":"Horizontal","vertical":"Vertical"},"template":{"audio":"Audio","audio_loop":"Background-Audio","background_image":"Background-Image","background_video":"Background-Video","internal_links":"Internal Links","video":"Video"},"text_position":{"left":"Left","right":"Right","center":"Center"},"transition":{"fade":"Fade","scroll":"Scroll"},"inline_text_position":{"center":"Center","left":"Left","right":"Right"},"text_coverage":{"banner":"Banner","extend_into":"Text partially visible","title_only":"Title area only"}},"pageflow/linkmap_page/area":{"marker":{"dynamic_marker":"Circle","no_marker":"None"},"target_type":{"audio_file":"Audio file","external_site":"External link","page":"Page link","text_only":"Text only"}}}},"datetime":{"distance_in_words":{"half_a_minute":"half a minute","less_than_x_seconds":{"one":"less than 1 second","other":"less than %{count} seconds"},"x_seconds":{"one":"1 second","other":"%{count} seconds"},"less_than_x_minutes":{"one":"less than a minute","other":"less than %{count} minutes"},"x_minutes":{"one":"1 minute","other":"%{count} minutes"},"about_x_hours":{"one":"about 1 hour","other":"about %{count} hours"},"x_days":{"one":"1 day","other":"%{count} days"},"about_x_months":{"one":"about 1 month","other":"about %{count} months"},"x_months":{"one":"1 month","other":"%{count} months"},"about_x_years":{"one":"about 1 year","other":"about %{count} years"},"over_x_years":{"one":"over 1 year","other":"over %{count} years"},"almost_x_years":{"one":"almost 1 year","other":"almost %{count} years"}},"prompts":{"year":"Year","month":"Month","day":"Day","hour":"Hour","minute":"Minute","second":"Seconds"}},"helpers":{"select":{"prompt":"Please select"},"submit":{"create":"Create %{model}","update":"Update %{model}","submit":"Save %{model}"},"page_entries_info":{"one_page":{"display_entries":{"zero":"No %{entry_name} found","one":"Displaying \u003cb\u003e1\u003c/b\u003e %{entry_name}","other":"Displaying \u003cb\u003eall %{count}\u003c/b\u003e %{entry_name}"}},"more_pages":{"display_entries":"Displaying %{entry_name} \u003cb\u003e%{first}\u0026nbsp;-\u0026nbsp;%{last}\u003c/b\u003e of \u003cb\u003e%{total}\u003c/b\u003e in total"}}},"flash":{"actions":{"create":{"notice":"%{resource_name} was successfully created."},"update":{"notice":"%{resource_name} was successfully updated."},"destroy":{"notice":"%{resource_name} was successfully destroyed.","alert":"%{resource_name} could not be destroyed."}}},"ransack":{"search":"search","predicate":"predicate","and":"and","or":"or","any":"any","all":"all","combinator":"combinator","attribute":"attribute","value":"value","condition":"condition","sort":"sort","asc":"ascending","desc":"descending","predicates":{"eq":"equals","eq_any":"equals any","eq_all":"equals all","not_eq":"not equal to","not_eq_any":"not equal to any","not_eq_all":"not equal to all","matches":"matches","matches_any":"matches any","matches_all":"matches all","does_not_match":"doesn't match","does_not_match_any":"doesn't match any","does_not_match_all":"doesn't match all","lt":"less than","lt_any":"less than any","lt_all":"less than all","lteq":"less than or equal to","lteq_any":"less than or equal to any","lteq_all":"less than or equal to all","gt":"greater than","gt_any":"greater than any","gt_all":"greater than all","gteq":"greater than or equal to","gteq_any":"greater than or equal to any","gteq_all":"greater than or equal to all","in":"in","in_any":"in any","in_all":"in all","not_in":"not in","not_in_any":"not in any","not_in_all":"not in all","cont":"contains","cont_any":"contains any","cont_all":"contains all","not_cont":"doesn't contain","not_cont_any":"doesn't contain any","not_cont_all":"doesn't contain all","start":"starts with","start_any":"starts with any","start_all":"starts with all","not_start":"doesn't start with","not_start_any":"doesn't start with any","not_start_all":"doesn't start with all","end":"ends with","end_any":"ends with any","end_all":"ends with all","not_end":"doesn't end with","not_end_any":"doesn't end with any","not_end_all":"doesn't end with all","true":"is true","false":"is false","present":"is present","blank":"is blank","null":"is null","not_null":"is not null"}},"active_admin":{"access_denied":{"message":"You are not authorized to perform this action."},"any":"Any","batch_actions":{"action_label":"%{title} Selected","button_label":"Batch Actions","default_confirmation":"Are you sure you want to do this?","delete_confirmation":"Are you sure you want to delete these %{plural_model}?","labels":{"destroy":"Delete"},"link":"Create one","selection_toggle_explanation":"(Toggle Selection)","succesfully_destroyed":{"one":"Successfully destroyed 1 %{model}","other":"Successfully destroyed %{count} %{plural_model}"}},"blank_slate":{"content":"There are no %{resource_name} yet.","link":"Create one"},"cancel":"Cancel","clear_filters":"Clear filters","comments":{"add":"Add Comment","author":"Author","author_missing":"Anonymous","author_type":"Author Type","body":"Body","errors":{"empty_text":"Comment wasn't saved, text was empty."},"no_comments_yet":"No comments yet.","resource":"Resource","resource_type":"Resource Type","title":"Comment","title_content":"Comments (%{count})","created_at":"Created","delete":"Delete Comment","delete_confirmation":"Are you sure you want to delete these comment?"},"create_model":"Create %{model}","dashboard":"Dashboard","dashboard_welcome":{"call_to_action":"To add dashboard sections, checkout 'app/admin/dashboard.rb'","welcome":"Welcome to Active Admin. This is the default dashboard page."},"delete":"Delete","delete_confirmation":"Are you sure you want to delete this?","delete_model":"Delete %{model}","details":"%{model} Details","devise":{"change_password":{"submit":"Change my password","title":"Change your password"},"email":{"title":"Email"},"links":{"forgot_your_password":"Forgot your password?","resend_confirmation_instructions":"Re-send confirmation instructions","resend_unlock_instructions":"Re-send unlock instructions","sign_in":"Sign in","sign_in_with_omniauth_provider":"Sign in with %{provider}","sign_up":"Sign up"},"login":{"remember_me":"Remember me","submit":"Login","title":"Login"},"password":{"title":"Password"},"resend_confirmation_instructions":{"submit":"Resend confirmation instructions","title":"Resend confirmation instructions"},"reset_password":{"submit":"Reset My Password","title":"Forgot your password?"},"sign_up":{"submit":"Sign up","title":"Sign up"},"subdomain":{"title":"Subdomain"},"unlock":{"submit":"Resend unlock instructions","title":"Resend unlock instructions"},"username":{"title":"Username"}},"download":"Download:","dropdown_actions":{"button_label":"Actions"},"edit":"Edit","edit_model":"Edit %{model}","empty":"Empty","equal_to":"Equal to","filter":"Filter","filters":{"buttons":{"clear":"Clear Filters","filter":"Filter"},"predicates":{"contains":"Contains","ends_with":"Ends with","equals":"Equals","greater_than":"Greater than","less_than":"Less than","starts_with":"Starts with"}},"greater_than":"Greater than","has_many_delete":"Delete","has_many_new":"Add New %{model}","has_many_remove":"Remove","index_list":{"block":"List","blog":"Blog","grid":"Grid","table":"Table"},"less_than":"Less than","logout":"Logout","main_content":"Please implement %{model}#main_content to display content.","new_model":"New %{model}","next":"Next","pagination":{"empty":"No %{model} found","entry":{"one":"entry","other":"entries"},"multiple":"Displaying %{model} \u003cb\u003e%{from}\u0026nbsp;-\u0026nbsp;%{to}\u003c/b\u003e of \u003cb\u003e%{total}\u003c/b\u003e in total","multiple_without_total":"Displaying %{model} \u003cb\u003e%{from}\u0026nbsp;-\u0026nbsp;%{to}\u003c/b\u003e","one_page":"Displaying \u003cb\u003eall %{n}\u003c/b\u003e %{model}","one":"Displaying \u003cb\u003e1\u003c/b\u003e %{model}"},"powered_by":" ","previous":"Previous","scopes":{"frozen":"All","publications":"Only published","publications_and_user_snapshots":"Only published/snapshots"},"search_field":"Search %{field} ","sidebars":{"filters":"Filters","folders":"Folders","search_status":"Search Status"},"status_tag":{"no":"No","yes":"Yes"},"undelete":"Undelete","unsupported_browser":{"headline":"Please note that Internet Explorer versions 9 or less is no longer supported.","recommendation":"We recommend upgrading to the latest \u003ca href=\"http://windows.microsoft.com/ie\"\u003eInternet Explorer\u003c/a\u003e, \u003ca href=\"https://chrome.google.com/\"\u003eGoogle Chrome\u003c/a\u003e, or \u003ca href=\"https://mozilla.org/firefox/\"\u003eFirefox\u003c/a\u003e.","turn_off_compatibility_view":"If you are using IE 9 or later, make sure you \u003ca href=\"http://windows.microsoft.com/en-US/windows7/webpages-look-incorrect-in-Internet-Explorer\"\u003eturn off \"Compatibility View\"\u003c/a\u003e."},"view":"View","search_status":{"headline":"Search status:","current_scope":"Scope:","current_filters":"Current filters:","no_current_filters":"None"}},"devise":{"confirmations":{"confirmed":"Your account was successfully confirmed. You are now signed in.","send_instructions":"You will receive an email with instructions about how to confirm your account in a few minutes.","send_paranoid_instructions":"If your email address exists in our database, you will receive an email with instructions about how to confirm your account in a few minutes."},"failure":{"admin_user":{"invalid":"Password or username was not correct.","unauthenticated":"Please log-in using an administrator account."},"already_authenticated":"You are already signed in.","inactive":"Your account was not activated yet.","invalid":"Invalid email or password.","invalid_token":"Invalid authentication token.","locked":"Your account is locked.","not_found_in_database":"Invalid email or password.","timeout":"Your session expired, please sign in again to continue.","unauthenticated":"You need to sign in or sign up before continuing.","unconfirmed":"You have to confirm your account before continuing.","last_attempt":"You have one more attempt before your account is locked."},"mailer":{"confirmation_instructions":{"subject":"Confirmation instructions"},"reset_password_instructions":{"subject":"Reset password instructions"},"unlock_instructions":{"subject":"Unlock Instructions"},"password_change":{"subject":"Password Changed"}},"oauth_providers":{"facebook":"Facebook","google_oauth2":"Google"},"omniauth_callbacks":{"failure":"Could not authenticate you from %{kind} because \"%{reason}\".","success":"Successfully authenticated from %{kind} account."},"passwords":{"no_token":"You can't access this page without coming from a password reset email. If you do come from a password reset email, please make sure you used the full URL provided.","send_instructions":"You will receive an email with instructions about how to reset your password in a few minutes.","send_paranoid_instructions":"If your email address exists in our database, you will receive a password recovery link at your email address in a few minutes.","updated":"Your password was changed successfully. You are now signed in.","updated_not_active":"Your password was changed successfully."},"registrations":{"destroyed":"Bye! Your account was successfully cancelled. We hope to see you again soon.","edit":{"are_you_sure":"Are you sure?","change_password":"Change password","delete_account":"Delete account","submit":"Save","userdata":"Userinfo"},"new":{"cancel_oauth_sign_up":"Cancel","registration":"Registration","sign_up_with_facebook":"Log-in using Facebook","sign_up_with_google":"Log in using Google","submit":"Submit"},"signed_up":"Welcome! You have signed up successfully.","signed_up_but_inactive":"You have signed up successfully. However, we could not sign you in because your account is not yet activated.","signed_up_but_locked":"You have signed up successfully. However, we could not sign you in because your account is locked.","signed_up_but_unconfirmed":"A message with a confirmation link has been sent to your email address. Please open the link to activate your account.","update_needs_confirmation":"You updated your account successfully, but we need to verify your new email address. Please check your email and click on the confirm link to finalize confirming your new email address.","updated":"You updated your account successfully."},"sessions":{"admin_user":{"signed_in":"Successfully signed in as administrator."},"new":{"sign_in_with_facebook":"Sign in with Facebook","sign_in_with_google":"Sign in with Google"},"signed_in":"Signed in successfully.","signed_out":"Signed out successfully.","already_signed_out":"Signed out successfully."},"unlocks":{"send_instructions":"You will receive an email with instructions about how to unlock your account in a few minutes.","send_paranoid_instructions":"If your account exists, you will receive an email with instructions about how to unlock it in a few minutes.","unlocked":"Your account has been unlocked successfully. Please sign in to continue."}},"formtastic":{"cancel":"Cancel","create":"Create %{model} ","no":"No","required":"required","reset":"Reset %{model} ","submit":"Submit %{model} ","update":"Update %{model} ","yes":"Yes"},"language":"English","pageflow":{"admin":{"accounts":{"no_entries":"No Stories","no_members":"No members","widgets_inline_help":"The widgets selected here will be used as defaults for new entries in this account. Changes do not affect existing entries."},"entries":{"add_folder":"Add folder","confirm_depublish":"Unpublish this story?","confirm_duplicate":"Duplicate this story?","confirm_restore":"Restore story to the selected version? A snapshot will be created, so that you can roll back later.","depublish":"Unpublish story","duplicate":"Copy Story","edit":"Edit","edit_config":"Edit configuration","edit_revision":"Edit","editor":"Editor","editor_hint":"Open editor","entries":"Stories","forever":"(unlimited)","members":"Members","no_members":"No members assigned","no_revisions":"No versions yet","not_published":"Not yet published","password_protected":"Password protected","preview":"Preview","preview_hint":"Open preview","published_forever":"Published","published_revision_legend":"Currently published version","published_until":"Published until %{published_until}","remove":"Remove","remove_logo":"Remove logo","restore":"Restore","revision_created_with":{"auto":"Automatic snapshot","publish":"Publish","restore":"Automatic snapshot","user":"Manual snapshot"},"revision_created_with_hint":{"auto":"This version was automatically saved","publish":"This version has been published","restore":"This version has been automatically saved before an resrore was made","user":"This version was manually saved"},"show":"View","show_public":"Public","show_public_hint":"Visit public page","snapshot":"Save current version","title_hint":"This field determines the URL for this story."},"features":{"states":{"default":"Default (%{inherited})","disabled":"Disabled","enabled":"Enabled","undefined":"(Default)"}},"folders":{"all":"All","confirm_destroy":"Delete folder? Note: Containing stories will be preserved.","destroy":"Delete","edit":"Edit"},"resource_tabs":{"entries":"Stories","features":"Features","members":"Members","revisions":"Versions","users":"User"},"revisions":{"published_until_hint":"Leave blank to publish indefinitely."},"themings":{"additional_cnames_hint":"Comma separated list of additional CNAMES. Used only to select the correct redirect URL.","cname_hint":"For social sharing","default_author_hint":"Default 'author' meta field for entries","default_keywords_hint":"Default 'keywords' meta field for entries","default_publisher_hint":"Default 'publisher' meta field for entries","home_url_hint":"Used for requests to the root path with one of the above CNAMES. Default target location for the home button.","name":"%{account_name}","remove_logo":"Remove logo","show":"View"},"users":{"account":"Profile","add":"Add user","add_entry":"Add story","confirm_delete":"Delete this user? This action cannot be undone.","delete":"Delete","delete_me":{"cancel_label":"No, do not delete my account!","delete_label":"Delete account","warning_html":"Please enter your current password to confirm deletion of your account. \u003cb\u003eAll data will be deleted. This action cannot be undone.\u003c/b\u003e"},"deleted":"This user was deleted.","edit":"Edit","email_invitation_hint":"The user will be invited to choose a password.","empty":"This user has no associated stories. ","invite_user":"Invite user","me":{"change_password_hint":"Leave blank to keep your current password.","delete_account":"Delete account","delete_account_hint":"You don't want to continue using Scrollytelling?","deleted":"Your account has been deleted. You may sign-up for a new one at any time!","updated":"Your profile has been updated."},"none":"There are no stories.","resend_invitation":"Resend invitation email","resent_invitation":"The invitation email has been resent.","role_hint":{"admin":"Account-Administrators are able to manage all users and stories of their account only. System-Administrators can manage all settings.","others":"Account-Administrators are able to manage all users and stories of their account."},"roles":{"account_manager":"Account-Administrator","admin":"System-Administrator","editor":"Editor"},"suspend":"Suspend","suspended":"The user was suspended and will not be able to sign-in again. ","unsuspend":"Unsuspend","unsuspended":"The user was unsuspended."}},"atmo":{"feature_name":"Atmo Audios"},"audio":{"open":"Play audio"},"auto_change_page":{"feature_name":"Automatic Page Change"},"built_in_page_type":{"audio":{"page_type_category_name":"Audio","page_type_description":"Audio player with controls"},"audio_loop":{"page_type_category_name":"Audio","page_type_description":"Audio playback in the background without controls"},"background_image":{"page_type_category_name":"Basic","page_type_description":"Fullscreen image with text"},"background_video":{"page_type_category_name":"Video","page_type_description":"Fullscreen video loop without controls"},"internal_links":{"page_type_category_name":"Links","page_type_description":"A grid of thumbnails linking to other pages inside the story"},"video":{"page_type_category_name":"Video","page_type_description":"Video player with controls"}},"chapter_hierachy":{"feature_name":"Chapter Hierachy"},"common_page_link_attributes":{"label":{"inline_help":"Choose a label to recognize the link within the overview. This label is for your orientation only and will not be displayed to the reader.","label":"Label"},"page_transition":{"inline_help":"Choose the animation, that will be used to transition to the link's target page.","label":"Page transition"},"target_page_id":{"inline_help":"Users will get to this page when clicking the link.","label":"Target page"}},"delayed_text_fade_in":{"feature_name":"Delayed text fade in"},"devise":{"mailer":{"reset_password_instructions":{"ignore_hint":"Please ignore this mail If you have not requested a password reset. Your password will not be changed in this case.","instruction":"Somebody recently asked to reset your Scrollytelling password. Click here to change your password.","salutation":"Hello %{first_name}"}}},"edit_locks":{"break_action":{"acquire":"Continue here","aquire":"Continue here"},"errors":{"held_by_other_session_error":{"acquire_html":"\u003cp\u003eThis story is already open in another editor window.\u003c/p\u003e","other_html":"\u003cp\u003eThis story is already open in another editor window. Please reload this page and click on the 'Continue here' button.\u003c/p\u003e\n\u003cp\u003eIf you continue working without reload, data loss may occur.\u003c/p\u003e","aquire_html":"\u003cp\u003eThis story is already open in another editor window.\u003c/p\u003e"},"held_by_other_user_error":{"acquire_html":"\u003cp\u003e\u003cstrong\u003e%{user_name}\u003c/strong\u003e is currently working on this story or has left the editor window open. Click 'Continue here' to take over.\u003c/p\u003e","other_html":"\u003cp\u003e\u003cstrong\u003e%{user_name}\u003c/strong\u003e has ended your editor session. Please reload the page and click 'Continue here' to view the current version.\u003c/p\u003e","aquire_html":"\u003cp\u003e\u003cstrong\u003e%{user_name}\u003c/strong\u003e is currently working on this story or has left the editor window open. Click 'Continue here' to take over.\u003c/p\u003e"},"not_held_error":{"other_html":"\u003cp\u003eYour editor session has been ended from another session. Please reload the page and click 'Continue here' to view the current version.\u003c/p\u003e"}},"required":"This action cannot be executed because this story has been opened in another editor session.","required_but_held_by_other_user":"This action cannot be executed because this story has been opened by another user."},"editor":{"atmo":{"disabled":"Atmo disabled"},"blank_entry":{"create_chapter":"Click \u003cem\u003eNew chapter\u003c/em\u003e to create your first chapter.","create_page":"Use the \u003cem\u003eNew page\u003c/em\u003e button within the chapter to add pages.","edit_page":"Click directly on a page to switch to the pages edit view.","header":"This is an empty story","intro":"Each story consists of chapters and pages. The editor panel to your right shows the outline of your story.","outro":"In this area, a live preview will be shown."},"entries":{"unsupported_browser_hint":{"message":"The Pageflow editor does not support the browser version you are using. We recommend upgrading your browser to the most recent version."}},"errors":{"UnmatchedUploadError":"This filetype is not supported.","unknown":"A unknown error has occurred."},"files":{"stages":{"encoding":{"action_required":"Confirmation required.","active":"Encoding in progress.","failed":"Encoding failed.","finished":"Encoding was successful.","pending":"Encoding pending."},"fetching_meta_data":{"active":"Fetching metadata.","failed":"Metadata failure.","finished":"Metadata successfully fetched.","pending":"Metadata polling pending."},"processing":{"active":"Processing.","failed":"Processing failure.","finished":"Processing successfully finished.","pending":"Processing pending."},"uploading":{"active":"Upload in progress.","failed":"Upload failure.","finished":"Successfully uploaded.","pending":"Upload pending."},"uploading_to_s3":{"active":"Transfering to S3.","failed":"Transfer to S3 failed.","finished":"Successfully transferred to S3.","pending":"Transfer to S3 pending."}},"tabs":{"audio_files":"Audios","image_files":"Images","video_files":"Videos"}},"quotas":{"loading":"Checking quotas..."},"templates":{"back_button_decorator":{"outline":"Outline"},"background_positioning":{"cancel":"Cancel","help":"In order to have an optimal presentation on mobile devices you can adjust the image detail to the display.","preview_title":"Preview","previews":{"banner":"Banner","ratio16to9":"16:9 Landscape","ratio16to9Portrait":"16:9 Portrait","ratio4to3":"4:3 Landscape","ratio4to3Portrait":"4:3 Portrait"},"save":"Save","title":"Adjust position"},"chapter_item":{"new_page":"New page","save_error":"Errors were detected while saving this chapter."},"confirm_encoding":{"all_released":"All files have been scheduled for encoding. ","audios_tab":"Audios","confirm_button":"Encode selected files","link_to_progress":"The %{link} page shows encoding progress.","manage_files":"Manage files","videos_tab":"Videos"},"confirmable_file_item":{"remove":"Remove"},"edit_chapter":{"destroy":"Delete","outline":"Outline","retry":"Retry","save_error":"Errors were detected while saving this chapter."},"edit_entry":{"close":"Close","manage_files":"Manage files","metadata":"Title and options","publish":"Publish","save_error":"There were errors while saving metadata.","new_chapter":"New chapter","outline":"Outline"},"edit_meta_data":{"outline":"Outline","retry":"Retry","save_error":"There were errors while saving metadata."},"edit_page":{"destroy":"Delete","outline":"Outline","retry":"Retry","save_error":"There were errors while saving page."},"edit_page_link":{"back":"Back","destroy":"Delete"},"edit_storyline":{"destroy":"Delete","outline":"Outline","retry":"Retry","save_error":"Errors were detected while saving the storyline."},"embedded":{"page_link":{"reset":"Reset"}},"file_item":{"cancel":"Cancel","confirm":"Confirm","credits":"Credits","destroy":"Delete","download":"Download","retry":"Retry","select":"Select","source":"Source"},"files":{"back":"Back"},"files_blank_slate":{"no_files":"There are no files of this type, yet. You can upload one to get started."},"files_explorer":{"cancel":"Cancel","ok":"Ok","reuse_files":"Reuse files from other stories"},"files_explorer_blank_slate":{"choose_hint":"Please choose a story."},"files_gallery_blank_slate":{"no_files":"This story does not contain any files of this type."},"help":{"close":"Close","title":"Help"},"help_button":{"open_help":"Open help"},"inputs":{"reference":{"edit":"Edit","reset":"Reset"}},"list_blank_slate":{"text":"(No items)"},"list_item":{"edit":"Edit","remove":"Delete"},"loading":{"loading":"Loading..."},"locked":{"close":"Close editor","loading":"Loading story. Please wait...","open_here":"Continue here"},"notification":{"approve_files":"%{num_files} files awaiting confirmation for the encoding process.","retry":"Retry","save_error":"There were errors while saving changes.","saved":"All changes have been saved.","saving":"Saving changes...","show":"Show","upload_pending":"Uploads pending."},"other_entries_blank_slate":{"none_available":"There are no other stories yet"},"page_item":{"save_error":"There were errors while saving page."},"page_link_item":{"edit":"Edit page","remove":"Delete"},"page_links":{"add":"Add","label":"Linked pages"},"page_selection":{"cancel":"Cancel","ok":"OK","title":"Select target page"},"publish_entry":{"already_published_with_password_help":"This entry is already published with a password. Leave password field blank to keep the previous password.","already_published_without_password_help":"This entry is published without a password at the moment. Setting a password will prevent public access from now on.","date":"Date","files_pending_notice":"Please wait until all files have been processed and check the results. You may then publish your story.","not_published_notice":"This story is currently not published.","password":"Password","password_help":"Restrict access to the published version of this entry. Visiters will have to enter a password.","password_protected":"Protect with Password","previously_published_with_password_help":"This entry was published with a password before. Leave password field blank to keep the previous password.","publish":"Publish","publish_current":"Publish current version","publish_success":"Your story has been sucessfully published.","published_notice":"A version of this story is currently published.","published_url_hint":"It can be accessed using following URL:","show_files":"Show files","time":"Time","unlimited":"indefinitely","until_including":"Until including","user_name":"User name","view_revisions":"View versions"},"select_button":{"select":"Select"},"storyline_outline":{"header":"Outline","new_chapter":"New chapter"},"storyline_picker":{"add":"Add","edit":"Edit settings"}},"views":{"chapter_item_view":{"chapter":"Chapter","unnamed":"(New chapter)"},"edit_chapter_view":{"confirm_destroy":"Really delete this chapter including ALL its pages?\n\nThis operation cannot be undone."},"edit_page_link_view":{"default_page_transition":"(Default)"},"edit_page_view":{"confirm_destroy":"Really delete this page?"},"edit_storyline_view":{"cannot_destroy":"Only empty storylines can be deleted.","confirm_destroy":"Really delete storyline","default_parent_page_transition":"(Default)"},"editor_views":{"files_pending_warning":"You are currently uploading files. All uploads will be canceled if you leave this page.","hide_editor":"Hide editor panel","resize_editor":"Resize editor panel","show_editor":"Show editor panel"},"entry_preview_view":{"scroll_hint":"Scroll down to continue"},"files_view":{"add":"Add","reuse":"Reuse","upload":"Upload"},"inputs":{"reference_input_view":{"none":"(None)"}},"page_item_view":{"unnamed":"(New page)"},"page_link_item_view":{"no_page":"(No page)","unnamed":"(No title)"},"storylines_picker_view":{"label":"Storyline","without_parent_page":"Without parent page"}}},"entry":{"duplicated_title":"Copy of %{title}"},"help_entries":{"atmo":{"menu_item":"Atmo Audio","text":"# Atmo Audio\n\nThis feature lets you add background audio to every page regardless of its page type. You can define if a sound should play only for one page or continue playing for more pages without interruption. Simply select the same atmo audio file for some adjacent pages.\n\nThat way chapters can be seperated acoustically and pages that belong together can be weaved to a stronger unit.\n\nFor the page type „Video“ there is a special option to pause background audio or continue at lower volume while the video is playing.\n\nYou find the atmo settings on the „Options“ tab of each page.\n\nShould you ever feel distracted by the atmo audio while working on your entry, you can use the hot key „Alt + a“ to temporarily mute it. Simply press „Alt + a“ again to reactivate atmo audio."},"built_in_page_type":{"audio":{"menu_item":"Audio","text":"# Audio\n\n*Playing audio-files with controls*\n    \nHere you can combine audio-files with pictures and\ntext-content. Controls similar to the page type „Video“\nare shown.  In addition to that you can write a\ndescription into an „Infobox“.\n\nExamples of application: interviews, direct quotes, music"},"audio_loop":{"menu_item":"Audio Loop","text":"# Audio Loop\n\n*Playing an audio-loop without control (Ambience)*\n    \nA full-screen photo is shown as a „Background-Image“. The\ndifference to the normal Audio-Page is that the user\ncannot influence the audio-file by controlling it. Instead\nit is an endless-loop.\n\nTypical examples of application: Ambience, soundscape, field-recordings"},"background_image":{"menu_item":"Background Image","text":"# Background Image\n\nFull-screen image and text\n\nBy using the page type „Background-Image“, large pictures\nare the background for the text and are paired with a\nmanually adjustable color gradient for an optimal\nlegibility. In order to have an optimal presentation on\nmobile devices you can adjust the image detail to the\ndisplay. Optionally the text color can be inverted. This\nis especially useful for bright background-images.\n\nUsers are able to hide the color-gradient and text in\nthe front-end, if they want to have a view of the\nbackground-image.\n\nExamples: Presentation, part of a picture gallery,\nportrait"},"background_video":{"menu_item":"Background Video","text":"# Background Video\n\n*Full-screen video played in a loop without control* \n    \nThis type of page is comparable to „Background-Image“. But\ninstead of an image, a video is shown in the\nbackground. This video starts automatically and is played\nwithout control. Thus the user cannot influence the start\nand stop of the video. Since the video is played in an\nendless-loop, it should be long enough and it should have\na proper crossover. The same applies to the soundtrack.\n\nAs a hint for the use of Scrollytelling on a smartphone: In\norder to prevent unintended data consumption, the video is\nnot played on smartphones. Instead a poster-image is\nshown, which is generated automatically. You can however\nalso choose the image yourself.\n\nExamples of application: intro, chapter cross-fade,\nambience"},"internal_links":{"menu_item":"Internal Links","text":"# Internal Links\n\nReferences to other pages inside a story\n\nIn contrast to external link, you can link to pages inside\nyour story. This page type helps you guide your users\nthrough your story.\n\nExamples of application: Welcome page, chapter homepage\n"},"video":{"menu_item":"Video","text":"# Video\n\n*Playing a video with control*\n    \nIn contrast to „Background-Videos“ the text elements fade\nout after a few seconds, in order to draw attention to the\nvideo. With controls the user can start and pause the\nvideo or even fast-forward and rewind it. You can choose\nwhether the video should start automatically as soon as\nthe page is opened.\n\nAs an alternative to the normal text input, you can write\na description into an „Infobox“ with text.\n\nOn the „Options“ tab you can activate auto-scrolling to the next page at the end of a video. \nThis can be useful to create a seamless transition.\n\nExamples of application: Videos of all kinds, interviews,\nportraits"}},"files":{"menu_item":"Manage Files","text":"# Manage Files\n\nScrollytelling processes all major media formats (photo, audio,\nvideo) and converts them into different formats and\nqualities. The system adapts the quality of the media to the\ninternet connection and the end device of the user\nautomatically. In principle the files should be uploaded in\nthe optimal resolution and not be compressed beforehand. In\norder to have a well-structured work-flow, it is helpful to\nstore all audio-files, background-video-loops, movies,\npictures and texts in the required version in a separate\nfile on your computer.\n\n## Upload and Manage Files\n\nThe menu item „Manage Files“ leads to the files, which have\nalready been uploaded. If you click „Add more“ and „Upload“\nyou can add more files.\n\nAfter you have uploaded the files, they are processed on the\nserver. This can take a few minutes - especially if the\nvideos are long. Click on the thumbnail of a file, in order\nto see its status. Moreover you can see the general features\nlike the size of the picture or length of an audio-file and\nyou can download the original file.\n\nThe files can already be used before the process is\nfinished. You can therefore continue your work during the\nloading process.\n\n## Copyrights of Files\n\nIf you click on the thumbnail of a media file (picture,\nvideo, audio), you can add information with regards to its\ncopyright. This information is shown automatically in the\nlegal notice.\n\n## Reuse Files\n\nVideos, audio files and pictures can be used in more than\none article. Thus, videos, for example, do not have to be\nuploaded several times. Click on „Manage Files“ and on\n„Add“/„Reuse“, to search for files in other articles and add\nthem to a new one.\n"},"meta_data":{"menu_item":"Title and Options","text":"# Title and Options\n\n## General\n\n### Title of the story\n\nHere you can choose a title for your story. It will be\nshown on the title bar of the browser window. It also acts\nas an indicator for search engines once the report is\npublished.\n\n### Language\n\nDecide in which language your story should be\ndisplayed. This refers to text which cannot be edited - like\nmultimedia tips, scroll-indicators, the overview and the\nlegal notice.\n\n## Appearance\n\n### Multimedia tips before the start\n\nDecide if tips or advice should be shown at the beginning of\nyour story.\n\n### Highlighting chapter beginnings\n\nThis option lets the title of the first page of a chapter\nappear in a bigger font.\n\n### Highlighting new pages\n\nAt the beginning of a story an info-box shows new pages\nthat were created since the last visit.\n\n### Display Home-Button\n\nYou can have a button in the navigation, which hyperlinks to\nan external website, for example back to the website from\nwhich you hyperlinked to the story.\n\n### Navigation\n\nChoose between two forms of navigation: The navigation with\na progress bar or the navigation with thumbnails. Please\nnote, that due to the lack of space on mobile devices only\nthe icon „Overview“ is shown.\n\n## Social\n\n### Social Sharing Picture\n\nChoose a picture, which should be shown, if your story is\nshared in social networks.\n\n### Summary\n\nHere you can write a description, which is shown, when your\nstory is shared in social networks.\n"},"outline":{"menu_item":"Chapters and Pages","text":"# Chapters and Pages\n\nA story consists of at least one chapter with at least\none page. You can create as many chapters and pages as you\nwant. In order to create content, click:\n\n1. „New Chapter“ to create a new chapter,\n2. „New Page“ to add a page,\n3. onto the new page, in order to edit the content.\n\n## Structuring Chapters\n\nYou can structure the composition of your story with\nchapters - e.g. thematically or chronologically . The\nchapters are shown in the overview and help the users find\ntheir way around. It is therefore advisable to give each\nchapter a title.\n\nIf you create an unnamed chapter, Scrollytelling acts as if there\nis no structure of chapters. The chapter and the title of\nthis chapter are consequently not shown in the\noverview/navigation."},"overview":{"menu_item":"Overview","text":"# Overview\n\nThis is Scrollytelling’s editing platform. The division of the\nscreen into two allows you to edit your story and see a\npreview at the same time. The editor shows modifications and\nnewly selected files directly and saves them automatically.\n\nThe sidebar can be hidden or shown. You can change the size\nof the preview-window by pulling the sidebar to the right or\nthe left. If the preview-window is long and narrow like ´ a\nsmartphone, you will only be able to see the „overview“ icon\nand not the entire navigation. This is due to lack of space.\n\nThe navigation is divided into four parts:\n\n## Title and Options\n\nUnder „Title and Options“ you can set up basic appearance\nparameters as well as the title, language and legal\nnotice. You can also decide which content should be\ndisplayed when sharing the report on social media platforms.\n\nFor more details see: [Title and Options](#pageflow.help_entries.meta_data)\n\n## Manage Files\n\nUnder „Manage Files“ you can upload your media files, which\nyou want to use in your stories. Furthermore you can reuse\nvideos, photos and audio-files that have already been\nuploaded.\n\nFor more details see: [Manage Files](#pageflow.help_entries.files)\n\n## Outline\n\nVia the „Outline“ you can add chapters and pages - the\nactual content. Per Drag and Drop you can resort the pages\nand chapters any time.\n\nFor more details see: [Chapter and Pages](#pageflow.help_entries.outline)"},"page_options":{"menu_item":"General Page Options","text":"# General Page Options\n\n### Title\n\nHere you can add the title of a particular page. This\ntitle is not only the headline of the text on the page, it\nalso functions as the title in the navigation and\noverview. If a single page is shared in social networks,\nthis title is also the title of the social media post.\n\n### Hide the title\n\nOptionally you can hide the title. Thus the title is not shown as the\nheading of the text body. For the identification of the page it\nremains visible in the navigation, overview and on social media posts.\n\n### Tagline and Subtitle\n\nHere you can optionally enter a tagline and/or a\nsubtitle. If you click on „Hide title“ the tagline and\nsubtitle are not shown either.\n\n### Text\n\nThe text-block can be formatted with the buttons underneath\nthe input field. [B= bold / I=italic / U=underlined /\ninfinity symbol= Link/URL to an external website]\n\nAll changes are visible in the left front-end-view as soon\nas you leave the appropriate input field in the editor.\n\n### Textposition\n\nDecide if the text should be shown on the left or right side.\n\n### Opacity of the gradient\n\nThe opacity of the gradient improves the legibility of\nthe text on background-videos or pictures.\n\nYou can use the slider to darken or lighten up the\nbackground until the contrast between text and background is\noptimal.\n\n### Invert colors\n\nIf you invert the colors, „bright“ and „dark“ are\ninterchanged. Thus the normally white font changes into\nblack.\n\nA general rule: Bright font for dark pictures, dark font for\nbright pictures.\n\n### Thumbnail\n\nThe thumbnail replaces the automatically generated\npreview-picture in the navigation and overview.\n\n### Display in navigation\n\nIf this option is not taken, the particular page is not\nrepresented in the navigation and therefore cannot be\nreached through it.  You can use this option if a page is\nsupposed to read more like a subpage of another page.\n\n### Transition effect\n\nThere are different scroll effects, which are visible when users enter or leave pages. You can use vertical transitions like „crossfade“ or „cut“ or „Fade to black“. Besides this you also can choose horizontal scrolling from right or left. You can determine which effect should be used for each individual page.\n\n### Fade in text after delay\n\nDefine whether text and gradient of a page should appear with a delay. \nUsers will first see the background image, then title, tagline and subtitle until finally the content text will be displayed.\n\nThere are three different durations of delay: short = 1 second, medium = 3 seconds, long = 5 seconds.\n\nThis feature fits best for intros or beginnings of chapters.\n\n### Description for the overview\n\nYou can enter a text, which appears when the user navigates\nwith the mouse over the particular page. This text matches\nwith the mouse-over-text for the page-type „Page References“\nas well as with the text, which appears when you share the\nstory in social networks."},"page_types":{"menu_item":"Page Types","text":"# Page Types\n\nBy choosing the page type, you determine what type of media\nfiles are used for which page. For each type of page you can\nuse different settings.  For further information please\nclick on a page type on the left column.\n"},"publishing":{"menu_item":"Publishing","text":"# Publishing\n\nClick on the „Publish“ button to publish your story. A\nstory can be published at any point in time. \n\nBesides this, there is the possibility to publish stories with \na password protection. Just activate „Protect with password“. \nScrollytelling uses the name of the account as user name and \nautomatically generates a password, which can be changed afterwords. \n\nAlready published stories can also be protected with a password by \npublishing another version - the other way round works as well. \nFor this please just click on the „Publishing“ button. The following \nsteps will then be shown and explained within the dialog window.\n\nPublished\nStories can also be unpublished manually at any time. If a\nstory has already been published, changes will not be\nshown until you publish your report again.  A story can\nonly be edited by one author at one time.\n\nThumbnail for embedding the story on external websites\nAfter publishing your story, the system generates a\nthumbnail, which can be embedded as an iframe to the\nhyperlink of another website. By means of the code, the size\nof the iframe can be adjusted. The minimum size is a height\n150px and a width of 220px."},"storylines":{"menu_item":"Storylines","text":"# Storylines\n\nBesides the linear narrative form from „top to bottom“, additional storylines and excursions can be used to tell further aspects of a story. For this create a new „internal link“ page and connect these links to a new storyline. Thereby you can choose at which page such a branch will lead back to the main storyline or even links to another part of a story. \n\nCreate these storylines within the „Outline“ by clicking on the plus-button next to the storyline menu. A new chapter will then be added in which you have to create the new pages of your excursion. For every storyline a „Parent page“ can be chosen, to where a user will be led, when he scrolls at the end of a storyline. Define this target page by clicking on the pen symbol.\n\n*Notice: Only the chosen storyline will be shown while editing it. Click the menu „Storyline“ to go back to the other chapters.*"}},"helpers":{"entries":{"global_links":"Global links","image_rights":"Credits"}},"invalid_transition":"Invalid transition","page_transitions":{"crossfade":"Crossfade","cut":"Cut","fade":"Fade","fade_to_black":"Fade to black","scroll":"Scroll","scroll_left":"Scroll left","scroll_over_from_left":"Scroll over from left","scroll_over_from_right":"Scroll over from right","scroll_right":"Scroll right"},"quotas":{"exhausted":"Quota exhausted"},"storyline_attributes":{"main":{"inline_help":"Turns the first page of this storyline into the start page of the entry.","inline_help_disabled":"The first page of this storyline is the start page of the entry.","label":"Main storyline"},"navigation_bar_mode":{"label":"Navigation bar mode","values":{"current_storyline":"Current storyline","inherit_from_parent":"Display parent storyline","non":"Hide"}},"page_transition":{"inline_help":"By default, comming from the parent page, the first page of the storyline is scrolled in from the right. When clicking the back button, pages of the storyline are scrolled back out to the right. Here you can choose an alternative effect.","label":"Transition effect"},"parent_page_perma_id":{"inline_help":"The user is redirected to this page when reaching the end of the storyline or when clicking the back button. The parent page settings determine the chapter hierachy. For more information on the chapter hierarchy see the 'Storylines' help topic.","label":"Parent page"},"scroll_successor_id":{"inline_help":"Page to go to when scrolling down from the last page of the storyline. By default the user is brought back to the storyline's parent page.","label":"Scroll successor"},"title":{"label":"Title"}},"storylines":{"feature_name":"Storylines","main":"Main storyline","untitled":"Unnamed storyline"},"ui":{"configuration_editor":{"tabs":{"files":"Files","general":"General","links":"Links","options":"Options","social":"Social","widgets":"Appearance","content":"Text area","header":"Title area","topic":"Contents","appearance":"Appearance","areas":"Areas"}},"inline_help":{"pageflow/chapter":{"title":"Will be shown on the overview page."},"pageflow/entry":{"author":"The author's name.","credits":"Will be shown in the info box.","emphasize_chapter_beginning":"This option emphasizes the title of the first page of a chapter.","emphasize_new_pages":"At the beginning of a story an info-box shows news pages that were created since the last visit.","home_button_enabled":"Scrollytelling can display a button in the navigation, which hyperlinks to an external website, for example back to the website from which you hyperlinked to the story.","home_button_enabled_disabled":"This option is not available for your theme.","home_url":"URL of your home page. Leave empty to use your accounts default setting.","home_url_disabled":"This option is not available for your theme.","keywords":"Keywords as a suggestion for search engines.","manual_start":"Decide if tips or advice should be shown at the beginning of your story.","overview_button_enabled":"The overview displays chapters and pages of the main storyline.","overview_button_enabled_disabled":"This option is not available for your theme.","publisher":"The publisher's name or company name.","share_url":"URL to share via social media buttons. Leave blank to use URL of published entry.","summary":"Here you can write a description, which is shown, when your story is shared in social networks.","title":"Here you can choose a title for your story. It will be shown on the title bar of the browser window. It also acts as an indicator for search engines once the report is published."},"pageflow/page":{"additional_title":"The info box appears close to the player controls.","atmo_audio_file_id":"Choose an audio file, that shall be played in the background. If you want this audio to continue playing on following pages, just choose the same file again there. Not available on mobile devices at the moment.","atmo_during_playback":"Choose which way the atmo shall behave during playback of this page's main media.","delayed_text_fade_in":"Fades in the page contents after a delay such that the background image can be viewed initially.","description":"You can enter a text, which appears when the user navigates with the mouse over the particular page. This text matches with the mouse-over-text for the page-type „Page References“ as well as with the text, which appears when you share the story in social networks.","gradient_opacity":"The opacity of the gradient improves the legibility of the text on background-videos or pictures.\n\nYou can use the slider to darken or lighten up the background until the contrast between text and background is optimal.","invert":"If you invert the colors, „bright“ and „dark“ are interchanged. Thus the normally white font changes into black.\n\nA general rule: Bright font for dark pictures, dark font for bright pictures.","mobile_poster_image_id":"This image is used as poster image on mobile devices.","text":"The text-block can be formatted with the buttons underneath the input field. [B= bold / I=italic / U=underlined / infinity symbol= Link/URL to an external website]\n\nAll changes are visible in the left front-end-view as soon as you leave the appropriate input field in the editor.","thumbnail_image_id":"The thumbnail replaces the automatically generated preview-picture in the navigation and overview.\n","transition":"Choose the animation, that will be used when users scroll to this page.","invert_text":"Switches text and background colors","prevent_fullscreen":"Prevents the image from opening fullscreen on click","sticky_inline_image":"The image scrolls with the text but eventually remains at a vertically centered position.","text_coverage":"Determines how much of the title image is visible initially.","text_image_id":"This image is displayed alongside the text.","topasset_dim":"Animate the opacity of the title image while scrolling down.","topasset_parallax":"Translate the title image vertically while scrolling down."},"pageflow/external_links/site":{"description":"Suggested text length: 220 chars","thumbnail":"Suggested aspect ratio: 16:9"},"pageflow/linkmap_page/area":{"link_title":"The description is displayed inside an overlay when the cursor hovers the hotspot.","marker":"Choose the hotspot's visual appearance. ","name":"Choose a label to recognize the link within the overview. This label is for your orientation only and will not be displayed to the reader.","page_transition":"Choose the animation, that will be used to transition to the link's target page.","target_id":"Object the hotspot links to.","target_type":"Choose the type of object the hotspot is supposed to link to.","inverted":"Display dark pictograms to improve visibility on light backgrounds."}},"templates":{"inputs":{"file_input":{"adjust_positioning":"Adjust field of view","edit":"Edit","reset":"Reset"},"page_reference":{"drag_hint":"Drag pages into the preview to create links."},"text_area_input":{"bold":"Bold","cancel":"Cancel","create_link":"Insert link","italic":"Italic","ok":"Ok","underline":"Underline","url":"URL"}}},"views":{"extended_select_input_view":{"display_help":"Display help"},"inputs":{"file_input_view":{"none":"(none)"},"proxy_url_input_view":{"http_error":"The given URL could not be fetched. (The server answered with a HTTP status code ' %{status}')","url_validation":"Checking URL..."},"select_input_view":{"none":"(none)","placeholder":"Default (%{text})"},"text_input_view":{"required_field":"Required field"},"url_input_view":{"required_field":"Required field","supported_vendors":"Following providers are supported:","url_hint":"URL must start with http:// ","url_hint_https":"URL must start with http:// or https://"}}}},"unauthorized":"You are not authorized to view this page.","user_mailer":{"invitation":{"ending":"Thank you and have fun,","greeting":"Your Scrollytelling Team","instruction":"Welcome to Scrollytelling. Please use the following link to set your personal password. You may use your email address to sign-in. ","salutation":"Hello %{first_name}","subject":"Your Scrollytelling Invitation"}},"widgets":{"none":"(none)","roles":{"analytics":"Tracking","mobile_navigation":"Mobile navigation","navigation":"Navigation bar","player_controls":"Player Controls","head":"HTML header widget","overview":"Overview widget"},"type_names":{"classic_player_controls":"Classic","default_mobile_navigation":"Navigation bar with thumbnails","default_navigation":"Navigation bar with thumbnails","slim_player_controls":"Minimal"}},"public":{"_language":"English","audio":"Audio","back":"Back","back_to_chapter":"Back to chapter","before_after":{"drag_hint":"Press the left mouse button and move left or right","hint":"Before/after view","leave_view":"Leave before/after view","start":"Start before/after view","start_title":"Start before/after view"},"chapter":"Chapter","chart":{"toggle":"Toggle"},"close":"Close","close_hint":"Close hint","close_navigation":"Close navigation","close_overview":"Close overview","deprecated_browser":"\u003cp\u003eYour browser is outdated and this page might not work as intended. We recommend upgrading your browser to the most recent version.\u003c/p\u003e","embedded_video":{"leave_video":"Leave embedded video"},"enlarge_view":"Enlarge view","enter_fullscreen":"Enter Fullscreen mode","first_page":"First page","forward":"Forward","fullscreen":"Fullscreen","goto_first_page":"Go to first page","goto_top":"Goto first page","hide_text":"Hide text","home":"Start","imprint":"Imprint","javascript_hint":"This application utilizes JavaScript for enhanced functionality and user experience. Your browser may not support JavaScript or it may be disabled.","languages":{"ar":"Arabic","cs":"Czech","de":"German","dk":"Danish","el":"Greek","en":"English","es":"Spanish","fr":"French","it":"Italian","nl":"Dutch","pl":"Polish","pt":"Portuguese","ru":"Russioan","sr":"Serbian","tr":"Turkish","unknown":"(Unknown)","zh":"Chinese"},"leave_fullscreen":"Exit fullscreen mode","lets_go":"Let's go","logo":"Logo","media_quality":"Quality","mute_off":"Unmute","mute_on":"Mute","navigate_top":"Goto first page","navigation":"Navigation","new_pages_box":{"additional_pages_html":"...and \u003cspan\u003e\u003c/span\u003e more","description":"Since your last visit, pages have been added to this pageflow:","title":"New Pages"},"notice":"Notice","open_audio":"Open audio","open_navigation":"Open navigation","open_overview":"Open overview","open_video":"Open video","overview":"Overview","panorama":{"close":"Close 360° panorama and display text","start":"Start 360° panorama"},"play_video":"Play video","scroll_back_indicator":" ","scroll_down":"Scroll down","scroll_hint":"Use the mouse wheel or the arrow keys on your keyboard to navigate between pages.","scroll_indicator":"Scroll to continue","scroll_left":"Scroll left","scroll_right":"Scroll right","scroll_up":"Scroll up","share":"Share","share_on_facebook":"Share on Facebook","share_on_google":"Share on Google+","share_on_twitter":"Share on Twitter","share_this_entry":"This story","share_this_page":"This page","show_home":"Start","show_text":"Show text","skip_links_content":"Goto content","skip_links_navigation":"Goto navigation","skip_links_top_navigation":"Goto main navigation","sound_hint":"This multimedia story format uses video and audio footage. Please make sure your speakers are turned on.","start_audio":"Start audio now","start_video":"Start video now","swipe_hint":"Swipe to navigate between pages.","swipe_indicator":"Swipe to continue","text_track_modes":{"auto":"Auto (%{label})","auto_off":"Auto (Aus)","none":"(None)"},"text_tracks":"Subtitles","video":"Video","video_qualities":{"annotations":{"4k":"4K","fullhd":"HD","medium":"HD"},"labels":{"4k":"2160p","auto":"Auto","fullhd":"1080p","medium":"720p"}},"volume":"Volume","vr":{"no_vr":{"link":"Show video in Youtube app.","text":"360° videos can't be displayed in your browser."},"select_quality":"Choose video quality","start":"Watch 360° video","start_cardboard":"Start cardboard mode","video_qualities":{"4k":"2160s","fullhd":"1080s","high":"720s"},"video_quality_annotations":{"4k":"4K","fullhd":"HD","high":"HD"}}},"internal_links":{"editor":{"templates":{"edit_page_link":{"back":"Back","destroy":"Delete"},"embedded":{"grid_page_link":{"edit":"Edit","set":"Set"}}},"views":{"edit_page_link_view":{"confirm_destroy":"Really delete this link?","default_page_transition":"Default page transition"}}},"grid":{"help_entries":{"page_type":{"menu_item":"Internal Links Grid","text":"# Internal Links Grid\n\nReferences to other pages inside a Pageflow\n\nIn contrast to external link, you can link to pages inside\nyour Pageflow. This page type helps you guide your users\nthrough your Pageflow.\n\nExamples of application: Welcome page, chapter homepage"}},"page_attributes":{"linked_pages_layout":{"inline_help":"Emphasize one of the thumbnails.","label":"Enlarged element","values":{"default":"(none)","hero_top_left":"Top left","hero_top_right":"Top right"}}},"page_type_category_name":"Links","page_type_description":"A grid of thumbnails linking to other pages inside the Pageflow","page_type_name":"Internal Links Grid"},"list":{"help_entries":{"page_type":{"menu_item":"Multiple Choice","text":"# Multiple Choice\n\nA collection of links to other pages of the Pageflow displayed as a row of boxes with some text.\n\nExamples of application: Question/answer page, interactive interview, quiz\n\n"}},"page_type_category_name":"Links","page_type_description":"Links to other pages as collection of answers","page_type_name":"Multiple Choice"},"page_link_attributes":{"description":{"inline_help":"This text is displayed on the link item.","label":"Description"}}},"internal_links_list":{"page_type_feature_name":"Multiple Choice Page Type"},"external_links":{"editor":{"templates":{"edit_site":{"back":"Back","destroy":"Delete","failure":"There was an error while saving the external link.","retry":"Retry"},"embedded":{"list_item":{"open_in_new_tab":"Open in new tab","open_in_new_tab_message":"Opening in same tab is disabled inside the editor"}},"inputs":{"site_reference":{"add":"Add"}},"site_item":{"failure":"There was an error while saving the site.","select":"Select"},"site_reference_item":{"edit":"Edit","remove":"Remove"},"site_selection":{"cancel":"Cancel","title":"Select external site"},"sites":{"add":"Add"},"sites_blank_slate":{"text":"There are no sites yet."}},"views":{"edit_site":{"back":"Back","confirm_destroy":"Are you sure you want to delete this site?\n\nAll usages of this site on external link pages will also be removed. This action cannot be undone."},"site_item_reference_view":{"unknown":"(New site)"},"site_item_view":{"unknown":"(New site)"}}},"help_entries":{"page_type":{"menu_item":"External Links","text":"# External Links\n\nCollection of References to Websites outside of Pageflow\n\nBesides a standard background-image you can embedlinks to external websites, which open in a new window. For each link you can add a title, description and picture. Note: With each link you risk losing the users to the other websites Empirically it is advisable to use external references in the end of the Pageflow.\n\nExamples of application: Consolidation, Resources, Twitter and Facebook feeds, links to  own homepage"},"sites":{"menu_item":"Manging External Sites","text":"# Manging External Sites\n\nWith „external sites“ you manage links to external websites, which you want to integrate into your Pageflow. You can choose photos as a teaser and write a description for the links.\n\nThe references are used for the page-type „External Links“. External links allow you to explore a topic in more depth.\n\nPlease note, that these links should rather be placed at the end of a Pageflow, because they offer a premature exit from the Pageflow. "}},"manage_sites":"Manage external sites","page_type_category_name":"Links","page_type_description":"Allows linking to external websites with a thumbnail and description text.","page_type_help_entry":{"title":"External Links: Round off your story with further readings"},"page_type_name":"External Links"},"before_after":{"help_entries":{"page_type":{"menu_item":"Before/After","text":"# Before/After\n\n*Two overlapping pictures, separated through a slider*\n    \nWith the before and after effect two pictures can be put on top of each other. The pictures can be viewed with a slider. This page type makes sense, if you want to compare something. If the angle and sequence match, this it is particularly effective.\n\nExamples of application: now and then, status quo and planned, empty or crowded"}},"page_type_category_name":"Interactive","page_type_description":"Two images separated by a slider","page_type_name":"Before/After"},"text_page":{"help_entries":{"page_type":{"menu_item":"Text","text":"# Text Page\n\n*Page for long texts*\n    \nThis page is especially designed for longer bodies of text on a neutral background. It offers  whole range of ´options design, which are comparable to the classical blog design (parallax) of sites like WordPress or Tumblr.\n\nThere are several options for arranging the title pictures and various ways of embedding another picture into the text body. Pictures within the text can move along with the text or can be fixed to a certain part of the page.\n\nExamples of application: blog article, news article, interview"}},"page_type_category_name":"Basic","page_type_description":"Longer texts with a banner image","page_type_name":"Text Page"},"embedded_video":{"help_entries":{"page_type":{"menu_item":"Embedded Video","text":"# Embedded Video\n\n*Embeds an external video from Youtube or Vimeo*\n    \nIf you want to use external videos beside your own material, you can embed the video-URL and give it a caption. For technical reasons the video is embedded in a frame, that is fitting only parts of the  screen. You can therefore add a background-image, which creates a visual frame. You can use videos from Youtube and Vimeo.\n\nExamples of application: integration of playlists, trailer or short movies"}},"page_type_category_name":"Video","page_type_description":"Embed YouTube or Vimeo videos","page_type_name":"Embedded Video"},"linkmap_page":{"default_page_transition":"(Default)","editor":{"area_types":{"audio_file":"Audio file","external_site":"External link","page":"Page link","text_only":"Text only"},"templates":{"edit_area":{"back":"Back","destroy":"Delete"},"embedded":{"area_item":{"edit":"Edit","toggle_marker":"Toggle display"}},"file_area_item":{"edit":"Edit","remove":"Remove","toggle_marker":"Toggle marker"},"file_areas":{"add":"Add","label":"Label"}},"views":{"areas_list":{"add":"Add","label":"Areas"},"edit_area_view":{"confirm_destroy":"Really delete this area?"}}},"help_entries":{"page_type":{"menu_item":"Hotspots","text":"# Hotspots\n\nLinks with configurable click areas.\n\nHotspots can play audio files, link to other pages in a Pageflow or to external websites. You can define as many hotspots as you want.\n\nDecide if you want to show a background image or a background video. (Keep in mind, that background videos will not be played on mobile devices, therefore use an additional fallback image for the mobile version)\n\nThe hotspot page type allows to use panoramic images that are wider and taller than the screen-size. It enables users to explore these images by horizontal or vertical scrolling.\n\nTo add a Hotspot just click on „Areas“ and choose between „Audio“, „Internal link“, or „External link“. \n\nThere are two ways to display hotspot areas:\n\n##  Hotspots as circles\n\nDisplay a white circle whose position and size can be defined by dragging. Click on the eye-symbol button of the corresponding hotspot and move this circle onto the desired position. If you use an audio file, a headphone-symbol will appear within the circle. The size of the symbol depends on the circle´s size. The circle becomes more visible when the cursor moves closer to it.\n\n## Individually designed hotspots\n\nAlternatively, an additional panorama image can be used to determine the look of hotspots when the cursor hovers above them. Two images have to be prepared:\n\n1. An image with all hotspots in an inactive state (e.g. a map with cities represented by black dots)\n2. An image with all hotspots in an active state (e.g. the same map with red dots representing cities)\n\nNow the rectangular hotspot areas are positioned to cover the graphic representations of the hotspots. When the cursor hovers above one of the hotspots, the corresponding part of the hover-image will be displayed inside the hotspot's area. That way the hotspot is displayed in its active state while all others remain inactive.\n\nIt is also possible to use videos instead of images. The following combinations are possible:\n\n1. Background image with hover image\n2. Background video with hover image\n3. Background image with hover video\n\nIf you wish to mark hotspots as \"already visited\" you can also upload a „Visited-Image“ which then shows a certain spot in a different color after visiting the linked page.\n\n## Text options\n\nBoth of these hotspot types can be entitled and have additional text/description.\nThe description editor contains basic formatting options like bold, italic \u0026 underline.\n\n## Atmo options\n\nEvery Hotspot page, can play an additional backround sound that can optionally stop or continue playing (at the same or a lower volume) while an audio-Hotspot is playing.\n\n## Further options\n\nRestrict scrolling to hotspot areas: Only scroll between hotspots.\n\nForce scrolling: Ensure there is a margin which ensures the panorama can be scrolled both vertically and horizontally.\n\nDeactivate scrolling at image border: Do not scroll in panorama view when user moves the cursor.\n\nExamples of application: Menu site, multiple choice, exploration tour"}},"manage_sites":"Manage links","page":{"scroll_left":"Scroll left","scroll_right":"Scroll right","scroll_up":"Scroll up","scroll_down":"Scroll down"},"page_attributes":{"add_environment":{"inline_help":"Zoom panorama to allow scrolling in both directions.","label":"Ensure scroll margin"},"audio_areas":{"label":"Audio areas"},"background_type":{"label":"Panorama type","values":{"hover_video":"Backgrund image/hover video","image":"Background image/hover image","video":"Background video/hover image"}},"hover_image_id":{"inline_help":"A part of this image is displayed inside the area of a hotspot when the cursor hovers it.","label":"Hover image"},"hover_video_type":{"hover_image_id":{"inline_help":"Image to display instead of hover video on mobile platforms","label":"Hover image (mobile)"},"panorama_video_id":{"inline_help":"A part of this video will be displayed in the area of a hotspot when the cursor hovers it.","label":"Hover video"}},"limit_scrolling":{"inline_help":"Enable scrolling only if there hotspot areas outside the view port.","label":"Restict to hotspot areas"},"linked_linkmap_page_perma_ids":{"label":"Page links"},"linkmap_areas":{"label":"Link areas"},"margin_scrolling_disabled":{"inline_help":"Do not scroll panorama when the cursor moves.","label":"Disable autoscroll in page margin"},"panorama_image_id":{"inline_help":"Image to place hotspots on","label":"Panorama image"},"panorama_video_id":{"inline_help":"Video to place hotspots on","label":"Panorama video"},"video_type":{"panorama_image_id":{"inline_help":"Image displayed instead of panorama video on mobile platforms.","label":"Panorama image (mobile)"}},"visited_image_id":{"inline_help":"A part of this image is displayed inside the areas of hotspots whose target pages have already been visited.","label":"Visited image"}},"page_type_category_name":"Links","page_type_description":"Links with configurable click areas","page_type_feature_name":"Hotspot page type","page_type_name":"Hotspots"},"chart":{"editor":{"templates":{"scraped_site_status":{"failed":"Chart download failed.","pending":"Downloading chart..."},"datawrapper_ad":{"create_chart":"Create new Datawrapper chart"}}},"help_entries":{"page_type":{"menu_item":"Chart","text":"# Chart\n\nIntegration of a Datawrapper-Diagram\n\nHere you can add animated infographics to your Pageflow. The diagram is embedded into a background-picture and text. To enlarge the graphic you simply have to click on it. \n\nBut first of all you have to create your graphic externally and generate a link. You can find examples and requirements for this under www.datawrapper.de.\n\nNote that Datawrapper offers a special layout option for charts that shall be embedded into a Pageflow: In the \"Visualize\" step of the chart creation wizard, click the \"Design\" tab and select the \"Pageflow\" layout. That way a color scheme is used which complements Pageflow's look.\n\nExamples of application: statistics, diagrams, numbers \u0026 facts"}},"page_type_category_name":"Data and Charts","page_type_description":"Embedded Datawrapper chart","page_type_name":"Chart","page_attributes":{"full_width":{"inline_help":"Extends the chart to use the maximum width available.","label":"Use full width"},"scraped_site_id":{"inline_help":"URL of a chart published via Datawrapper. Datawrapper offers a special 'Pageflow' layout selectable on the 'Design' tab for optimal display inside Pageflow."}}},"scrollytelling_pageflow_navigation":{"home_link":" Home","home_title":"That will take you to %{url}","widget_type_name":"Scrollytelling dots with tooltips"},"analytics":{"amnesty":{"feature_name":"Analytics for Amnesty International","widget_type_name":"Amnesty International tracking codes"},"beeldengeluid":{"feature_name":"Analytics for Beeld en Geluid","widget_type_name":"Beeld en Geluid tracking codes"},"blof":{"feature_name":"Analytics for BLØF","widget_type_name":"BLØF tracking codes"},"concertatsea":{"feature_name":"Analytics for Concert at SEA","widget_type_name":"Concert at SEA tracking codes"},"destijl":{"feature_name":"Analytics for De Schatkamer van De Stijl","widget_type_name":"De Schatkamer van De Stijl tracking codes"},"meerveerkracht":{"feature_name":"Analytics for Meer Veerkracht, Langer Thuis","widget_type_name":"Meer Veerkracht, Langer Thuis tracking codes"},"ed":{"feature_name":"Analytics for Ed","widget_type_name":"Ed tracking codes"},"ricostickstyphoon":{"feature_name":"Analytics for Rico, Sticks en Typhoon","widget_type_name":"Rico, Sticks en Typhoon tracking codes"},"buildingbridges":{"feature_name":"Building Bridges trackers","widget_type_name":"Building Bridges"},"default":{"feature_name":"Analytics default (blank)","widget_type_name":"Blank (no tracking codes)"},"grasnapolsky":{"feature_name":"Analytics for Grasnapolsky","widget_type_name":"Grasnapolsky tracking codes"},"nos":{"feature_name":"Analytics for NOS","widget_type_name":"NOS tracking codes"},"nieuwsuur":{"feature_name":"Analytics for Nieuwsuur","widget_type_name":"Nieuwsuur tracking codes"},"omroepbrabant":{"feature_name":"Analytics for Omroep Brabant","widget_type_name":"Omroep Brabant tracking codes"},"psv":{"feature_name":"Analytics for PSV","widget_type_name":"PSV tracking codes"},"radio1":{"feature_name":"Analytics for NPO Radio 1","widget_type_name":"Radio 1 tracking codes"},"sbb":{"feature_name":"Analytics for Staatsbosbeheer","widget_type_name":"Analytics for Staatsbosbeheer"},"stephaniestruijk":{"feature_name":"Analytics for Stephanie Struijk","widget_type_name":"Stephanie Struijk tracking codes"},"krisberry":{"feature_name":"Analytics for Kris Berry","widget_type_name":"Kris Berry tracking codes"},"volkskrant":{"feature_name":"Analytics for de Volkskrant","widget_type_name":"de Volkskrant tracking codes"}}},"views":{"pagination":{"first":"|\u003c","last":"\u003e|","next":"\u003e\u003e","previous":"\u003c\u003c","truncate":"..."}},"activemodel":{"errors":{"messages":{"invalid":"is invalid","invalid_event":"cannot transition when %{state}","invalid_transition":"cannot transition via \"%{event}\""}}},"okcomputer":{"check":{"passed":"%{registrant_name}: PASSED %{message} (%{time})","failed":"%{registrant_name}: FAILED %{message} (%{time})"}}},"da":{"ransack":{"search":"søg","predicate":"predicate","and":"og","or":"eller","any":"anhver","all":"alle","combinator":"kombinering","attribute":"attribut","value":"værdi","condition":"betingelse","sort":"sorter","asc":"opstigende","desc":"faldende","predicates":{"eq":"lig med","eq_any":"lig med enhver","eq_all":"lig med alle","not_eq":"ikke lig med","not_eq_any":"ikke lig med nogen","not_eq_all":"ikke lig med alle","matches":"matcher","matches_any":"matcher enhver","matches_all":"matcher alle","does_not_match":"matcher ikke","does_not_match_any":"matcher ikke nogen","does_not_match_all":"matcher ikke alle","lt":"mindre end","lt_any":"mindre end nogen","lt_all":"mindre end alle","lteq":"mindre end eller lig med","lteq_any":"mindre end eller lig med nogen","lteq_all":"mindre end eller lig med alle","gt":"større end","gt_any":"større end nogen","gt_all":"større end alle","gteq":"større end eller lig med","gteq_any":"større end eller lig med nogen","gteq_all":"større end eller lig med alle","in":"i","in_any":"i nogen","in_all":"i alle","not_in":"ikke i","not_in_any":"ikke i nogen","not_in_all":"ikke i alle","cont":"indeholder","cont_any":"indeholder nogen","cont_all":"indeholder alle","not_cont":"indeholder ikke","not_cont_any":"indeholder ikke nogen","not_cont_all":"indeholder ikke alle","start":"starter med","start_any":"starter med nogen","start_all":"starter med alle","not_start":"starter ikke med","not_start_any":"starter ikke med nogen","not_start_all":"starter ikke med alle","end":"slutter med","end_any":"slutter med nogen","end_all":"slutter med alle","not_end":"slutter ikke med","not_end_any":"slutter ikke med nogen","not_end_all":"slutter ikke med alle","true":"er sand","false":"er falsk","present":"er til stede","blank":"er blank","null":"er nul","not_null":"er ikke nul"}},"active_admin":{"dashboard":"Kontrolpanel","dashboard_welcome":{"welcome":"Velkommen til Active Admin. Dette er standardoversigtssiden.","call_to_action":"Rediger 'app/admin/dashboard.rb' for at tilføje nye elementer til oversigtssiden."},"view":"Vis","edit":"Rediger","delete":"Slet","delete_confirmation":"Er du sikker på at du ønsker at slette?","new_model":"Ny(t) %{model}","edit_model":"Rediger %{model}","delete_model":"Slet %{model}","details":"%{model} detaljer","cancel":"Fortryd","empty":"Tom","previous":"Forrige","next":"Næste","download":"Download:","has_many_new":"Tilføj ny(t) %{model}","has_many_delete":"Slet","has_many_remove":"Fjern","filters":{"buttons":{"filter":"Filtrer","clear":"Ryd filtre"},"predicates":{"contains":"Indeholder","equals":"lig","starts_with":"Begynder med","ends_with":"Slutter med","greater_than":"større end","less_than":"mindre end"}},"status_tag":{"yes":"Ja","no":"Nej"},"main_content":"Implementer venligst %{model}#main_content for at vise noget indhold.","logout":"Log ud","powered_by":"Powered by %{active_admin} %{version}","sidebars":{"filters":"Filtre"},"pagination":{"empty":"Ingen %{model} fundet","one":"Viser \u003cb\u003e1\u003c/b\u003e %{model}","one_page":"Viser \u003cb\u003ealle %{n}\u003c/b\u003e %{model}","multiple":"Viser %{model} \u003cb\u003e%{from}\u0026nbsp;-\u0026nbsp;%{to}\u003c/b\u003e af \u003cb\u003e%{total}\u003c/b\u003e i alt","multiple_without_total":"Viser %{model} \u003cb\u003e%{from}\u0026nbsp;-\u0026nbsp;%{to}\u003c/b\u003e","entry":{"one":"post","other":"poster"}},"any":"Alle","blank_slate":{"content":"Der er ingen %{resource_name} endnu.","link":"Opret"},"dropdown_actions":{"button_label":"Handlinger"},"batch_actions":{"button_label":"Batch Handlinger","default_confirmation":"Er du sikker på du vil gøre dette?","delete_confirmation":"Er du sikker på du vil slette disse %{plural_model}?","succesfully_destroyed":{"one":"Vellykket ødelagt 1 %{model}","other":"Vellykket ødelagt %{count} %{plural_model}"},"selection_toggle_explanation":"(Skift Selection)","link":"Opret en","action_label":"%{title} Valgte","labels":{"destroy":"Slet"}},"comments":{"resource_type":"resource type","author_type":"forfatter type","body":"krop","author":"forfatter","title":"Kommentar","add":"Tilføj Kommentar","resource":"Resource","no_comments_yet":"Ingen kommentarer endnu.","title_content":"Kommentarer (%{count})","errors":{"empty_text":"Kommentar blev ikke gemt, tekst var tom."}},"devise":{"login":{"title":"Login","remember_me":"Husk mig","submit":"Login"},"reset_password":{"title":"Glemt din adgangskode?","submit":"Nulstille min adgangskode"},"change_password":{"title":"Skift din adgangskode","submit":"Skift min adgangskode"},"unlock":{"title":"Send oplåsnings instruktioner igen","submit":"Send oplåsnings instruktioner igen"},"links":{"sign_in":"Log ind","forgot_your_password":"Glemt din adgangskode?","sign_in_with_omniauth_provider":"Log ind med %{provider}"}},"access_denied":{"message":"Du har ikke rettigheder til at udføre denne handling."},"index_list":{"table":"Tabel","block":"Liste","grid":"Gitter","blog":"Blog"}}},"ro":{"ransack":{"search":"caută","predicate":"predicat","and":"și","or":"sau","any":"oricare","all":"toate","combinator":"combinator","attribute":"atribut","value":"valoare","condition":"condiție","sort":"sortează","asc":"crescător","desc":"descrescător","predicates":{"eq":"egal cu","eq_any":"egal cu unul din","eq_all":"egal cu toate","not_eq":"diferit de","not_eq_any":"diferit de toate","not_eq_all":"nu este egal cu toate","matches":"corespunde","matches_any":"corespunde cu unul din","matches_all":"corespunde cu toate","does_not_match":"nu corespunde","does_not_match_any":"nu corespunde cu nici un","does_not_match_all":"nu corespunde cu toate","lt":"mai mic de","lt_any":"mai mic decât cel puțin unul din","lt_all":"mai mic decât toate","lteq":"mai mic sau egal decât","lteq_any":"mai mic sau egal decât cel puțin unul din","lteq_all":"mai mic sau egal decât toate","gt":"mai mare de","gt_any":"mai mare decât cel puțin unul din","gt_all":"mai mare decât toate","gteq":"mai mare sau egal decât","gteq_any":"mai mare sau egal decât cel puțin unul din","gteq_all":"mai mare sau egal decât toate","in":"inclus în","in_any":"inclus într-unul din","in_all":"inclus în toate","not_in":"nu este inclus în","not_in_any":"nu este inclus într-unul din","not_in_all":"nu este inclus în toate","cont":"conține","cont_any":"conține unul din","cont_all":"conține toate","not_cont":"nu conține","not_cont_any":"nu conține unul din","not_cont_all":"nu conține toate","start":"începe cu","start_any":"începe cu unul din","start_all":"începe cu toate","not_start":"nu începe","not_start_any":"nu începe cu unul din","not_start_all":"nu începe cu toate","end":"se termină cu","end_any":"se termină cu unul din","end_all":"se termină cu toate","not_end":"nu se termină cu","not_end_any":"nu se termină cu unul din","not_end_all":"nu se termină cu toate","true":"este adevărat","false":"este fals","present":"este prezent","blank":"este gol","null":"este nul","not_null":"nu este nul"}},"active_admin":{"dashboard":"Pagina Principala","dashboard_welcome":{"welcome":"Bine ati venit pe Active Admin. Aceasta este pagina principala.","call_to_action":"Pentru a adauga sectiuni, vedeti 'app/admin/dashboard.rb'"},"view":"Vizualizati","edit":"Modificati","delete":"Stergeti","delete_confirmation":"Sigur vreti sa stergeti?","new_model":"Un nou %{model}","edit_model":"Modificati %{model}","delete_model":"Stergeti %{model}","details":"Detalii %{model}","cancel":"Renuntati","empty":"Gol","previous":"Inapoi","next":"Inainte","download":"Descarcati:","has_many_new":"Adaugati un nou %{model}","has_many_delete":"Stergeti","has_many_remove":"Scoate","filters":{"buttons":{"filter":"Cautati","clear":"Stergeti filtrele"},"predicates":{"contains":"Conține","equals":"Egal Cu","starts_with":"începe cu","ends_with":"se termină cu","greater_than":"Mai Mare Decat","less_than":"Mai Mic Decat"}},"status_tag":{"yes":"Da","no":"Nu"},"main_content":"Va rugam sa implementati %{model}#main_content pentru a afisa continut.","logout":"Iesire","powered_by":"Powered by %{active_admin} %{version}","sidebars":{"filters":"Filtre"},"pagination":{"empty":"Nu am gasit nici un %{model}","one":"Afisare \u003cb\u003e1\u003c/b\u003e %{model}","one_page":"Sunt afisate \u003cb\u003etoate %{n}\u003c/b\u003e inregistrarile","multiple":"Sunt afisate \u003cb\u003e%{from}\u0026nbsp;-\u0026nbsp;%{to}\u003c/b\u003e din \u003cb\u003e%{total}\u003c/b\u003e inregistrari","multiple_without_total":"Sunt afisate \u003cb\u003e%{from}\u0026nbsp;-\u0026nbsp;%{to}\u003c/b\u003e","entry":{"one":"inregistrare","other":"inregistrari"}},"any":"Oricare","blank_slate":{"content":"Momentan nu exista %{resource_name}.","link":"Creati un"},"dropdown_actions":{"button_label":"Actiuni"},"batch_actions":{"button_label":"Grupare Actiuni","default_confirmation":"Sunteţi sigur că doriţi să faceţi acest lucru?","delete_confirmation":"Sunteţi sigur că doriţi să stergeţi aceste %{plural_model}?","succesfully_destroyed":{"one":"1 %{model} sters","few":"%{count} %{plural_model} sterse","other":"%{count} %{plural_model} sterse"},"selection_toggle_explanation":"(Modifica Selectia)","link":"Creati unul","action_label":"%{title} Selectat","labels":{"destroy":"Sterge"}},"comments":{"body":"Text","author":"Autor","title":"Comentariu","add":"Adaugati comentariu","resource":"Resursa","no_comments_yet":"Nu exista comentarii.","title_content":"Comentarii (%{count})","errors":{"empty_text":"Comentariul nu a fost salvat, textul lipseste."}},"devise":{"login":{"title":"Autentificare","remember_me":"Tine-ma minte","submit":"Autentificare"},"reset_password":{"title":"Ați uitat parola?","submit":"Reseta parola"},"change_password":{"title":"Schimbați parola","submit":"Schimbă parola"},"unlock":{"title":"Retrimite instrucțiunile de deblocare","submit":"Retrimite instrucțiunile de deblocare"},"links":{"sign_in":"Autentificare","forgot_your_password":"Ați uitat parola?","sign_in_with_omniauth_provider":"Conectați-vă cu %{provider}"}}}},"de":{"ransack":{"search":"suchen","predicate":"Eigenschaft","and":"und","or":"oder","any":"beliebige","all":"alle","combinator":"Kombinator","attribute":"Attribut","value":"Wert","condition":"Bedingung","sort":"sortieren","asc":"aufsteigend","desc":"absteigend","predicates":{"eq":"gleicht","eq_any":"gleicht beliebigen","eq_all":"gleicht allen","not_eq":"ungleich","not_eq_any":"ungleich beliebigen","not_eq_all":"ungleich allen","matches":"entspricht","matches_any":"stimmt überein mit einem beliebigen","matches_all":"stimmt mit allen überein","does_not_match":"stimmt nicht überein","does_not_match_any":"erfüllt ein beliebiger/s nicht","does_not_match_all":"stimmt nicht mit allen überein","lt":"kleiner als","lt_any":"kleiner als ein beliebiger/s","lt_all":"kleiner als alle als alle","lteq":"kleiner oder gleich","lteq_any":"kleiner oder gleich beliebige","lteq_all":"kleiner oder gleich allen","gt":"größer als","gt_any":"größer als ein beliebiger/s","gt_all":"größer als alle","gteq":"größer oder gleich","gteq_any":"größer oder gleich als ein beliebiger/s","gteq_all":"größer oder gleich alle","in":"in","in_any":"ist nicht in einem beliebigen","in_all":"in allen","not_in":"nicht in","not_in_any":"nicht in beliebige","not_in_all":"nicht in allen","cont":"enthält","cont_any":"enthält beliebige","cont_all":"enthält alle","not_cont":"enthält nicht","not_cont_any":"enthält ein beliebiger/s nicht","not_cont_all":"enthält keine/s","start":"beginnt mit","start_any":"beginnt mit beliebigen","start_all":"beginnt mit allen","not_start":"beginnt nicht mit","not_start_any":"beginnt nicht mit beliebigen","not_start_all":"beginnt nicht mit allen","end":"endet mit","end_any":"endet mit beliebigen","end_all":"endet mit allen","not_end":"endet nicht mit","not_end_any":"endet nicht mit beliebigen","not_end_all":"endet nicht mit allen","true":"ist wahr","false":"ist falsch","present":"ist vorhanden","blank":"ist leer","null":"ist null","not_null":"ist nicht null"}},"active_admin":{"access_denied":{"message":"Sie sind nicht berechtigt diese Seite anzuzeigen."},"any":"Alle","batch_actions":{"action_label":"Ausgewählte %{title}","button_label":"Massenoperationen","default_confirmation":"Bist Du sicher?","delete_confirmation":"Bist Du sicher, dass Du diese %{plural_model} löschen willst?","labels":{"destroy":"Löschen"},"link":"Erstellen","selection_toggle_explanation":"(Auswahl)","succesfully_destroyed":{"one":"1 %{model} erfolgreich gelöscht","other":"%{count} %{plural_model} erfolgreich gelöscht"}},"blank_slate":{"content":"Es gibt noch keine %{resource_name}.","link":"Erstellen"},"cancel":"Abbrechen","clear_filters":"Filter entfernen","comments":{"add":"Kommentar hinzufügen","author":"Autor","author_missing":"Anonym","author_type":"Autor","body":"Inhalt","errors":{"empty_text":"Der Kommentar wurde nicht gespeichert, da der Text fehlt."},"no_comments_yet":"Es gibt noch keine Kommentare.","resource":"Resource","resource_type":"Ressource","title":"Kommentar","title_content":"Kommentare (%{count})","delete":"Löschen","delete_confirmation":"Sind Sie sicher dass sie diesen Kommentar löschen wollen?"},"create_model":"%{model} erstellen","dashboard":"Übersicht","dashboard_welcome":{"call_to_action":"Siehe 'app/admin/dashboards.rb', um Übersichts-Bereiche hinzuzufügen.","welcome":"Willkommen in Active Admin. Dies ist die Standard-Übersichtsseite."},"delete":"Löschen","delete_confirmation":"Wollen Sie dieses Element wirklich löschen?","delete_model":"%{model} löschen","details":"%{model} Details","devise":{"change_password":{"submit":"Mein Passwort ändern","title":"Ändern Sie Ihr Passwort"},"email":{"title":"Email"},"links":{"forgot_your_password":"Passwort vergessen?","resend_confirmation_instructions":"Bestätigungsmail erneut versenden","resend_unlock_instructions":"Entsperrungsmail erneut versenden","sign_in":"Anmeldung","sign_in_with_omniauth_provider":"Mit %{provider} anmelden","sign_up":"Registrieren"},"login":{"remember_me":"Erinnere dich an mich","submit":"Login","title":"Login"},"password":{"title":"Passwort"},"resend_confirmation_instructions":{"submit":"Senden","title":"Bestätigungsmail erneut versenden"},"reset_password":{"submit":"Mein Passwort zurücksetzen","title":"Passwort vergessen?"},"sign_up":{"submit":"Registrieren","title":"Registrieren"},"subdomain":{"title":"Subdomain"},"unlock":{"submit":"Senden","title":"Entsperrinformationen senden"},"username":{"title":"Benutzername"}},"download":"Herunterladen:","dropdown_actions":{"button_label":"Aktionen"},"edit":"Bearbeiten","edit_model":"%{model} bearbeiten","empty":"Leer","equal_to":"Gleich","filter":"Filtern","filters":{"buttons":{"clear":"Filter zurücksetzen","filter":"Filter"},"predicates":{"contains":"Enthält","ends_with":"Endet mit","equals":"Ist gleich","greater_than":"Größer als","less_than":"Kleiner als","starts_with":"Beginnt mit"}},"greater_than":"Größer als","has_many_delete":"Löschen","has_many_new":"%{model} hinzufügen","has_many_remove":"Entfernen","index_list":{"block":"Liste","blog":"Blog","grid":"Grid","table":"Tabelle"},"less_than":"Kleiner als","logout":"Abmelden","main_content":"Bitte implementieren Sie %{model}#main_content, um Inhalte anzuzeigen.","new_model":"%{model} erstellen","next":"Weiter","pagination":{"empty":"Keine %{model} gefunden","entry":{"one":"Eintrag","other":"Einträge"},"multiple":"Zeige %{model} \u003cb\u003e%{from}\u0026nbsp;–\u0026nbsp;%{to}\u003c/b\u003e von \u003cb\u003e%{total}\u003c/b\u003e","multiple_without_total":"Zeige %{model} \u003cb\u003e %{from}\u0026nbsp;-\u0026nbsp;%{to}\u003c/b\u003e","one_page":"Zeige \u003cb\u003ealle %{n}\u003c/b\u003e %{model}","one":"Zeige \u003cb\u003e1\u003c/b\u003e %{model}"},"powered_by":" ","previous":"Zurück","scopes":{"frozen":"Alle","publications":"Nur Veröffentlichungen","publications_and_user_snapshots":"Nur Veröffentlichungen/Sicherungen"},"search_field":"Durchsuche %{field}","sidebars":{"filters":"Filter","folders":"Ordner","search_status":"Suchstatus"},"status_tag":{"no":"Nein","yes":"Ja"},"undelete":"Wiederherstellen","unsupported_browser":{"headline":"Internet Explorer Version 9 und niedriger sind nicht unterstützt.","recommendation":"Wir empfehlen ein Update des Browsers auf eine aktuelle Version von \u003ca href=\"http://windows.microsoft.com/ie\"\u003eInternet Explorer\u003c/a\u003e, \u003ca href=\"https://chrome.google.com/\"\u003eGoogle Chrome\u003c/a\u003e, oder \u003ca href=\"https://mozilla.org/firefox/\"\u003eFirefox\u003c/a\u003e.","turn_off_compatibility_view":"Internet Explorer Version 9 und niedriger sind nicht unterstützt."},"view":"Anzeigen","search_status":{"headline":"Filter","current_scope":"Anwendungsbereich:","current_filters":"Aktuelle Filter:","no_current_filters":"Keine"}},"activerecord":{"attributes":{"admin_user":{"created_at":"Erstellt am","current_sign_in_at":"Aktuell angemeldet seit","current_sign_in_ip":"Aktuelle IP-Adresse","email":"E-Mail","encrypted_Password":"Verschlüsseltes Passwort","id":"ID","last_sign_in_at":"Letzter Login am","last_sign_in_ip":"Letzte IP-Adresse","remember_created_at":"Passwort merken seit","reset_password_sent_at":"Passwort Reset Anweisungen gesendet am","reset_password_token":"Passwort Reset Token","sign_in_count":"Anzahl Logins","updated_at":"Aktualisiert am"},"pageflow/account":{"created_at":"Erstellt am","default_file_rights":"Standard Urheber","default_theming":"Theme","entries_count":"# Beiträge","landing_page_name":"Einstiegsseite","name":"Name","users_count":"# Benutzer"},"pageflow/audio_file":{"duration":"Länge","format":"Format"},"pageflow/chapter":{"display_parent_page_button":"'Übergeordnete Seite'-Button anzeigen","navigation_bar_mode":"Navigationsleiste","parent_page_perma_id":"Übergeordnete Seite","title":"Titel"},"pageflow/entry":{"account":"Konto","author":"Autor","created_at":"Erstellt am","credits":"Credits","edited_at":"Geändert am","emphasize_chapter_beginning":"Kapitelanfang hervorheben","emphasize_new_pages":"Neue Seiten hervorheben","first_published_at":"Erstmals veröffentlicht am","home_button_enabled":"Home-Button anzeigen","home_url":"Home-Button URL","keywords":"Schlüsselwörter","locale":"Sprache","manual_start":"Multimedia Hinweis vor dem Start anzeigen","overview_button_enabled":"Übersicht-Button anzeigen","published?":"Veröffentlichungstatus","published_at":"Veröffentlicht seit","published_revision_published_at":"Veröffentlicht am","publisher":"Herausgeber","share_image_id":"Social Sharing Bild","share_url":"Social Sharing URL","summary":"Zusammenfassung","title":"Titel","updated_at":"Geändert am","url":"Permalink","with_publication_state":"Veröffentlichungsstatus"},"pageflow/folder":{"account":"Konto","name":"Name"},"pageflow/image_file":{"dimensions":"Maße"},"pageflow/membership":{"created_at":"Mitglied seit","entry":"Beitrag","user":"Redakteur"},"pageflow/page":{"additional_description":"Beschreibung für Infobox","additional_title":"Titel für Infobox","allow_full_screen":"Vollbild Anzeige erlauben","atmo_audio_file_id":"Atmo-Audio","atmo_during_playback":"Atmo während Medien-Wiedergabe","audio_file_id":"Audio","auto_change_page_on_ended":"Am Ende weiterblättern","autoplay":"Automatische Wiedergabe","background_image_id":"Hintergrundbild","background_video_id":"Hintergrundvideo","delayed_text_fade_in":"Text verzögert einblenden","description":"Beschreibung für Übersicht","display_in_navigation":"In Navigationsleiste anzeigen","emphasize_in_navigation":"In Navigationsleiste hervorheben","gradient_opacity":"Intensität der Abblendung","hide_title":"Titel ausblenden","invert":"Farben invertieren","linked_page_ids":"Seiten verknüpfen","linked_pages_layout":"Hervorgehobenes Element","mobile_poster_image_id":"Posterbild (mobil)","poster_image_id":"Posterbild","scroll_indicator_mode":"Sichtbare Scroll Indikatoren","scroll_indicator_orientation":"Scroll Indikator Ausrichtung","subtitle":"Untertitel","tagline":"Tagline","template":"Seitentyp","text":"Text","text_position":"Textposition","thumbnail_image_id":"Thumbnail","title":"Titel","transition":"Übergangseffekt","video_file_id":"Video","linked_external_site_perma_ids":"Externe Seiten","after_image_id":"Nachher-Bild","before_image_id":"Vorher-Bild","control_bar_text":"Start-Button Beschriftung","image_description":"Bildunterschrift","inline_text_position":"Fließtextposition","invert_text":"Farben des Textbereichs invertieren","invert_title":"Farben des Titelbereichs invertieren","prevent_fullscreen":"Vollbildansicht ausschalten","sticky_inline_image":"Bild an Seite haften","text_coverage":"Textabdeckung","text_image_id":"Bild im Text","text_titel":"Überschrift","text_title":"Texttitel","title_position":"Titelposition","topasset_dim":"Abblenden","topasset_parallax":"Parallax","embedded_video_id":"Video URL","full_width":"Gesamte Breite nutzen","video_caption":"Bildunterschrift","scraped_site_id":"Diagramm URL"},"pageflow/revision":{"created_at":"Erstellt am","created_with":"Erstellt durch","creator":"Erstellt von","frozen_at":"Stand vom","published_at":"Publiziert am","published_until":"Publiziert bis","updated_at":"Geändert am"},"pageflow/theming":{"additional_cnames":"Zusätzliche CNAMES","cname":"CNAME","copyright_link_label":"Copyright-Link Text","copyright_link_url":"Copyright-Link URL","default_author":"Standard Autor","default_keywords":"Standard Schlüsselwörter","default_publisher":"Standard Herausgeber","home_button_enabled_by_default":"Home-Button in neuen Beiträgen anzeigen","home_url":"Redirect URL","imprint_link_label":"Impressum-Link Text","imprint_link_url":"Impressum-Link URL","theme_name":"Theme"},"pageflow/video_file":{"dimensions":"Maße","duration":"Länge","format":"Format"},"user":{"account":"Konto","admin":"Administrator","admin?":"Administrator","created_at":"Registriert seit","current_password":"Aktuelles Passwort","current_sign_in_at":"Aktuell angemeldet seit","email":"E-Mail-Adresse","entry":"Beitrag","first_name":"Vorname","full_name":"Name","last_name":"Nachname","last_sign_in_at":"Zuletzt angemeldet am","locale":"Sprache","membership":"Mitgliedschaft","password":"Passwort","password_confirmation":"Passwort wiederholen","role":"Rolle","sign_in_count":"# Anmeldungen","suspended?":"Gesperrt","unconfirmed_email":"Noch nicht bestätigte E-Mail-Adresse"},"pageflow/external_links/site":{"description":"Beschreibung","open_in_new_tab":"In neuem Tab öffnen","thumbnail":"Teaserbild","title":"Titel","url":"Ziel URL"},"pageflow/linkmap_page/area":{"link_description":"Linkbeschreibung: Text","link_title":"Linkbeschreibung: Titel","marker":"Linkmarkierung","name":"Bezeichnung","page_transition":"Seitenwechsel-Animation","target_id":"Ziel","target_type":"Bereichstyp","inverted":"Invertieren"}},"errors":{"messages":{"accepted":"muss akzeptiert werden","blank":"muss ausgefüllt werden","confirmation":"stimmt nicht mit der Bestätigung überein","empty":"muss ausgefüllt werden","equal_to":{"one":"muss genau %{count} sein","other":"muss genau %{count} sein"},"even":"muss gerade sein","exclusion":"ist nicht verfügbar","greater_than":{"one":"muss größer als %{count} sein","other":"muss größer als %{count} sein"},"greater_than_or_equal_to":{"one":"muss größer oder gleich %{count} sein","other":"muss größer oder gleich %{count} sein"},"inclusion":"ist kein gültiger Wert","invalid":"ist nicht gültig","invalid_date":"ist kein gültiges Datum","less_than":{"one":"muss kleiner als %{count} sein","other":"muss kleiner als %{count} sein"},"less_than_or_equal_to":{"one":"muss kleiner oder gleich %{count} sein","other":"muss kleiner oder gleich %{count} sein"},"not_a_number":"ist keine Zahl","not_an_integer":"muss ganzzahlig sein","odd":"muss ungerade sein","record_invalid":"Gültigkeitsprüfung ist fehlgeschlagen: %{errors}","taken":"ist bereits vergeben","too_long":{"one":"ist zu lang (nicht mehr als %{count} Zeichen)","other":"ist zu lang (nicht mehr als %{count} Zeichen)"},"too_short":{"one":"ist zu kurz (nicht weniger als %{count} Zeichen)","other":"ist zu kurz (nicht weniger als %{count} Zeichen)"},"validation":"muss mindestens 5 Zeichen lang sein und eine Ziffer beinhalten.","wrong_length":{"one":"hat die falsche Länge (muss genau %{count} Zeichen haben)","other":"hat die falsche Länge (muss genau %{count} Zeichen haben)"}}},"models":{"account":{"one":"Konto","other":"Konten"},"admin_user":{"one":"Administrator","other":"Administratoren"},"entry":{"one":"Beitrag","other":"Beiträge"},"folder":{"one":"Ordner","other":"Ordner"},"membership":{"one":"Mitgliedschaft","other":"Mitgliedschaften"},"pageflow/account":{"one":"Konto","other":"Konten"},"pageflow/entry":{"one":"Beitrag","other":"Beiträge"},"pageflow/folder":{"one":"Ordner","other":"Ordner"},"pageflow/membership":{"one":"Mitgliedschaft","other":"Mitgliedschaften"},"pageflow/revision":{"one":"Revision","other":"Revisionen"},"pageflow/theming":{"one":"Theming","other":"Themings"},"revision":{"one":"Revision","other":"Revisionen"},"theming":{"one":"Theming","other":"Themings"},"user":{"one":"Nutzer","other":"Nutzer"}},"values":{"pageflow/chapter":{"navigation_bar_mode":{"all":"Alle Seiten zeigen","current_chapter":"Nur aktuelles Kapitel","inherit_from_parent":"Von übergeordnetem Kapitel erben","non":"Ausblenden","same_parent_chapter":"Nur Kapitel mit gleichem übergeordneten Kapitel","same_parent_page":"Nur Kapitel mit gleicher übergeordneter Seite"}},"pageflow/entry":{"publication_states":{"not_published":"Nicht veröffentlicht","published_with_password_protection":"Mit Passwortschutz veröffentlicht","published_without_password_protection":"Ohne Passwortschutz veröffentlicht"}},"pageflow/page":{"atmo_during_playback":{"mute":"Ausblenden","play":"Weiterspielen","turn_down":"Leiser weiterspielen"},"delayed_text_fade_in":{"long":"Lange Verzögerung","medium":"Mittlere Verzögerung","no_fade":"Nicht verzögert einblenden","short":"Kurze Verzögerung"},"linked_pages_layout":{"default":"(Kein)","hero_top_left":"Links oben","hero_top_right":"Rechts oben"},"scroll_indicator_mode":{"all":"Vorwärts und zurück","non":"Keine","only_back":"Nur zurück","only_next":"Nur vorwärts"},"scroll_indicator_orientation":{"horizontal":"Horizontal","vertical":"Vertikal"},"template":{"audio":"Audio","audio_loop":"Hintergrund-Audio","background_image":"Hintergrund-Bild","background_video":"Hintergrund-Video","internal_links":"Seiten-Verweise","video":"Video"},"text_position":{"left":"Links","right":"Rechts","center":"Zentriert"},"transition":{"fade":"Überblenden","scroll":"Scrollen"},"inline_text_position":{"center":"Zentriert","left":"Links","right":"Rechts"},"text_coverage":{"banner":"Banner","extend_into":"Text ragt hinein","title_only":"Nur Titel"}},"pageflow/linkmap_page/area":{"marker":{"dynamic_marker":"Flexible Markierung","no_marker":"Keine Markierung"},"target_type":{"audio_file":"Audio Datei","external_site":"Externer Verweis","page":"Seitenverweis","text_only":"Nur Text"}}}},"date":{"abbr_day_names":["So","Mo","Di","Mi","Do","Fr","Sa"],"abbr_month_names":[null,"Jan","Feb","Mär","Apr","Mai","Jun","Jul","Aug","Sep","Okt","Nov","Dez"],"day_names":["Sonntag","Montag","Dienstag","Mittwoch","Donnerstag","Freitag","Samstag"],"formats":{"default":"%d.%m.%Y","long":"%e. %B %Y","short":"%e. %b"},"month_names":[null,"Januar","Februar","März","April","Mai","Juni","Juli","August","September","Oktober","November","Dezember"],"order":["day","month","year"]},"datetime":{"distance_in_words":{"about_x_hours":{"one":"etwa eine Stunde","other":"etwa %{count} Stunden"},"about_x_months":{"one":"etwa ein Monat","other":"etwa %{count} Monate"},"about_x_years":{"one":"etwa ein Jahr","other":"etwa %{count} Jahre"},"almost_x_years":{"one":"fast ein Jahr","other":"fast %{count} Jahre"},"half_a_minute":"eine halbe Minute","less_than_x_minutes":{"one":"weniger als eine Minute","other":"weniger als %{count} Minuten"},"less_than_x_seconds":{"one":"weniger als eine Sekunde","other":"weniger als %{count} Sekunden"},"over_x_years":{"one":"mehr als ein Jahr","other":"mehr als %{count} Jahre"},"x_days":{"one":"ein Tag","other":"%{count} Tage"},"x_minutes":{"one":"eine Minute","other":"%{count} Minuten"},"x_months":{"one":"ein Monat","other":"%{count} Monate"},"x_seconds":{"one":"eine Sekunde","other":"%{count} Sekunden"}},"prompts":{"day":"Tag","hour":"Stunden","minute":"Minuten","month":"Monat","second":"Sekunden","year":"Jahr"}},"devise":{"confirmations":{"confirmed":"Vielen Dank für die Bestätigung deiner E-Mail-Adresse.","send_instructions":"Du erhältst in wenigen Minuten eine E-Mail, mit der du deine Registrierung bestätigen kannst.","send_paranoid_instructions":"Falls deine E-Mail-Adresse in unserer Datenbank existiert, erhältst du in Kürze eine E-Mail mit der du die Registrierung bestätigen kannst."},"failure":{"admin_user":{"invalid":"Benutzername oder Kennwort nicht korrekt.","unauthenticated":"Bitte melden Sie sich als Administrator an."},"already_authenticated":"Du bist bereits angemeldet.","inactive":"Dein Account ist nicht aktiv.","invalid":"Ungültige Anmeldedaten. Bitte überprüfe, ob du dich beim Passwort oder Benutzernamen vertippt hast.","invalid_token":"Der Anmelde-Token ist ungültig.","locked":"Dein Account ist für einige Minuten gesperrt, da das Passwort zu oft falsch eingegeben wurde.","not_found_in_database":"Es wurde kein Benutzer mit diesen Anmeldedaten gefunden.","timeout":"Deine Sitzung ist abgelaufen, bitte melde Dich erneut an.","unauthenticated":"Du musst dich anmelden oder registrieren, bevor du fortfahren kannst.","unconfirmed":"Du musst deinen Account bestätigen, bevor du fortfahren kannst."},"mailer":{"confirmation_instructions":{"subject":"Bestätigung"},"reset_password_instructions":{"subject":"Anleitung um dein Passwort zurückzusetzen"},"unlock_instructions":{"subject":"Anleitung um deinen Account freizuschalten"}},"oauth_providers":{"facebook":"Facebook","google_oauth2":"Google"},"omniauth_callbacks":{"failure":"Du kannst nicht mit deinem %{kind}-Account angemeldet werden, weil \"%{reason}\".","success":"Du hast dich erfolgreich mit deinem %{kind}-Account angemeldet."},"passwords":{"no_token":"Du musst diese Seite von einem Link aus der \"Passwort zurücksetzen\" E-Mail aufrufen. Achte dabei darauf, dass der Link die vollständige URL enthält.","send_instructions":"Du erhältst in Kürze eine E-Mail mit der Anleitung, wie das Passwort zurückgesetzt werden kann.","send_paranoid_instructions":"Wenn Deine E-Mail-Adresse in unserer Datenbank existiert, erhältst du in Kürze eine E-Mail mit der Anleitung, wie das Passwort zurückgesetzt werden kann.","updated":"Dein Passwort wurde geändert. Du bist jetzt angemeldet.","updated_not_active":"Dein Passwort wurde geändert."},"registrations":{"destroyed":"Dein Account wurde gelöscht.","edit":{"are_you_sure":"Bist du sicher?","change_password":"Passwort ändern","delete_account":"Account löschen","submit":"Daten speichern","userdata":"Benutzerdaten"},"new":{"cancel_oauth_sign_up":"Abbrechen","registration":"Registrierung","sign_up_with_facebook":"Mit Facebook anmelden","sign_up_with_google":"Mit Google anmelden","submit":"Daten speichern"},"signed_up":"Du hast dich erfolgreich registriert und bist nun angemeldet.","signed_up_but_inactive":"Du hast dich erfolgreich registriert. Wir konnten dich aber noch nicht anmelden, da dein Account inaktiv ist.","signed_up_but_locked":"Du hast dich erfolgreich registriert. Wir konnten dich aber noch nicht anmelden, da dein Account gesperrt ist.","signed_up_but_unconfirmed":"Du hast dich erfolgreich registriert. Wir konnten dich aber noch nicht anmelden, da dein Account noch nicht bestätigt ist. Du erhältst in Kürze eine E-Mail mit der Anleitung, wie du deinen Account freischalten kannst.","update_needs_confirmation":"Deine Daten wurden aktualisiert, aber du musst deine neue E-Mail-Adresse bestätigen. Du erhältst in wenigen Minuten eine E-Mail, mit der du die Änderung deiner E-Mail-Adresse abschließen kannst.","updated":"Deine Daten wurden aktualisiert."},"sessions":{"admin_user":{"signed_in":"Erfolgreich als Administrator angemeldet."},"new":{"sign_in_with_facebook":"Mit Facebook anmelden","sign_in_with_google":"Mit Google anmelden"},"signed_in":"Erfolgreich angemeldet.","signed_out":"Erfolgreich abgemeldet."},"unlocks":{"send_instructions":"Du erhältst in Kürze eine E-Mail mit der Anleitung, wie du deinen Account entsperren kannst.","send_paranoid_instructions":"Falls deine E-Mail-Adresse in unserer Datenbank existiert, erhältst du in wenigen Minuten eine E-Mail mit der Anleitung, wie du deinen Account entsperren kannst.","unlocked":"Dein Account wurde entsperrt. Du bist jetzt angemeldet."}},"errors":{"format":"%{attribute} %{message}","messages":{"accepted":"muss akzeptiert werden","already_confirmed":"wurde bereits bestätigt","blank":"muss ausgefüllt werden","confirmation":"stimmt nicht mit der Bestätigung überein","confirmation_period_expired":"muss innherhalb von %{period} bestätigt werden, bitte einen neuen Link anfordern","empty":"muss ausgefüllt werden","equal_to":{"one":"muss genau %{count} sein","other":"muss genau %{count} sein"},"even":"muss gerade sein","exclusion":"ist nicht verfügbar","expired":"ist abgelaufen, bitte neu anfordern","greater_than":{"one":"muss größer als %{count} sein","other":"muss größer als %{count} sein"},"greater_than_or_equal_to":{"one":"muss größer oder gleich %{count} sein","other":"muss größer oder gleich %{count} sein"},"inclusion":"ist kein gültiger Wert","invalid":"ist nicht gültig","invalid_date":"ist kein gültiges Datum","less_than":{"one":"muss kleiner als %{count} sein","other":"muss kleiner als %{count} sein"},"less_than_or_equal_to":{"one":"muss kleiner oder gleich %{count} sein","other":"muss kleiner oder gleich %{count} sein"},"not_a_number":"ist keine Zahl","not_an_integer":"muss ganzzahlig sein","not_found":"nicht gefunden","not_locked":"ist nicht gesperrt","not_saved":{"one":"Registrierung kann nicht abgeschlossen werden. Ein Fehler.","other":"Registrierung kann nicht abgeschlossen werden. %{count} Fehler."},"odd":"muss ungerade sein","other_than":{"one":"muss ungleich %{count} sein","other":"muss ungleich %{count} sein"},"present":"muss leer sein","readonly":"ist schreibgeschützt","record_invalid":"Gültigkeitsprüfung ist fehlgeschlagen: %{errors}","restrict_dependent_destroy":{"one":"Der Datensatz kann nicht gelöscht werden, da  %{record} von ihm abhängt.","other":"Der Datensatz kann nicht gelöscht werden, da %{record} von ihm abhängen."},"taken":"ist bereits vergeben","too_long":{"one":"ist zu lang (nicht mehr als 1 Zeichen)","other":"ist zu lang (nicht mehr als %{count} Zeichen)"},"too_short":{"one":"ist zu kurz (nicht weniger als 1 Zeichen)","other":"ist zu kurz (nicht weniger als %{count} Zeichen)"},"wrong_length":{"one":"hat die falsche Länge (muss genau 1 Zeichen haben)","other":"hat die falsche Länge (muss genau %{count} Zeichen haben)"},"in_between":"muss zwischen %{min} und %{max} sein","spoofed_media_type":"trägt eine Dateiendung, die nicht mit dem Inhalt der Datei übereinstimmt"},"template":{"body":"Bitte überprüfen Sie die folgenden Felder:","header":{"one":"Konnte %{model} nicht speichern: ein Fehler.","other":"Konnte %{model} nicht speichern: %{count} Fehler."}}},"formtastic":{"cancel":"Abbrechen","create":"%{model} speichern","no":"Nein","required":"erforderlich","reset":"%{model} zurücksetzen","submit":"%{model} speichern","update":"%{model} speichern","yes":"Ja"},"helpers":{"select":{"prompt":"Bitte wählen"},"submit":{"create":"%{model} erstellen","submit":"%{model} speichern","update":"%{model} aktualisieren"}},"language":"Deutsch","number":{"currency":{"format":{"delimiter":".","format":"%n %u","precision":2,"separator":",","significant":false,"strip_insignificant_zeros":false,"unit":"€"}},"format":{"delimiter":".","precision":2,"separator":",","significant":false,"strip_insignificant_zeros":false},"human":{"decimal_units":{"format":"%n %u","units":{"billion":{"one":"Milliarde","other":"Milliarden"},"million":"Millionen","quadrillion":{"one":"Billiarde","other":"Billiarden"},"thousand":"Tausend","trillion":"Billionen","unit":"Einheit"}},"format":{"delimiter":".","precision":1,"significant":true,"strip_insignificant_zeros":true},"storage_units":{"format":"%n %u","units":{"byte":{"one":"Byte","other":"Bytes"},"gb":"GB","kb":"KB","mb":"MB","tb":"TB"}}},"percentage":{"format":{"delimiter":".","format":"%n%"}},"precision":{"format":{"delimiter":"."}}},"pageflow":{"admin":{"accounts":{"no_entries":"Keine Beiträge","no_members":"Keine Benutzer","widgets_inline_help":"Die hier ausgewählten Widgets werden als Standard für neue Beiträge des Kontos verwendet. Änderungen wirken sich nicht auf existierende Beiträge aus."},"entries":{"add_folder":"Ordner hinzufügen","confirm_depublish":"Soll der Beitrag wirklich depubliziert werden?","confirm_duplicate":"Beitrag wirklich duplizieren?","confirm_restore":"Soll der Beitrag wirklich auf den Stand dieser Revision zurückgesetzt werden? Vor dem Zurücksetzen wird eine automatische Sicherung des aktuellen Standes erstellt.","depublish":"Beitrag depublizieren","duplicate":"Beitrag kopieren","edit":"Bearbeiten","edit_config":"Konfiguration ändern","edit_revision":"Ändern","editor":"Editor","editor_hint":"Editor öffnen","entries":"Beiträge","forever":"(unbegrenzt)","members":"Redakteure","no_members":"Es sind keine Redakteure zugeordnet.","no_revisions":"Bisher keine Revisionen","not_published":"Nicht veröffentlicht","password_protected":"Mit Passwortschutz","preview":"Vorschau","preview_hint":"Vorschau anzeigen","published_forever":"Veröffentlicht","published_revision_legend":"Aktuell Veröffentlichter Stand","published_until":"Veröffentlicht bis %{published_until}","remove":"Entfernen","remove_logo":"Logo löschen","restore":"Wiederherstellen","revision_created_with":{"auto":"Auto-Sicherung","publish":"Veröffentlichung","restore":"Auto-Sicherung","user":"Sicherung"},"revision_created_with_hint":{"auto":"Dieser Stand wurde automatisch gesichert","publish":"Dieser Stand des Beitrags wurde veröffentlicht","restore":"Dieser Stand wurde gesichert bevor eine älteren Revision des Beitrags wiederhergestellt wurde","user":"Dieser Stand wurde durch einen Benutzer gesichert"},"show":"Anzeigen","show_public":"Öffentlich","show_public_hint":"Öffentliche Seite anzeigen","snapshot":"Aktuellen Stand sichern","title_hint":"Dieses Feld bestimmt die URL, unter der der Beitrag öffentlich erreichbar ist."},"features":{"states":{"default":"Standard (%{inherited})","disabled":"Deaktiviert","enabled":"Aktiviert","undefined":"(Standard)"}},"folders":{"all":"Alle","confirm_destroy":"Ordner wirklick löschen? Beiträge bleiben erhalten.","destroy":"Löschen","edit":"Bearbeiten"},"resource_tabs":{"entries":"Beiträge","features":"Features","members":"Mitglieder","revisions":"Revisionen","users":"Benutzer"},"revisions":{"published_until_hint":"Freilassen, um Beitrag unbegrenzt zu veröffentlichen."},"themings":{"additional_cnames_hint":"Kommaseparierte Liste von weiteren CNAMES. Ausschließlich zur Auswahl der Redirect URL genutzt.","cname_hint":"Wird in Share Links verwendet.","default_author_hint":"Voreinstellung 'author' Meta-Feld für Eintrage","default_keywords_hint":"Voreinstellung 'keywords' Meta-Feld für Eintrage","default_publisher_hint":"Voreinstellung 'publisher' Meta-Feld für Eintrage","home_url_hint":"Wird einer der obigen CNAMES ohne Pfad in der URL verwendet, wird zu dieser URL umgeleitet. Standard Link Ziel des Home Buttons.","name":"%{account_name}","remove_logo":"Logo entfernen","show":"Anzeigen"},"users":{"account":"Profil","add":"Benutzer hinzufügen","add_entry":"Beitrag hinzufügen","confirm_delete":"Soll der Benutzer wirklich gelöscht werden. Alle persönlichen Daten des Benutzers gehen verloren. Dieser Vorgang kann nicht rückgangig gemacht werden.","delete":"Löschen","delete_me":{"cancel_label":"Nein, mein Benutzerkonto nicht löschen","delete_label":"Benutzerkonto löschen","warning_html":"Gib Dein aktuelles Passwort ein, um zu bestätigen, dass Du Dein Benutzerkonto wirklich löschen möchtest. \u003cb\u003eAlle Deine Daten gehen dabei verloren. Der Vorgang kann nicht rückgangig gemacht werden.\u003c/b\u003e"},"deleted":"Der Benutzer wurde gelöscht.","edit":"Bearbeiten","email_invitation_hint":"Dem Benutzer wird eine E-Mail mit Anweisungen zum Festelegen eines Passworts gesendet.","empty":"Keine Beiträge assoziiert. Fügen Sie dem ausgewählten Benutzer Beiträge hinzu.","invite_user":"Benutzer einladen","me":{"change_password_hint":"Freilassen um bisheriges Passwort beizubehalten.","delete_account":"Benutzerkonto löschen","delete_account_hint":"Du möchtest die Anwendung nicht mehr nutzen?","deleted":"Dein Benutzerkonto wurde gelöscht.","updated":"Dein Profil wurde aktualisiert."},"none":"Sie haben keine Beiträge.","resend_invitation":"Einladung erneut verschicken","resent_invitation":"Der Benutzer wurde erneut per E-Mail eingeladen.","role_hint":{"admin":"Konto Administratoren können Benutzer und Beiträge des eigenen Kontos verwalten. System Admisitratoren haben Vollzugriff auf alle Konten.","others":"Konto Administratoren können Benutzer und Beiträge verwalten."},"roles":{"account_manager":"Konto Administrator","admin":"System Administrator","editor":"Redakteur"},"suspend":"Sperren","suspended":"Der Benutzer wurde gesperrt. Er kann sich nun nicht mehr anmelden.","unsuspend":"Entsperren","unsuspended":"Der Benutzer wurde entsperrt. Er kann sich nun wieder anmelden."}},"atmo":{"feature_name":"Atmo-Audios"},"audio":{"open":"Audio anhören"},"auto_change_page":{"feature_name":"Automatischer Seitenwechsel"},"built_in_page_type":{"audio":{"page_type_category_name":"Audio","page_type_description":"Wiedergabe von Audiodatei mit Steuerelementen"},"audio_loop":{"page_type_category_name":"Audio","page_type_description":"Wiedergabe einer Audiodatei ohne Steuerelemente (Atmo)"},"background_image":{"page_type_category_name":"Basic","page_type_description":"Bildschirmfüllendes Bild und Text"},"background_video":{"page_type_category_name":"Video","page_type_description":"Bildschirmfüllendes Video ohne Steuerelemente im Loop abgespielt"},"internal_links":{"page_type_category_name":"Verweise","page_type_description":"Sammlung von Verweisen zu anderen Seiten dieses Pageflows"},"video":{"page_type_category_name":"Video","page_type_description":"Wiedergabe einer Videodatei mit Steuerelementen"}},"chapter_hierachy":{"feature_name":"Kapitel Hierachie"},"common_page_link_attributes":{"label":{"inline_help":"Gib hier eine Bezeichnung ein, um später bei in der Verweis-Übersicht direkt zu erkennen, um welchen Verweis es sich handelt. Die Bezeichnung ist für die Leser nicht sichtbar.","label":"Bezeichnung"},"page_transition":{"inline_help":"Wähle hier den Effekt, der beim Übergang zur Zielseite des Verweises benutzt werden soll.","label":"Seitenübergangseffekt"},"target_page_id":{"inline_help":"Auf diese Seite kommt der Leser beim Klick auf den Verweis.","label":"Zielseite"}},"delayed_text_fade_in":{"feature_name":"Text verzögert einblenden"},"devise":{"mailer":{"reset_password_instructions":{"ignore_hint":"Falls Du diese Anfrage zur Passwortänderung gar nicht selbst gestartet hast, ignorier diese Mail einfach. Dein Passwort wird nicht geändert, bevor du den oben stehenden Link nicht bestätigt hast und im Anschluss ein neues Passwort anlegst.","instruction":"für dein persönliches Pageflow-Benutzerkonto wurde ein Link zur Passwortänderung angefordert. Du kannst diese Aktion durchführen, indem du folgenden Link anklickst.","salutation":"Hallo %{first_name}"}}},"edit_locks":{"break_action":{"acquire":"Stattdessen hier bearbeiten"},"errors":{"held_by_other_session_error":{"acquire_html":"\u003cp\u003eSie haben diesen Beitrag in einem anderen Fenster geöffnet.\u003c/p\u003e","other_html":"\u003cp\u003eSie haben diesen Beitrag in einem anderen Fenster geöffnet. Laden Sie die Seite neu und klicken Sie auf 'Stattdessen hier bearbeiten', um den akutellen Stand des Beitrags zu sehen.\u003c/p\u003e\u003cp\u003eWenn Sie die Bearbeitung hier fortsetzen, gehen möglicherweise Änderungen verloren.\u003c/p\u003e"},"held_by_other_user_error":{"acquire_html":"\u003cp\u003eDieser Beitrag wird im Moment von \u003cstrong\u003e%{user_name}\u003c/strong\u003e bearbeitet. Klicken Sie auf 'Stattdessen hier bearbeiten', um die Bearbeitung durch den anderen Benutzers abzubrechen.\u003c/p\u003e","other_html":"\u003cp\u003e\u003cstrong\u003e%{user_name}\u003c/strong\u003e hat ihre Bearbeitung abgebrochen. Laden Sie die Seite neu und klicken Sie auf 'Stattdessen hier bearbeiten', um den aktuellen Stand des Beitrags zu sehen.\u003c/p\u003e\u003cp\u003eWenn Sie die Bearbeitung hier fortsetzen, gehen möglicherweise Änderungen des anderen Benutzers verloren.\u003c/p\u003e"},"not_held_error":{"other_html":"\u003cp\u003eDie Bearbeitung des Beitrags wurde außerhalb dieses Editor beendet. Laden Sie die Seite neu, um den akutellen Stand des Beitrags zu sehen.\u003c/p\u003e\u003cp\u003eWenn Sie die Bearbeitung hier fortsetzen, gehen möglicherweise Änderungen verloren.\u003c/p\u003e"}},"required":"Die Aktion kann nicht durchgeführt werden, da der Beitrag gerade in einem Editor geöffnet ist.","required_but_held_by_other_user":"Die Aktion kann nicht durchgeführt werden, da der Beitrag gerade von einem anderen Benutzer bearbeitet wird."},"editor":{"atmo":{"disabled":"Atmo deaktiviert"},"blank_entry":{"create_chapter":"Klicke jetzt auf \u003cem\u003eNeues Kapitel\u003c/em\u003e, um ein erstes Kapitel zu erstellen.","create_page":"Klicke dann auf \u003cem\u003eNeue Seite\u003c/em\u003e, um dem Kapitel eine erste Seite hinzuzufügen.","edit_page":"Klicke auf eine Seite, um ihren Inhalt zu bearbeiten.","header":"Dies ist ein leerer Pageflow","intro":"Pageflows bestehen aus Kapiteln und Seiten. In der Seitenleiste rechts findest Du die Gliederung.","outro":"Hier siehst Du dann eine Vorschau deines Pageflows."},"entries":{"unsupported_browser_hint":{"message":"Die Version Ihres Browsers wird vom Pageflow Editor nicht unterstützt. Bitte benutzen Sie einen aktuellen Browser."}},"errors":{"UnmatchedUploadError":"Der Dateityp wird nicht unterstützt.","unknown":"Ein unbekannter Fehler ist aufgetreten."},"files":{"stages":{"encoding":{"action_required":"Bestätigung erforderlich.","active":"Encoding läuft.","failed":"Fehler beim Encoding.","finished":"Erfolgreich encodiert.","pending":"Noch nicht encodiert."},"fetching_meta_data":{"active":"Metadaten werden abgerufen.","failed":"Fehler beim Abrufen der Metadaten.","finished":"Metadaten erfolgreich abgerufen.","pending":"Metadaten noch nicht abgerufen."},"processing":{"active":"Verarbeitung läuft.","failed":"Fehler beim Verarbeiten.","finished":"Erfolgreich verarbeitet.","pending":"Noch nicht verarbeitet."},"uploading":{"active":"Wird hochgeladen.","failed":"Fehler beim hochladen.","finished":"Erfolgreich hochgeladen.","pending":"Noch nicht hochgeladen."},"uploading_to_s3":{"active":"Wird zu S3 übertragen.","failed":"Fehler beim übertragen zu S3.","finished":"Erfolgreich zu S3 übertragen.","pending":"Noch nicht zu S3 übertragen."}},"tabs":{"audio_files":"Audios","image_files":"Bilder","video_files":"Videos"}},"quotas":{"loading":"Quotas überprüfen..."},"templates":{"back_button_decorator":{"outline":"Gliederung"},"background_positioning":{"cancel":"Abbrechen","help":"Über die Auswahl des Bildausschnitts stellst Du sicher, dass Dein Bild auch auf mobilen Endgeräten optimal dargestellt wird.","preview_title":"Vorschau","previews":{"banner":"Banner","ratio16to9":"16:9 Landscape","ratio16to9Portrait":"16:9 Portrait","ratio4to3":"4:3 Landscape","ratio4to3Portrait":"4:3 Portrait"},"save":"Speichern","title":"Bildausschnitt anpassen"},"chapter_item":{"new_page":"Neue Seite","save_error":"Beim Speichern des Kapitels ist ein Fehler aufgetreten."},"confirm_encoding":{"all_released":"Alle Dateien wurden zur Transcodierung freigegeben.","audios_tab":"Audios","confirm_button":"Ausgewählte Dateien transcodieren","link_to_progress":"Auf der %{link} Seite wird der Fortschritt der Verarbeitung angezeigt.","manage_files":"Dateien verwalten","videos_tab":"Videos"},"confirmable_file_item":{"remove":"Löschen"},"edit_chapter":{"destroy":"Löschen","outline":"Gliederung","retry":"Erneut versuchen","save_error":"Beim Speichern des Kapitels ist ein Problem aufgetreten."},"edit_entry":{"close":"Schließen","manage_files":"Dateien verwalten","metadata":"Titel und Optionen","publish":"Veröffentlichen...","save_error":"Beim Speichern der Metadaten ist ein Fehler aufgetreten."},"edit_meta_data":{"outline":"Gliederung","retry":"Erneut versuchen","save_error":"Beim Speichern der Metadaten ist ein Problem aufgetreten."},"edit_page":{"destroy":"Löschen","outline":"Gliederung","retry":"Erneut versuchen","save_error":"Beim Speichern der Seite ist ein Problem aufgetreten."},"edit_page_link":{"back":"Zurück","destroy":"Löschen"},"edit_storyline":{"destroy":"Löschen","outline":"Gliederung","retry":"Erneut versuchen","save_error":"Beim Speichern des Erzählstrangs ist ein Problem aufgetreten."},"embedded":{"page_link":{"reset":"Zurücksetzen"}},"file_item":{"cancel":"Abbrechen","confirm":"Überprüfen und bestätigen","credits":"Rechte","destroy":"Löschen","download":"Herunterladen","retry":"Erneut versuchen","select":"Auswählen","source":"Original"},"files":{"back":"Zurück"},"files_blank_slate":{"no_files":"Es wurden noch keine Dateien dieses Typs hochgeladen."},"files_explorer":{"cancel":"Abbrechen","ok":"Ok","reuse_files":"Dateien wiederverwenden"},"files_explorer_blank_slate":{"choose_hint":"Bitte wählen Sie einen Beitrag aus."},"files_gallery_blank_slate":{"no_files":"In diesem Beitrag gibt es keine Dateien dieses Typs."},"help":{"close":"Schließen","title":"Hilfe"},"help_button":{"open_help":"Hilfe anzeigen"},"inputs":{"reference":{"edit":"Verknüpfung ändern","reset":"Verknüpfung entfernen"}},"list_blank_slate":{"text":"(Keine Einträge)"},"list_item":{"edit":"Bearbeiten","remove":"Löschen"},"loading":{"loading":"Daten werden geladen."},"locked":{"close":"Editor schließen","loading":"Der Beitrag wird zur Bearbeitung geöffnet. Bitte warten...","open_here":"Stattdessen hier öffnen"},"notification":{"approve_files":"%{num_files} Dateien müssen für die Transcodierung freigeben werden.","retry":"Erneut versuchen","save_error":"Datensätze konnten nicht gespeichert werden.","saved":"Alle Änderungen wurden gespeichert.","saving":"Änderungen werden gespeichert...","show":"Anzeigen","upload_pending":"Dateien werden gerade hochgeladen."},"other_entries_blank_slate":{"none_available":"Keine anderen Beiträge verfügbar"},"page_item":{"save_error":"Beim Speichern der Seite ist ein Fehler aufgetreten."},"page_link_item":{"edit":"Bearbeiten","remove":"Löschen"},"page_links":{"add":"Hinzufügen","label":"Verlinkte Seiten"},"page_selection":{"cancel":"Abbrechen","ok":"OK","title":"Zielseite auswählen"},"publish_entry":{"already_published_with_password_help":"Dieser Beitrag ist im Moment mit Passwortschutz veröffentlicht. Lassen Sie das Passwort-Feld frei, um das bisherige Passwort beizubehalten.","already_published_without_password_help":"Dieser Beitrag ist im Moment ohne Passwortschutz veröffentlicht. Nach Festlegen eines Passworts ist kein öffentlicher Zugriff mehr möglich.","date":"Datum","files_pending_notice":"Bitte warten Sie bis alle Dateien des Beitrags verarbeitet wurden und überprüfen Sie das Ergebnis. Der Beitrag kann dann veröffentlicht werden.","not_published_notice":"Dieser Beitrag ist zur Zeit nicht veröffentlicht.","password":"Passwort","password_help":"Teilen Sie Ihren veröffentlichten Beitrag nur mit bestimmten Personen. Besucher benötigen dann das von Ihnen festgelegte Passwort, um den Beitrag ansehen zu können.","password_protected":"Mit Passwort schützen","previously_published_with_password_help":"Dieser Beitrag war zuletzt mit Passwortschutz veröffentlicht. Lassen Sie das Passwort-Feld frei, um das bisherige Passwort beizubehalten.","publish":"Veröffentlichen","publish_current":"Akuellen Stand veröffentlichen","publish_success":"Der Beitrag wurde erfolgreich veröffentlicht.","published_notice":"Eine Revision dieses Beitrags ist zur Zeit veröffentlicht.","published_url_hint":"Er kann nun unter folgender URL erreicht werden:","show_files":"Dateien anzeigen","time":"Uhrzeit","unlimited":"Unbegrenzt","until_including":"Bis einschließlich","user_name":"Benutzername","view_revisions":"Revisionen ansehen"},"select_button":{"select":"Auswählen"},"storyline_outline":{"header":"Gliederung","new_chapter":"Neues Kapitel"},"storyline_picker":{"add":"Hinzufügen","edit":"Einstellungen bearbeiten"}},"views":{"chapter_item_view":{"chapter":"Kapitel","unnamed":"(Unbenannt)"},"edit_chapter_view":{"confirm_destroy":"Kapitel einschließlich ALLER enthaltener Seiten wirklich löschen?\n\nDieser Schritt kann nicht rückgängig gemacht werden."},"edit_page_link_view":{"default_page_transition":"(Standard)"},"edit_page_view":{"confirm_destroy":"Seite wirklich löschen?"},"edit_storyline_view":{"cannot_destroy":"Nur leere Erzählstränge können gelöscht werden.","confirm_destroy":"Erzählstrang wirklich löschen?","default_parent_page_transition":"(Standard)"},"editor_views":{"files_pending_warning":"Es werden noch Dateien hochgeladen. Wenn Sie die Seite verlassen werden die Uploads abgebrochen.","hide_editor":"Editorleiste ausblenden","resize_editor":"Größe der Editorleiste ändern","show_editor":"Editorleiste einblenden"},"entry_preview_view":{"scroll_hint":"Scrollen, um weiterzulesen"},"files_view":{"add":"Hinzufügen","reuse":"Wiederverwenden","upload":"Hochladen"},"inputs":{"reference_input_view":{"none":"(Kein)"}},"page_item_view":{"unnamed":"(Unbenannt)"},"page_link_item_view":{"no_page":"(Keine Seite)","unnamed":"(Unbenannt)"},"storylines_picker_view":{"label":"Erzählstrang","without_parent_page":"Ohne übergeordnete Seite"}}},"entry":{"duplicated_title":"Kopie von %{title}"},"help_entries":{"atmo":{"menu_item":"Atmo Audio","text":"# Atmo Audio\n\nMit der „Atmo“ kann jede Seite, unabhängig vom Seitentyp, im Hintergrund Sound abspielen. Dabei kannst Du bestimmen, ob ein Sound nur auf einer Seite zu hören ist oder über mehrere Seiten ohne Unterbrechung läuft. Wähle dazu einfach für die benachbarten Seiten die selbe Audiodatei als Atmo aus.\n\nAuf diese Weise lassen sich Kapitel akustisch voneinander absetzen und zusammenhängende Seiten stärker verweben.\n\nBeim Seitentyp Video kann zusätzlich ausgwählt werden, ob der Hintergrundsound während der Video-Wiedergabe normal oder leiser weitergespielt oder ganz ausgeblendet werden soll.\n\nDie Einstellung der Atmo-Sounds erreichst du bei jeder Seite über den Reiter „Optionen“.\n\nSollte Dich die Atmo während der Bearbeitung Deines Beitrags im Editor einmal stören, kannst Du sie mit der Tastenkombination „Alt + a“ vorübergehend stumm schalten. Um die Atmo wieder zu aktivieren, drücke einfach erneut „Alt + a“.\n\nACHTUNG: Atmo-Audios werden auf mobilen Geräten nicht wiedergegeben."},"built_in_page_type":{"audio":{"menu_item":"Audio","text":"# Audio\n\n*Wiedergabe von Audiodatei mit Steuerelementen* \n    \nHiermit kannst Du Audiodateien mit Bild und Textinhalten\nkombinieren. Wie beim Seitentyp „Video“ werden\nSteuerelemente angezeigt, und ebenso kann eine zusätzliche\nInfobox mit Text befüllt werden.\n\nTypische Anwendungsbeispiele: Interview, O-Töne,\nMusikstücke"},"audio_loop":{"menu_item":"Hintergrund-Audio","text":"# Hintergrund-Audio\n\nWiedergabe eines Audio-Loops ohne Steuerelemente (Atmo)\n    \nAuch hier wird wie beim „Hintergrund-Bild“ ein bildschirmfüllendes Foto ausgespielt. Der\nUnterschied zum reinen „Audio“ besteht darin, dass der Nutzer mangels Steuerelemente\nkeinen Einfluss auf die Wiedergabe hat und das Audio in einer Endlosschleife läuft.\n\nTypische Anwendungsbeispiele: Atmos, Klangwelten,\nFeld-Aufnahmen"},"background_image":{"menu_item":"Hintergrund-Bild","text":"# Hintergrund-Bild\n\nBildschirmfüllendes Bild und Text\n\nMit dem Seitentyp „Hintergrund-Bild“ werden großformatige\nBilder mit Text überlagert und zur optimalen Lesbarkeit\nmit einem manuell einstellbaren Farbverlauf gepaart. über\ndie Auswahl des Bildausschnitts stellst Du sicher, dass\nDein Bild auch auf mobilen Endgeräten optimal dargestellt\nwird. Wahlweise kann der Text für einen ausreichenden\nKontrast auch invertiert - also von hell in dunkel -\nvertauscht werden. Das bietet sich bei hellen\nHintergrund-Bildern an.\n\nUser haben übrigens die Möglichkeit Farbverlauf und Text\nim Front-End auszublenden, sofern Sie sich speziell für\ndas Hintergrund-Bild interessieren.\n\nTypische Anwendungsbeispiele: Präsentation, Teil einer\nBildergalerie, Portrait\n"},"background_video":{"menu_item":"Hintergrund-Video","text":"# Hintergrund-Video\n\n*Bildschirmfüllendes Video ohne Steuerelemente im Loop*\n    \nabgespielt Dieser Seitentyp entspricht dem\nHintergrund-Bild mit dem Unterschied, dass hier statt\neines Bildes ein Video angezeigt wird. Dieses startet\nautomatisch und wird ohne Steuerungselement abgespielt,\nwomit User Start und Stopp nicht beeinflussen können.  Da\ndas Video in einer Endlosschleife abgespielt wird, sollte\ndeshalb auf ausreichende Länge und/oder einen sauberen\nübergang geachtet werden. Gleiches gilt für die im Video\nenthaltene Tonspur.\n\nEin Hinweis zur Nutzung von Pageflow auf Smartphones: Um\nungewollten Datenverbrauch beim übertragen großer\nVideodateien zu verhindern, werden diese auf mobilen\nEndgeräten nicht ausgespielt. Stattdessen wird ein\nPoster-Bild angezeigt, das automatisch aus dem Video\ngeneriert wird. Optional kann dieses aber auch durch ein\nselbstgewähltes Bild ersetzt werden.\n\nTypische Anwendungsbeispiele: Intro, Kapitelübergang, Atmo"},"internal_links":{"menu_item":"Seitenverweise","text":"# Seitenverweise\n\nVerweise auf andere Seiten innerhalb eines Pageflows\nIm Gegensatz zur externen Verweis-Seite, werden hier interne Seiten innerhalb des\nPageflows verlinkt. Dies bietet sich an, um den User gezielt durch den Pageflow zu leiten.\n\nTypische Anwendungsbeispiele: Willkommens-Seite, Kapitel-Startseite\n"},"video":{"menu_item":"Video","text":"# Video\n\n*Wiedergabe einer Videodatei mit Steuerelementen* \n   \nAnders als bei „Hintergrund-Videos“ werden hier Textelemente nach ein\npaar Sekunden automatisch ausgeblendet, um die\nAufmerksamkeit auf das Bewegtbild zu lenken. Mit\nSteuerelementen kann der Nutzer das Video jederzeit\nstarten und pausieren, vor- oder zurückspulen. Ein\nweiterer Unterschied ist, dass Du wählen kannst, ob ein\nVideo automatisch gestartet wird, sobald die Seite\nangezeigt wird.  Als dezente Alternative oder Ergänzung zu\nden normalen Texteingabemöglichkeiten, kann eine\nsogenannte „Infobox“ mit Text befüllt werden.\n\nUnter Optionen lässt sich ein automatisches weiterscrollen am Ende des Videos aktivieren. \nDas kann nützlich sein, um einen nahtlosen Übergang zur nächsten Seite herzustellen.\n\nTypische Anwendungsbeispiele: Filme aller Art, Interviews,\nPortrait"}},"files":{"menu_item":"Dateien verwalten","text":"# Dateien verwalten\n\nPageflow verarbeitet alle gängigen Medien-Formate (Bild,\nAudio, Video) und rechnet diese in unterschiedliche Formate\nund Qualitäten um. Das System passt dann automatisch die\nAusgabequalität der Medien an die jeweilige\nInternetverbindung und das Endgerät des Users\nan. Prinzipiell sollten Dateien in der bestmöglichen\nAuflösung verwendet werden und vor dem Upload nicht\nkomprimiert sein. Zudem ist es für ein strukturiertes\nArbeiten enorm hilfreich, sämtliche Audios,\nHintergrund-Video-Loops, Filme, Bilder und Texte bereits im\nVorfeld in der gewünschten Version in einem separaten Ordner\nauf dem eigenen Rechner abzulegen.\n\n## Dateien hochladen \u0026 verwalten\n\nVon der Gliederung führt der Menüpunkt \"Dateien verwalten\"\nzur Liste der bereits hochgeladenen Dateien. Über die\nSchaltfläche \"Hinzufügen -\u003e Hochladen\" fügst Du weitere\nDateien hinzu.\n\nNach dem Hochladen werden die Dateien zunächst auf dem\nServer verarbeitet. Dies kann bei längeren Videos einige\nMinuten in Anspruch nehmen. Klicke auf das Thumbnail einer\nDatei, um den aktuellen Verarbeitungsstatus\neinzublenden. Hier lassen sich auch die allgemeinen\nEigenschaften, wie Bildgröße oder Audiolänge einsehen und\ndie Originaldatei herunterladen.\n\nDateien können bereits in Seiten verwendet werden, auch wenn\ndie Verarbeitung noch nicht abgeschlossen ist. Während des\nLadevorgangs kann also problemlos weiter gearbeitet werden.\n\n## Urheberrechte von Dateien\n\nBei jeder einzelnen Mediendatei (Bilder, Videos, Audios)\ngibt es bei Klick auf das jeweilige Thumbnail die\nMöglichkeit, Angaben zu den Urheberrechten zu machen, die\ndann automatisch im „Impressum“ angezeigt werden.\n\n## Dateien wiederverwenden\n\nVideos, Audios und Bilder können in mehr als einem Beitrag\nverwendet werden. So müssen z.B. Videos nicht mehrfach\nhochgeladen und verarbeitet werden. Klicke hierfür unter\n\"Dateien verwalten“ auf \"Hinzufügen -\u003e Wiederverwenden\", um\nandere Beiträge nach Dateien zu durchsuchen und sie in den\nbearbeiteten Beitrag zu übernehmen."},"meta_data":{"menu_item":"Titel und Optionen","text":"# Titel und Optionen\n\n## Allgemein\n\n### Titel des Pageflows\n\nHier kannst Du Deinem Pageflow einen Titel geben, der in der\nTitelleiste des Browserfensters angezeigt wird. Unter diesem\nTitel wird Dein Pageflow nach der Veröffentlichung auch in\nSuchmaschinen indiziert werden.\n\n### Sprache\n\nWähle hier, in welcher Sprache Dein Pageflow ausgespielt\nwird. Hierbei geht es um nicht editierbare Texte, wie\nz.B. den Multimedia-Hinweis, Scroll-Hinweis, die Übersicht\nund Impressum.\n\n### Impressum\n\nHier kannst Du Deine Impressums-Information im Freitext\neingeben.\n\n## Erscheinungsbild\n\n### Multimedia Hinweis vor dem Start\n\nEntscheide, ob zu Beginn Deines Pageflows ein Hinweis angezeigt wird.\n\n### Kapitelanfang hervorheben\n\nMit dieser Option wird der Titel der jeweils ersten Seite\neines Kapitels größer dargestellt.\n\n## Neue Seiten hervorheben\n\nZeigt zum Start des Pageflows in einer Info-Box die seit dem\nletzten Besuch neu erstellen Seiten an.\n\n### Home-Button anzeigen\n\nEs gibt die Möglichkeit, in der Navigation einen Button\nanzuzeigen, der auf eine externe Seite verlinkt, z.B. zurück\nauf die Homepage, von der aus Du den Pageflow verlinkt hast.\n\n### Navigationsleiste\n\nWähle zwischen \"Navigationsleiste mit Fortschrittsbalken“\noder \"Navigationsleiste mit Thumbnails“. Beachte, dass bei\nmobilen Endgeräten statt der Navigationsleiste aus\nPlatzgründen in beiden Fällen lediglich das Icon „Übersicht“\nangezeigt wird.\n\n## Social\n\n### Social Sharing Bild\n\nWähle hier das Bild aus, das beim Teilen des Pageflows in\nsozialen Netzwerken erscheinen soll.\n\n### Zusammenfassung\n\nTrage hier ein, welcher Beschreibungstext beim Teilen in\nsozialen Netzwerken angezeigt wird.\n"},"outline":{"menu_item":"Kapitel und Seiten","text":"# Kapitel und Seiten\n\nEin Pageflow besteht aus mindestens einem Kapitel mit\nmindestens einer Seite. Es können beliebig viele Kapitel mit\nbeliebig vielen Seiten erstellt werden. Um Inhalte zu\nerstellen, klicke\n\n1. auf Neues Kaptitel, um eine erstes Kapitel zu erstellen\n2. auf Neue Seite, um dem Kapitel eine Seite hinzuzufügen, und\n3. auf diese Seite, um den Inhalt zu bearbeiten.\n\n## Aufbau eines Kapitels\n\nMit den „Kapiteln\" strukturierst Du den Aufbau Deiner\nReportage - beispielsweise nach Themenschwerpunkten oder\nZeiträumen. Die Kapitel werden in der „Übersicht“ angezeigt\nund dienen dem User als Orientierungshilfe. Deshalb ist es\nratsam die jeweiligen Kapitel mit Titeln zu versehen.\n\nWenn nur ein unbenanntes Kapitel angelegt wird, so verhält\nsich Pageflow, als ob keine Kapitelstruktur vorhanden\nist. (Kapitel und Kapiteltitel werden in diesem Falle nicht\nin der Übersicht bzw. Navigation dargestellt).\n"},"overview":{"menu_item":"Übersicht","text":"# Übersicht\n\nDies ist der Editor zum Bearbeiten eines Pageflows. Mit\nseiner Zweiteilung ermöglicht er die direkte Vorschau\nwährend der Bearbeitung, zeigt Änderungen am Text oder neu\nausgewählte Dateien unmittelbar an und speichert diese\nautomatisch.\n\nDie Seitenleiste kann durch einen Klick auf den Anfasser zur\nGrößenänderung ein- und ausgeblendet werden. Mit einem\nVerschieben der Seitenleiste nach links und rechts kannst Du\ndie Größe des Vorschaufensters verändern. Wird das\nVorschaufenster schmal, und somit eher zu einem hochkantigen\nMobiltelefon-Format gestaucht, wird aus Platzgründen statt\nder Navigationsleiste nur das Icon „Übersicht“ angezeigt.\n\nDie Navigation des Editors ist unterteilt in die vier\nBereiche:\n\n## Titel und Optionen\n\nUnter „Titel und Optionen“ kannst Du grundsätzliche\nParameter des Erscheinungsbildes, sowie Titel, Sprache,\nImpressum etc. einstellen. Dazu können Texte festgelegt\nwerden, die beim Teilen des Beitrags über Social Media\nDienste angezeigt werden sollen.\n\nDetails findest Du unter: [Titel und Optionen](#pageflow.help_entries.meta_data)\n\n## Dateien verwalten\n\nUnter „Dateien verwalten“ lädst Du die Mediendateien hoch,\ndie im Pageflow verwendet werden sollen. Du kannst hier auch\nbereits hochgeladene Videos, Fotos und Audios\nwiederverwenden.\n\nDetails findest Du unter: [Dateien verwalten](#pageflow.help_entries.files)\n\n## Gliederung\n\nÜber die „Gliederung“ kannst Du Kapitel und Seiten\nhinzufügen, also die eigentlichen Inhalte bearbeiten. Per\nDrag\u0026Drop lassen sich Seiten und Kapitel auch jederzeit\numsortieren.\n\nDetails findest Du unter: [Kapitel und Seiten](#pageflow.help_entries.outline)\n"},"page_options":{"menu_item":"Allgemeine Seitenoptionen","text":"# Allgemeine Seitenoptionen\n\n### Titel\n\nHier gibst Du den Titel der jeweiligen Seite ein. Dieser\nwird nicht nur als Überschrift des Fliesstextes der Seite\nausgespielt, sondern dient zudem als Titel innerhalb der\nNavigation und der Übersicht. Wird eine einzelne Seite in\nsozialen Netzwerken geteilt, ist dieser Titel zugleich auch\nder Titel des Social Media-Beitrages.\n\n### Titel ausblenden\n\nOptional lässt sich der Titel auch ausblenden. Das heisst:\nEr wird nicht mehr als Überschrift im Fliesstext\nangezeigt. Er bleibt zur Identifikation einer Seite\nallerdings in Navigation, Übersicht und geteilten Beträgen\nerhalten.\n\n### Tagline und Untertitel\n\nHier kann wahlweise eine Tagline und/oder ein Untertitel\neingegeben werden. Falls Du ein Häkchen bei „Titel\nausblenden“ gesetzt hast, sind Tagline und Untertitel über\ndem Fliesstext ebenfalls nicht zu sehen.\n\n### Text\n\nDer Textblock kann mit den Buttons unterhalb des\nEingabefeldes formatiert werden. [ B=Fett / I=kursiv /\nU=unterstrichen „gekippte acht“=Link/URL auf fremde Seite\neinfügen].\n\nAlle Änderungen sind in der linken Frontend-Ansicht\nsichtbar, sobald das entsprechende Texteingabefeld im\nEditierbereich verlassen wurde.\n\n### Textposition\n\nWähle hier, ob der Text auf der linken oder rechten Seite\nangezeigt wird.\n\n### Intensität der Abblendung\n\nDie Intensität des Farbverlaufs dient der Lesbarkeit von\nTexten auf Videos oder Bildern.\n\nDurch den Schieberegler kann der Bildhintergrund so stark\nabgedunkelt bzw. aufgehellt werden, bis der Kontrast\nzwischen Bild und Text ausreichend ist.\n\n### Farben invertieren\n\nBeim Invertieren werden „hell“ und „dunkel“ vertauscht, die\nsonst weiße Schrift ändert sich dabei automatisch in\nschwarz.\n\nGrundsätzlich gilt: Helle Schrift für dunkle Bilder, dunkle\nSchrift für helle Bilder.\n\n### Thumbnail\n\nDas Thumbnail ersetzt das ansonsten automatisch generierte\nVorschaubild in der Navigation und in der Übersicht.\n\n### In Navigationsleiste anzeigen\n\nIst diese Option nicht gesetzt, wird die jeweilige Seite\nnicht in der Navigation repräsentiert, kann also nicht\ndirekt über die Navigation erreicht werden.\n\nDies bietet sich vor allem für Seiten an, die inhaltlich als\n„Unterseiten“ einer anderen Seite anzusehen sind.\n\n### Übergangseffekt\n\nEs gibt verschiedene Effekte, die sichtbar sind, wenn von einer Kapitelseite zur nächsten gescrollt oder geklickt wird. Zur Auswahl stehen Seitenübergänge, wie „Überblendung“, „Schwarzblende“ oder „Harter Schnitt“ die sich vertikal auswirken, zudem kann auch „Horizontal Scrollen“ von rechts oder links ausgewählt werden. \n\nWelcher Effekt verwendet wird, kann unter „Optionen“ individuell für jede Seite festgelegt werden.\n\n### Text verzögert einblenden\n\nBestimme mit dieser Option, ob Text und Abblendung mit zeitlicher Verzögerung angezeigt werden.\nHierbei sehen User zunächst nur den Hintergrund, dann erscheinen Titel, Tagline und Untertitel und mit minimaler Verzögerung schließlich der Fließtext.\n\nInsgesamt stehen drei Verzögerungslängen zur Verfügung: kurz = 1 Sekunde, mittel = 3 Sekunde, lang = 5 Sekunde.\n\nDieses Feature eignet sich zum Beispiel für Intros oder Kapitelanfänge.\n\n### Beschreibung für Übersicht\n\nHier kann der Text eingegeben werden, der angezeigt wird,\nwenn der User in der Übersicht mit der Mouse über die\njeweilige Seite fährt. Außerdem entspricht der hier\neingegebene Text"},"page_types":{"menu_item":"Seitentypen","text":"# Seitentypen\n\nDurch die Auswahl des Seitentyps legst Du fest, welche\nMedien in der jeweiligen Seite verwendet werden. Je nach\nSeitentyp stehen verschiedene Einstellungen zur Verfügung.\nFür weitere Informationen klicke bitte auf einen Seitentyp\nin der linken Spalte.\n"},"publishing":{"menu_item":"Veröffentlichen","text":"# Veröffentlichen\n\nKlicke in der Gliederung auf die Schaltfläche\n„Veröffentlichen“ um Deinen Pageflow zu publizieren. Eine\nReportage kann entweder zeitlich unbegrenzt oder bis zu\neinem bestimmten Stichtag veröffentlicht\nwerden. \n\nAußerdem gibt es die Möglichkeit, Pageflows mit einem Passwort zu schützen. \nHierzu muss einfach das entsprechende Häkchen bei „Mit Passwort schützen\" gesetzt werden. \nDas System verwendet als Benutzernamen den Namen des Kontos und generiert ein Passwort, \nwelches auch manuell geändert werden kann. \n\nBeiträge, die bereits veröffentlicht sind, können nachträglich mit einem Passwort geschützt werden - \nund andersherum können auch geschützte Beiträge anschließend mit erneutem Klick auf „Veröffentlichen“ vom Passwortschutz befreit werden. \nBei der Veröffentlichung werden die auszuführenden Schritte im Dialogfenster angezeigt und erklärt.\n\nVeröffentlichte Pageflows können jederzeit manuell\ndepubliziert werden. Sollte eine Reportage bereits\nveröffentlicht sein, bleiben Änderungen solange öffentlich\nunsichtbar, bis die Reportage erneut veröffentlicht wird.\nEine Reportage kann stets nur von einem Redakteur zur\ngleichen Zeit bearbeitet werden.\n\nVorschaubild zum Einbetten in Externe Webseiten Nach der\nVeröffentlichung erstellt das System ein Vorschaubild, das\nals iframe zur Verlinkung in eine externe Seite eingebunden\nwerden kann.  Anhand des ausgespielten Codes lässt sich die\nGröße des iframes frei einstellen. Hierbei ist jedoch eine\nMindesthöhe von 150px und und eine Mindestbreite von 220px\nzu beachten."},"storylines":{"menu_item":"Erzählstränge","text":"# Erzählstränge\n\nErgänzend zur linearen Erzählung von „oben nach unten“, können auch weitere (non-lineare) Erzählstränge als Exkurse zu vertiefenden Inhalten genutzt werden. Mit „Erzählstrang“ ist hier die zusammenhängende Kapitel- und Seitenabfolge gemeint, durch die ein User hindurch scrollt. Zu unterscheiden ist zwischen dem sogenannten Haupterzählstrang, in dem ein User zu Beginn eines Pageflows einsteigt, und weiteren untergeordneten Erzählsträngen. \n\nUm vom Haupterzählstrang einen Abzweig zu erstellen, benutze eine „Verweise“-Seite (Mosaik, Collage oder Hotspot) und lege auf der jeweiligen Seite unter „Verweise“ die entsprechenden Verknüpfungen an. \n\nDabei kann durch das Festlegen einer „übergeordneten Seite“ bestimmt werden, zu welcher Seite der User am Ende des Erzählstrangs  gelangt.\n\nOptisch unterstützt werden diese Exkurse in untergeordnete Erzählstränge durch einen horizontalen Seitenübergangseffekt, der beim Eintreten und Verlassen dieser Stränge automatisch eingestellt ist. \n\nErstellt werden diese Erzählstränge in der Gliederung über ein Klick auf die Plus-Schaltfläche neben der Erzählstrang-Auswahl. Dabei öffnet sich automatisch ein neues Kapitel, in dem dann weitere Seiten angelegt werden können.\n\n\n### Übergeordnete Seiten\n\nIn jedem Untererzählstrang muss eine „Übergeordnete Seite“ festgelegt werden, die bestimmt, wohin ein User beim zurück-scrollen gelangt. Mit einem Klick auf das Stift-Symbol neben der Erzählstrang-Auswahl kann diese Zielseite ausgewählt werden. Durch die Auswahl einer übergeordneten Seite erscheint auf allen Seiten eines untergeordneten Erzählstrangs zudem automatisch ein „Zurück“-Button, der zu der übergeordneten Seite führt. \n\n\n### Kapitel-Hierarchie\n\nDurch die Verwendung mehrerer „untergeordneter“ Erzählstränge und der Festlegung von übergeordneten Seiten ergibt sich eine Kapitelhierarchie, wie man sie auch von Buch-Gliederungen kennt:\n\n1. (Hauptstrang), 1.1 (Übergeordneter Unterstrang), 1.1.1 (vertiefende Seite im übergeordneten Unterstrang) und so weiter.\n\nDiese Hierarchie kann nachträglich in der Erzählstrang-Auswahl über ein Klick auf Stift-Symbol geändert werden. Ein untergeordneter Erzählstrang kann an dieser Stelle zudem auch nachträglich zum Haupt-Erzählstrang umsortiert werden.\n\n\n### Scroll-Nachfolger\n\nFalls der User von der letzten Seite eines Unterkapitels (1.1.1) auf eine andere Stelle im Beitrag geleitet werden soll (z.B. 2.1), kann hierzu ebenfalls über das Stiftsymbol in den Erzählstrang-Einstellungen der sogenannte „Scroll-Nachfolger“ festgelegt werden. Um in dem Beispiel zu bleiben wäre der folgende Ablauf denkbar: 1 -\u003e 1.1 -\u003e 1.1.1 -\u003e 2.1\n\nAchtung: Während des Editierens wird immer nur das aktuell ausgewählte Kapitel angezeigt. Um zu den anderen Erzählsträngen zu gelangen klicke auf das Auswahlmenü „Erzählstrang“."}},"helpers":{"entries":{"global_links":"Globale Links","image_rights":"Bildrechte"}},"invalid_transition":"Der gewünschte Statuswechsel ist nicht erlaubt.","page_transitions":{"crossfade":"Überblenden","cut":"Harter Schnitt","fade":"Hintergrund Blenden/Vordergrund Scrollen","fade_to_black":"Schwarzblende","scroll":"Scrollen","scroll_left":"Scrollen (von links)","scroll_over_from_left":"Überlagern (von links)","scroll_over_from_right":"Überlagern (von rechts)","scroll_right":"Scrollen (von rechts)"},"quotas":{"exhausted":"Quota verbraucht."},"storyline_attributes":{"main":{"inline_help":"Macht die erste Seite dieses Erzählstrangs zur Startseite des Beitrags.","inline_help_disabled":"Die erste Seite dieses Erzählstrangs ist die Startseite des Beitrags.","label":"Haupterzählstrang"},"navigation_bar_mode":{"label":"Navigationsleiste","values":{"current_storyline":"Aktueller Erzählstrang","inherit_from_parent":"Von übergeordnetem Kapitel erben","non":"Ausblenden"}},"page_transition":{"inline_help":"Standardmäßig wird beim Erreichen des Erzählstrangs von der übergeordneten Seite die erste Seite des Erzählstrangs von rechts hineingeschoben. Bei Klick auf den Zurück-Button fährt die Seite wieder nach rechts hinaus. Hier kannst Du einen alternativen Effekt wählen.","label":"Seitenübergangseffekt"},"parent_page_perma_id":{"inline_help":"Die Auswahl einer übergeordneten Seite bestimmt, auf welcher Seite der User am Ende eines untergeordneten Erzählstrangs oder bei Klick auf den Zurück-Button landet. Mit einer solchen Seite kann die Kapitelhierarchie bestimmt werden, falls mehr als zwei Erzählstränge benutzt werden. Mehr Informationen zur Kapitelhierachie findest Du im Hilfethema 'Erzählstränge'.","label":"Übergeordnete Seite"},"scroll_successor_id":{"inline_help":"Seite, die beim Weiterscrollen am Ende des Erzählstrangs erreicht werden soll. Standardmäßig gelangt der Leser zur übergeordneten Seite zurück.","label":"Scroll Nachfolger"},"title":{"label":"Titel"}},"storylines":{"feature_name":"Erzählstränge","main":"Haupstrang","untitled":"Unbenannter Erzählstrang"},"ui":{"configuration_editor":{"tabs":{"files":"Dateien","general":"Allgemein","links":"Verweise","options":"Optionen","social":"Social","widgets":"Erscheinungsbild","content":"Fließtext","header":"Titel","topic":"Inhalt","appearance":"Erscheinungsbild","areas":"Bereiche"}},"inline_help":{"pageflow/chapter":{"title":"Wird auf der Übersichtsseite angezeigt."},"pageflow/entry":{"author":"Name des Autors.","credits":"Text wird zusammen mit dem Impressumsverweis angezeigt.","emphasize_chapter_beginning":"Mit dieser Option wird der Titel der jeweils ersten Seite eines Kapitels größer dargestellt.","emphasize_new_pages":"Zeigt zum Start des Pageflows in einer Info-Box die seit dem letzten Besuch neu erstellen Seiten an.","home_button_enabled":"Es gibt die Möglichkeit, in der Navigation einen Button anzuzeigen, der auf eine externe Seite verlinkt, z.B. zurück auf die Homepage, von der aus Du den Pageflow verlinkt hast.","home_button_enabled_disabled":"Diese Funktion steht in diesem Theme nicht zur Verfügung.","home_url":"URL der Übersichtseite. Leer lassen, um Standard zu übernehmen.","home_url_disabled":"Diese Funktion steht in diesem Theme nicht zur Verfügung.","keywords":"Schlüsselwörter als Vorschlag für Suchmaschinen.","manual_start":"Entscheide, ob zu Beginn Deines Pageflows ein Hinweis angezeigt wird.","overview_button_enabled":"In der Übersicht werden die Kapitel und Seiten des Haupterzählstrangs angezeigt.","overview_button_enabled_disabled":"Diese Funktion steht in diesem Theme nicht zur Verfügung.","publisher":"Name oder Firmenname des Herausgeber.","share_url":"URL, die geteilt werden soll, wenn der Benutzer auf einen der Social Media Buttons klickt. Feld frei lassen, um URL des veröffentlichten Beitrags zu verwenden.","summary":"Trage hier ein, welcher Beschreibungstext beim Teilen in sozialen Netzwerken angezeigt wird.\n","title":"Hier kannst Du Deinem Pageflow einen Titel geben, der in der Titelleiste des Browserfensters angezeigt wird. Unter diesem Titel wird Dein Pageflow nach der Veröffentlichung auch in Suchmaschinen indiziert werden"},"pageflow/page":{"additional_title":"Die Infobox wird über den Steuerelementen zum Starten und Stoppen der Wiedegabe angezeigt.","atmo_audio_file_id":"Wähle eine Audio-Datei, die im Hintergrund abgespielt werden soll. Wenn diese Atmo auch auf Folgeseiten nahtlos weiterspielen soll, wähle auf diesen Seiten die selbe Datei aus. Diese Funktionalität steht im Moment nicht auf mobilen Geräten zur Verfügung.","atmo_during_playback":"Wähle wie sich die Atmo während der Wiedergabe des Hauptmediums dieser Seite verhalten soll.","delayed_text_fade_in":"Blendet die Textinhalte der Seite sowie die Abblendung zeitverzögert ein, nachdem man auf die Seite geblättert hat. So wird für eine gewisse Zeit der Blick auf den Hintergrund freigegeben.","description":"Hier kann der Text eingegeben werden, der angezeigt wird, wenn der User in der Übersicht mit der Mouse über die jeweilige Seite fährt. Außerdem entspricht der hier eingegebene Text auch dem Mouse-Over-Text beim Seitentyp „Seiten-Verweise“, sowie dem Text zum Teilen in sozialen Netzwerken.","gradient_opacity":"Die Intensität des Farbverlaufs dient der Lesbarkeit von Texten auf Videos oder Bildern.\n\nDurch den Schieberegler kann der Bildhintergrund so stark abgedunkelt bzw. aufgehellt werden, bis der Kontrast zwischen Bild und Text ausreichend ist.","invert":"Beim Invertieren werden „hell“ und „dunkel“ vertauscht, die sonst weiße Schrift ändert sich dabei automatisch in schwarz. \n\nGrundsätzlich gilt: Helle Schrift für dunkle Bilder, dunkle Schrift für helle Bilder.","mobile_poster_image_id":"Dieses Bild wird in der Mobilvariante der Seite als Posterbild gezeigt.","text":"Der Textblock kann mit den Buttons unterhalb des Eingabefeldes formatiert werden. [ B=Fett / I=kursiv / U=unterstrichen „gekippte acht“=Link/URL auf fremde Seite einfügen].\n\nAlle Änderungen sind in der linken Frontend-Ansicht sichtbar, sobald das entsprechende Texteingabefeld im Editierbereich verlassen wurde.","thumbnail_image_id":"Das Thumbnail ersetzt das ansonsten automatisch generierte Vorschaubild in der Navigation und in der Übersicht.","transition":"Wähle hier den Effekt, der beim Erreichen dieser der Seite benutzt werden soll.","invert_text":"Vertauscht Text- und Hintergrundfarbe im Fließtextbereich.","prevent_fullscreen":"Verhindert, dass das Fließtextbild bei Klick auf das Bild im Vollbild dargestellt wird.","sticky_inline_image":"Das Bild wird zunächst zusammen mit dem Text gescrollt, bleibt dann aber vertikal zentriert stehen, während der Text weiter scrollt.","text_coverage":"Definiert, wie viel Text (und wie viel vom Titelbild) anfangs sichtbar ist.","text_image_id":"Dieses Bild wird neben dem Text angezeigt.","topasset_dim":"Titlebild abhängig von der Scroll-Position farblich abblenden.","topasset_parallax":"Titelbild abhängig von der Scroll-Position vertikal verschieben."},"pageflow/external_links/site":{"description":"Empfohlene Textlänge: bis zu 220 Zeichen","thumbnail":"Empfohlenes Seitenverhältnis: 16:9"},"pageflow/linkmap_page/area":{"link_title":"Die Beschreibung wird in einem Overlay angezeigt, wenn sich der Cursor über dem Hotspot befindet.","marker":"Wähle die visuelle Darstellung des Hotspots.","name":"Gib hier eine Bezeichnung ein, um später bei in der Verweis-Übersicht direkt zu erkennen, um welchen Verweis es sich handelt. Die Bezeichnung ist für die Leser nicht sichtbar.","page_transition":"Wähle hier den Effekt, der beim Übergang zur Zielseite des Verweises benutzt werden soll.","target_id":"Objekt auf das der Hotspot verlinkt.","target_type":"Wähle den Typ von Objekt auf den Hotspot verlinken soll.","inverted":"Dunkle Piktogramme für die Verwendung auf hellen Hintergründen anzeigen."}},"templates":{"inputs":{"file_input":{"adjust_positioning":"Bildausschnitt anpassen","edit":"Ändern","reset":"Zurücksetzen"},"page_reference":{"drag_hint":"Ziehen Sie Seiten per Drag \u0026amp; Drop in die Seite um Verweise zu erstellen."},"text_area_input":{"bold":"Fett","cancel":"Abbrechen","create_link":"Link einfügen","italic":"Kursiv","ok":"Ok","underline":"Unterstrichen","url":"URL"}}},"views":{"extended_select_input_view":{"display_help":"Hilfe anzeigen"},"inputs":{"file_input_view":{"none":"(Kein)"},"proxy_url_input_view":{"http_error":"Die URL konnte nicht erfolgreich abgerufen werden (Der Server antwortete mit HTTP Status Code ' %{status}')","url_validation":"Prüfe Erreichbarkeit der URL..."},"select_input_view":{"none":"(Kein)","placeholder":"Standard (%{text})"},"text_input_view":{"required_field":"Muss ausgefüllt werden"},"url_input_view":{"required_field":"Muss ausgefüllt werden","supported_vendors":"Es werden nur die folgenden Anbieter unterstützt:","url_hint":"URL muss mit http:// beginnen.","url_hint_https":"URL muss mit http:// oder https:// beginnen."}}}},"unauthorized":"Sie sind nicht berechtigt diese Seite anzuzeigen.","user_mailer":{"invitation":{"ending":"Dankeschön und viel Spaß,","greeting":"Dein Pageflow-Team","instruction":"Willkommen bei Pageflow. Bitte lege über den folgenden Link ein Kennwort fest. In Zukunft kannst Du Dich dann mit Deiner E-Mail-Adresse anmelden.","salutation":"Hallo %{first_name}","subject":"Ihre Pageflow Einladung"}},"widgets":{"none":"(Kein)","roles":{"analytics":"Zählpixel","mobile_navigation":"Mobile Navigation","navigation":"Navigationsleiste","player_controls":"Player Controls"},"type_names":{"classic_player_controls":"Klassisch","default_mobile_navigation":"Navigationsmenü mit Thumbnails","default_navigation":"Navigationsleiste mit Thumbnails","slim_player_controls":"Minimalistisch"}},"public":{"_language":"Deutsch","audio":"Audio","back":"Zurück","back_to_chapter":"Zurück zu Kapitel","before_after":{"drag_hint":"Linke Maustaste drücken und nach links oder rechts ziehen","hint":"Vorher/Nacher Ansicht","leave_view":"Vorher/Nachher-Ansicht verlassen","start":"Vorher/Nachher-Ansicht starten","start_title":"Vorher/Nachher-Ansicht starten"},"chapter":"Kapitel","chart":{"toggle":"Ansicht vergrößern bzw. verkleinern"},"close":"Schließen","close_hint":"Hinweis schließen","close_navigation":"Navigation schließen","close_overview":"Übersicht schließen","deprecated_browser":"\u003cp\u003eLiebe Nutzer,\u003c/p\u003e\u003cp\u003eleider nutzen Sie eine veraltete Version Ihres Browsers. Deshalb können die an dieser Stelle vorgesehenen Inhalte nicht korrekt dargestellt werden. Bitte aktualisieren Sie auf eine aktuelle Version.\u003c/p\u003e","embedded_video":{"leave_video":"Eingebettetes Video verlassen"},"enlarge_view":"Ansicht vergrößern","enter_fullscreen":"Vollbilddarstellung","first_page":"Erste Seite","forward":"Vorwärts","fullscreen":"Vollbild","goto_first_page":"Zur ersten Seite","goto_top":"Zum Anfang","hide_text":"Text ausblenden","home":"Startseite","imprint":"Impressum","javascript_hint":"Zur korrekten Anzeige der Seite benötigen Sie JavaScript.","languages":{"ar":"Arabisch","cs":"Tschechisch","de":"Deutsch","dk":"Dänisch","el":"Griechisch","en":"Englisch","es":"Spanisch","fr":"Französisch","it":"Italienisch","nl":"Holländisch","pl":"Polnisch","pt":"Portugiesisch","ru":"Russisch","sr":"Serbisch","tr":"Türkisch","unknown":"(Unbekannt)","zh":"Chinesisch"},"leave_fullscreen":"Vollbilddarstellung beenden","lets_go":"Los geht's","logo":"Logo","media_quality":"Qualität","mute_off":"Ton ein","mute_on":"Ton aus","navigate_top":"Zum Anfang","navigation":"Navigation","new_pages_box":{"additional_pages_html":"...und \u003cspan\u003e\u003c/span\u003e weitere","description":"Seit dem letzten Besuch wurden diesem Pageflow neue Seiten hinzugefügt:","title":"Neue Seiten"},"notice":"Hinweis","open_audio":"Audio öffnen","open_navigation":"Navigation öffnen","open_overview":"Übersicht öffnen","open_video":"Video öffnen","overview":"Übersicht","panorama":{"close":"360°-Ansicht verlassen und Text einblenden","start":"360°-Ansicht starten"},"play_video":"Video ansehen","scroll_back_indicator":" ","scroll_down":"Runter scrollen","scroll_hint":"Mit dem Mausrad oder den Pfeiltasten auf der Tastatur wird die jeweils nächste Kapitelseite aufgerufen.","scroll_indicator":"Scrollen, um weiterzulesen","scroll_left":"Nach links scrollen","scroll_right":"Nach rechts scrollen","scroll_up":"Hoch scrollen","share":"Teilen","share_on_facebook":"Auf Facebook teilen","share_on_google":"Auf Google+ teilen","share_on_twitter":"Auf Twitter teilen","share_this_entry":"Diesen Beitrag","share_this_page":"Diese Seite","show_home":"Zur Startseite","show_text":"Text einblenden","skip_links_content":"Zum Inhalt","skip_links_navigation":"Zur Seitennavigation","skip_links_top_navigation":"Zur Dachnavigation","sound_hint":"Für dieses multimediale Reportage-Format nutzen wir neben Texten und Fotos auch Audios und Videos. Daher sollten die Lautsprecher des Systems eingeschaltet sein.","start_audio":"Audio jetzt starten","start_video":"Video jetzt starten","swipe_hint":"Durch Wischen wird die jeweils nächste Kapitelseite aufgerufen.","swipe_indicator":"Wischen, um Text einzublenden","text_track_modes":{"auto":"Auto (%{label})","auto_off":"Automatisch (Aus)","none":"Aus"},"text_tracks":"Untertitel","video":"Video","video_qualities":{"annotations":{"4k":"4K","fullhd":"HD","medium":"HD"},"labels":{"4k":"2160p","auto":"Automatisch","fullhd":"1080p","medium":"720p"}},"volume":"Lautstärke","vr":{"no_vr":{"link":"Video in der YouTube-App ansehen","text":"360°-Videos können in ihrem Browser nicht angezeigt werden."},"select_quality":"Video-Qualität auswählen","start":"360° Video ansehen","start_cardboard":"Cardboard-Modus starten","video_qualities":{"4k":"2160s","fullhd":"1080s","high":"720s"},"video_quality_annotations":{"4k":"4K","fullhd":"HD","high":"HD"}}},"internal_links":{"editor":{"templates":{"edit_page_link":{"back":"Zurück","destroy":"Löschen"},"embedded":{"grid_page_link":{"edit":"Bearbeiten","set":"Zielseite auswählen"}}},"views":{"edit_page_link_view":{"confirm_destroy":"Verweis wirklich löschen?","default_page_transition":"(Standard)"}}},"grid":{"help_entries":{"page_type":{"menu_item":"Mosaik","text":"# Mosaik\n\nVerweise auf andere Seiten innerhalb eines Pageflows\nIm Gegensatz zur externen Verweis-Seite, werden hier interne Seiten innerhalb des\nPageflows verlinkt. Dies bietet sich an, um den User gezielt durch den Pageflow zu leiten.\n\nTypische Anwendungsbeispiele: Willkommens-Seite, Kapitel-Startseite"}},"page_attributes":{"linked_pages_layout":{"inline_help":"Ein Thumbnail im Mosaik kann größer dargestellt werden.","label":"Hervorgehobenes Element","values":{"default":"(Kein)","hero_top_left":"Links oben","hero_top_right":"Rechts oben"}}},"page_type_category_name":"Verweise","page_type_description":"Verweise zu anderen Seiten als Mosaik angeordnet","page_type_name":"Mosaik"},"list":{"help_entries":{"page_type":{"menu_item":"Multiple Choice","text":"# Multiple Choice\n\nLinks auf andere Seiten des Pageflows dargestellt als horizontal angeordnete Boxen mit einem kurzen Text.\n\nTypische Anwendungsbeispiele: Frage/Antwort-Seite, interaktives Interview, Quiz"}},"page_type_category_name":"Verweise","page_type_description":"Verweise auf andere Seiten als Reihe von Antworten","page_type_name":"Multiple Choice"},"page_link_attributes":{"description":{"inline_help":"Dieser Text wird auf dem Verweis angezeigt.","label":"Beschreibung"}}},"internal_links_list":{"page_type_feature_name":"Multiple Choice Seitentyp"},"external_links":{"editor":{"templates":{"edit_site":{"back":"Externe Verweise","destroy":"Löschen","failure":"Beim Speichern des externen Verweises ist ein Problem aufgetreten.","retry":"Erneut versuchen"},"embedded":{"list_item":{"open_in_new_tab":"Seite in neuem Tab ansehen","open_in_new_tab_message":"Öffnen im selben Tab ist im Editor deaktiviert."}},"inputs":{"site_reference":{"add":"Hinzufügen"}},"site_item":{"failure":"Beim Speichern der Seite ist ein Fehler aufgetreten.","select":"Auswählen"},"site_reference_item":{"edit":"Bearbeiten","remove":"Löschen"},"site_selection":{"cancel":"Abbrechen","title":"Externe Seite auswählen"},"sites":{"add":"Hinzufügen"},"sites_blank_slate":{"text":"Es wurden noch keine Seiten erstellt."}},"views":{"edit_site":{"back":"Zurück","confirm_destroy":"Externen Verweis wirklich löschen?\n\nAlle Benutzungen dieses Verweises auf Seiten werden ebenfalls entfernt. Dieser Schritt kann nicht rückgängig gemacht werden."},"site_item_reference_view":{"unknown":"(Unbenannt)"},"site_item_view":{"unknown":"(Unbenannt)"}}},"help_entries":{"page_type":{"menu_item":"Externe Verweise","text":"# Externe Verweise\n\nSammlung von Verweisen zu Webseiten ausserhalb des Pageflows\n\nZu dem üblichen Hintergrund-Bild können hier Verweise auf externe Webseiten\neingebunden werden, die sich bei Klick in einem neuen Browserfenster öffnen. Pro\nVerweis kann jeweils ein Bild, ein Titel und eine Beschreibung verwendet werden.\nAchtung: Mit jedem Verweis auf eine externe Webseite riskierst Du, dass User\nmöglicherweise aus Deinem Pageflow aussteigen bzw. von dem neu geöffneten Fenster\nnicht zurückkehren. Erfahrungsgemäß empfiehlt sich daher die Verwendung solcher Links\neher im hinteren Teil Deines Pageflows.\n\nTypische Anwendungsbeispiele: Vertiefungen, Quellen, Twitter- und Facebook-Feeds, Backlinks zur Homepage"},"sites":{"menu_item":"Externe Verweise verwalten","text":"# Externe Verweise verwalten\n\nMit „Externe Verweise“ verwaltest Du Links auf Webseiten, die Du in eine Reportage einbinden möchtest. Hierzu kannst Du sowohl Bilder als „Teaser“, als auch Infotext zur Beschreibung des Verweises benutzen.\n\nDiese Verweise werden vom Seitentyp „Externe Verweise“ verwendet.\nDer Verwendung externer Links bietet sich beispielsweise an, um bestimmte Themen weiter zu vertiefen. \n\nBeachte bitte, dass diese Links eher zum Ende eines Pageflows eingesetzt werden sollten, da sie die Möglichkeit eines vorzeitigen Ausstieges aus der Reportage anbieten."}},"manage_sites":"Externe Verweise verwalten","page_type_category_name":"Verweise","page_type_description":"Sammlung von Verweisen zu Webseiten außerhalb des Pageflows","page_type_help_entry":{"title":"Externe Verweise Seitentyp: Inhalte optisch ansprechend abrunden"},"page_type_name":"Externe-Verweise"},"before_after":{"help_entries":{"page_type":{"menu_item":"Vorher/Nachher","text":"# Vorher/Nachher\n\n*Zwei übereinander liegende Bilder mit Schieberegler getrennt*\n    \nMit dem Vorher/Nachher-Effekt lassen sich zwei Bilder übereinander legen, die dann per\nSchieberegler mehr oder weniger in Erscheinung treten.\nDieser Seitentyp macht vor allem dann Sinn, wenn Du etwas miteinander vergleichen\nmöchtest. Besonders wirksam ist dieser optische Abgleich, wenn Winkel und Ausschnitt\nbeider Aufnahmen oder Grafiken exakt übereinstimmen.\n\nTypische Anwendungsbeispiele: Damals wie Heute, Status quo und Planung, leer oder voll etc."}},"page_type_category_name":"Interaktiv","page_type_description":"Zwei übereinandergelegte Bilder mit Schieberegler getrennt","page_type_name":"Vorher/Nachher"},"text_page":{"help_entries":{"page_type":{"menu_item":"Text","text":"# Text Seite\n\n*Blog-artige Seite für lange Texte*\n    \nDiese Seite ist speziell für längere Texte auf neutralem Hintergrund ausgelegt. Sie bietet\nbesondere Gestaltungsmöglichkeiten, die mit den Features klassischer (Parallax-) Blog-\nSeiten vergleichbar sind, wie man sie beispielsweise von Tumblr und WordPress kennt.\nEs gibt unterschiedliche Optionen bei der Anordnung von Titel-Bildern und auch\nverschiedene Varianten, ein weiteres Bild im Fließtext einzubinden. Zum Beispiel ob das\nBild mitwandert oder auf dem Bildschirm fixiert wird.\n\nTypische Anwendungsbeispiele: Blog-Artikel, News-Artikel, Interview"}},"page_type_category_name":"Basic","page_type_description":"Lange Texte mit einem Banner-Bild","page_type_name":"Text"},"embedded_video":{"help_entries":{"page_type":{"menu_item":"Embedded Video","text":"# Embedded Video\n\n*Bettet ein externes Video von YouTube oder Vimeo ein*\n    \nFalls Du neben eigenem Filmmaterial auch externe Videos verwenden möchtest, kannst\nDu diese über eine Video-URL integrieren und zudem mit einer Bildunterschrift versehen.\nAus technischen Gründen wird das Bild in einem Rahmen in die Seite\neingebunden, der sich der Größe des Bildschirms und dem Textfluss automatisch anpasst, ihn aber nie komplett ausfüllt.\nDeshalb besteht bei diesem Seitentyp die Möglichkeit, ein zusätzliches Hintergrundbild\neinzufügen, beispielsweise um einen visuellen Rahmen zu schaffen.\n\nEs können Videos der beiden Plattformen YouTube und Vimeo verwendet werden.\n\nTypische Anwendungsbeispiele: Einbinden von Playlists, Trailern, Kurzfilmen"}},"page_type_category_name":"Video","page_type_description":"Bettet ein externes Video von YouTube oder Vimeo ein","page_type_name":"Embedded Video"},"linkmap_page":{"default_page_transition":"(Standard)","editor":{"area_types":{"audio_file":"Audio Datei","external_site":"Externer Verweis","page":"Seitenverweis","text_only":"Nur Text"},"templates":{"edit_area":{"back":"Zurück","destroy":"Löschen"},"embedded":{"area_item":{"edit":"Bearbeiten","toggle_marker":"Linkmarkierung aktivieren"}},"file_area_item":{"edit":"Bearbeiten","remove":"Entfernen","toggle_marker":"Linkmarkierung aktivieren"},"file_areas":{"add":"Hinzufügen","label":"Audios"}},"views":{"areas_list":{"add":"Hinzufügen","label":"Bereiche"},"edit_area_view":{"confirm_destroy":"Bereich wirklich löschen?"}}},"help_entries":{"page_type":{"menu_item":"Hotspots","text":"# Hotspots\n\n*Verweise mit konfigurierbaren Klickbereichen*\n    \nHotspots können Audio-Dateien abspielen, interne Verweise auf andere Seiten im Pageflow sein oder auf externe Seiten verlinken. Es können so viele Hotspots angelegt werden wie gewünscht. \n\nDer Panorama Typ entscheidet darüber, ob die Seite ein Hintergrund-Bild oder Hintergrund-Video zeigt. (Beachte, dass Hintergrund-Videos auf mobilen Geräten nicht abgespielt werden, deshalb wähle ein zusätzliches Panorama-Bild für die mobile Version) \n\nDie Hotspot-Seite ermöglicht auch die Nutzung von Panorama-Bildern, die größer sind, als der sichtbare Bildschirmbereich. So können Nutzer diese Seiten auch horizontal oder vertikal durch scrollen erkunden.\n\nUm einen Hotspot zu erstellen, klicke auf „Bereiche“ und wähle zwischen „Audio“, „Seitenverweis“ oder „Externer Verweis“.\n\nDiese „Bereiche\" können auf zwei unterschiedliche Arten dargestellt werden:\n\n##  Hotspots als Kreise\n\nEin weißer Kreis, dessen Position und Größe frei gewählt werden kann, markiert den Hotspot. Hierzu klicke beim entsprechenden Hotspot auf den Button mit dem Auge-Symbol und ziehe den Kreis dann an die gewünschte Position. Bei Auswahl einer Audio-Datei erscheint innerhalb des Kreises ein Kopfhörer-Symbol mit einem Inline-Audio-Player. Dessen Größe hängt von der Größe des Kreises ab. Je näher der Mauszeiger Richtung Kreis bewegt wird, desto heller/sichtbarer wird dieser. Mit Klick auf den Kopfhörer wird der Audio-Player gestartet und gestoppt. \n\n## Individuell gestaltete Hotspots\n\nAlternativ kann ein zweites Panorama-Bild verwendet werden, um das Aussehen der Hotspots zu bestimmen, über denen sich der Cursor befindet. Es müssen zwei Panorama-Bilder vorbereitet werden:\n\n1. Ein Bild mit allen Hotspots im inaktiven Modus (z.B. eine Karte, auf der Städte mit schwarzen Punkten markiert sind)\n2. Ein Bild mit allen Hotspots im aktiven Zustand (z.B. die selbe Karte, aber mit roten Punkten als Markierung)\n\nDie rechteckigen Bereiche der Hotspots werden nun so positioniert, dass sie die graphischen Darstellungen der Hotspots im Bild überdecken. Befindet sich der Cursor über einem der Bereiche, wird genau in diesem Ausschnitt der entsprechende Teil des Hover-Bildes gezeigt. Der Hotspot erscheint daher aktiv, während alle anderen Hotspots weiterhin inaktiv dargestellt werden.\n\nAn Stelle von Bildern können auch Videos verwendet werden. Folgende Kombinationen sind möglich:\n\n1. Hintergrund-Bild mit Hover-Bild\n2. Hintergrund-Video mit Hover-Bild\n3. Hintergrund-Bild mit Hover-Video\n\nFalls die vom User bereits besuchten Bereiche anschliessend anders dargestellt werden sollen, kann ein „Visited-Bild“ festgelegt werden, das dann zum Beispiel einen bestimmten Hotspot nach dem Klick in einer abgeschwächten Farbe zeigt.\n\n## Textoptionen\n\nDie Hotspots können mit einem Titel benannt und mit weiteren Text versehen werden. Der Text kann in fett, kursiv und unterstrichen formatiert werden.\n\n## Atmo Optionen\n\nWie bei den anderen Seitentypen auch, kann im Hintergrund ein zusätzliches Audiofile abgespielt werden. Für die Kombination mit Audio-Hotspots ist es neben “Ausblenden” und “Weiterspielen” zudem möglich, die Option “Leiser weiterspielen” auszuwählen. Das kann sinnvoll sein, wenn zum Beispiel ein im Hintergrund laufender Titel von einem kurzen Interview überlagert wird.\n\n## Weitere Optionen\n\nUnter „Optionen\" können folgende Regeln definiert werden:\n\nScrollbereich auf aktive Bereiche beschränken: Hierbei wird verhindert, dass die User sich in Bildbereiche ausserhalb der Hotspots bewegen können.\n\nScrollumgebung erzwingen: Hierbei wird der sichtbare Bereich so verkleinert, dass User sich durch die Seite scrollen müssen, um alle Hotspots zu sehen.\n\nAm Bildrand scrollen deaktivieren: Hierbei wird das sonst automatische Scrollen unterdrückt, sobald User die Maus zum Bildrand bewegen.\n\nTypische Anwendungsbeispiele: Menüseite, Multiple Choice, Entdeckungstour"}},"manage_sites":"Verweise verwalten","page":{"scroll_left":"Nach links scrollen","scroll_right":"Nach rechts scrollen","scroll_up":"Nach oben scrollen","scroll_down":"Nach unten scrollen"},"page_attributes":{"add_environment":{"inline_help":"Panorama etwas vergrößern, um Scrollen in beide Richtungen zu erlauben.","label":"Scrollumgebung erzwingen"},"audio_areas":{"label":"Bereiche mit Audio"},"background_type":{"label":"Panorama-Typ","values":{"hover_video":"Hintergrund-Bild/Hover-Video","image":"Hintergrund-Bild/Hover-Bild","video":"Hintergrund-Video/Hover-Bild"}},"hover_image_id":{"inline_help":"Ein Ausschnitt dieses Bildes wird im Bereich eines Hotspots angezeigt, wenn sich der Cursor über dem Hotspot befindet.","label":"Hover-Bild"},"hover_video_type":{"hover_image_id":{"inline_help":"Bild, das auf mobilen Plattformen anstelle des Hover-Videos gezeigt werden soll.","label":"Hover-Bild (mobil)"},"panorama_video_id":{"inline_help":"Ein Ausschnitt dieses Videos wird im Bereich eines Hotspots angezeigt, wenn sich der Cursor über dem Hotspot befindet.","label":"Hover-Video"}},"limit_scrolling":{"inline_help":"Scrollen nur erlauben, falls Hotspot Bereiche außerhalb des sichtbaren Bereichs liegen.","label":"Scrollbereich auf aktive Bereiche beschränken"},"linked_linkmap_page_perma_ids":{"label":"Verlinkte Seiten"},"linkmap_areas":{"label":"Verweisbereiche"},"margin_scrolling_disabled":{"inline_help":"Panorama nicht automatisch scrollen, wenn der Cursor bewegt wird.","label":"Am Bildrand scrollen deaktivieren"},"panorama_image_id":{"inline_help":"Bild auf dem Hotspots gesetzt werden sollen.","label":"Panorama-Bild"},"panorama_video_id":{"inline_help":"Video auf dem Hotspots gesetzt werden sollen.","label":"Panorama-Video"},"video_type":{"panorama_image_id":{"inline_help":"Bild, das auf mobilen Plattformen anstelle des Panorama-Videos gezeigt werden soll.","label":"Panorama-Bild (mobil)"}},"visited_image_id":{"inline_help":"Ein Ausschnitt dieses Bildes wird in den Bereichen der Hotspots angezeigt, deren Zielseite bereits besucht wurde.","label":"Visited-Bild"}},"page_type_category_name":"Verweise","page_type_description":"Verweise mit konfigurierbaren Klickbereichen","page_type_feature_name":"Hotspot-Seitentyp","page_type_name":"Hotspots"},"chart":{"editor":{"templates":{"scraped_site_status":{"failed":"Beim Herunterladen des Diagramms ist ein Fehler aufgetreten.","pending":"Diagramm wird heruntergeladen..."},"datawrapper_ad":{"create_chart":"Neues Datawrapper Diagramm erstellen"}}},"help_entries":{"page_type":{"menu_item":"Diagramm","text":"# Diagramm\n\nEinbindung von Datawrapper-Diagrammen\n\nHier kannst Du Deinen Pageflow um animierte Infografiken ergänzen. Eingebettet ist das\nDiagramm in ein Hintergrund-Bild und Text. Die Infografik lässt sich durch Klicken\nvergrössern.\n\nDein Diagramm musst Du allerdings zuvor extern erstellen und einen entsprechenden Link generieren. Unter www.datawrapper.de findest Du Beispiele und die Konditionen, um\ndiesen Dienst in Anspruch zu nehmen.\n\nBeachte, dass Datawrapper ein spezielles Design für Diagramme bietet, die in Pageflow eingebettet werden sollen. Klicke dazu im \"Visualisieren\" Schritt des Diagramm Assistenten auf das Tab \"Design\" und wähle \"Pageflow\" aus. Das Farbschema des Diagramms ist dann für die Verwendung in Pageflow optimiert.\n\nTypische Anwendungsbeispiele: Statistiken, Diagramme, Zahlen\u0026Fakten"}},"page_type_category_name":"Daten und Diagramme","page_type_description":"Einbindung von Diagrammen, die mit Datawrapper erstellt wurden","page_type_name":"Diagramm","page_attributes":{"full_width":{"inline_help":"Verbreitert das Diagramm, so dass es die maximal verfügbare Breite nutzt.","label":"Gesamte Breite nutzen"},"scraped_site_id":{"inline_help":"URL zu einem bei Datawrapper publiziertem Diagramm. Datawrapper bietet in den Diagramm Optionen ein spezielles 'Pageflow' Design für eine optimale Darstellung innerhalb des Beitrags. "}}},"scrollytelling_pageflow_navigation":{"home_link":" Home","home_title":"Du geths denn nach %{url}","widget_type_name":"Scrollytelling Punkte mit Tooltips"}},"support":{"array":{"last_word_connector":" und ","two_words_connector":" und ","words_connector":", "}},"time":{"am":"vormittags","formats":{"date":"%d.%m.%Y","default":"%d.%m.%Y, %H:%M","long":"%d.%m.%Y, %H:%M","short":"%d. %B %Y, %H:%M Uhr"},"pm":"nachmittags"},"views":{"pagination":{"first":"|\u003c","last":"\u003e|","next":"\u003e\u003e","previous":"\u003c\u003c","truncate":"..."}}},"cs":{"ransack":{"search":"vyhledávání","predicate":"predikát","and":"a","or":"nebo","any":"kteroukoliv","all":"každou","combinator":"kombinátor","attribute":"atribut","value":"hodnota","condition":"podmínka","sort":"řazení","asc":"vzestupné","desc":"sestupné","predicates":{"eq":"rovno","eq_any":"rovno kterékoliv","eq_all":"rovno všem","not_eq":"nerovno","not_eq_any":"nerovno kterékoliv","not_eq_all":"nerovno všem","matches":"odpovídá","matches_any":"odpovídá kterékoliv","matches_all":"odpovídá všem","does_not_match":"neodpovídá","does_not_match_any":"neodpovídá kterékoliv","does_not_match_all":"neodpovídá všem","lt":"menší než","lt_any":"menší než kterákoliv","lt_all":"menší než všechny","lteq":"menší nebo rovno než","lteq_any":"menší nebo rovno než kterákoliv","lteq_all":"menší nebo rovno než všechny","gt":"větší než","gt_any":"větší než kterákoliv","gt_all":"větší než všechny","gteq":"větší nebo rovno než","gteq_any":"větší nebo rovno než kterákoliv","gteq_all":"větší nebo rovno než všechny","in":"v","in_any":"v kterékoliv","in_all":"ve všech","not_in":"není v","not_in_any":"není v kterékoliv","not_in_all":"není ve všech","cont":"obsahuje","cont_any":"obsahuje kterékoliv","cont_all":"obsahuje všechny","not_cont":"neobsahuje","not_cont_any":"neobsahuje kteroukoliv","not_cont_all":"neobsahuje všechny","start":"začíná s","start_any":"začíná s kteroukoliv","start_all":"začíná se všemi","not_start":"nezačíná s","not_start_any":"nezačíná s kteroukoliv","not_start_all":"nezačíná se všemi","end":"končí s","end_any":"končí s kteroukoliv","end_all":"končí se všemi","not_end":"nekončí s","not_end_any":"nekončí s kteroukoliv","not_end_all":"nekončí se všemi","true":"je pravdivé","false":"není pravdivé","present":"je vyplněné","blank":"je prázdné","null":"je null","not_null":"není null"}},"active_admin":{"dashboard":"Úvod","dashboard_welcome":{"welcome":"Vítejte v Active Admin. Toto je nástěnka.","call_to_action":"Pro přidání sekcí na nástěnku se podívejte do souboru 'app/admin/dashboard.rb'"},"view":"Zobrazit","edit":"Upravit","delete":"Smazat","delete_confirmation":"Jste si jistí, že chcete tuto položku smazat?","new_model":"Vytvořit","edit_model":"Upravit","delete_model":"Smazat","details":"Detaily","cancel":"Zrušit","empty":"Prázdné","previous":"Předchozí","next":"Následující","download":"Stáhnout:","has_many_new":"Přidat nový","has_many_delete":"Smazat","has_many_remove":"Odstranit","filters":{"buttons":{"filter":"Filtrovat","clear":"Vyčistit filtry"},"predicates":{"contains":"Obsahuje","equals":"Odpovídá","starts_with":"Začíná na","ends_with":"Končí na","greater_than":"Větší než","less_than":"Menší než"}},"status_tag":{"yes":"Ano","no":"Ne"},"main_content":"Implementujte prosím %{model}#main_content pro zobrazení obsahu.","logout":"Odhlásit","powered_by":"%{active_admin} %{version}","sidebars":{"filters":"Filtry"},"pagination":{"empty":"Nenalezen.","one":"Zobrazena  \u003cb\u003e1\u003c/b\u003e položka","one_page":"Počet zobrazených položek %{n}","multiple":"\u003cb\u003e%{from}\u0026nbsp;-\u0026nbsp;%{to}\u003c/b\u003e z \u003cb\u003e%{total}\u003c/b\u003e","multiple_without_total":"\u003cb\u003e%{from}\u0026nbsp;-\u0026nbsp;%{to}\u003c/b\u003e","entry":{"one":"položka","few":"položky","other":"položky"}},"any":"Kterákoliv","blank_slate":{"content":"Zatím zde není žádný obsah.","link":"Vytvořit"},"dropdown_actions":{"button_label":"Akce"},"batch_actions":{"button_label":"Hromadné akce","default_confirmation":"Jste si jisti, že chcete provést?","delete_confirmation":"Jste si jisti, že chcete smazat tyto %{plural_model}?","succesfully_destroyed":{"zero":"Nebyl smazán žádný %{model}","one":"Úspěšně smazán %{model}","few":"Úspěšně smazány %{count} %{plural_model}","other":"Úspěšně smazáno %{count} %{plural_model}"},"selection_toggle_explanation":"(Změnit výběr)","link":"Vytvořit","action_label":"%{title}","labels":{"destroy":"Vymazat"}},"comments":{"resource_type":"Typ zdroje","author_type":"Typ autora","body":"Tělo","author":"Autor","title":"Komentář","add":"Přidat komentář","resource":"Zdroj","no_comments_yet":"Žádný komentář","author_missing":"Anonymní","title_content":"Komentáře administrátorů (%{count})","errors":{"empty_text":"Komentář nebyl uložen, je prázdný."}},"devise":{"login":{"title":"Přihlášení","remember_me":"Zapamatovat si mě","submit":"Přihlásit"},"reset_password":{"title":"Zapomněli jste heslo?","submit":"Obnovit heslo"},"change_password":{"title":"Změnit heslo","submit":"Změnit své heslo"},"unlock":{"title":"Zaslání instrukcí k odemčení účtu","submit":"Zaslat instrukce k odemčení účtu"},"links":{"sign_in":"Přihlásit se","sign_up":"Registrovat se","forgot_your_password":"Zapomněli jste heslo?","sign_in_with_omniauth_provider":"Přihlásit se přes %{provider}"}},"access_denied":{"message":"Nemáte oprávnění k provedení této akce."},"index_list":{"table":"Tabulka","block":"Seznam","grid":"Tabulka","blog":"Blog"}}},"zh-CN":{"ransack":{"search":"搜索","predicate":"基于(predicate)","and":"并且","or":"或者","any":"任意","all":"所有","combinator":"条件组合(combinator)","attribute":"属性","value":"数值","condition":"条件","sort":"排序","asc":"升序","desc":"降序","predicates":{"eq":"等于","eq_any":"等于任意值","eq_all":"等于所有值","not_eq":"不等于","not_eq_any":"不等于任意值","not_eq_all":"不等于所有值","matches":"符合","matches_any":"符合任意条件","matches_all":"符合所有条件","does_not_match":"不符合","does_not_match_any":"符合任意条件","does_not_match_all":"不符合所有条件","lt":"小于","lt_any":"小于任意一个值","lt_all":"小于所有值","lteq":"小于等于","lteq_any":"小于等于任意一个值","lteq_all":"小于等于所有值","gt":"大于","gt_any":"大于任意一个值","gt_all":"大于所有值","gteq":"大于等于","gteq_any":"大于等于任意一个值","gteq_all":"大于等于所有值","in":"被包含","in_any":"被任意值包含","in_all":"被所有值包含","not_in":"不被包含","not_in_any":"不被任意值包含","not_in_all":"不被所有值包含","cont":"包含","cont_any":"包含任意一个值","cont_all":"包含所有值","not_cont":"不包含","not_cont_any":"不包含任意一个值","not_cont_all":"不包含所有值","start":"以改值开始","start_any":"以任意一个值开始","start_all":"以所有值开始","not_start":"不以改值开始","not_start_any":"不以任意一个值开始","not_start_all":"不以所有值开始","end":"以改值结尾","end_any":"以任意一个值结尾","end_all":"以所有值结尾","not_end":"不以改值结尾","not_end_any":"不以任意一个值结尾","not_end_all":"不以所有值结尾","true":"等于true","false":"等于false","present":"有值","blank":"为空","null":"是null","not_null":"不是null"}},"errors":{"messages":{"in_between":"文件大小必须介于 %{min} 到 %{max} 之间","spoofed_media_type":"扩展名与内容类型不符"}},"number":{"human":{"storage_units":{"format":"%n %u","units":{"byte":{"one":"Byte","other":"Bytes"},"kb":"KB","mb":"MB","gb":"GB","tb":"TB"}}}},"formtastic":{"yes":"YES","no":"NO","create":"新建%{model}","update":"更新%{model}","submit":"确认","cancel":"取消","reset":"重置%{model}","required":"必须的"},"active_admin":{"dashboard":"控制面板","dashboard_welcome":{"welcome":"欢迎使用Active Admin. 这是默认的控制面板页.","call_to_action":"若要添加新的面板内容, 请修改 'app/admin/dashboard.rb'"},"view":"查看","edit":"编辑","delete":"删除","delete_confirmation":"确定删除?","new_model":"新建%{model}","edit_model":"编辑%{model}","delete_model":"删除%{model}","details":"%{model}详情","cancel":"取消","empty":"清空","previous":"上一个","next":"下一个","download":"下载:","has_many_new":"新建一个%{model}","has_many_delete":"删除","has_many_remove":"清除","filters":{"buttons":{"filter":"过滤","clear":"清除条件"},"predicates":{"contains":"包含","equals":"等于","starts_with":"开头","ends_with":"完与","greater_than":"大于","less_than":"小于"}},"search_status":{"headline":"搜索条件：","current_scope":"搜索范围：","current_filters":"过滤条件：","no_current_filters":"无"},"status_tag":{"yes":"是的","no":"无"},"main_content":"请执行 %{model}#main_content 来显示内容.","logout":"退出","powered_by":"Powered by %{active_admin} %{version}","sidebars":{"filters":"所有条件","search_status":"搜索条件"},"pagination":{"empty":"暂时没有%{model}","one":"显示 \u003cb\u003e1\u003c/b\u003e %{model}","one_page":"显示 \u003cb\u003e所有 %{n}\u003c/b\u003e %{model}","multiple":"显示所有 \u003cb\u003e%{total}\u003c/b\u003e %{model}中的\u003cb\u003e%{from}\u0026nbsp;-\u0026nbsp;%{to}\u003c/b\u003e 条","multiple_without_total":"%{model}中的\u003cb\u003e%{from}\u0026nbsp;-\u0026nbsp;%{to}\u003c/b\u003e 条","entry":{"one":"条目","other":"条目"}},"any":"任何","blank_slate":{"content":"暂时还没有%{resource_name}.","link":"新建一个"},"dropdown_actions":{"button_label":"行动"},"batch_actions":{"button_label":"批处理","default_confirmation":"你确定你要这样做？","delete_confirmation":"你确定要删除所有%{plural_model}?","succesfully_destroyed":{"one":"成功删除 1 %{model}","other":"成功删除 %{count} %{plural_model}"},"selection_toggle_explanation":"(切换选择)","link":"新建一个","action_label":"%{title} 被选中","labels":{"destroy":"删除"}},"comments":{"body":"内容","author":"作者","title":"评论","add":"添加评论","resource":"资源","no_comments_yet":"暂时没有评论","title_content":"(%{count})条评论","errors":{"empty_text":"评论保存失败，内空不能为空."}},"devise":{"username":{"title":"用户名"},"email":{"title":"邮箱"},"subdomain":{"title":"子域"},"password":{"title":"密码"},"login":{"title":"登录","remember_me":"记住我","submit":"登录"},"reset_password":{"title":"忘记了密码？","submit":"重置我的密码"},"unlock":{"title":"重新发送送解锁命令","submit":"重新发送送解锁命令"},"resend_confirmation_instructions":{"title":" 重新发送确认指示","submit":" 重新发送确认指示"},"links":{"sign_in":"登录","forgot_your_password":"忘记了密码？","sign_in_with_omniauth_provider":"登入%{provider}"}},"access_denied":{"message":"您无权处理此操作"}}},"ja":{"ransack":{"search":"検索","predicate":"は以下である","and":"と","or":"あるいは","any":"いずれか","all":"全て","combinator":"組み合わせ","attribute":"属性","value":"値","condition":"状態","sort":"分類","asc":"昇順","desc":"降順","predicates":{"eq":"は以下と等しい","eq_any":"は以下のいずれかに等しい","eq_all":"は以下の全てに等しい","not_eq":"は以下と等しくない","not_eq_any":"は以下のいずれかに等しくない","not_eq_all":"は以下の全てと等しくない","matches":"は以下と合致している","matches_any":"は以下のいずれかと合致している","matches_all":"は以下の全てと合致している","does_not_match":"は以下と合致していない","does_not_match_any":"は以下のいずれかに合致していない","does_not_match_all":"は以下の全てに合致していない","lt":"は以下よりも小さい","lt_any":"は以下のいずれかより小さい","lt_all":"は以下の全てよりも小さい","lteq":"は以下より小さいか等しい","lteq_any":"は以下のいずれかより小さいか等しい","lteq_all":"は以下の全てより小さいか等しい","gt":"は以下より大きい","gt_any":"は以下のいずれかより大きい","gt_all":"は以下の全てより大きい","gteq":"は以下より大きいか等しい","gteq_any":"は以下のいずれかより大きいか等しい","gteq_all":"は以下の全てより大きいか等しい","in":"は以下の範囲内である","in_any":"は以下のいずれかの範囲内である","in_all":"は以下の全ての範囲内である","not_in":"は以下の範囲内でない","not_in_any":"は以下のいずれかの範囲内でない","not_in_all":"は以下の全ての範囲内","cont":"は以下を含む","cont_any":"はいずれかを含む","cont_all":"は以下の全てを含む","not_cont":"は含まない","not_cont_any":"は以下のいずれかを含まない","not_cont_all":"は以下の全てを含まない","start":"は以下で始まる","start_any":"は以下のどれかで始まる","start_all":"は以下の全てで始まる","not_start":"は以下で始まらない","not_start_any":"は以下のいずれかで始まらない","not_start_all":"は以下の全てで始まらない","end":"は以下で終わる","end_any":"は以下のいずれかで終わる","end_all":"は以下の全てで終わる","not_end":"は以下のどれでも終わらない","not_end_any":"は以下のいずれかで終わらない","not_end_all":"は以下の全てで終わらない","true":"真","false":"偽","present":"は存在する","blank":"は空である","null":"無効","not_null":"は無効ではない"}},"errors":{"messages":{"in_between":"の容量は%{min}以上%{max}以下にしてください。","spoofed_media_type":"の拡張子と内容が一致していません。"}},"number":{"human":{"storage_units":{"format":"%n %u","units":{"byte":{"one":"Byte","other":"Bytes"},"kb":"KB","mb":"MB","gb":"GB","tb":"TB"}}}},"formtastic":{"yes":"はい","no":"いいえ","create":"%{model}を作成","update":"%{model}を更新","submit":"送信","cancel":"中止","reset":"リセット","required":"必須"},"active_admin":{"dashboard":"ダッシュボード","dashboard_welcome":{"welcome":"Active Admin へようこそ。ダッシュボードの初期ページを表示しています。","call_to_action":"ダッシュボードに項目を追加するために 'app/admin/dashboard.rb' を編集してください。"},"view":"閲覧","edit":"編集","delete":"削除","delete_confirmation":"本当に削除しますか？","new_model":"%{model} を作成する","edit_model":"%{model} を編集する","delete_model":"%{model} を削除する","details":"%{model} の詳細","cancel":"取り消す","empty":"空","previous":"前","next":"次","download":"ダウンロード:","has_many_new":"新規に %{model} を追加する","has_many_delete":"削除する","has_many_remove":"削除する","filters":{"buttons":{"filter":"絞り込む","clear":"条件を削除する"},"predicates":{"contains":"含まれています","equals":"等しい","starts_with":"で始まる","ends_with":"で終わる","greater_than":"より大きい","less_than":"より小さい"}},"search_status":{"headline":"検索条件:","current_scope":"範囲:","current_filters":"現在の絞り込み:","no_current_filters":"なし"},"status_tag":{"yes":"はい","no":"いいえ"},"main_content":"内容を表示するために %{model}#main_content を実装してください。","logout":"ログアウト","powered_by":"Powered by %{active_admin} %{version}","sidebars":{"filters":"検索条件","search_status":"検索状態"},"pagination":{"empty":"%{model} は見つかりませんでした","one":"\u003cb\u003e1\u003c/b\u003e 件の %{model} を表示しています","one_page":"\u003cb\u003e全 %{n}\u003c/b\u003e 件の %{model} を表示しています","multiple":"全 \u003cb\u003e%{total}\u003c/b\u003e 件中 \u003cb\u003e%{from}\u0026nbsp;-\u0026nbsp;%{to}\u003c/b\u003e 件の %{model} を表示しています","multiple_without_total":"\u003cb\u003e%{from}\u0026nbsp;-\u0026nbsp;%{to}\u003c/b\u003e 件の %{model} を表示しています","entry":{"one":"レコード","other":"レコード"}},"any":"任意","blank_slate":{"content":"%{resource_name} はまだありません。","link":"作成する"},"dropdown_actions":{"button_label":"操作"},"batch_actions":{"button_label":"一括操作","default_confirmation":"本当によろしいですか？","delete_confirmation":"%{plural_model} を削除してもよろしいですか？","succesfully_destroyed":{"one":"1件の %{model} を削除しました","other":"%{count}件の %{plural_model} を削除しました"},"selection_toggle_explanation":"(選択)","link":"作成する","action_label":"選択した行を%{title}","labels":{"destroy":"削除する"}},"comments":{"created_at":"作成日","resource_type":"リソース種別","author_type":"作成者種別","body":"本文","author":"作成者","title":"コメント","add":"コメントを追加","delete":"コメントを削除","delete_confirmation":"本当にコメントを削除しますか？","resource":"リソース","no_comments_yet":"コメントはまだありません。","author_missing":"匿名ユーザ","title_content":"コメント (%{count})","errors":{"empty_text":"テキストが空のため、コメントは保存されませんでした。"}},"devise":{"username":{"title":"ユーザ名"},"email":{"title":"メールアドレス"},"subdomain":{"title":"サブドメイン"},"password":{"title":"パスワード"},"sign_up":{"title":"登録","submit":"登録"},"login":{"title":"ログイン","remember_me":"次回から自動的にログイン","submit":"ログイン"},"reset_password":{"title":"パスワードをお忘れですか？","submit":"パスワードをリセットする"},"change_password":{"title":"パスワードを変更する","submit":"パスワードを変更する"},"unlock":{"title":"ロックの解除方法を送る","submit":"ロックの解除方法を送る"},"resend_confirmation_instructions":{"title":"確認方法を再送信する","submit":"確認方法を再送信する"},"links":{"sign_in":"サインイン","sign_up":"ユーザ登録","forgot_your_password":"パスワードをお忘れですか？","sign_in_with_omniauth_provider":"%{provider}のアカウントを使ってログイン","resend_confirmation_instructions":"ユーザ確認手順を再送する","resend_unlock_instructions":"ロックの解除方法を再送する"}},"unsupported_browser":{"headline":"ActiveAdminは、Internet Explorer 8以下はサポートはしていません。","recommendation":"最新版の\u003ca href=\"http://windows.microsoft.com/ie\"\u003eInternet Explorer\u003c/a\u003e、\u003ca href=\"https://chrome.google.com/\"\u003eGoogle Chrome\u003c/a\u003e、もしくは\u003ca href=\"https://mozilla.org/firefox/\"\u003eFirefox\u003c/a\u003eを使うことを推奨します。","turn_off_compatibility_view":"Internet Explorer 9以降を使っている場合、\u003ca href=\"http://windows.microsoft.com/ja-JP/windows7/webpages-look-incorrect-in-Internet-Explorer\"\u003e互換表示をオフ\u003c/a\u003eにしてください。"},"access_denied":{"message":"アクションを実行する権限がありません"},"index_list":{"table":"テーブル","block":"リスト","grid":"グリッド","blog":"ブログ"}}},"fr":{"ransack":{"search":"recherche","predicate":"prédicat","and":"et","or":"ou","any":"au moins un","all":"tous","combinator":"combinateur","attribute":"attribut","value":"valeur","condition":"condition","sort":"tri","asc":"ascendant","desc":"descendant","predicates":{"eq":"égal à","eq_any":"égal à au moins un","eq_all":"égal à tous","not_eq":"différent de","not_eq_any":"différent d'au moins un","not_eq_all":"différent de tous","matches":"correspond à","matches_any":"correspond à au moins un","matches_all":"correspond à tous","does_not_match":"ne correspond pas à","does_not_match_any":"ne correspond pas à au moins un","does_not_match_all":"ne correspond à aucun","lt":"inférieur à","lt_any":"inférieur à au moins un","lt_all":"inférieur à tous","lteq":"inférieur ou égal à","lteq_any":"inférieur ou égal à au moins un","lteq_all":"inférieur ou égal à tous","gt":"supérieur à","gt_any":"supérieur à au moins un","gt_all":"supérieur à tous","gteq":"supérieur ou égal à","gteq_any":"supérieur ou égal à au moins un","gteq_all":"supérieur ou égal à tous","in":"inclus dans","in_any":"inclus dans au moins un","in_all":"inclus dans tous","not_in":"non inclus dans","not_in_any":"non inclus dans au moins un","not_in_all":"non inclus dans tous","cont":"contient","cont_any":"contient au moins un","cont_all":"contient tous","not_cont":"ne contient pas","not_cont_any":"ne contient pas au moins un","not_cont_all":"ne contient pas tous","start":"commence par","start_any":"commence par au moins un","start_all":"commence par tous","not_start":"ne commence pas par","not_start_any":"ne commence pas par au moins un","not_start_all":"ne commence pas par tous","end":"finit par","end_any":"finit par au moins un","end_all":"finit par tous","not_end":"ne finit pas par","not_end_any":"ne finit pas par au moins un","not_end_all":"ne finit pas par tous","true":"est vrai","false":"est faux","present":"est présent","blank":"est blanc","null":"est null","not_null":"n'est pas null"}},"formtastic":{"yes":"Oui","no":"Non","create":"Créer un(e) %{model}","update":"Modifier ce(tte) %{model}","submit":"Enregistrer ce(tte) %{model}","cancel":"Annuler","reset":"Réinitialiser ce(tte) %{model}","required":"requis(e)"},"active_admin":{"dashboard":"Tableau de bord","dashboard_welcome":{"welcome":"Bienvenue dans Active Admin. Ceci est la page par défaut.","call_to_action":"Pour ajouter des sections au tableau de bord, consultez 'app/admin/dashboard.rb'"},"view":"Voir","edit":"Modifier","delete":"Supprimer","delete_confirmation":"Êtes-vous certain de vouloir supprimer ceci ?","new_model":"Créer %{model}","edit_model":"Modifier %{model}","delete_model":"Supprimer %{model}","details":"Détails de %{model}","cancel":"Annuler","empty":"Vide","previous":"Précédent","next":"Suivant","download":"Télécharger :","has_many_new":"Ajouter un nouveau %{model}","has_many_delete":"Supprimer","has_many_remove":"Enlever","filters":{"buttons":{"filter":"Filtrer","clear":"Supprimer les filtres"},"predicates":{"contains":"Contient","equals":"Égal à","starts_with":"Commence par","ends_with":"Se termine par","greater_than":"Plus grand que","less_than":"Plus petit que"}},"search_status":{"headline":"Statut de la recherche :","current_scope":"Etendu du filtre :","current_filters":"Filtres actuels :","no_current_filters":"Aucun filtres"},"status_tag":{"yes":"Oui","no":"Non"},"main_content":"Veuillez implémenter %{model}#main_content pour afficher le contenu.","logout":"Déconnexion","powered_by":"Propulsé par %{active_admin} %{version}","sidebars":{"filters":"Filtres","search_status":"Statut de la recherche"},"pagination":{"empty":"Aucun %{model} trouvé","one":"Affichage de \u003cb\u003e1\u003c/b\u003e %{model}","one_page":"Affichage des \u003cb\u003e%{n}\u003c/b\u003e %{model}","multiple":"Affichage de %{model} \u003cb\u003e%{from}\u0026nbsp;-\u0026nbsp;%{to}\u003c/b\u003e sur un total de \u003cb\u003e%{total}\u003c/b\u003e","multiple_without_total":"Affichage de %{model} \u003cb\u003e%{from}\u0026nbsp;-\u0026nbsp;%{to}\u003c/b\u003e","entry":{"one":"entrée","other":"entrées"}},"any":"N'importe lequel","blank_slate":{"content":"Il n'y a pas encore de %{resource_name}.","link":"Créez en un"},"dropdown_actions":{"button_label":"Actions"},"batch_actions":{"button_label":"Actions groupées","default_confirmation":"Êtes-vous sûr de vouloir faire cela ?","delete_confirmation":"Êtes-vous sûr de vouloir supprimer ces %{plural_model} ?","succesfully_destroyed":{"one":"1 %{model} supprimé","other":"%{count} %{plural_model} supprimés"},"selection_toggle_explanation":"(Inverser la sélection)","link":"Créer un","action_label":"%{title} les éléments sélectionnés","labels":{"destroy":"Supprimer"}},"comments":{"body":"Corps","author":"Auteur","title":"Commentaire","add":"Ajouter un commentaire","resource":"Ressource","resource_type":"Type de ressource","author_type":"Profil de l'auteur","no_comments_yet":"Aucun commentaire actuellement","title_content":"Commentaires (%{count})","errors":{"empty_text":"Le commentaire n'a pas été enregistré puisque le texte était vide."}},"devise":{"username":{"title":"Nom d'utilisateur"},"email":{"title":"Email"},"subdomain":{"title":"Sous-domaine"},"password":{"title":"Mot de passe"},"login":{"title":"Connexion","remember_me":"Garder ma session ouverte","submit":"Se connecter"},"reset_password":{"title":"Vous avez oublié votre mot de passe ?","submit":"Réinitialiser mon mot de passe"},"change_password":{"title":"Changez votre mot de passe","submit":"Changer mon mot de passe"},"resend_confirmation_instructions":{"title":"Renvoyer les instructions de confirmation","submit":"Renvoyer les instructions de confirmation"},"links":{"sign_in":"Connectez-vous","forgot_your_password":"Vous avez oublié votre mot de passe ?","sign_in_with_omniauth_provider":"Connectez-vous avec %{provider}"}},"access_denied":{"message":"Vous n'êtes pas autorisé à exécuter cette action"},"index_list":{"table":"Tableau","block":"Liste","grid":"Grille","blog":"Blog"}},"pageflow":{"public":{"_language":"Français","audio":"Audio","back":"Précédent","back_to_chapter":"Retour à chapitre","before_after":{"drag_hint":null,"hint":"Affichage \"avant/après\"","leave_view":"Quitter l'affichage \"avant/après\"","start":"Lancer l'affichage \"avant/après\"","start_title":"Lancer l'affichage \"avant/après\""},"chapter":"Chapitre","chart":{"toggle":"Activer/Désactiver"},"close":"Fermer","close_hint":"Fermer l’astuce","close_navigation":"Fermer la navigation","close_overview":"Fermer l’aperçu","deprecated_browser":"\u003cp\u003eVotre navigateur est obsolète et il est possible que cette page ne fonctionne pas correctement. Nous vous recommandons de passer à la dernière version de votre navigateur.\u003cp\u003e","embedded_video":{"leave_video":"Quitter la vidéo intégrée"},"enlarge_view":"Agrandir l’affichage","enter_fullscreen":"Passer en mode plein écran","first_page":"Première page","forward":"Suivant","fullscreen":"Plein écran","goto_first_page":"Accéder à la première page","goto_top":"Accéder à la première page","hide_text":"Masquer le texte","home":"Commencer","imprint":"Achevé d'imprimer","javascript_hint":"Pour un fonctionnement optimal et une meilleure expérience utilisateur, cette application nécessite l’utilisation de JavaScript. Il se peut que votre navigateur soit incompatible avec JavaScript ou que JavaScript soit désactivé.","languages":{"ar":null,"cs":null,"de":null,"dk":null,"el":null,"en":null,"es":null,"fr":null,"it":null,"nl":null,"pl":null,"pt":null,"ru":null,"sr":null,"tr":null,"unknown":null,"zh":null},"leave_fullscreen":"Quitter le mode plein écran","lets_go":"Démarrer","logo":"Logo","media_quality":null,"mute_off":"Désactiver Muet","mute_on":"Muet","navigate_top":"Accéder à la première page","navigation":"Navigation","new_pages_box":{"additional_pages_html":"… et \u003cspan\u003e\u003c/span\u003e plus","description":"Depuis votre dernière visite, des pages ont été ajoutées à ce Pageflow:","title":"Nouvelles pages"},"notice":"Remarque","open_audio":null,"open_navigation":"Ouvrir la navigation","open_overview":"Ouvrir l‘aperçu","open_video":null,"overview":"Aperçu","panorama":{"close":"Fermer le panorama à 360° et afficher le texte","start":"Démarrer le panorama à 360°"},"play_video":"Lancer la vidéo","scroll_back_indicator":null,"scroll_down":"Faire défiler\t","scroll_hint":"Utilisez la roulette de la souris ou les touches de direction de votre clavier pour parcourir les pages.","scroll_indicator":"Faire défiler pour continuer","scroll_left":"Faire défiler vers la gauche","scroll_right":"Faire défiler vers la droite","scroll_up":"Faire défiler vers le haut","share":"Partager","share_on_facebook":"Partager sur Facebook","share_on_google":"Partager sur Google+","share_on_twitter":"Partager sur Twitter","share_this_entry":"Cette histoire","share_this_page":"Cette page","show_home":"Commencer","show_text":"Afficher le texte","skip_links_content":"Accéder au contenu","skip_links_navigation":"Accéder à la navigation","skip_links_top_navigation":"Accéder à la navigation principale","sound_hint":"Ce format d’histoire multimédia utilise du contenu audio et vidéo. Veuillez vérifier que vos haut-parleurs sont allumés.","start_audio":"Démarrer Audio maintenant","start_video":"Démarrer la vidéo maintenant","swipe_hint":"Balayer pour parcourir les pages.","swipe_indicator":"Balayer pour continuer","text_track_modes":{"auto":null,"auto_off":null,"none":null},"text_tracks":null,"video":"Video","video_qualities":{"annotations":{"4k":null,"fullhd":null,"medium":null},"labels":{"4k":null,"auto":null,"fullhd":null,"medium":null}},"volume":"Volume","vr":{"no_vr":{"link":null,"text":null},"select_quality":null,"start":null,"start_cardboard":null,"video_qualities":{"4k":null,"fullhd":null,"high":null},"video_quality_annotations":{"4k":null,"fullhd":null,"high":null}}}}},"es":{"ransack":{"search":"buscar","predicate":"predicado","and":"y","or":"o","any":"cualquier","all":"todos","combinator":"combinado","attribute":"atributo","value":"valor","condition":"condición","sort":"ordernar","asc":"ascendente","desc":"descendente","predicates":{"eq":"es igual a","eq_any":"es igual a cualquier","eq_all":"es igual a todos","not_eq":"no es igual a","not_eq_any":"no es igual a cualquier","not_eq_all":"no es iguala todos","matches":"coincidir","matches_any":"coincidir a cualquier","matches_all":"coincidir a todos","does_not_match":"no coincide","does_not_match_any":"no coincide con ninguna","does_not_match_all":"no coincide con todos","lt":"menor que","lt_any":"menor que cualquier","lt_all":"menor o igual a","lteq":"menor que o igual a","lteq_any":"menor o igual a cualquier","lteq_all":"menor o igual a todos","gt":"mayor que","gt_any":"mayor que cualquier","gt_all":"mayor que todos","gteq":"mayor que o igual a","gteq_any":"mayor que o igual a cualquier","gteq_all":"mayor que o igual a todos","in":"en","in_any":"en cualquier","in_all":"en todos","not_in":"no en","not_in_any":"no en cualquier","not_in_all":"no en todos","cont":"contiene","cont_any":"contiene cualquier","cont_all":"contiene todos","not_cont":"no contiene","not_cont_any":"no contiene ninguna","not_cont_all":"no contiene toda","start":"comienza con","start_any":"comienza con cualquier","start_all":"comienza con toda","not_start":"no inicia con","not_start_any":"no comienza con cualquier","not_start_all":"no inicia con toda","end":"termina con","end_any":"termina con cualquier","end_all":"termina con todo","not_end":"no termina con","not_end_any":"no termina con cualquier","not_end_all":"no termina con todo","true":"es verdadero","false":"es falso","present":"es presente","blank":"está en blanco","null":"es nula","not_null":"no es nula"}},"errors":{"messages":{"in_between":"debe estar entre %{min} y %{max}","spoofed_media_type":"tiene una extensión que no coincide con su contenido"}},"number":{"human":{"storage_units":{"format":"%n %u","units":{"byte":{"one":"Byte","other":"Bytes"},"kb":"KB","mb":"MB","gb":"GB","tb":"TB"}}}},"formtastic":{"yes":"Sí","no":"No","create":"Guardar %{model}","update":"Guardar %{model}","submit":"Aceptar","cancel":"Cancelar","reset":"Restablecer %{model}","required":"requerido"},"active_admin":{"dashboard":"Inicio","dashboard_welcome":{"welcome":"Bienvenido a Active Admin. Esta es la página de inicio predeterminada.","call_to_action":"Para agregar secciones edite 'app/admin/dashboard.rb'"},"view":"Ver","edit":"Editar","delete":"Eliminar","delete_confirmation":"¿Está seguro de que quiere eliminar esto?","new_model":"Añadir %{model}","edit_model":"Editar %{model}","delete_model":"Eliminar %{model}","details":"Detalles de %{model}","cancel":"Cancelar","empty":"Vacío","previous":"Anterior","next":"Siguiente","download":"Descargar:","has_many_new":"Añadir %{model}","has_many_delete":"Eliminar","has_many_remove":"Quitar","filters":{"buttons":{"filter":"Filtrar","clear":"Quitar Filtros"},"predicates":{"contains":"Contiene","equals":"Igual a","starts_with":"Empieza con","ends_with":"Termina con","greater_than":"Mayor que","less_than":"Menor que"}},"search_status":{"headline":"Estado de la búsqueda:","current_scope":"Alcance:","current_filters":"Filtros actuales:","no_current_filters":"Ninguno"},"status_tag":{"yes":"Sí","no":"No"},"main_content":"Por favor implemente %{model}#main_content para mostrar contenido.","logout":"Salir","powered_by":"Funciona con %{active_admin} %{version}","sidebars":{"filters":"Filtros","search_status":"Estado de la búsqueda"},"pagination":{"empty":"No se han encontrado %{model}","one":"Mostrando \u003cb\u003e1\u003c/b\u003e %{model}","one_page":"Mostrando \u003cb\u003eun total de %{n}\u003c/b\u003e %{model}","multiple":"Mostrando %{model} \u003cb\u003e%{from}\u0026nbsp;-\u0026nbsp;%{to}\u003c/b\u003e de un total de \u003cb\u003e%{total}\u003c/b\u003e","multiple_without_total":"Mostrando %{model} \u003cb\u003e%{from}\u0026nbsp;-\u0026nbsp;%{to}\u003c/b\u003e","entry":{"one":"registro","other":"registros"}},"any":"Cualquiera","blank_slate":{"content":"No hay %{resource_name} aún.","link":"Añadir"},"dropdown_actions":{"button_label":"Acciones"},"batch_actions":{"button_label":"Acciones en masa","default_confirmation":"¿Seguro que quieres hacer esto?","delete_confirmation":"Eliminar %{plural_model}: ¿Está seguro?","succesfully_destroyed":{"one":"Se ha destruido 1 %{model} con éxito","other":"Se han destruido %{count} %{plural_model} con éxito"},"selection_toggle_explanation":"(Cambiar selección)","link":"Añadir","action_label":"%{title} seleccionado","labels":{"destroy":"Borrar"}},"comments":{"created_at":"Fecha de creación","resource_type":"Tipo de recurso","author_type":"Tipo de autor","body":"Cuerpo","author":"Autor","title":"Comentario","add":"Comentar","delete":"Borrar Comentario","delete_confirmation":"¿Está seguro que desea borrar este comentario?","resource":"Recurso","no_comments_yet":"No hay comentarios aún.","author_missing":"Anónimo","title_content":"Comentarios (%{count})","errors":{"empty_text":"El comentario no fue guardado, el texto estaba vacío."}},"devise":{"username":{"title":"Nombre de usuario"},"email":{"title":"Email"},"subdomain":{"title":"Subdominio"},"password":{"title":"Password"},"sign_up":{"title":"Registrarse","submit":"Registrarse"},"login":{"title":"Iniciar Sesión","remember_me":"Recordarme","submit":"Iniciar Sesión"},"reset_password":{"title":"¿Olvidó su contraseña?","submit":"Restablecer mi contraseña"},"change_password":{"title":"Cambie su contraseña","submit":"Cambiar mi contraseña"},"unlock":{"title":"Reenviar instrucciones de desbloqueo","submit":"Reenviar instrucciones de desbloqueo"},"resend_confirmation_instructions":{"title":"Reenviar instrucciones de confirmación","submit":"Reenviar instrucciones de confirmación"},"links":{"sign_up":"Ingresar","sign_in":"Registrarse","forgot_your_password":"¿Olvidó su contraseña?","sign_in_with_omniauth_provider":"Conéctate con %{provider}","resend_unlock_instructions":"Reenviar instrucciones de desbloqueo","resend_confirmation_instructions":"Reenviar instrucciones de confirmación"}},"unsupported_browser":{"headline":"Por favor tenga en cuenta que Active Admin no soporta versiones de Internet Explorer menores a 8.","recommendation":"Recomendamos que actualice a la última versión de \u003ca href=\"http://windows.microsoft.com/ie\"\u003eInternet Explorer\u003c/a\u003e, \u003ca href=\"https://chrome.google.com/\"\u003eGoogle Chrome\u003c/a\u003e, o \u003ca href=\"https://mozilla.org/firefox/\"\u003eFirefox\u003c/a\u003e.","turn_off_compatibility_view":"Si está usando IE 9 o superior, asegúrese de \u003ca href=\"http://windows.microsoft.com/es-es/windows7/webpages-look-incorrect-in-Internet-Explorer\"\u003eapagar la \"Vista de compatibilidad\"\u003c/a\u003e."},"access_denied":{"message":"No está autorizado/a a realizar esta acción."},"index_list":{"table":"Tabla","block":"Lista","grid":"Grilla","blog":"Blog"}},"pageflow":{"public":{"_language":"Español","audio":"Audio","back":"Volver","back_to_chapter":"Volver al capítulo","before_after":{"drag_hint":null,"hint":"Vista antes/después","leave_view":"Abandonar vista antes/después","start":"Iniciar vista antes/después","start_title":"Iniciar vista antes/después"},"chapter":"Capítulo","chart":{"toggle":"Pulsar"},"close":"Cerrar","close_hint":"Cerrar consejo","close_navigation":"Cerrar navegación","close_overview":"Cerrar vista general","deprecated_browser":"\u003cp\u003eLa versión de su browser no es la más reciente por lo que ésta página puede funcionar de forma incorrecta. Le recomendamos actualizar su browser a la versión más actual.\u003c/p\u003e","embedded_video":{"leave_video":"Abandonar vídeo integrado"},"enlarge_view":"Vista ampliada","enter_fullscreen":"Iniciar modo de pantalla completa","first_page":"Primera página","forward":"Avanzar","fullscreen":"Pantalla completa","goto_first_page":"Ir a la primera página","goto_top":"Ir a la primera página","hide_text":"Ocultar texto","home":"Inicio","imprint":"Imprimir","javascript_hint":"Esta aplicación utiliza JavaScript para una funcionalidad y experiencia de usuario óptimas. Su browser probablemente no es compatible con JavaScript o ésta función quizá se encuentre inhabilitada.","languages":{"ar":null,"cs":null,"de":null,"dk":null,"el":null,"en":null,"es":null,"fr":null,"it":null,"nl":null,"pl":null,"pt":null,"ru":null,"sr":null,"tr":null,"unknown":null,"zh":null},"leave_fullscreen":"Abandonar modo de pantalla completa","lets_go":"Comenzemos","logo":"Logo","media_quality":null,"mute_off":"Abandonar modo silencio","mute_on":"Iniciar modo silencio","navigate_top":"Ir a la primera página","navigation":"Navegación","new_pages_box":{"additional_pages_html":"...y \u003cspan\u003e\u003c/span\u003e más","description":"Desde su última visita han sido añadidas páginas a éste Pageflow","title":"Páginas nuevas"},"notice":"Nota","open_audio":null,"open_navigation":"Abrir navegación","open_overview":"Abrir vista general","open_video":null,"overview":"Vista general","panorama":{"close":"Cerrar vista panorama de 360° y mostrar texto","start":"Iniciar vista panorama de 360°"},"play_video":"Iniciar vídeo","scroll_back_indicator":"Desplazarse hacia atrás","scroll_down":"Desplazarse hacia abajo","scroll_hint":"Utilize la rueda de desplazamiento de su ratón o las teclas de dirección de su teclado para navegar entre las páginas. ","scroll_indicator":"Desplazar hacia abajo","scroll_left":"Desplazarse hacia la izquierda","scroll_right":"Desplazarse hacia la derecha","scroll_up":"Desplazarse hacia arriba","share":"Compartir","share_on_facebook":"Compartir en Facebook","share_on_google":"Compartir en Google+","share_on_twitter":"Compartir en Twitter","share_this_entry":"Esta historia","share_this_page":"Esta página","show_home":"Inicio","show_text":"Mostrar texto","skip_links_content":"Ir al contenido","skip_links_navigation":"Ir al menú","skip_links_top_navigation":"Ir al menú principal","sound_hint":"Este formato de historia multimedia utiliza secuencias de vídeo y audio. Por favor asegúrese de que sus altavoces estén encendidos.  ","start_audio":"Iniciar audio ahora","start_video":"Iniciar vídeo ahora","swipe_hint":"Deslíze el dedo por la pantalla para navegar entre las páginas.","swipe_indicator":"Deslíze el dedo por la pantalla para continuar","text_track_modes":{"auto":null,"auto_off":null,"none":null},"text_tracks":null,"video":"Vídeo","video_qualities":{"annotations":{"4k":null,"fullhd":null,"medium":null},"labels":{"4k":null,"auto":null,"fullhd":null,"medium":null}},"volume":"Volúmen","vr":{"no_vr":{"link":null,"text":null},"select_quality":null,"start":null,"start_cardboard":null,"video_qualities":{"4k":null,"fullhd":null,"high":null},"video_quality_annotations":{"4k":null,"fullhd":null,"high":null}}}}},"zh-TW":{"ransack":{"search":"搜尋","predicate":"基於","and":"而且","or":"或者","any":"任何","all":"所有","combinator":"條件組合","attribute":"屬性","value":"數值","condition":"條件","sort":"排序","asc":"升冪排序","desc":"降冪排序","predicates":{"eq":"等於","eq_any":"等於任何一個值","eq_all":"等於所有值","not_eq":"不等於","not_eq_any":"不等於任何一個值","not_eq_all":"不等於所有值","matches":"符合","matches_any":"符合任何一個條件","matches_all":"符合所有條件","does_not_match":"不符合","does_not_match_any":"不符合任何一個條件","does_not_match_all":"不符合所有條件","lt":"小於","lt_any":"小於任何一個值","lt_all":"小於所有值","lteq":"小於或等於","lteq_any":"小於或等於任何一個值","lteq_all":"小於或等於所有值","gt":"大於","gt_any":"大於任何一個值","gt_all":"大於所有值","gteq":"大於或等於","gteq_any":"大於或等於任何一個值","gteq_all":"大於或等於所有值","in":"被包含於","in_any":"被包含於任何一個值","in_all":"被包含於所有值","not_in":"不被包含於","not_in_any":"不被包含於任何一個值","not_in_all":"不被包含於所有值","cont":"包含","cont_any":"包含任何一個值","cont_all":"包含所有值","not_cont":"不包含","not_cont_any":"不包含任何一個值","not_cont_all":"不包含所有值","start":"以某個值開始","start_any":"以任何一個值開始","start_all":"以所有值開始","not_start":"不以某個值開始","not_start_any":"不以任何一值開始","not_start_all":"不以所有值開始","end":"以某個值結尾","end_any":"以任何一個值結尾","end_all":"以所有值結尾","not_end":"不以某個值結尾","not_end_any":"不以任何一個值結尾","not_end_all":"不以所有值結尾","true":"為真","false":"為假","present":"有值","blank":"為空","null":"為 null","not_null":"不為 null"}},"errors":{"messages":{"in_between":"檔案大小必須介於 %{min} 到 %{max} 之間","spoofed_media_type":"副檔名與內容類型不符"}},"number":{"human":{"storage_units":{"format":"%n %u","units":{"byte":{"one":"Byte","other":"Bytes"},"kb":"KB","mb":"MB","gb":"GB","tb":"TB"}}}},"active_admin":{"dashboard":"儀表板","dashboard_welcome":{"welcome":"歡迎來到 Active Admin，這是預設的儀表板頁面。","call_to_action":"要新增儀表板內容，請查看 'app/admin/dashboard.rb'"},"view":"檢視","edit":"編輯","delete":"刪除","delete_confirmation":"你確定要刪除嗎？","new_model":"新增 %{model}","edit_model":"編輯 %{model}","delete_model":"刪除 %{model}","details":"%{model} 明細","cancel":"取消","empty":"空的","previous":"前一個","next":"下一個","download":"下載:","has_many_new":"增加新的 %{model}","has_many_delete":"刪除","has_many_remove":"清除","filters":{"buttons":{"filter":"篩選","clear":"清除篩選條件"},"predicates":{"contains":"包含","equals":"等於","starts_with":"開頭為","ends_with":"結尾為","greater_than":"大於","less_than":"小於"}},"search_status":{"headline":"搜尋條件:","current_scope":"子集：","current_filters":"目前篩選條件：","no_current_filters":"無"},"status_tag":{"yes":"是","no":"否"},"main_content":"請實作 %{model}#main_content 以顯示內容。","logout":"登出","powered_by":"Powered by %{active_admin} %{version}","sidebars":{"filters":"篩選條件","search_status":"搜尋條件"},"pagination":{"empty":"找不到 %{model} ","one":"顯示 \u003cb\u003e1\u003c/b\u003e %{model}","one_page":"顯示 \u003cb\u003e全部 %{n}\u003c/b\u003e %{model}","multiple":"總計 \u003cb\u003e%{total}\u003c/b\u003e 顯示 %{model} 中\u003cb\u003e%{from}\u0026nbsp;-\u0026nbsp;%{to}\u003c/b\u003e 筆","multiple_without_total":"顯示 %{model} 中\u003cb\u003e%{from}\u0026nbsp;-\u0026nbsp;%{to}\u003c/b\u003e 筆","entry":{"one":"筆","other":"筆"}},"any":"任何","blank_slate":{"content":"尚無 %{resource_name}","link":"建立一筆"},"dropdown_actions":{"button_label":"操作"},"batch_actions":{"button_label":"批次作業","default_confirmation":"你確定你要這樣做？","delete_confirmation":"你確定要刪除這些 %{plural_model} 嗎？","succesfully_destroyed":{"one":"成功刪除 1 %{model}","other":"成功刪除 %{count} %{plural_model}"},"selection_toggle_explanation":"（切換選取）","link":"建立一個","action_label":"%{title} 已選取","labels":{"destroy":"刪除"}},"comments":{"created_at":"建立","resource_type":"資源種類","author_type":"作者身份","body":"內文","author":"作者","title":"評論","add":"新增評論","delete":"刪除評論","delete_confirmation":"你確定要刪除這些評論嗎？","resource":"資源","no_comments_yet":"尚無評論","author_missing":"匿名","title_content":"(%{count}) 則評論","errors":{"empty_text":"評論儲存失敗，不允許空白的內容。"}},"devise":{"username":{"title":"帳號"},"email":{"title":"電子郵件信箱"},"subdomain":{"title":"子網域"},"password":{"title":"密碼"},"sign_up":{"title":"註冊","submit":"註冊"},"login":{"title":"登入","remember_me":"記住我","submit":"登入"},"reset_password":{"title":"忘記密碼？","submit":"重置密碼"},"change_password":{"title":"更改你的密碼","submit":"更改我的密碼"},"unlock":{"title":"重新發送解鎖指示","submit":"重新發送解鎖指示"},"resend_confirmation_instructions":{"title":"重新發送確認信","submit":"重新發送確認信"},"links":{"sign_up":"註冊","sign_in":"登入","forgot_your_password":"忘記密碼？","sign_in_with_omniauth_provider":"使用 %{provider} 登入","resend_unlock_instructions":"重新發送解鎖指示","resend_confirmation_instructions":"重新發送確認信"}},"unsupported_browser":{"headline":"很抱歉，ActiveAdmin 已不再支援 Internet Explorer 8 以下版本的瀏覽器。","recommendation":"建議您升級到最新版本的\u003ca href=\"http://windows.microsoft.com/ie\"\u003eInternet Explorer\u003c/a\u003e，\u003ca href=\"https://chrome.google.com/\"\u003eGoogle Chrome\u003c/a\u003e，或是 \u003ca href=\"https://mozilla.org/firefox/\"\u003eFirefox\u003c/a\u003e。","turn_off_compatibility_view":"若您是使用 IE 9 或更新的版本，請確認\u003ca href=\"http://windows.microsoft.com/zh-TW/windows7/webpages-look-incorrect-in-Internet-Explorer\"\u003e「相容性檢視」是關閉的\u003c/a\u003e。"},"access_denied":{"message":"您沒有權限執行此項操作"},"index_list":{"table":"表格","block":"清單","grid":"格狀","blog":"部落格"}}},"nl":{"ransack":{"search":"zoeken","predicate":"eigenschap","and":"en","or":"of","any":"enig","all":"alle","combinator":"combinator","attribute":"attribuut","value":"waarde","condition":"conditie","sort":"sorteren","asc":"oplopend","desc":"aflopend","predicates":{"eq":"gelijk","eq_any":"gelijk enig","eq_all":"gelijk alle","not_eq":"niet gelijk aan","not_eq_any":"niet gelijk aan enig","not_eq_all":"niet gelijk aan alle","matches":"evenaart","matches_any":"evenaart enig","matches_all":"evenaart alle","does_not_match":"evenaart niet","does_not_match_any":"evenaart niet voor enig","does_not_match_all":"evenaart niet voor alle","lt":"kleiner dan","lt_any":"kleiner dan enig","lt_all":"kleiner dan alle","lteq":"kleiner dan of gelijk aan","lteq_any":"kleiner dan of gelijk aan enig","lteq_all":"kleiner dan of gelijk aan alle","gt":"groter dan","gt_any":"groter dan enig","gt_all":"groter dan alle","gteq":"groter dan or equal to","gteq_any":"groter dan or equal to enig","gteq_all":"groter dan or equal to alle","in":"in","in_any":"in enig","in_all":"in alle","not_in":"niet in","not_in_any":"niet in enig","not_in_all":"niet in alle","cont":"bevat","cont_any":"bevat enig","cont_all":"bevat alle","not_cont":"bevat niet","not_cont_any":"bevat niet enig","not_cont_all":"bevat niet alle","start":"start met","start_any":"start met enig","start_all":"start met alle","not_start":"start niet met","not_start_any":"start niet met enig","not_start_all":"start niet met alle","end":"eindigt met","end_any":"eindigt met enig","end_all":"eindigt met alle","not_end":"eindigt niet met","not_end_any":"eindigt niet met enig","not_end_all":"eindigt niet met alle","true":"is waar","false":"is niet waar","present":"is present","blank":"is afwezig","null":"is null","not_null":"is niet null"}},"active_admin":{"dashboard":"Dashboard","dashboard_welcome":{"welcome":"Welkom bij Active Admin. Dit is de standaard dashboard pagina","call_to_action":"Pas uw eigen dashboard aan in het bestand 'app/admin/dashboard.rb'"},"view":"Bekijk","edit":"Wijzig","delete":"Verwijder","delete_confirmation":"Weet u zeker dat je dit item wilt verwijderen?","new_model":"Nieuwe %{model}","edit_model":"Wijzig %{model}","delete_model":"Verwijder %{model}","details":"%{model} details","cancel":"Annuleren","empty":"Leeg","previous":"Vorige","next":"Volgende","download":"Download","has_many_new":"Voeg nieuwe %{model} toe","has_many_delete":"Verwijderen","has_many_remove":"Verwijderen","filters":{"buttons":{"filter":"Filter","clear":"Maak Filters Ongedaan"},"predicates":{"contains":"Bevat","equals":"Gelijk aan","starts_with":"Begint met","ends_with":"Eindigt op","greater_than":"Groter dan","less_than":"Kleiner dan"}},"search_status":{"current_scope":"Scope:","current_filters":"Huidige filters:","no_current_filters":"Geen"},"status_tag":{"yes":"Ja","no":"Geen"},"main_content":"Implementeer %{model}#main_content om de content weer te geven.","logout":"Uitloggen","powered_by":"Mogelijk gemaakt door %{active_admin} %{version}","sidebars":{"filters":"Filters"},"pagination":{"empty":"Geen %{model} gevonden","one":"Geeft \u003cb\u003e1\u003c/b\u003e %{model} weer","one_page":"Geeft \u003cb\u003e%{n}\u003c/b\u003e %{model} weer","multiple":"Geeft %{model} \u003cb\u003e%{from}\u0026nbsp;-\u0026nbsp;%{to}\u003c/b\u003e van de \u003cb\u003e%{total}\u003c/b\u003e weer","multiple_without_total":"Geeft %{model} \u003cb\u003e%{from}\u0026nbsp;-\u0026nbsp;%{to}\u003c/b\u003e","entry":{"one":"entry","other":"entries"}},"any":"Alle","blank_slate":{"content":"Er zijn geen %{resource_name} gevonden.","link":"Maak aan"},"dropdown_actions":{"button_label":"Acties"},"batch_actions":{"button_label":"Batch acties","default_confirmation":"Weet u zeker dat u dit wilt doen?","delete_confirmation":"Weet u zeker dat u deze %{plural_model} wilt verwijderen?","succesfully_destroyed":{"one":"1 %{model} verwijderd.","other":"%{count} %{plural_model} verwijderd."},"selection_toggle_explanation":"(Toggle selectie)","link":"Maak aan","action_label":"%{title} geselecteerde","labels":{"destroy":"Verwijder"}},"comments":{"created_at":"Aangemaakt op","resource_type":"Resource Type","author_type":"Auteur Type","body":"Tekst","author":"Auteur","title":"Reactie","add":"Voeg commentaar toe","delete":"Verwijder commentaar","delete_confirmation":"Weet u zeker dat u dit commentaar wilt verwijderen?","resource":"Resource","no_comments_yet":"Nog geen reacties.","author_missing":"Anoniem","title_content":"Reacties (%{count})","errors":{"empty_text":"De reactie is niet opgeslagen, de tekst was leeg."}},"devise":{"username":{"title":"Gebruikersnaam"},"email":{"title":"Email"},"subdomain":{"title":"Subdomein"},"password":{"title":"Wachtwoord"},"sign_up":{"title":"Registreren","submit":"Registreren"},"login":{"title":"inloggen","remember_me":"Onthoud mij","submit":"inloggen"},"reset_password":{"title":"Wachtwoord vergeten?","submit":"Reset mijn wachtwoord vergeten"},"change_password":{"title":"Wijzig uw wachtwoord","submit":"Mijn wachtwoord wijzigen"},"unlock":{"title":"Verstuur ontgrendelinstructies opnieuw","submit":"Verstuur ontgrendelinstructies opnieuw"},"resend_confirmation_instructions":{"title":"Verstuur bevestigingsinstructies opnieuw","submit":"Verstuur bevestigingsinstructies opnieuw"},"links":{"sign_up":"Registreren","sign_in":"Meld u aan","forgot_your_password":"Wachtwoord vergeten?","sign_in_with_omniauth_provider":"Log in met %{provider}","resend_unlock_instructions":"Ontgrendelinstructies opnieuw versturen","resend_confirmation_instructions":"Bevestigingsinstructies opnieuw versturen"}},"unsupported_browser":{"headline":"Opgelet, ActiveAdmin bied geen support meer voor Internet Explorer 8 of lager","recommendation":"Wij raden aan om te upgraden naar de nieuwste \u003ca href=\"http://windows.microsoft.com/ie\"\u003eInternet Explorer\u003c/a\u003e, \u003ca href=\"https://chrome.google.com/\"\u003eGoogle Chrome\u003c/a\u003e, of \u003ca href=\"https://mozilla.org/firefox/\"\u003eFirefox\u003c/a\u003e.","turn_off_compatibility_view":"Als u IE 9 of nieuwer gebruikt, zorg ervoor dat u \u003ca href=\"http://windows.microsoft.com/en-US/windows7/webpages-look-incorrect-in-Internet-Explorer\"\u003e \"Compatibility View\" uit zet\u003c/a\u003e."},"access_denied":{"message":"U bent niet gemachtigd voor deze actie."},"index_list":{"table":"Tabel","block":"Lijst","grid":"Rooster","blog":"Blog"}},"pageflow":{"public":{"_language":"Nederlands","audio":"Audio","back":"Terug","back_to_chapter":"Terug naar hoofdstuk","before_after":{"drag_hint":"Linkermuisknop indrukken en naar links of rechts bewegen","hint":"Voor/na weergave","leave_view":"Verlaat de voor/na weergave","start":"Start de voor/na weergave","start_title":"Start de voor/na weergave"},"chapter":"Hoofdstuk","chart":{"toggle":"In-/uitschakelen"},"close":"Sluiten","close_hint":"Hint sluiten","close_navigation":"Navigatie sluiten","close_overview":"Overzicht sluiten","deprecated_browser":"\u003cp\u003eUw browser is verouderd en deze pagina werkt mogelijk niet zoals verwacht. We raden u aan uw browser te upgraden naar de nieuwste versie.\u003cp\u003e","embedded_video":{"leave_video":"Embedded video verlaten"},"enlarge_view":"Weergave vergroten","enter_fullscreen":"Volledig scherm weergeven","first_page":"Eerste pagina","forward":"Verder","fullscreen":"Volledig scherm","goto_first_page":"Ga naar de eerste pagina","goto_top":"Naar boven","hide_text":"Verberg tekst","home":"Home","imprint":"Colofon","javascript_hint":"Deze toepassing gebruikt JavaScript voor verbeterde functionaliteit en gebruikservaring. Uw browser ondersteunt JavaScript mogelijk niet of het is mogelijk uitgeschakeld.","languages":{"ar":null,"cs":null,"de":null,"dk":null,"el":null,"en":null,"es":null,"fr":null,"it":null,"nl":null,"pl":null,"pt":null,"ru":null,"sr":null,"tr":null,"unknown":null,"zh":null},"leave_fullscreen":"Verlaat volledig scherm","lets_go":"Hier gaan we","logo":"Logo","media_quality":null,"mute_off":"Geluid aan","mute_on":"Geluid uit","navigate_top":"Ga naar de eerste pagina","navigation":"Navigatie","new_pages_box":{"additional_pages_html":"...en \u003cspan\u003e\u003c/span\u003e meer","description":"Sinds uw laatste bezoek zijn pagina's toegevoegd aan dit verhaal:","title":"Nieuwe pagina's"},"notice":"Melding","open_audio":null,"open_navigation":"Toon navigatie","open_overview":"Toon overzicht","open_video":null,"overview":"Overzicht","panorama":{"close":"Sluit 360° panorama en toon tekst","start":"Begin 360° panorama"},"play_video":"Speel video","scroll_back_indicator":"Scoll omhoog","scroll_down":"Scroll omlaag","scroll_hint":"Gebruik het muiswiel of de pijltjestoetsen om tussen pagina's te navigeren.","scroll_indicator":"Scroll om door te gaan","scroll_left":"Scroll links","scroll_right":"Scroll rechts","scroll_up":"Scroll omhoog","share":"Deel","share_on_facebook":"Deel op Facebook","share_on_google":"Deel op Google+","share_on_twitter":"Deel op Twitter","share_this_entry":"Dit verhaal","share_this_page":"Deze pagina","show_home":"Start","show_text":"Laat tekst zien","skip_links_content":"Ga naar inhoud","skip_links_navigation":"Na naar navigatie","skip_links_top_navigation":"Ga naar hoofdnavigatie","sound_hint":"Dit multimediaverhaal bevat video- en geluidsfragmenten. Zet het geluid aan.","start_audio":"Start audio now","start_video":"Start video now","swipe_hint":"Swipe om tussen pagina's te navigeren.","swipe_indicator":"Swipe om door te gaan","text_track_modes":{"auto":null,"auto_off":null,"none":null},"text_tracks":null,"video":"Video","video_qualities":{"annotations":{"4k":null,"fullhd":null,"medium":null},"labels":{"4k":null,"auto":null,"fullhd":null,"medium":null}},"volume":"Volume","vr":{"no_vr":{"link":null,"text":null},"select_quality":null,"start":null,"start_cardboard":null,"video_qualities":{"4k":null,"fullhd":null,"high":null},"video_quality_annotations":{"4k":null,"fullhd":null,"high":null}}},"scrollytelling_pageflow_navigation":{"home_link":" Home","home_title":"Je gaat dan naar %{url}","widget_type_name":"Scrollytelling stippen met tooltips"},"pageflow_oembed":{"widget_type_name":"When available, replace plain links with embedded content."}}},"pt-BR":{"ransack":{"search":"pesquisar","predicate":"predicado","and":"e","or":"ou","any":"algum","all":"todos","combinator":"combinador","attribute":"atributo","value":"valor","condition":"condição","sort":"classificar","asc":"ascendente","desc":"descendente","predicates":{"eq":"igual","eq_any":"igual a algum","eq_all":"igual a todos","not_eq":"não é igual a","not_eq_any":"não é igual a algum","not_eq_all":"não é igual a todos","matches":"corresponde","matches_any":"corresponde a algum","matches_all":"corresponde a todos","does_not_match":"não corresponde","does_not_match_any":"não corresponde a algum","does_not_match_all":"não corresponde a todos","lt":"menor que","lt_any":"menor que algum","lt_all":"menor que todos","lteq":"menor ou igual a","lteq_any":"menor ou igual a algum","lteq_all":"menor ou igual a todos","gt":"maior que","gt_any":"maior que algum","gt_all":"maior que todos","gteq":"maior que ou igual a","gteq_any":"maior que ou igual a algum","gteq_all":"maior que ou igual a todos","in":"em","in_any":"em algum","in_all":"em todos","not_in":"não em","not_in_any":"não em algum","not_in_all":"não em todos","cont":"contém","cont_any":"contém algum","cont_all":"contém todos","not_cont":"não contém","not_cont_any":"não contém algum","not_cont_all":"não contém todos","start":"começa com","start_any":"começa com algum","start_all":"começa com todos","not_start":"não começa com","not_start_any":"não começa com algum","not_start_all":"não começa com algum","end":"termina com","end_any":"termina com algum","end_all":"termina com todos","not_end":"não termina com","not_end_any":"não termina com algum","not_end_all":"não termina com todos","true":"é verdadeiro","false":"é falso","present":"está presente","blank":"está em branco","null":"é nulo","not_null":"não é nulo"}},"errors":{"messages":{"in_between":"deve ter entre %{min} e %{max}","spoofed_media_type":"tem uma extensão que não corresponde ao seu conteúdo"}},"number":{"human":{"storage_units":{"format":"%n %u","units":{"byte":{"one":"Byte","other":"Bytes"},"kb":"KB","mb":"MB","gb":"GB","tb":"TB"}}}},"formtastic":{"yes":"Sim","no":"Não","create":"Criar %{model}","update":"Atualizar %{model}","submit":"Salvar %{model}","cancel":"Cancelar %{model}","reset":"Voltar %{model}","required":"obrigatório"},"active_admin":{"dashboard":"Painel Administrativo","dashboard_welcome":{"welcome":"Bem vindo ao Active Admin. Esta é a página de painéis padrão.","call_to_action":"Para adicionar seções ao painel, verifique 'app/admin/dashboard.rb'"},"view":"Visualizar","edit":"Editar","delete":"Remover","delete_confirmation":"Você tem certeza que deseja remover este item?","new_model":"Novo(a) %{model}","edit_model":"Editar %{model}","delete_model":"Remover %{model}","details":"Detalhes do(a) %{model}","cancel":"Cancelar","empty":"Vazio","previous":"Anterior","next":"Próximo","download":"Baixar:","has_many_new":"Adicionar Novo(a) %{model}","has_many_delete":"Remover","has_many_remove":"Remover","filters":{"buttons":{"filter":"Filtrar","clear":"Limpar Filtros"},"predicates":{"contains":"Contém","equals":"Igual A","starts_with":"Começa com","ends_with":"Termina com","greater_than":"Maior Que","less_than":"Menor Que"}},"search_status":{"headline":"Buscou:","current_scope":"Em:","current_filters":"Filtros escolhidos:","no_current_filters":"Nenhum"},"status_tag":{"yes":"Sim","no":"Não"},"main_content":"Por favor implemente %{model}#main_content para exibir conteúdo.","logout":"Sair","powered_by":"Powered by %{active_admin} %{version}","sidebars":{"filters":"Filtros","search_status":"Buscou"},"pagination":{"empty":"Nenhum(a) %{model} encontrado(a)","one":"Exibindo \u003cb\u003e1\u003c/b\u003e %{model}","one_page":"Exibindo \u003cb\u003etodos(as) os(as) %{n}\u003c/b\u003e %{model}","multiple":"Exibindo %{model} \u003cb\u003e%{from}\u0026nbsp;-\u0026nbsp;%{to}\u003c/b\u003e de um total de \u003cb\u003e%{total}\u003c/b\u003e","multiple_without_total":"Exibindo %{model} \u003cb\u003e%{from}\u0026nbsp;-\u0026nbsp;%{to}\u003c/b\u003e","entry":{"one":"registro","other":"registros"}},"any":"Qualquer","blank_slate":{"content":"Não existem %{resource_name} ainda.","link":"Novo"},"dropdown_actions":{"button_label":"Ações"},"batch_actions":{"button_label":"Ações em lote","default_confirmation":"Tem certeza que quer fazer isso?","delete_confirmation":"Tem certeza que deseja excluir estes %{plural_model}?","succesfully_destroyed":{"one":"Excluiu com sucesso 1 %{model}","other":"Excluiu com sucesso %{count} %{plural_model}"},"selection_toggle_explanation":"(Alternar Seleção)","link":"Novo","action_label":"%{title} Selecionado","labels":{"destroy":"Excluir"}},"comments":{"created_at":"Criado em","resource_type":"Tipo de Objeto","author_type":"Tipo de Autor","body":"Conteúdo","author":"Autor","title":"Comentário","add":"Adicionar Comentário","delete":"Deletar comentário","delete_confirmation":"Tem certeza que deseja excluir este comentário?","resource":"Objeto","no_comments_yet":"Nenhum comentário.","author_missing":"Anônimo","title_content":"Comentários: %{count}","errors":{"empty_text":"O comentário não foi salvo porque o texto estava vazio."}},"devise":{"username":{"title":"Nome de Usuário"},"email":{"title":"E-mail"},"subdomain":{"title":"Subdomínio"},"password":{"title":"Senha"},"sign_up":{"title":"Cadastre-se","submit":"Continuar"},"login":{"title":"Conta","remember_me":"Lembrar da senha","submit":"Entrar"},"reset_password":{"title":"Esqueceu sua senha?","submit":"Reinicie minha senha"},"change_password":{"title":"Troque sua senha","submit":"Troque minha senha"},"unlock":{"title":"Reenviar instruções de desbloqueio","submit":"Reenviar instruções de desbloqueio"},"resend_confirmation_instructions":{"title":"Reenviar instruções de confirmação","submit":"Reenviar instruções de confirmação"},"links":{"sign_up":"Criar conta","sign_in":"Entrar","forgot_your_password":"Esqueceu sua senha?","sign_in_with_omniauth_provider":"Entre com o %{provider}","resend_unlock_instructions":"Reenviar instruções de desbloqueio","resend_confirmation_instructions":"Reenviar instruções de confirmação"}},"unsupported_browser":{"headline":"O ActiveAdmin não oferece suporte ao Internet Explorer versão 8 ou inferior.","recommendation":"Nós recomendamos atualizar para a última versão do \u003ca href=\"http://windows.microsoft.com/ie\"\u003eInternet Explorer\u003c/a\u003e, \u003ca href=\"https://chrome.google.com/\"\u003eGoogle Chrome\u003c/a\u003e, ou \u003ca href=\"https://mozilla.org/firefox/\"\u003eFirefox\u003c/a\u003e.","turn_off_compatibility_view":"Se você está usando o IE 9 ou superior, \u003ca href=\"http://windows.microsoft.com/pt-BR/windows7/webpages-look-incorrect-in-Internet-Explorer\"\u003edesligue o \"Modo de Exibição de Compatibilidade\"\u003c/a\u003e."},"access_denied":{"message":"Você não tem permissão para realizar o solicitado"},"index_list":{"table":"Tabela","block":"Lista","grid":"Grid","blog":"Blog"}},"pageflow":{"public":{"_language":"Português brasileiro","audio":"Audio","back":"Voltar","back_to_chapter":"Voltar à capítulo","before_after":{"drag_hint":null,"hint":"Visão antes/depois","leave_view":"Deixar visão antes/depois","start":"Iniciar visão antes/depois","start_title":"Iniciar visão antes/depois"},"chapter":"Capítulo","chart":{"toggle":"Alternar"},"close":"Fechar","close_hint":"Fechar dica","close_navigation":"Fechar navegação","close_overview":"Fechar visão geral","deprecated_browser":"\u003cp\u003eO seu navegador está desatualizado e essa página pode não funcionar como planejado. Recomendamos atualizar seu navegador para a versão mais recente.\u003c/p\u003e","embedded_video":{"leave_video":"Sair do vídeo"},"enlarge_view":"Aumentar","enter_fullscreen":"Tela cheia","first_page":"Primeira página","forward":"Avançar","fullscreen":"Tela cheia","goto_first_page":"Ir p/ primeira página","goto_top":"Ir p/ início","hide_text":"Esconder texto","home":"Início","imprint":"Imprimir","javascript_hint":"Essa aplicação utiliza JavaScript para uma melhor funcionalidade e experiência do usuário. Seu navegador talvez não suporte JavaScript ou talvez esteja desabilitado.","languages":{"ar":null,"cs":null,"de":null,"dk":null,"el":null,"en":null,"es":null,"fr":null,"it":null,"nl":null,"pl":null,"pt":null,"ru":null,"sr":null,"tr":null,"unknown":null,"zh":null},"leave_fullscreen":"Sair de tela cheia","lets_go":"Vamos lá","logo":"Logo","media_quality":null,"mute_off":"Habilitar som","mute_on":"Mudo","navigate_top":"Topo","navigation":"Navegação","new_pages_box":{"additional_pages_html":"...e \u003cspan\u003e\u003c/span\u003e mais","description":"Desde sua última visita, foram adicionadas novas páginas","title":"Nova página"},"notice":"Aviso","open_audio":null,"open_navigation":"Abrir navegação","open_overview":"Abrir visão geral","open_video":null,"overview":"Visão geral","panorama":{"close":"Fechar panorama 360° e exibir texto","start":"Iniciar panorama 360°"},"play_video":"Reproduzir vídeo","scroll_back_indicator":null,"scroll_down":"Rolar para baixo","scroll_hint":"Use a rolagem do mouse ou as setas do teclado para navegar entre as páginas.","scroll_indicator":"Role para baixo para continuar","scroll_left":"Rolar para esquerda","scroll_right":"Rolar para direita","scroll_up":"Rolar para cima","share":"Compartilhar","share_on_facebook":"Compartilhar no Facebook","share_on_google":"Compartilhar no Google+","share_on_twitter":"Compartilhar no Twitter","share_this_entry":"Esta história","share_this_page":"Esta página","show_home":"Início","show_text":"Mostrar texto","skip_links_content":"Ir para o conteúdo","skip_links_navigation":"Ir para a navegação","skip_links_top_navigation":"Ir para navegação principal","sound_hint":"Este formato de história multimídia utiliza vídeo e áudio. Por favor, certifique-se que seus alto-falantes estão ligados.","start_audio":"Start audio now","start_video":"Start video now","swipe_hint":"Deslize para navegar entre as páginas.","swipe_indicator":"Deslize para continuar","text_track_modes":{"auto":null,"auto_off":null,"none":null},"text_tracks":null,"video":"Vídeo","video_qualities":{"annotations":{"4k":null,"fullhd":null,"medium":null},"labels":{"4k":null,"auto":null,"fullhd":null,"medium":null}},"volume":"Volume","vr":{"no_vr":{"link":null,"text":null},"select_quality":null,"start":null,"start_cardboard":null,"video_qualities":{"4k":null,"fullhd":null,"high":null},"video_quality_annotations":{"4k":null,"fullhd":null,"high":null}}}}},"id":{"ransack":{"search":"cari","predicate":"predikat","and":"dan","or":"atau","any":"apapun","all":"semua","combinator":"kombinasi","attribute":"atribut","value":"data","condition":"kondisi","sort":"urutan","asc":"ascending","desc":"descending","predicates":{"eq":"sama dengan","eq_any":"sama beberapa dengan","eq_all":"sama seluruhnya dengan","not_eq":"tidak sama dengan","not_eq_any":"tidak sama beberapa dengan","not_eq_all":"tidak semua seluruhnya dengan","matches":"mirip","matches_any":"mirip beberapa dengan","matches_all":"mirip semua dengan","does_not_match":"tidak mirip dengan","does_not_match_any":"tidak mirip beberapa dengan","does_not_match_all":"tidak mirip semua dengan","lt":"kurang dari","lt_any":"kurang beberapa dengan","lt_all":"kurang seluruhnya dengan","lteq":"kurang lebih","lteq_any":"kurang lebih beberapa dengan","lteq_all":"kurang lebih semua dengan","gt":"lebih besar daripada","gt_any":"lebih besar beberapa dengan","gt_all":"lebih besar semua dengan","gteq":"lebih besar atau sama dengan","gteq_any":"beberapa lebih besar atau sama dengan","gteq_all":"semua lebih besar atau sama dengan","in":"di","in_any":"di beberapa","in_all":"di semua","not_in":"tidak di","not_in_any":"tidak di beberapa","not_in_all":"tidak semua di","cont":"mengandung","cont_any":"mengandung beberapa","cont_all":"mengandung semua","not_cont":"tidak mengandung","not_cont_any":"tidak mengandung beberapa","not_cont_all":"tidak mengandung semua","start":"diawali dengan","start_any":"diawali beberapa dengan","start_all":"diawali semua dengan","not_start":"tidak diawali dengan","not_start_any":"tidak diawali beberapa dengan","not_start_all":"tidak diawali semua dengan","end":"diakhiri dengan","end_any":"diakhiri beberapa dengan","end_all":"diakhiri semua dengan","not_end":"tidak diakhiri dengan","not_end_any":"tidak diakhiri dengan beberapa","not_end_all":"tidak diakhiri dengan semua","true":"bernilai benar","false":"bernilai salah","present":"ada","blank":"kosong","null":"null","not_null":"tidak null"}},"active_admin":{"dashboard":"Dashboard","dashboard_welcome":{"welcome":"Selamat datang di Active Admin. Ini adalah tampilan standar halaman dashboard.","call_to_action":"Tampilan halaman ini bisa diubah di file 'app/admin/dashboard.rb'"},"view":"Lihat","edit":"Ubah","delete":"Hapus","delete_confirmation":"Apakah anda yakin ingin menghapus data ini?","new_model":"Tambah %{model} baru","edit_model":"Ubah %{model}","delete_model":"Hapus %{model}","details":"Detail %{model}","cancel":"Batal","empty":"Kosong","previous":"Sebelumnya","next":"Berikutnya","download":"Unduh:","has_many_new":"Tambah %{model} baru","has_many_delete":"Hapus","has_many_remove":"Hapus","filters":{"buttons":{"filter":"Filter","clear":"Hapus Filters"},"predicates":{"contains":"Mengandung","equals":"Sama dengan","starts_with":"Diawali dengan","ends_with":"Diakhiri dengan","greater_than":"Lebih besar dari","less_than":"Lebih kecil dari"}},"search_status":{"headline":"Status Pencarian:","current_scope":"Scope:","current_filters":"Filter kini:","no_current_filters":"Tidak ada"},"status_tag":{"yes":"Ya","no":"Tidak"},"main_content":"Harap mengimplementasikan %{model}#main_content untuk menampilkan konten.","logout":"Keluar","powered_by":"Dibuat dengan %{active_admin} %{version}","sidebars":{"filters":"Filter","search_status":"Status Pencarian"},"pagination":{"empty":"Tidak ada %{model} yang bisa ditemukan","one":"Menampilkan \u003cb\u003e1\u003c/b\u003e %{model}","one_page":"Menampilkan \u003cb\u003esemua %{n}\u003c/b\u003e %{model}","multiple":"Menampilkan \u003cb\u003e%{from}\u0026nbsp;-\u0026nbsp;%{to}\u003c/b\u003e dari \u003cb\u003e%{total}\u003c/b\u003e keseluruhan %{model}","multiple_without_total":"Menampilkan \u003cb\u003e%{from}\u0026nbsp;-\u0026nbsp;%{to} %{model}\u003c/b\u003e","entry":{"one":"data","other":"data"}},"any":"Apapun","blank_slate":{"content":"%{resource_name} masih belum ada sama sekali.","link":"Tambah data"},"dropdown_actions":{"button_label":"Tindakan"},"batch_actions":{"button_label":"Tindakan Serentak","default_confirmation":"Apakah anda yakin akan melakukan ini?","delete_confirmation":"Apakah anda yakin akan menghapus %{plural_model}?","succesfully_destroyed":{"one":"Berhasil menghapus %{model}","other":"Berhasil menghapus %{count} %{plural_model}"},"selection_toggle_explanation":"(Tampilkan Pilihan)","link":"Tambah data","action_label":"%{title} terpilih","labels":{"destroy":"Hapus"}},"comments":{"created_at":"Dibuat","resource_type":"Jenis Resource","author_type":"Tipe Penulis","body":"Isi","author":"Penulis","title":"Komentar","add":"Tambah Komentar","delete":"Hapus Komentar","delete_confirmation":"Apakah anda yakin akan menghapus komentar tersebut?","resource":"Resource","no_comments_yet":"Belum ada komentar sama sekali.","author_missing":"Anonim","title_content":"Komentar (%{count})","errors":{"empty_text":"Komentar tak bisa disimpan, text tidak boleh dikosongi."}},"devise":{"username":{"title":"Username"},"email":{"title":"Email"},"subdomain":{"title":"Subdomain"},"password":{"title":"Password"},"sign_up":{"title":" - Daftar","submit":"Daftar"},"login":{"title":" - Masuk","remember_me":"Ingat saya","submit":"Masuk"},"reset_password":{"title":" - Form Atur Ulang Password","submit":"Atur ulang password"},"change_password":{"title":" - Atur Ulang Password","submit":"Kirimkan instruksi pengaturan ulang password"},"unlock":{"title":" - Kirim Instruksi Pengaktifan Kembali Akun","submit":"Kirimkan instruksi pengaktifan kembali akun"},"resend_confirmation_instructions":{"title":" - Kirim Lagi Instruksi Konfirmasi Akun","submit":"Kirimkan lagi instruksi konfirmasi akun"},"links":{"sign_up":"Daftar","sign_in":"Masuk","forgot_your_password":"Lupa password?","sign_in_with_omniauth_provider":"Daftar melalui %{provider}","resend_unlock_instructions":"Kirim instruksi pengaktifan kembali akun","resend_confirmation_instructions":"Kirim lagi instruksi konfirmasi akun"}},"unsupported_browser":{"headline":"Harap dicatat bahwa ActiveAdmin sudah tidak mendukung InternetExplorer versi 8 atau versi sebelum itu.","recommendation":"Kami sarankan agar anda mengupgrade ke versi \u003ca href=\"http://windows.microsoft.com/ie\"\u003eInternet Explorer\u003c/a\u003e, \u003ca href=\"https://chrome.google.com/\"\u003eGoogle Chrome\u003c/a\u003e, atau \u003ca href=\"https://mozilla.org/firefox/\"\u003eFirefox\u003c/a\u003e yang terbaru.","turn_off_compatibility_view":"Kalau anda menggunakan IE 9 atau yang lebih baru, pastikan anda \u003ca href=\"http://windows.microsoft.com/en-US/windows7/webpages-look-incorrect-in-Internet-Explorer\"\u003emematikan \"Compatibility View\"\u003c/a\u003e."},"access_denied":{"message":"Anda tidak diperkenankan melakukan aksi tersebut."},"index_list":{"table":"Tabel","block":"Daftar","grid":"Grid","blog":"Blog"}},"pageflow":{"public":{"_language":"Bahasa Indonesia","audio":"Audio","back":"Kembali","back_to_chapter":"Kembali ke bab","before_after":{"drag_hint":null,"hint":"Paparan sebelum/selepas","leave_view":"Tinggalkan paparan sebelum/selepas","start":"Mulakan paparan sebelum/selepas","start_title":"Mulakan paparan sebelum/selepas"},"chapter":"Bab","chart":{"toggle":"Alih"},"close":"Tutup","close_hint":"Tutup petunjuk","close_navigation":"Tutup navigasi","close_overview":"Tutup ikhtisar","deprecated_browser":"Peramban anda sudah usang dan halaman ini mungkin tidak akan berfungsi sebagaimana dimaksud. Sebaiknya upgrade peramban anda ke versi terbaru.","embedded_video":{"leave_video":"Tinggalkan video tertanam"},"enlarge_view":"Perbesar pandangan","enter_fullscreen":"Masuk mode layar penuh","first_page":"Halaman pertama","forward":"Ke depan","fullscreen":"Layar penuh","goto_first_page":"Pergi ke halaman pertama","goto_top":"Pergi ke halaman pertama","hide_text":"Sembunyikan teks ","home":"Mulai","imprint":"Jejak","javascript_hint":"Aplikasi ini menggunakan JavaScript untuk peningkatan fungsi dan pengalaman pengguna. Peramban anda mungkin tidak mendukung JavaScript atau dinonaktifkan.","languages":{"ar":null,"cs":null,"de":null,"dk":null,"el":null,"en":null,"es":null,"fr":null,"it":null,"nl":null,"pl":null,"pt":null,"ru":null,"sr":null,"tr":null,"unknown":null,"zh":null},"leave_fullscreen":"Keluar mode layar penuh","lets_go":"Ayo","logo":"Logo","media_quality":null,"mute_off":"Aktifkan bunyi ","mute_on":"Bisukan bunyi","navigate_top":"Pergi ke halaman pertama","navigation":"Navigasi","new_pages_box":{"additional_pages_html":"...dan \u003cspan\u003e\u003c/span\u003e lebih","description":"Sejak kunjungan terakhir anda, halaman baru telah ditambahkan ke Pageflow ini:","title":"Halaman baru"},"notice":"Pemberitahuan","open_audio":null,"open_navigation":"Buka navigasi","open_overview":"Buka ikhtisar","open_video":null,"overview":"Gambaran ikhtisar","panorama":{"close":"Tutup panorama 360° dan tampilan teks","start":"Mulai panorama 360° "},"play_video":"Putar video","scroll_back_indicator":"Gulir kembali","scroll_down":"Gulir ke bawah","scroll_hint":"Menggunakan roda mouse atau tombol panah pada keyboard Anda untuk menavigasi antara halaman.","scroll_indicator":"Gulir ke bawah untuk teruskan ","scroll_left":"Gulir ke kiri","scroll_right":"Gulir ke kanan","scroll_up":"Gulir ke atas","share":"Bagikan","share_on_facebook":"Bagikan di Facebook","share_on_google":"Bagikan di Google+","share_on_twitter":"Bagikan di Twitter","share_this_entry":"Cerita ini","share_this_page":"Halaman ini","show_home":"Mulai","show_text":"Tampilkan teks","skip_links_content":"Pergi ke kandungan","skip_links_navigation":"Pergi ke navigasi","skip_links_top_navigation":"Pergi ke navigasi utama","sound_hint":"Format cerita multimedia ini menggunakan rekaman video dan audio. Pastikan speaker anda diaktifkan. ","start_audio":"Mulai audio sekarang","start_video":"Mulai video sekarang","swipe_hint":"Gesek untuk menavigasi antara halaman.","swipe_indicator":"Gesek untuk teruskan.","text_track_modes":{"auto":null,"auto_off":null,"none":null},"text_tracks":null,"video":"Video","video_qualities":{"annotations":{"4k":null,"fullhd":null,"medium":null},"labels":{"4k":null,"auto":null,"fullhd":null,"medium":null}},"volume":"Volume","vr":{"no_vr":{"link":null,"text":null},"select_quality":null,"start":null,"start_cardboard":null,"video_qualities":{"4k":null,"fullhd":null,"high":null},"video_quality_annotations":{"4k":null,"fullhd":null,"high":null}}}}},"hu":{"ransack":{"search":"keresés","predicate":"állítás","and":"és","or":"vagy","any":"bármely","all":"mindegyik","combinator":"combinator","attribute":"attribute","value":"érték","condition":"feltétel","sort":"rendezés","asc":"növekvő","desc":"csökkenő","predicates":{"eq":"egyenlő","eq_any":"bármelyikkel egyenlő","eq_all":"minddel egyenlő","not_eq":"nem egyenlő","not_eq_any":"nem egyenlő bármelyikkel","not_eq_all":"nem egyenlő egyikkel sem","matches":"egyezik","matches_any":"bármelyikkel egyezik","matches_all":"minddel egyezik","does_not_match":"nem egyezik","does_not_match_any":"nem egyezik semelyikkel","does_not_match_all":"nem egyezik az összessel","lt":"kisebb, mint","lt_any":"bármelyiknél kisebb","lt_all":"mindegyiknél kisebb","lteq":"kisebb vagy egyenlő, mint","lteq_any":"bármelyiknél kisebb vagy egyenlő","lteq_all":"mindegyiknél kisebb vagy egyenlő","gt":"nagyobb, mint","gt_any":"bármelyiknél nagyobb","gt_all":"mindegyiknél nagyobb","gteq":"nagyobb vagy egyenlő, mint","gteq_any":"bármelyiknél nagyobb vagy egyenlő","gteq_all":"mindegyiknél nagyobb vagy egyenlő","in":"értéke","in_any":"értéke bármelyik","in_all":"értéke mindegyik","not_in":"nem ez az értéke","not_in_any":"értéke egyik sem","not_in_all":"értéke nem ezek az elemek","cont":"tartalmazza","cont_any":"bármelyiket tartalmazza","cont_all":"mindet tartalmazza","not_cont":"nem tartalmazza","not_cont_any":"egyiket sem tartalmazza","not_cont_all":"nem tartalmazza mindet","start":"így kezdődik","start_any":"bármelyikkel kezdődik","start_all":"ezekkel kezdődik","not_start":"nem így kezdődik","not_start_any":"nem ezek egyikével kezdődik","not_start_all":"nem ezekkel kezdődik","end":"így végződik","end_any":"bármelyikkel végződik","end_all":"ezekkel végződik","not_end":"nem úgy végződik","not_end_any":"nem ezek egyikével végződik","not_end_all":"nem ezekkel végződik","true":"igaz","false":"hamis","present":"létezik","blank":"üres","null":"null","not_null":"nem null"}},"active_admin":{"dashboard":"Vezérlőpult","dashboard_welcome":{"welcome":"Üdvözöljük az Active Admin felületén. Ez a vezérlőpult kezdőlapja","call_to_action":"Elemek hozzáadásához nézze meg a 'app/admin/dashboard.rb' fájlt"},"view":"Megtekintés","edit":"Szerkesztés","delete":"Törlés","delete_confirmation":"Biztosan törli ezt az elemet?","new_model":"Új %{model}","edit_model":"%{model} módosítása","delete_model":"%{model} törlése","details":"%{model} részletei","cancel":"Mégsem","empty":"Üres","previous":"Előző","next":"Következő","download":"Letöltés:","has_many_new":"Új %{model} hozzáadása","has_many_delete":"Törlés","has_many_remove":"Eltávolít","filters":{"buttons":{"filter":"Szűrés","clear":"Feltételek törlése"},"predicates":{"contains":"Tartalmazza","equals":"Pontosan","starts_with":"kezdődik","ends_with":"végződik","greater_than":"Nagyobb, mint","less_than":"Kisebb, mint"}},"status_tag":{"yes":"Igen","no":"Nem"},"main_content":"Kérem, implementálja a %{model}#main_content metódust a tartalom megjelenítéséhez.","logout":"Kilépés","powered_by":"Powered by %{active_admin} %{version}","sidebars":{"filters":"Szűrők"},"pagination":{"empty":"Nincs több %{model}","one":"\u003cb\u003eEgy\u003c/b\u003e %{model} megjelenítése","one_page":"\u003cb\u003eAz összes (%{n} db)\u003c/b\u003e %{model} megjelenítése","multiple":"%{model} listájának megjelenítése, \u003cb\u003e%{from}\u0026nbsp;-\u0026nbsp;%{to}\u003c/b\u003e/\u003cb\u003e%{total}\u003c/b\u003e ","multiple_without_total":"%{model} listájának megjelenítése, \u003cb\u003e%{from}\u0026nbsp;-\u0026nbsp;%{to}\u003c/b\u003e ","entry":{"one":"elem","other":"elem"}},"any":"Összes","blank_slate":{"content":"Még nincs létrehozva %{resource_name}.","link":"Létrehozás most"},"dropdown_actions":{"button_label":"Műveletek"},"batch_actions":{"button_label":"Tömeges műveletek","default_confirmation":"Biztos vagy benne, hogy a ön akar-hoz csinál ez?","delete_confirmation":"Biztosan törli ezeket a %{plural_model}?","succesfully_destroyed":{"one":"1 %{model} sikeresen törölve","other":"%{count} %{plural_model} sikeresen törölve"},"selection_toggle_explanation":"(Kijelölés megfordítása)","link":"Létrehozás","action_label":"%{title} kiválasztva","labels":{"destroy":"Törlés"}},"comments":{"body":"Törzs","author":"Szerző","title":"Hozzászólás","add":"Új hozzászólás","resource":"Erőforrás","no_comments_yet":"Nincsenek hozzászólások.","title_content":"%{count} hozzászólás","errors":{"empty_text":"A hozzászólás nem lett mentve, a törzs nem lehet üres."}},"devise":{"login":{"title":"Bejelentkezés","remember_me":"Emlékezz rám","submit":"Belépés"},"reset_password":{"title":"Elfelejtette a jelszavát?","submit":"Jelszó visszaállítása"},"change_password":{"title":"A jelszó módosítása","submit":"Jelszó módosítása"},"unlock":{"title":"Újraküldés unlock utasítások","submit":"Újraküldés unlock utasítások"},"resend_confirmation_instructions":{"title":"Megerősítő levél újraküldése","submit":"Megerősítő levél újraküldése"},"links":{"sign_in":"Bejelentkezés","forgot_your_password":"Elfelejtette a jelszavát?","sign_in_with_omniauth_provider":"Jelentkezzen be a %{provider}"}}}},"zh-HK":{"errors":{"messages":{"in_between":"必須介於%{min}到%{max}之間","spoofed_media_type":"副檔名與內容類型不匹配"}},"number":{"human":{"storage_units":{"format":"%n %u","units":{"byte":{"one":"Byte","other":"Bytes"},"kb":"KB","mb":"MB","gb":"GB","tb":"TB"}}}}},"ca":{"formtastic":{"yes":"Sí","no":"No","create":"Crear %{model}","update":"Actualitzar %{model}","submit":"Acceptar","cancel":"Cancel·lar","reset":"Restablir %{model}","required":"obligatori"},"active_admin":{"dashboard":"Tauler","dashboard_welcome":{"welcome":"Benvingut a Active Admin. Aquest és el tauler per defecte.","call_to_action":"Mira l'arxiu 'app/admin/dashboard.rb' per afegir seccions al tauler"},"view":"Mostra","edit":"Edita","delete":"Elimina","delete_confirmation":"Segur que vols eliminar-ho?","new_model":"Crear %{model}","edit_model":"Editar %{model}","delete_model":"eliminar %{model}","details":"Detalls de %{model}","cancel":"Cancel·lar","empty":"Buit","previous":"Anterior","next":"Següent","download":"Descarregar:","has_many_new":"Afegir %{model}","has_many_delete":"Eliminar","has_many_remove":"Treure","filters":{"buttons":{"filter":"Filtrar","clear":"Treure filtres"},"predicates":{"contains":"Conté","equals":"Igual a","starts_with":"Comença amb","ends_with":"Acaba amb","greater_than":"Més gran que","less_than":"Més petit que"}},"status_tag":{"yes":"Sí","no":"No"},"main_content":"Implementa %{model}#main_content per mostrar contingut.","logout":"Desconnecta't","powered_by":"Powered by %{active_admin} %{version}","sidebars":{"filters":"Filtres"},"pagination":{"empty":"No hi ha %{model}","one":"S'està mostrant \u003cb\u003e1\u003c/b\u003e %{model}","one_page":"S'estan mostrant \u003cb\u003etots %{n}\u003c/b\u003e %{model}","multiple":"S'estan mostrant %{model} \u003cb\u003e%{from}\u0026nbsp;-\u0026nbsp;%{to}\u003c/b\u003e de \u003cb\u003e%{total}\u003c/b\u003e en total","multiple_without_total":"S'estan mostrant %{model} \u003cb\u003e%{from}\u0026nbsp;-\u0026nbsp;%{to}\u003c/b\u003e","entry":{"one":"entrada","other":"entrades"}},"any":"Qualsevol","blank_slate":{"content":"Encara no hi ha cap %{resource_name}.","link":"Crea'n un/a"},"dropdown_actions":{"button_label":"accions"},"batch_actions":{"button_label":"les accions per lots","default_confirmation":"¿Esteu segur que voleu fer-ho?","delete_confirmation":"¿Està segur que desitja eliminar aquests %{plural_model}?","succesfully_destroyed":{"one":"Va destruir amb èxit 1 %{model}","other":"Va destruir amb èxit %{count} %{plural_model}"},"selection_toggle_explanation":"(Selecció de Canviar)","link":"crear una","action_label":"%{title} seleccionat","labels":{"destroy":"esborrar"}},"comments":{"body":"Cos","author":"autor","title":"comentari","add":"Afegeix comentari","resource":"Recurs","no_comments_yet":"No hi ha comentaris","title_content":"comentaris (%{count})","errors":{"empty_text":"El comentari no es va salvar, el text estava buida."}},"devise":{"login":{"title":"iniciar sessió","remember_me":"Recordar","submit":"iniciar sessió"},"reset_password":{"title":"Heu perdut la contrasenya?","submit":"Restablir la contrasenya"},"change_password":{"title":"Canvieu la contrasenya","submit":"Canviar la contrasenya"},"unlock":{"title":"Reenvia instruccions per a desbloquejar","submit":"Reenvia instruccions per a desbloquejar"},"resend_confirmation_instructions":{"title":"Reenviar instruccions de confirmació","submit":"Reenviar instruccions de confirmació"},"links":{"sign_in":"Registrar","forgot_your_password":"Heu perdut la contrasenya?","sign_in_with_omniauth_provider":"Connecta't amb %{provider}"}},"access_denied":{"message":"No esta autoritzat a realitzar aquesta acció."},"index_list":{"table":"Taula","block":"Llista","grid":"Graella","blog":"Bloc"}}},"it":{"formtastic":{"yes":"Sì","no":"No","create":"Crea %{model}","update":"Aggiorna %{model}","submit":"Invia","cancel":"Annulla","reset":"Ripristina %{model}","required":"obbligatorio"},"active_admin":{"dashboard":"Dashboard","dashboard_welcome":{"welcome":"Benvenuti in Active Admin. Questa è la pagina dashboard di default.","call_to_action":"Per aggiungere sezioni alla dashboard controlla il file 'app/admin/dashboard.rb'"},"view":"Mostra","edit":"Modifica","delete":"Rimuovi","delete_confirmation":"Sei sicuro di volerlo rimuovere?","new_model":"Aggiungi %{model}","edit_model":"Modifica %{model}","delete_model":"Rimuovi %{model}","details":"Dettagli %{model}","cancel":"Annulla","empty":"Vuoto","previous":"Precedente","next":"Prossimo","download":"Scarica:","has_many_new":"Aggiungi nuovo/a %{model}","has_many_delete":"Rimuovi","has_many_remove":"Rimuovi","filters":{"buttons":{"filter":"Filtra","clear":"Rimuovi filtri"},"predicates":{"contains":"Contiene","equals":"Uguale a","starts_with":"Inizia con","ends_with":"Finisce con","greater_than":"Maggiore di","less_than":"Minore di"}},"search_status":{"headline":"Situazione filtri:","current_scope":"Contesto selezionato:","current_filters":"Filtri attivi:","no_current_filters":"Nessuno"},"status_tag":{"yes":"Sì","no":"No"},"main_content":"Devi implemetare %{model}#main_content per mostrarne il contenuto.","logout":"Esci","powered_by":"Powered by %{active_admin} %{version}","sidebars":{"filters":"Filtri","search_status":"Informazioni sulla ricerca"},"pagination":{"empty":"Nessun %{model} trovato","one":"Sto mostrando \u003cb\u003e1\u003c/b\u003e %{model}","one_page":"Sto mostrando \u003cb\u003e%{n}\u003c/b\u003e %{model}. Lista completa.","multiple":"Sto mostrando %{model} \u003cb\u003e%{from}\u0026nbsp;-\u0026nbsp;%{to}\u003c/b\u003e di \u003cb\u003e%{total}\u003c/b\u003e in totale","multiple_without_total":"Sto mostrando %{model} \u003cb\u003e%{from}\u0026nbsp;-\u0026nbsp;%{to}\u003c/b\u003e","entry":{"one":"voce","other":"voci"}},"any":"Qualsiasi","blank_slate":{"content":"Non sono presenti %{resource_name}","link":"Crea nuovo/a"},"dropdown_actions":{"button_label":"Azioni"},"batch_actions":{"button_label":"Azioni multiple","default_confirmation":"Sei sicuro di che voler fare questo?","delete_confirmation":"Sei sicuro di volere cancellare %{plural_model}?","succesfully_destroyed":{"one":"Eliminato con successo 1 %{model}","other":"Eliminati con successo %{count} %{plural_model}"},"selection_toggle_explanation":"(Toggle Selection)","link":"Crea uno","action_label":"%{title} Selezionati","labels":{"destroy":"Elimina"}},"comments":{"created_at":"Creato il","resource_type":"Tipo di risorsa","author_type":"Tipo di Autore","body":"Corpo","author":"Autore","title":"Commento","add":"Aggiungi Commento","delete":"Cancella Commento","delete_confirmation":"Sei sicuro di voler cancellare questo commento?","resource":"Risorsa","no_comments_yet":"Nessun commento.","author_missing":"Anonimo","title_content":"Commenti (%{count})","errors":{"empty_text":"Il commento non può essere salvato, il testo è vuoto."}},"devise":{"username":{"title":"Nome Utente"},"email":{"title":"Email"},"subdomain":{"title":"Sottodominio"},"password":{"title":"Password"},"sign_up":{"title":"Iscriviti","submit":"Iscriviti"},"login":{"title":"Entra","remember_me":"Ricordami","submit":"Entra"},"reset_password":{"title":"Dimenticato la password?","submit":"Reimposta la tua password"},"change_password":{"title":"Cambia la tua password","submit":"Cambia la mia password"},"unlock":{"title":"Invia di nuovo le istruzioni per sbloccare","submit":"Invia di nuovo le istruzioni per sbloccare"},"resend_confirmation_instructions":{"title":"Invia di nuovo le istruzioni per la conferma","submit":"Invia di nuovo le istruzioni per la conferma"},"links":{"sign_in":"Entra","forgot_your_password":"Dimenticato la password?","sign_in_with_omniauth_provider":"Collegati a %{provider}","resend_unlock_instructions":"Invia di nuovo le istruzioni per lo sblocco","resend_confirmation_instructions":"Invia di nuovo le istruzioni per la conferma"}},"unsupported_browser":{"headline":"Perfavore, notare che ActiveAdmin non supporta più Internet Explorer 8 o inferiore","recommendation":"Ti raccomandiamo di aggiornare alla versione più recente di \u003ca href=\"http://windows.microsoft.com/ie\"\u003eInternet Explorer\u003c/a\u003e, \u003ca href=\"https://chrome.google.com/\"\u003eGoogle Chrome\u003c/a\u003e, o \u003ca href=\"https://mozilla.org/firefox/\"\u003eFirefox\u003c/a\u003e.","turn_off_compatibility_view":"Se stai utilizzando Internet Explorer 9 o successivo, assicurati di \u003ca href=\"http://windows.microsoft.com/en-US/windows7/webpages-look-incorrect-in-Internet-Explorer\"\u003edisabilitare la \"Modalità Compatibilità\"\u003c/a\u003e."},"access_denied":{"message":"Non hai le autorizzazioni necessarie per eseguire questa azione."},"index_list":{"table":"Tabella","block":"Lista","grid":"Griglia","blog":"Blog"}},"pageflow":{"public":{"_language":"Italiano","audio":"audio","back":"indietro","back_to_chapter":"ritorno al capitolo","before_after":{"drag_hint":null,"hint":"visuale prima/dopo","leave_view":"chiudere visuale prima/dopo e visualizzare il testo","start":"aprire la visuale prima/dopo","start_title":"aprire la visuale prima/dopo"},"chapter":"capitolo","chart":{"toggle":"ingrandire o ridurre la visuale"},"close":"chiudere","close_hint":"chiudere suggerimento","close_navigation":"terminare navigazione","close_overview":"chiudere panoramica","deprecated_browser":"Gentile utilizzatore, sta usando una versione vecchia del suo browser. Per questo motivo non può visualizzare correttamente i contenuti di questa pagina. Per favore aggiorni il browser con l’ultima versione disponibile.","embedded_video":{"leave_video":"abbandonare video inserito"},"enlarge_view":"ingrandire visuale","enter_fullscreen":"schermo intero","first_page":"prima pagina","forward":"avanti","fullscreen":"schermo intero","goto_first_page":"vai alla prima pagina","goto_top":"vai alla prima pagina","hide_text":"dissolvere testo","home":"inizio","imprint":" informazioni ","javascript_hint":"Per una corretta visualizzazione della pagina necessita di JavaScript.","languages":{"ar":null,"cs":null,"de":null,"dk":null,"el":null,"en":null,"es":null,"fr":null,"it":null,"nl":null,"pl":null,"pt":null,"ru":null,"sr":null,"tr":null,"unknown":null,"zh":null},"leave_fullscreen":"chiudere schermo intero","lets_go":"si parte","logo":"logo","media_quality":null,"mute_off":"volume on","mute_on":"volume off","navigate_top":"all’inizio","navigation":" navigazione","new_pages_box":{"additional_pages_html":"…e \u003cspan\u003e\u003c/span\u003e ulteriori","description":"Dall’ultima visita sono state inserite nuove pagine:","title":"nuove pagine"},"notice":"note","open_audio":null,"open_navigation":"aprire navigazione","open_overview":"aprire anteprima","open_video":null,"overview":"anteprima","panorama":{"close":"avvio visuale 360° e visualizzare testo","start":"avvio visuale 360°"},"play_video":"guardare video","scroll_back_indicator":"scorrere indietro","scroll_down":"scorrere in basso","scroll_hint":"Con la rotella del mouse o le frecce sulla tastiera verrà visualizzata la pagina successiva.","scroll_indicator":"scorrere per continuare a leggere","scroll_left":"scorrere a sinistra","scroll_right":"scorrere a destra","scroll_up":"scorrere in alto","share":"condividere","share_on_facebook":"condividere su Facebook","share_on_google":"condividere su Google+","share_on_twitter":"condividere su Twitter","share_this_entry":"condividere questo articolo ","share_this_page":"condividere questa pagina ","show_home":"alla pagina iniziale","show_text":"visualizzare testo","skip_links_content":"al contenuto","skip_links_navigation":"navigazione Goto","skip_links_top_navigation":"navigazione principale Goto","sound_hint":"Questo formato storia multimediale utilizza video e filmati audio. Si prega di assicurarsi che gli altoparlanti siano accesi.","start_audio":"avvio audio","start_video":"avvio video","swipe_hint":"scorrendo verrà visualizzata la pagina successiva","swipe_indicator":"strisciare a continuare","text_track_modes":{"auto":null,"auto_off":null,"none":null},"text_tracks":null,"video":"video","video_qualities":{"annotations":{"4k":null,"fullhd":null,"medium":null},"labels":{"4k":null,"auto":null,"fullhd":null,"medium":null}},"volume":"volume","vr":{"no_vr":{"link":null,"text":null},"select_quality":null,"start":null,"start_cardboard":null,"video_qualities":{"4k":null,"fullhd":null,"high":null},"video_quality_annotations":{"4k":null,"fullhd":null,"high":null}}}}},"pl":{"formtastic":{"update":"Aktualizuj %{model}","create":"Utwórz %{model}"},"active_admin":{"dashboard":"Pulpit","dashboard_welcome":{"welcome":"Witaj w Active Adminie. To jest domyślny pulpit.","call_to_action":"Aby dodać sekcje do pulpitu, sprawdź 'app/admin/dashboard.rb'"},"view":"Podgląd","edit":"Edytuj","delete":"Usuń","delete_confirmation":"Jesteś pewien, że chcesz to usunąć?","new_model":"Nowy %{model}","edit_model":"Edytuj %{model}","delete_model":"Usuń %{model}","details":"Detale %{model}","cancel":"Anuluj","empty":"Pusty","previous":"Poprzednia","next":"Następna","download":"Pobierz:","has_many_new":"Dodaj nowy %{model}","has_many_delete":"Usuń","has_many_remove":"Usuń","filters":{"buttons":{"filter":"Filtruj","clear":"Wyczyść Filtry"},"predicates":{"contains":"Zawiera","equals":"Równe","starts_with":"Zaczyna się","ends_with":"Kończy się","greater_than":"Większe niż","less_than":"Mniejsze niż"}},"status_tag":{"yes":"Tak","no":"Nie"},"main_content":"Zaimplementuj %{model}#main_content aby wyświetlić treść.","logout":"Wyloguj","powered_by":"Powered by %{active_admin} %{version}","sidebars":{"filters":"Filtry"},"pagination":{"empty":"Nie znaleziono %{model}","one":"Wyświetlanie \u003cb\u003e1\u003c/b\u003e %{model}","one_page":"Wyświetlanie \u003cb\u003ewszystkich %{n}\u003c/b\u003e %{model}","multiple":"Wyświetlanie %{model} \u003cb\u003e%{from}\u0026nbsp;-\u0026nbsp;%{to}\u003c/b\u003e z \u003cb\u003e%{total}\u003c/b\u003e","multiple_without_total":"Wyświetlanie %{model} \u003cb\u003e%{from}\u0026nbsp;-\u0026nbsp;%{to}\u003c/b\u003e"},"any":"Jakikolwiek","blank_slate":{"content":"Nie ma jeszcze zasobu %{resource_name}.","link":"Utwórz go"},"dropdown_actions":{"button_label":"Akcje"},"batch_actions":{"button_label":"Akcje na partiach","default_confirmation":"Czy na pewno chcesz to zrobić?","delete_confirmation":"Czy na pewno chcesz usunąć te %{plural_model}?","succesfully_destroyed":{"one":"Poprawnie usunięto 1 %{model}","other":"Poprawnie usunięto %{count} %{plural_model}","many":"Poprawnie usunięto %{count} %{plural_model}","few":"Poprawnie usunięto %{count} %{plural_model}"},"selection_toggle_explanation":"(Przełącz zaznaczenie)","link":"Utwórz jeden","action_label":"%{title} zaznaczone","labels":{"destroy":"Usuń"}},"comments":{"body":"Treść","author":"Autor","title":"Komentarz","add":"Dodaj komentarz","resource":"Zasób","no_comments_yet":"Nie ma jeszcze komentarzy.","title_content":"Komentarze (%{count})","errors":{"empty_text":"Komentarz nie został zapisany, zawartość była pusta."}},"devise":{"sign_up":{"title":"Rejestracja","submit":"Zarejestruj się"},"login":{"title":"Logowanie","remember_me":"Zapamiętaj mnie","submit":"Zaloguj się"},"reset_password":{"title":"Nie pamiętasz hasła?","submit":"Zresetować hasło"},"change_password":{"title":"Zmień hasło","submit":"Zmień hasło"},"resend_confirmation_instructions":{"title":"Wyślij ponownie instrukcje aktywacji","submit":"Wyślij ponownie instrukcje aktywacji"},"links":{"sign_in":"Zaloguj się","forgot_your_password":"Nie pamiętasz hasła?","sign_in_with_omniauth_provider":"Zaloguj się z %{provider}"}}}},"pt":{"formtastic":{"yes":"Sim","no":"Não","create":"Criar %{model}","update":"Atualizar %{model}","submit":"Salvar %{model}","cancel":"Cancelar %{model}","reset":"Resetar %{model}","required":"obrigatório"}},"tr":{"formtastic":{"yes":"Evet","no":"Hayır","create":"%{model} oluştur","update":"%{model} güncelle","submit":"Gönder","cancel":"İptal","reset":"%{model} sıfırla","required":"Zorunlu"},"active_admin":{"dashboard":"Gösterge Paneli","dashboard_welcome":{"welcome":"Active Admin'e hoş geldiniz. Burası varsayılan gösterge paneli sayfasıdır.","call_to_action":"Buraya bölümler eklemek için 'app/admin/dashboard.rb' dosyasına bakabilirsiniz."},"view":"Görüntüle","edit":"Düzenle","delete":"Sil","delete_confirmation":"Bu kaydı silmek istediğinizden emin misiniz?","new_model":"Yeni %{model}","edit_model":"%{model} Kaydını Düzenle","delete_model":"%{model} Kaydını Sil","details":"%{model} Ayrıntıları","cancel":"İptal","empty":"Boş","previous":"Önceki","next":"Sonraki","download":"İndir:","has_many_new":"Yeni %{model} Ekle","has_many_delete":"Sil","has_many_remove":"Çıkar","filters":{"buttons":{"filter":"Filtrele","clear":"Filtreleri Temizle"},"predicates":{"contains":"İçerir","equals":"Eşittir","starts_with":"İle başlar","ends_with":"İle biter","greater_than":"Büyüktür","less_than":"Küçüktür"}},"search_status":{"headline":"Arama","current_scope":"Kapsam:","current_filters":"Seçili filtreler:","no_current_filters":"Yok"},"status_tag":{"yes":"Evet","no":"Hayır"},"main_content":"İçeriği görüntülemek için lütfen %{model}#main_content metodunu ekleyin.","logout":"Çıkış Yap","powered_by":"%{active_admin} %{version} tarafından desteklenmektedir.","sidebars":{"filters":"Filtreler","search_status":"Arama Durumu"},"pagination":{"empty":"Hiç %{model} yok","one":"\u003cb\u003e1\u003c/b\u003e %{model} görüntüleniyor","one_page":"\u003cb\u003e%{n}\u003c/b\u003e %{model} kaydının tamamı görüntüleniyor","multiple":"\u003cb\u003e%{from}\u0026nbsp;-\u0026nbsp;%{to}\u003c/b\u003e arası %{model} görüntüleniyor (toplam %{total} kayıt)","multiple_without_total":"\u003cb\u003e%{from}\u0026nbsp;-\u0026nbsp;%{to}\u003c/b\u003e arası %{model} görüntüleniyor","entry":{"one":"kayıt","other":"kayıtlar"}},"any":"Herhangi biri","blank_slate":{"content":"Henüz %{resource_name} yok.","link":"Bir tane oluşturun"},"dropdown_actions":{"button_label":"İşlemler"},"batch_actions":{"button_label":"Toplu İşlemler","default_confirmation":"Bunu yapmak istediğinizden emin misiniz?","delete_confirmation":"Bu %{plural_model} kayıtlarını silmek istediğinizden emin misiniz?","succesfully_destroyed":{"one":"1 %{model} başarıyla silindi","other":"Toplam %{count} %{plural_model} başarıyla silindi"},"selection_toggle_explanation":"(Seçimi Değiştir)","link":"Yeni oluştur","action_label":"Seçilenleri %{title}","labels":{"destroy":"Sil"}},"comments":{"created_at":"Oluşturma Tarihi","resource_type":"Kayıt Tipi","author_type":"Yazar Tipi","body":"Ayrıntı","author":"Yazar","title":"Yorum","add":"Yorum Ekle","delete":"Yorumu Sil","delete_confirmation":"Bu yorumları silmek istediğinizden emin misiniz?","resource":"Kayıt","no_comments_yet":"Henüz yorum yok.","author_missing":"Anonim","title_content":"Yorumlar (%{count})","errors":{"empty_text":"Yorum boş olarak kaydedilemez."}},"devise":{"username":{"title":"Kullanıcı adı"},"email":{"title":"E-posta adresi"},"subdomain":{"title":"Alt alan adı"},"password":{"title":"Şifre"},"sign_up":{"title":"Kaydol","submit":"Kaydol"},"login":{"title":"Giriş yap","remember_me":"Beni hatırla","submit":"Giriş yap"},"reset_password":{"title":"Şifrenizi mi unuttunuz?","submit":"Şifremi sıfırla"},"change_password":{"title":"Şifrenizi değiştirin","submit":"Şifremi değiştir"},"unlock":{"title":"Hesap geri açma talimatlarını tekrar gönder","submit":"Hesap geri açma talimatlarını tekrar gönder"},"resend_confirmation_instructions":{"title":"Onaylama talimatlarını tekrar gönder","submit":"Onaylama talimatlarını tekrar gönder"},"links":{"sign_up":"Kaydol","sign_in":"Giriş yap","forgot_your_password":"Şifrenizi mi unuttunuz?","sign_in_with_omniauth_provider":"%{provider} ile giriş yapın","resend_unlock_instructions":"Hesap geri açma talimatlarını tekrar gönder","resend_confirmation_instructions":"Onaylama talimatlarını tekrar gönder"}},"unsupported_browser":{"headline":"ActiveAdmin Internet Explorer 8 ve altı artık desteklememektedir.","recommendation":"Son sürüm \u003ca href=\"http://windows.microsoft.com/ie\"\u003eInternet Explorer\u003c/a\u003e, \u003ca href=\"https://chrome.google.com/\"\u003eGoogle Chrome\u003c/a\u003e, ya da \u003ca href=\"https://mozilla.org/firefox/\"\u003eFirefox\u003c/a\u003e tarayıcılarından birine geçmenizi tavsiye ederiz.","turn_off_compatibility_view":"IE 9 ya da üstünü kullanıyorsanız, \u003ca href=\"http://windows.microsoft.com/tr-tr/internet-explorer/use-compatibility-view\"\u003e\"Uyumluluk Görünümü\"\u003c/a\u003enü kapatmayı unutmayın."},"access_denied":{"message":"Bu işlemi gerçekleştirmek için yetkiniz yok."},"index_list":{"table":"Tablo","block":"Liste","grid":"Izgara","blog":"Blog"}},"pageflow":{"public":{"_language":"Türkçe","audio":"Ses","back":"Geri","back_to_chapter":"Arka bölüme","before_after":{"drag_hint":null,"hint":"Geri/İleri","leave_view":"Geri/İleri ve metin açılması","start":"Geri/İleri görünümü başlat","start_title":"Geri/İleri görünümü başlat"},"chapter":"Bölüm","chart":{"toggle":"Görünümü yakınlaştır/uzaklaştır"},"close":"Kapat","close_hint":"Ipucunu kapat","close_navigation":"Gezinimi kapat","close_overview":"Görünümü kapat","deprecated_browser":"\u003cp\u003eInternet tarayıcınız malesef gündem dışı. Bundan dolayı sayfanın içerigi düzgün şekilde görüntülenemiyor.  Lütfen tarayıcınızı güncelleyin.\u003c/p\u003e","embedded_video":{"leave_video":"Gömülü videodan ayrıl"},"enlarge_view":"Görünümü büyüt","enter_fullscreen":"Tam ekran","first_page":"İlk sayfa","forward":"İleri","fullscreen":"Tam ekran","goto_first_page":"İlk sayfaya git","goto_top":"İlk sayfaya git","hide_text":"Metni sakla","home":"Başlat","imprint":"Künye","javascript_hint":"Bu uygulama geliştirilmiş fonksiyonellik ve kullanıcı deneyimi için JavaScript kullanmakta. Internet tarayıcınız Javascript desteklemiyor veya devre dışı.","languages":{"ar":null,"cs":null,"de":null,"dk":null,"el":null,"en":null,"es":null,"fr":null,"it":null,"nl":null,"pl":null,"pt":null,"ru":null,"sr":null,"tr":null,"unknown":null,"zh":null},"leave_fullscreen":"Tam ekrandan çık","lets_go":"Hadi başlayalım","logo":"Logo","media_quality":null,"mute_off":"Sesi aç","mute_on":"Sesi kapat","navigate_top":"İlk sayfaya git","navigation":"Navigasyon","new_pages_box":{"additional_pages_html":"...ve \u003cspan\u003e\u003c/span\u003e daha","description":"Son ziyaretinizden bu yana Pageflow'a eklenenler:","title":"Yeni sayfalar"},"notice":"Bildirim","open_audio":null,"open_navigation":"Navigasyonu aç","open_overview":"Görünümü aç","open_video":null,"overview":"Görünüm","panorama":{"close":"360 derece görünümü kapat ve metni göster","start":"360 derece görünümü başlat"},"play_video":"Videoyu başlat","scroll_back_indicator":null,"scroll_down":"Aşağı kaydır","scroll_hint":"Sayfalar arası navigasyon icin klavyedeki ok tuşlarını veya fare tekerleğini kullanın.","scroll_indicator":"Aşağı kaydırmaya devam et","scroll_left":"Sola kaydır","scroll_right":"Sağa kaydır","scroll_up":"Yukarı kaydır","share":"Paylaş","share_on_facebook":"Facebookta paylaş","share_on_google":"Google+ da paylaş","share_on_twitter":"Twitter da paylaş","share_this_entry":"Bu hikaye","share_this_page":"Bu sayfa","show_home":"Başlangıç","show_text":"Metni göster","skip_links_content":"İçeriğe git","skip_links_navigation":"Navigasyona git","skip_links_top_navigation":"Ana navigasyona git","sound_hint":"Bu çoklu ortamlı hikaye formatı ses ve video görüntüsü kullanmakta. Lütfen kolonlarınızın çalışır vaziyette olduguna dair emin olun.","start_audio":"Start audio now","start_video":"Start video now","swipe_hint":"Sayfalar arası navigasyon için swipe ediniz","swipe_indicator":"Devami icin swipe ediniz","text_track_modes":{"auto":null,"auto_off":null,"none":null},"text_tracks":null,"video":"Video","video_qualities":{"annotations":{"4k":null,"fullhd":null,"medium":null},"labels":{"4k":null,"auto":null,"fullhd":null,"medium":null}},"volume":"Ses düzeyi","vr":{"no_vr":{"link":null,"text":null},"select_quality":null,"start":null,"start_cardboard":null,"video_qualities":{"4k":null,"fullhd":null,"high":null},"video_quality_annotations":{"4k":null,"fullhd":null,"high":null}}}}},"ar":{"active_admin":{"dashboard":"لوحة تحكم","dashboard_welcome":{"welcome":"مرحبًا بك في في صفحة الإدارة، وهذه هي الصفحة الإفتراضيّة.","call_to_action":"لإضافة أقسام إلى  لوحة التحكم, راجع: 'app/admin/dashboard.rb'"},"view":"عرض","edit":"تعديل","delete":"حذف","delete_confirmation":"هل تريد تأكيد الحذف؟","new_model":"جديد %{model}","edit_model":"تعديل %{model}","delete_model":"حذف %{model}","details":"تفاصيل %{model}","cancel":"إلغاء","empty":"فارغ","previous":"السابق","next":"التالي","download":"تحميل","has_many_new":"إضافة %{model} جديد","has_many_delete":"حذف","has_many_remove":"إزالة","filters":{"buttons":{"filter":"تصفية","clear":"تفريغ التصفية"},"predicates":{"contains":"يحتوي","equals":"متساوي","starts_with":"يبدأ بـ","ends_with":"ينتهي بـ","greater_than":"أكبر من","less_than":"أقل من"}},"search_status":{"headline":"حالات البحث:","current_scope":"المجال:","current_filters":"المُرشحات الحاليّة:","no_current_filters":"بدون"},"status_tag":{"yes":"نعم","no":"لا"},"main_content":"الرجاء تنفيذ %{model}#main_content لعرض المحتوى.","logout":"تسجيل الخروج","powered_by":"تنفيذ %{active_admin} %{version}","sidebars":{"filters":"المُرشحات","search_status":"حالات البحث"},"pagination":{"empty":"لا يوجد %{model} ","one":"عرض \u003cb\u003e1\u003c/b\u003e %{model}","one_page":"عرض \u003cb\u003eall %{n}\u003c/b\u003e %{model}","multiple":"عرض %{model} \u003cb\u003e%{from}\u0026nbsp;-\u0026nbsp;%{to}\u003c/b\u003e من \u003cb\u003e%{total}\u003c/b\u003e بالمجمل","multiple_without_total":"عرض %{model} \u003cb\u003e%{from}\u0026nbsp;-\u0026nbsp;%{to}\u003c/b\u003e","entry":{"one":"مدخل","other":"مدخلات"}},"any":"أي","blank_slate":{"content":"لايوجد %{resource_name} بعد.","link":"إنشاء"},"dropdown_actions":{"button_label":"إجراءات"},"batch_actions":{"button_label":"إجراءات متعددة","default_confirmation":"هل أنت متأكّد؟","delete_confirmation":"هل أنت متأكّد من حذف هذه %{plural_model}؟","succesfully_destroyed":{"one":"حُذف بنجاح 1 %{model}","other":"حُذف بنجاح %{count} %{plural_model}"},"selection_toggle_explanation":"(تتبيث الخيار)","link":"إنشاء","action_label":"اُختير %{title}","labels":{"destroy":"حذف"}},"comments":{"resource_type":"نوع المصدر","author_type":"نوع الؤلّف","body":"هيكل","author":"مؤلّف","title":"تعليق","add":"إضافة تعليق","resource":"مصدر","no_comments_yet":"لا يوجد تعليقات بعد.","author_missing":"مجهول","title_content":"تعليقات (%{count})","errors":{"empty_text":"لم يُحفظ التعليق، النص فارغ."},"created_at":"أُنشئ","delete":"حذف تعليق","delete_confirmation":"هل أنت متأكّد من حذف هذه التعليقات؟"},"devise":{"username":{"title":"اسم المستخدم"},"email":{"title":"البريد الإلكترونيّ"},"subdomain":{"title":"مجال فرعي"},"password":{"title":"كلمة المرور"},"sign_up":{"title":"تسجيل الدخول","submit":"تسجيل الدخول"},"login":{"title":"دخول","remember_me":"تذكرني","submit":"تسحيل"},"reset_password":{"title":"هل نسيت كلمة المرور؟","submit":"استرجاع كلمة المرور"},"change_password":{"title":"تغير كلمة المرور خاصتك","submit":"تغير كلمة المرور خاصتي"},"unlock":{"title":"إعادة إرسال تعليمات فك الحظر","submit":"إعادة إرسال تعليمات فك الحظر"},"resend_confirmation_instructions":{"title":"إعادة ارسال تعليمات التأكيد","submit":"إعادة ارسال تعليمات التأكيد"},"links":{"sign_up":"التسجيل","sign_in":"دخول","forgot_your_password":"هل نسيت كلمة المرور؟","sign_in_with_omniauth_provider":"تسجيل الدخول بـ %{provider}","resend_unlock_instructions":"إعادة إرسال تعليمات تنشيط الحساب","resend_confirmation_instructions":"إعادة إرسال تعليمات تأكيد الحساب"}},"unsupported_browser":{"headline":"يُرجى مُلاحظة أن (أكتف أدمن) لم تعد تدعم المُتصفّح إنترنت اكسبلوررالإصدار الثامن وما قبله","recommendation":"ننصح بالتحديث إلى الإصدارات الأخيرة من: \u003ca href=\"http://windows.microsoft.com/ie\"\u003eInternet Explorer\u003c/a\u003e, \u003ca href=\"https://chrome.google.com/\"\u003eGoogle Chrome\u003c/a\u003e, أو \u003ca href=\"https://mozilla.org/firefox/\"\u003eFirefox\u003c/a\u003e.","turn_off_compatibility_view":"إن كنت تستخدم الإصدار التاسع وما يليه من إنترنت إكسبلورر تأكّد من \u003ca href=\"http://windows.microsoft.com/en-US/windows7/webpages-look-incorrect-in-Internet-Explorer\"\u003eتعطيل \"Compatibility View\"\u003c/a\u003e."},"access_denied":{"message":"لم يُصرّح لك بهذا الإجراء."},"index_list":{"table":"جدول","block":"قائمة","grid":"شبكة","blog":"مدونة"}}},"bg":{"active_admin":{"dashboard":"Табло","dashboard_welcome":{"welcome":"Добре дошли в Active Admin. Това е таблото по подразбиране.","call_to_action":"За да добавите секции, редактирайте 'app/admin/dashboard.rb'"},"view":"Преглед","edit":"Редакция","delete":"Изтриване","delete_confirmation":"Сигурни ли сте, че искате да изтриете това?","new_model":"Създаване на %{model}","edit_model":"Редакция на %{model}","delete_model":"Изтриване на %{model}","details":"%{model} детайли","cancel":"Отказ","empty":"Празно","previous":"Предишно","next":"Следващо","download":"Изтегляне:","has_many_new":"Добавяне на %{model}","has_many_delete":"Изтриване","has_many_remove":"Премахване","filters":{"buttons":{"filter":"Филтриране","clear":"Изчистване"},"predicates":{"contains":"съдържа","equals":"равно на","starts_with":"Започва с","ends_with":"Завършва с","greater_than":"по-голямо от","less_than":"по-малко от"}},"status_tag":{"yes":"Да","no":"не"},"main_content":"Добавете %{model}#main_content за да видите съдържание.","logout":"Изход","powered_by":"Задвижва се от %{active_admin} %{version}","sidebars":{"filters":"Филтри"},"pagination":{"empty":"Не са намерени %{model}","one":"Показване на \u003cb\u003e1\u003c/b\u003e %{model}","one_page":"Показване на \u003cb\u003eвсички %{n}\u003c/b\u003e %{model}","multiple":"Показване %{model} \u003cb\u003e%{from}\u0026nbsp;-\u0026nbsp;%{to}\u003c/b\u003e от общо \u003cb\u003e%{total}\u003c/b\u003e","multiple_without_total":"Показване %{model} \u003cb\u003e%{from}\u0026nbsp;-\u0026nbsp;%{to}\u003c/b\u003e","entry":{"one":"запис","other":"записи"}},"any":"Без значение","blank_slate":{"content":"Все още няма добавени %{resource_name}.","link":"Създаване"},"dropdown_actions":{"button_label":"действия"},"batch_actions":{"button_label":"Масови действия","default_confirmation":"Наистина ли искате да направите това?","delete_confirmation":"Сигурни ли сте, че искате да изтриете тези %{plural_model}?","succesfully_destroyed":{"one":"Успешно изтриване на 1 %{model}","other":"Успешно изтриване на %{count} %{plural_model}"},"selection_toggle_explanation":"(Инвертиране на маркирането)","link":"Създаване","action_label":"%{title} избран","labels":{"destroy":"Изтриване"}},"comments":{"resource_type":"Тип ресурс","author_type":"Тип автор","body":"Текст","author":"Автор","title":"Коментар","add":"Добавяне на коментар","resource":"Ресурс","no_comments_yet":"Все още няма коментари.","author_missing":"Анонимен","title_content":"Коментари (%{count})","errors":{"empty_text":"Коментарът с празен текст не беше запазен."}},"devise":{"username":{"title":"Потребителско име"},"email":{"title":"Поща"},"subdomain":{"title":"Поддомейн"},"password":{"title":"Парола"},"sign_up":{"title":"Регистрация","submit":"Регистрация"},"login":{"title":"Вход","remember_me":"Запомни ме","submit":"Вход"},"reset_password":{"title":"Забравена парола?","submit":"Изпращане на нова парола"},"change_password":{"title":"Промяна на паролата","submit":"Промяна на паролата"},"unlock":{"title":"Изпрати отново инструкциите за отключване","submit":"Изпрати отново инструкциите за отключване"},"resend_confirmation_instructions":{"title":"Изпрати отново инструкциите за потвърждаване","submit":"Изпрати отново инструкциите за потвърждаване"},"links":{"sign_in":"Вход","forgot_your_password":"Забравена парола?","sign_in_with_omniauth_provider":"Влез с %{provider}"}},"access_denied":{"message":"Нямате права да извършите това действие."},"index_list":{"table":"Таблица","block":"Списък","grid":"Грид","blog":"Блог"}},"pageflow":{"public":{"_language":"Български","audio":"Аудио","back":"Назад","back_to_chapter":"Назад към раздел","before_after":{"drag_hint":null,"hint":"Изглед преди/след","leave_view":"Излез от изглед преди/след","start":"Стартирай изглед преди/след","start_title":"Стартирай изглед преди/след"},"chapter":"Раздел","chart":{"toggle":"Включване/Изключване"},"close":"Затвори","close_hint":"Затвори предложението","close_navigation":"Затвори навигацията","close_overview":"Затвори прегледа","deprecated_browser":"\u003cp\u003eВашият браузър не е обновен и тази страница може да не работи нормално. Препоръчваме обновяване на браузъра до най-новата версия.\u003cp\u003e","embedded_video":{"leave_video":"Излез от вграденото видео"},"enlarge_view":"Увеличи изгледа","enter_fullscreen":"Влез в режим на цял екран","first_page":"Първа страница","forward":"Напред","fullscreen":"Цял екран","goto_first_page":"Отиди на първа страница","goto_top":"Отиди на първа страница","hide_text":"Скрий текста","home":"Старт","imprint":"Отпечатай","javascript_hint":"Това приложение ползва JavaScript за по-добра функционалност и потребителско преживяване. JavaScript може да не се поддържа от Вашия браузър или да е деактивиран.","languages":{"ar":null,"cs":null,"de":null,"dk":null,"el":null,"en":null,"es":null,"fr":null,"it":null,"nl":null,"pl":null,"pt":null,"ru":null,"sr":null,"tr":null,"unknown":null,"zh":null},"leave_fullscreen":"Излез от режим на цял екран","lets_go":"Да тръгваме","logo":"Лого","media_quality":null,"mute_off":"Включване на звука","mute_on":"Спиране на звука","navigate_top":"Отиди на първа страница","navigation":"Навигация","new_pages_box":{"additional_pages_html":"...и \u003cspan\u003e\u003c/span\u003e повече","description":"След Вашето последно посещение бяха добавени страници към този поток:","title":"Нови Страници"},"notice":"Известие","open_audio":null,"open_navigation":"Отвори навигацията","open_overview":"Отвори прегледа","open_video":null,"overview":"Преглед","panorama":{"close":"Затвори 360° панорама и покажи текста","start":"Стартирай 360° панорама"},"play_video":"Пусни видеото","scroll_back_indicator":"Кликни тук за да въведеш текст/превод","scroll_down":"Превърти надолу","scroll_hint":"Използвайте колелцето на мишката или стрелките на вашата клавиатура за навигация през страниците.","scroll_indicator":"Превърти надолу за да продължиш","scroll_left":"Превърти наляво","scroll_right":"Превърти надясно","scroll_up":"Превърти нагоре","share":"Сподели","share_on_facebook":"Сподели във Facebook","share_on_google":"Сподели в Google+","share_on_twitter":"Сподели в Twitter","share_this_entry":"Тази история","share_this_page":"Тази страница","show_home":"Старт","show_text":"Покажи текста","skip_links_content":"Отиди в съдържанието","skip_links_navigation":"Към навигацията","skip_links_top_navigation":"Към главната навигация","sound_hint":"Този разказвателен мултимедиен формат ползва видео и аудио съдържание. Моля, уверете се, че говорителите са включени.","start_audio":"Пусни звука сега","start_video":"Пусни видеото сега","swipe_hint":"Плъзни за навигация през страниците.","swipe_indicator":"Плъзни за да продължиш","text_track_modes":{"auto":null,"auto_off":null,"none":null},"text_tracks":null,"video":"Видео","video_qualities":{"annotations":{"4k":null,"fullhd":null,"medium":null},"labels":{"4k":null,"auto":null,"fullhd":null,"medium":null}},"volume":"Сила на звука","vr":{"no_vr":{"link":null,"text":null},"select_quality":null,"start":null,"start_cardboard":null,"video_qualities":{"4k":null,"fullhd":null,"high":null},"video_quality_annotations":{"4k":null,"fullhd":null,"high":null}}}}},"bs":{"active_admin":{"dashboard":"Upravljačka ploča","dashboard_welcome":{"welcome":"Dobrodošli u Active Admin. Ovo je početna upravljačka ploča.","call_to_action":"Da biste dodali nove odjeljke na upravljačku ploču, pogledajte 'app/admin/dashboard.rb'"},"view":"Pregledaj","edit":"Uredi","delete":"Obriši","delete_confirmation":"Jeste li sigurni da želite ovo obrisati?","new_model":"Novi %{model}","edit_model":"Uredi %{model}","delete_model":"Obriši %{model}","details":"%{model} detalji","cancel":"Odustani","empty":"Prazno","previous":"Prethodni","next":"Sljedeći","download":"Spremi na računalo:","has_many_new":"Dodaj novi %{model}","has_many_delete":"Obriši","has_many_remove":"Ukloniti","filters":{"buttons":{"filter":"Filtriraj","clear":"Ukloni filtere"},"predicates":{"contains":"Sadrži","equals":"Jednako","starts_with":"počinje s","ends_with":"Završava sa","greater_than":"Veće od","less_than":"Manje od"}},"status_tag":{"yes":"Da","no":"Nema"},"main_content":"Molim Vas, implementirajte %{model}#main_content da biste prikazali sadržaj.","logout":"Odjavi se","powered_by":"Powered by %{active_admin} %{version}","sidebars":{"filters":"Filtriranje"},"pagination":{"empty":"Nije pronađen niti jedan %{model}.","one":"Prikazan \u003cb\u003e1\u003c/b\u003e %{model}","one_page":"Prikazano \u003cb\u003esvih %{n}\u003c/b\u003e %{model}","multiple":"Prikazani %{model} \u003cb\u003e%{from}\u0026nbsp;-\u0026nbsp;%{to}\u003c/b\u003e od ukupno \u003cb\u003e%{total}\u003c/b\u003e","multiple_without_total":"Prikazani %{model} \u003cb\u003e%{from}\u0026nbsp;-\u0026nbsp;%{to}\u003c/b\u003e","entry":{"one":"zapis","few":"zapisa","many":"zapisa","other":"zapisa"}},"any":"Bilo koji","blank_slate":{"content":"Još uvijek ne postoji niti jedan zapis tipa %{resource_name}.","link":"Izradi jedan"},"batch_actions":{"button_label":"Grupne akcije","default_confirmation":"Jeste li sigurni da želite to učiniti?","delete_confirmation":"Jeste li sigurni da želite obrisati %{plural_model}?","succesfully_destroyed":{"one":"Uspješno je obrisan 1 %{model}","few":"Uspješno su obrisana %{count} %{plural_model}","many":"Uspješno je obrisano %{count} %{plural_model}","other":"Uspješno je obrisano %{count} %{plural_model}"},"selection_toggle_explanation":"(Izmijeni odabir)","link":"Izradi jedan","action_label":"%{title} označene","labels":{"destroy":"Obriši"}},"comments":{"resource_type":"Tip objekta","author_type":"Tip autora","body":"Sadržaj","author":"Autor","title":"Komentar","add":"Dodaj komentar","resource":"Objekt","no_comments_yet":"Još nema komentara.","author_missing":"Anoniman","title_content":"Komentari (%{count})","errors":{"empty_text":"Komentar nije spremljen, sadržaj je prazan."}},"devise":{"username":{"title":"Korisničko ime"},"email":{"title":"Email"},"subdomain":{"title":"Poddomena"},"password":{"title":"Lozinka"},"sign_up":{"title":"Registracija","submit":"Registruj"},"login":{"title":"Prijava","remember_me":"Zapamti me","submit":"Prijavi se"},"reset_password":{"title":"Zaboravljena lozinka?","submit":"Resetuj lozinku"},"change_password":{"title":"Izmjena lozinke","submit":"Izmijeni lozinku"},"unlock":{"title":"Ponovno slanje uputstva za otključavanje","submit":"Pošalji"},"resend_confirmation_instructions":{"title":"Ponovno slanje uputstva za potvrdu","submit":"Pošalji"},"links":{"sign_in":"Prijavi se","forgot_your_password":"Zaboravljena lozinka?","sign_in_with_omniauth_provider":"Prijavite se za %{provider}"}},"access_denied":{"message":"Nemaš dopuštenja."},"index_list":{"table":"Tabela","block":"Lista","grid":"Rešetka","blog":"Blog"}}},"de-CH":{"active_admin":{"dashboard":"Übersicht","dashboard_welcome":{"welcome":"Willkommen in Active Admin. Dies ist die Standard-Übersichtsseite.","call_to_action":"Siehe 'app/admin/dashboards.rb', um Übersichts-Bereiche hinzuzufügen."},"view":"Anzeigen","edit":"Bearbeiten","delete":"Löschen","delete_confirmation":"Wollen Sie dieses Element wirklich löschen?","new_model":"%{model} erstellen","edit_model":"%{model} bearbeiten","delete_model":"%{model} löschen","details":"%{model} Details","cancel":"Abbrechen","empty":"Leer","previous":"Zurück","next":"Weiter","download":"Herunterladen:","has_many_new":"%{model} hinzufügen","has_many_delete":"Löschen","has_many_remove":"Entfernen","filters":{"buttons":{"filter":"Filtern","clear":"Filter entfernen"},"predicates":{"contains":"Enthält","equals":"Gleich","starts_with":"Beginnt mit","ends_with":"Endet mit","greater_than":"Grösser als","less_than":"Kleiner als"}},"status_tag":{"yes":"Ja","no":"Nicht"},"main_content":"Bitte implementieren Sie %{model}#main_content, um Inhalte anzuzeigen.","logout":"Abmelden","powered_by":"Powered by %{active_admin} %{version}","sidebars":{"filters":"Filter"},"pagination":{"empty":"Keine %{model} gefunden","one":"Zeige \u003cb\u003e1\u003c/b\u003e %{model}","one_page":"Zeige \u003cb\u003ealle %{n}\u003c/b\u003e %{model}","multiple":"Zeige %{model} \u003cb\u003e%{from}\u0026nbsp;–\u0026nbsp;%{to}\u003c/b\u003e von \u003cb\u003e%{total}\u003c/b\u003e","multiple_without_total":"Zeige %{model} \u003cb\u003e%{from}\u0026nbsp;–\u0026nbsp;%{to}\u003c/b\u003e","entry":{"one":"Eintrag","other":"Einträge"}},"any":"Alle","blank_slate":{"content":"Es gibt noch keine %{resource_name}.","link":"Erstellen"},"dropdown_actions":{"button_label":"Aktionen"},"batch_actions":{"button_label":"Stapelverarbeitung","default_confirmation":"Bist du sicher, dass Sie dies tun wollen?","delete_confirmation":"Sind Sie sicher dass sie diese %{plural_model} löschen wollen?","succesfully_destroyed":{"one":"Erfolgreich 1 %{model} gelöscht","other":"Erfolgreich %{count} %{plural_model} gelöscht"},"selection_toggle_explanation":"(Auswahl umschalten)","link":"erstellen","action_label":"%{title} ausgewählte","labels":{"destroy":"Lösche"}},"comments":{"body":"Inhalt","author":"Autor","title":"Kommentar","resource":"Resource","add":"Kommentar hinzufügen","delete":"Löschen","delete_confirmation":"Sind Sie sicher dass sie diesen Kommentar löschen wollen?","no_comments_yet":"Es gibt noch keine Kommentare.","title_content":"Kommentare (%{count})","errors":{"empty_text":"Der Kommentar wurde nicht gespeichert, da der Text fehlt."}},"devise":{"login":{"title":"Login","remember_me":"erinnere dich an mich","submit":"Login"},"reset_password":{"title":"Passwort vergessen?","submit":"Mein Passwort zurücksetzen"},"change_password":{"title":"Ändern Sie Ihr Passwort","submit":"Mein Passwort ändern"},"links":{"sign_up":"Registrieren","sign_in":"Anmeldung","forgot_your_password":"Passwort vergessen?","sign_in_with_omniauth_provider":"Anmeldung mit %{provider}","resend_unlock_instructions":"Entsperrungsanweisung erneut senden","resend_confirmation_instructions":"Bestätigungsanweisung erneut senden"}},"unsupported_browser":{"headline":"ActiveAdmin unterstützt nicht länger den Internet Explorer in Version 8 oder niedriger.","recommendation":"Wir empfehlen die Nutzung von \u003ca href=\"http://windows.microsoft.com/ie\"\u003eInternet Explorer\u003c/a\u003e, \u003ca href=\"https://chrome.google.com/\"\u003eGoogle Chrome\u003c/a\u003e, oder \u003ca href=\"https://mozilla.org/firefox/\"\u003eFirefox\u003c/a\u003e.","turn_off_compatibility_view":"Wenn sie IE 9 oder neuer benutzen, stellen sie sicher das sie den \u003ca href=\"http://windows.microsoft.com/en-US/windows7/webpages-look-incorrect-in-Internet-Explorer\"\u003e\"Kompatibilitätsansicht\" ausgeschaltet\u003c/a\u003e haben."}}},"el":{"active_admin":{"dashboard":"Σελίδα διαχείρισης","dashboard_welcome":{"welcome":"Καλωσορίσατε στο Active Admin. Αυτή είναι η αρχική σελίδα διαχείρισης.","call_to_action":"Για να προσθέσετε ενότητες, ανατρέξτε στο αρχείο 'app/admin/dashboard.rb'"},"view":"Προβολή","edit":"Επεξεργασία","delete":"Διαγραφή","delete_confirmation":"Είστε σίγουρος πως θέλετε να το διαγράψετε;","new_model":"Δημιουργία %{model}","edit_model":"Επεξεργασία %{model}","delete_model":"Διαγραφή %{model}","details":"Λεπτομέρειες %{model}","cancel":"Ακύρωση","empty":"Άδειο","previous":"Προηγούμενη","next":"Επόμενη","download":"Κατέβασμα:","has_many_new":"Προσθήκη Νέου %{model}","has_many_delete":"Διαγραφή","has_many_remove":"Αφαίρεση","filters":{"buttons":{"filter":"Φίλτρα","clear":"Καθαρισμός Φίλτρων"},"predicates":{"contains":"Περιέχει","equals":"Είναι ίσο με","starts_with":"Αρχίζει με","ends_with":"Καταλήγει σε","greater_than":"Μεγαλύτερο από","less_than":"Μικρότερο από"}},"status_tag":{"yes":"Ναι","no":"Δεν"},"main_content":"Παρακαλώ υλοποιήστε την %{model}#main_content για να εμφανίσετε περιεχόμενο.","logout":"Αποσύνδεση","powered_by":"Powered by %{active_admin} %{version}","sidebars":{"filters":"Φίλτρα"},"pagination":{"empty":"Δε βρέθηκαν %{model}","one":"Εμφάνιζεται \u003cb\u003e1\u003c/b\u003e %{model}","one_page":"Εμφανίζονται \u003cb\u003eόλες οι %{n}\u003c/b\u003e εγγραφές %{model}","multiple":"Εμφανίζονται %{model} \u003cb\u003e%{from}\u0026nbsp;-\u0026nbsp;%{to}\u003c/b\u003e από \u003cb\u003e%{total}\u003c/b\u003e συνολικά","multiple_without_total":"Εμφανίζονται %{model} \u003cb\u003e%{from}\u0026nbsp;-\u0026nbsp;%{to}\u003c/b\u003e","entry":{"one":"εγγραφή","other":"εγγραφές"}},"any":"Όλες οι εγγραφές","blank_slate":{"content":"Δεν υπάρχουν %{resource_name} ακόμα.","link":"Δημιουργήστε μία εγγραφή"},"dropdown_actions":{"button_label":"Ενέργειες"},"batch_actions":{"button_label":"Μαζικές Ενέργειες","default_confirmation":"Είστε σίγουρος πως θέλετε να το κάνετε αυτό;","delete_confirmation":"Είστε σίγουρος πως θέλετε να διαγράψετε αυτά τα %{plural_model}?","succesfully_destroyed":{"one":"Διαγράφηκε επιτυχώς 1 %{model}","other":"Διαγράφηκαν επιτυχώς %{count} %{plural_model}"},"selection_toggle_explanation":"(Αντιστροφή επιλογών)","link":"Δημιουργήστε ένα","action_label":"%{title} επιλεγμένων","labels":{"destroy":"Διαγραφή"}},"comments":{"resource_type":"Τύπος Εγγραφής","author_type":"Τύπος Συγγραφέα","body":"Κείμενο","author":"Συγγραφέας","title":"Σχόλιο","add":"Προσθήκη Σχολίου","resource":"Εγγραφή","no_comments_yet":"Δεν υπάρχει κανένα σχόλιο.","author_missing":"Ανώνυμος","title_content":"Σχόλια (%{count})","errors":{"empty_text":"Το σχόλιο δε σώθηκε, το κείμενο ήταν κενό."}},"devise":{"username":{"title":"Όνομα χρήστη"},"email":{"title":"Email"},"subdomain":{"title":"Subdomain"},"password":{"title":"Κωδικός"},"sign_up":{"title":"Εγγραφή","submit":"Εγγραφή"},"login":{"title":"Σύνδεση","remember_me":"Να με θυμάσαι","submit":"Σύνδεση"},"reset_password":{"title":"Ξεχάσατε τον κωδικό σας;","submit":"Επαναφορά κωδικού"},"change_password":{"title":"Αλλάξτε τον κωδικό σας","submit":"Αλλαγή του κωδικού"},"unlock":{"title":"Αποστολή οδηγιών ξεκλειδώματος","submit":"Αποστολή οδηγιών ξεκλειδώματος"},"resend_confirmation_instructions":{"title":"Αποστολή οδηγιών επιβεβαίωσης","submit":"Αποστολή οδηγιών επιβεβαίωσης"},"links":{"sign_in":"Σύνδεση","sign_up":"Εγγραφή","forgot_your_password":"Ξεχάσατε τον κωδικό σας;","sign_in_with_omniauth_provider":"Σύνδεση με %{provider}","resend_unlock_instructions":"Αποστολή οδηγιών ξεκλειδώματος","resend_confirmation_instructions":"Αποστολή οδηγιών επιβεβαίωσης"}},"unsupported_browser":{"headline":"Το ActiveAdmin δεν υποστηρίζει πλεον τον Internet Explorer έκδοση 8 η μικρότερη.","recommendation":"Σας προτείνουμε να αναβαθμίσετε στην τελευταία \u003ca href=\"http://windows.microsoft.com/ie\"\u003eInternet Explorer\u003c/a\u003e, \u003ca href=\"https://chrome.google.com/\"\u003eGoogle Chrome\u003c/a\u003e, or \u003ca href=\"https://mozilla.org/firefox/\"\u003eFirefox\u003c/a\u003e.","turn_off_compatibility_view":"Αν χρησιμοποιείτε IE 9 ή μεγαλύτερη έκδοση, σιγουρευτείτε ότι \u003ca href=\"http://windows.microsoft.com/en-US/windows7/webpages-look-incorrect-in-Internet-Explorer\"\u003eturn off \"Compatibility View\"\u003c/a\u003e."},"access_denied":{"message":"Δεν έχετε πρόσβαση για αυτή την ενέργεια."},"index_list":{"table":"Πίνακας","block":"Λίστα","grid":"Πλέγμα","blog":"Blog"}},"pageflow":{"public":{"_language":"Ελληνικά","audio":"Ήχος","back":"Πίσω","back_to_chapter":"Πίσω στο κεφάλαιο","before_after":{"drag_hint":null,"hint":"Πριν/μετα προβολή","leave_view":"Αποχώριση πριν/μετα προβολή","start":"Εκκίνιση πριν/μετα προβολή","start_title":"Εκκίνιση πριν/μετα προβολή"},"chapter":"Κεφάλαιο","chart":{"toggle":"Εναλακτικα"},"close":"Κλείσιμο","close_hint":"Κλείσιμο βοηθήματος","close_navigation":"Κλείσιμο οδηγού","close_overview":"Κλείσιμο επισκόπισης","deprecated_browser":"\u003cp\u003eΤο πρόγραμα περιήγησης σας έχει ξεπερασμένο λογισμικό  και ίσως να μην λητουργεί. Σας προτείνουμε να αναβαθμίσετε το πρόγραμα περιήγησης σας με την ποιο πρόσφατη έκδοση.\u003c/p\u003e","embedded_video":{"leave_video":"Αποχώριση ενσώματομενου βίντεο"},"enlarge_view":"Μεγιστοποιηση προβολής","enter_fullscreen":"Είσοδος σε πλήρης οθόνη","first_page":"Πρώτη σελίδα","forward":"Μπροστά","fullscreen":"Πλήρης οθόνη","goto_first_page":"Πήγαινε στην αρχική σελίδα","goto_top":"Πήγαινε στην αρχική σελίδα","hide_text":"Απόκρυψη κειμένου","home":"Αρχική","imprint":"Αποτύπωμα","javascript_hint":"Αυτή η εφαρμογή χρησιμοποιεί JavaScript για καλύτερη απόδοση στον χρήστη. Το πρόγραμμα περιήγησης σας μπορεί να μην υποστηριζει το JavaScript ή να ειναι απενεργοποιημένο.","languages":{"ar":null,"cs":null,"de":null,"dk":null,"el":null,"en":null,"es":null,"fr":null,"it":null,"nl":null,"pl":null,"pt":null,"ru":null,"sr":null,"tr":null,"unknown":null,"zh":null},"leave_fullscreen":"Έξοδος απο πλήρης οθόνη","lets_go":"Εκκίνηση!","logo":"Λογότυπο","media_quality":null,"mute_off":"Κατάργηση σίγασης","mute_on":"Σίγαση","navigate_top":"Πήγαινε στην αρχική σελίδα","navigation":"Πλοήγηση","new_pages_box":{"additional_pages_html":"...και \u003cspan\u003e\u003c/span\u003e περισσότερες","description":"Απο την τελευταία σας επισκεψη , έχουν προστεθεί μερικές σελίδες στην pageflow:","title":"Νέες σελίδες"},"notice":"ειδοποίηση","open_audio":null,"open_navigation":"Άνοιγμα πλοήγησης","open_overview":"Άνοιγμα επισκόπησης","open_video":null,"overview":"Επισκόπηση","panorama":{"close":"κλείσιμο 360ᵒ πανοράματος και  απεικονιζόμενου κειμενού","start":"εκκινήση 360ᵒ πανοράματος"},"play_video":"αναπαραγωγή βιντεο","scroll_back_indicator":null,"scroll_down":"Σκρολάρετε κάτω","scroll_hint":"Χρησιμοποιήστε την ροδέλα ή τα βελάκια στο πληκτρολόγιο για να περιηγηθείτε ανάμεσα στις σελήδες","scroll_indicator":"Σκρολάρετε κατω για να συνεχίσετε","scroll_left":"Σκρολάρετε αριστερά","scroll_right":"Σκρολάρετε δεξιά","scroll_up":"Σκρολάρετε πάνω","share":"Μοιραστείτε","share_on_facebook":"Μοιραστείτε στο Facebook","share_on_google":"Μοιραστείτε στο Google+","share_on_twitter":"Μοιραστείτε στο Τwitter","share_this_entry":"αυτή η ιστορία","share_this_page":"αυτή η σελίδα","show_home":"Έναρξη","show_text":"Εμφάνιση κειμένου","skip_links_content":"πήγαινε στο περιεχώμενο","skip_links_navigation":"Πήγαινε στην περιήγηση","skip_links_top_navigation":"Πήγαινε στην κεντρική περιήγηση","sound_hint":"Αυτή η ιστορία χρησιμοποιεί οπτικοακουστίκο υλικό. Σιγουρευτείτε ότι το ηχείο σας είναι ανοιχτό.","start_audio":"Έναρξη ήχου τώρα","start_video":"Έναρξή βίντεο τώρα","swipe_hint":"σύρετε την οθόνη για να περιηγηθείτε ανάμεσα στις σελίδες","swipe_indicator":"σύρετε την οθόνη για να συνεχήσετε","text_track_modes":{"auto":null,"auto_off":null,"none":null},"text_tracks":null,"video":"βίντεο","video_qualities":{"annotations":{"4k":null,"fullhd":null,"medium":null},"labels":{"4k":null,"auto":null,"fullhd":null,"medium":null}},"volume":"Ήχος","vr":{"no_vr":{"link":null,"text":null},"select_quality":null,"start":null,"start_cardboard":null,"video_qualities":{"4k":null,"fullhd":null,"high":null},"video_quality_annotations":{"4k":null,"fullhd":null,"high":null}}}}},"en-GB":{"active_admin":{"dashboard":"Dashboard","dashboard_welcome":{"welcome":"Welcome to Active Admin. This is the default dashboard page.","call_to_action":"To add dashboard sections, checkout 'app/admin/dashboards.rb'"},"view":"View","edit":"Edit","delete":"Delete","delete_confirmation":"Are you sure you want to delete this?","new_model":"New %{model}","edit_model":"Edit %{model}","delete_model":"Delete %{model}","details":"%{model} Details","cancel":"Cancel","empty":"Empty","previous":"Previous","next":"Next","download":"Download:","has_many_new":"Add New %{model}","has_many_delete":"Delete","has_many_remove":"Remove","filters":{"buttons":{"filter":"Filter","clear":"Clear Filters"},"predicates":{"contains":"Contains","equals":"Equals","starts_with":"Starts with","ends_with":"Ends with","greater_than":"Greater than","less_than":"Less than"}},"status_tag":{"yes":"Yes","no":"No"},"main_content":"Please implement %{model}#main_content to display content.","logout":"Logout","powered_by":"Powered by %{active_admin} %{version}","sidebars":{"filters":"Filters"},"pagination":{"empty":"No %{model} found","one":"Displaying \u003cb\u003e1\u003c/b\u003e %{model}","one_page":"Displaying \u003cb\u003eall %{n}\u003c/b\u003e %{model}","multiple":"Displaying %{model} \u003cb\u003e%{from}\u0026nbsp;-\u0026nbsp;%{to}\u003c/b\u003e of \u003cb\u003e%{total}\u003c/b\u003e in total","multiple_without_total":"Displaying %{model} \u003cb\u003e%{from}\u0026nbsp;-\u0026nbsp;%{to}\u003c/b\u003e","entry":{"one":"entry","other":"entries"}},"any":"Any","blank_slate":{"content":"There are no %{resource_name} yet.","link":"Create one"},"dropdown_actions":{"button_label":"Actions"},"batch_actions":{"button_label":"Batch Actions","default_confirmation":"Are you sure you want to do this?","delete_confirmation":"Are you sure you want to delete these %{plural_model}?","succesfully_destroyed":{"one":"Successfully destroyed 1 %{model}","other":"Successfully destroyed %{count} %{plural_model}"},"selection_toggle_explanation":"(Toggle Selection)","link":"Create one","action_label":"%{title} Selected","labels":{"destroy":"Delete"}},"comments":{"body":"Body","author":"Author","title":"Comment","add":"Add Comment","resource":"Resource","no_comments_yet":"No comments yet.","author_missing":"Anonymous","title_content":"Comments (%{count})","errors":{"empty_text":"Comment wasn't saved, text was empty."}},"devise":{"login":{"title":"Login","remember_me":"Remember me","submit":"Login"},"reset_password":{"title":"Forgot your password?","submit":"Reset My Password"},"change_password":{"title":"Change your password","submit":"Change my password"},"resend_confirmation_instructions":{"title":"Resend confirmation instructions","submit":"Resend confirmation instructions"},"links":{"sign_in":"Sign in","forgot_your_password":"Forgot your password?","sign_in_with_omniauth_provider":"Sign in with %{provider}","resend_unlock_instructions":"Re-send unlock instructions"}}}},"es-MX":{"active_admin":{"dashboard":"Inicio","dashboard_welcome":{"welcome":"Bienvenido a Active Admin. Esta es la página de inicio predeterminada.","call_to_action":"Para agregar secciones edite 'app/admin/dashboard.rb'"},"view":"Ver","edit":"Editar","delete":"Eliminar","delete_confirmation":"¿Está seguro de que quiere eliminar esto?","new_model":"Añadir %{model}","edit_model":"Editar %{model}","delete_model":"Eliminar %{model}","details":"Detalles de %{model}","cancel":"Cancelar","empty":"Vacío","previous":"Anterior","next":"Siguiente","download":"Descargar:","has_many_new":"Añadir %{model}","has_many_delete":"Eliminar","has_many_remove":"Quitar","filters":{"buttons":{"filter":"Filtrar","clear":"Quitar Filtros"},"predicates":{"contains":"Contiene","equals":"Igual a","starts_with":"Empieza con","ends_with":"Termina con","greater_than":"Mayor que","less_than":"Menor que"}},"status_tag":{"yes":"Sí","no":"No"},"main_content":"Por favor implemente %{model}#main_content para mostrar contenido.","logout":"Salir","powered_by":"Powered by %{active_admin} %{version}","sidebars":{"filters":"Filtros"},"pagination":{"empty":"No se han encontrado %{model}","one":"Mostrando \u003cb\u003e1\u003c/b\u003e %{model}","one_page":"Mostrando \u003cb\u003eun total de %{n}\u003c/b\u003e %{model}","multiple":"Mostrando %{model} \u003cb\u003e%{from}\u0026nbsp;-\u0026nbsp;%{to}\u003c/b\u003e de un total de \u003cb\u003e%{total}\u003c/b\u003e"},"blank_slate":{"content":"No hay %{resource_name} aún.","link":"Añadir"},"any":"Cualquiera","dropdown_actions":{"button_label":"Acciones"},"batch_actions":{"button_label":"Acciones en masa","default_confirmation":"¿Seguro que quieres hacer esto?","delete_confirmation":"Eliminar %{plural_model}: ¿Está seguro?","succesfully_destroyed":{"one":"Se ha destruido 1 %{model} con éxito","other":"Se han destruido %{count} %{plural_model} con éxito"},"selection_toggle_explanation":"(Cambiar selección)","link":"Añadir","action_label":"%{title} seleccionado","labels":{"destroy":"Borrar"}},"comments":{"body":"Cuerpo","author":"Autor","title":"Comentario","add":"Comentar","resource":"Recurso","no_comments_yet":"Aún sin comentarios.","title_content":"Comentarios (%{count})","errors":{"empty_text":"El comentario no fue guardado, el texto estaba vacío."}},"devise":{"login":{"title":"Iniciar Sesión","remember_me":"Recordarme","submit":"Iniciar Sesión"},"reset_password":{"title":"¿Olvidó su contraseña?","submit":"Restablecer mi contraseña"},"change_password":{"title":"Cambie su contraseña","submit":"Cambiar mi contraseña"},"links":{"sign_in":"Registrarse","forgot_your_password":"¿Olvidó su contraseña?","sign_in_with_omniauth_provider":"Conéctate con %{provider}"}},"index_list":{"table":"Tabla","block":"Lista","grid":"Cuadrícula","blog":"Blog"}}},"fa":{"active_admin":{"dashboard":"داشبرد","dashboard_welcome":{"welcome":"به اکتیو ادمین خوش آمدید. این صفحه اول داشبرد است.","call_to_action":"برای اضافه کردن قسمت‌هایی به داشبرد اینجا را چک کنید: 'app/admin/dashboard.rb'"},"view":"نمایش","edit":"ویرایش","delete":"حذف","delete_confirmation":"آیا برای حذف این آیتم اطمینان دارید؟","new_model":"%{model} جدید","edit_model":"ویرایش %{model}","delete_model":"حذف %{model}","details":"جزئیات %{model}","cancel":"لغو","empty":"خالی","previous":"قبلی","next":"بعدی","download":"دریافت:","has_many_new":"اضافه کردن %{model} جدید","has_many_delete":"حذف","has_many_remove":"حذف","filters":{"buttons":{"filter":"فیلتر","clear":"پاک کردن فیلتر"},"predicates":{"contains":"شامل","equals":"برابر با","starts_with":"شروع با","ends_with":"پایان با","greater_than":"بزرگتر از","less_than":"کوچکتر از"}},"status_tag":{"yes":"بله","no":"بدون"},"main_content":"لطفا %{model}#main_content را پیاده سازی کنید تا محتوی نمایش داده شود.","logout":"خروج","powered_by":"قدرت گرفته از %{active_admin} %{version}","sidebars":{"filters":"فیلتر‌ها"},"pagination":{"empty":"هیچ رکورد %{model} یافت نشد","one":"نمایش \u003cb\u003e1\u003c/b\u003e %{model}","one_page":"نمایش \u003cb\u003eهمه %{n}\u003c/b\u003e %{model}","multiple":"نمایش %{model} \u003cb\u003e%{from}\u0026nbsp;-\u0026nbsp;%{to}\u003c/b\u003e از کل \u003cb\u003e%{total}\u003c/b\u003e رکورد","multiple_without_total":"نمایش %{model} \u003cb\u003e%{from}\u0026nbsp;-\u0026nbsp;%{to}\u003c/b\u003e","entry":{"one":"آیتم","other":"آیتم‌ها"}},"any":"هرکدام","blank_slate":{"content":"هنوز هیچ رکوردی از %{resource_name} درج نشده.","link":"درج اولین رکورد"},"dropdown_actions":{"button_label":"عملیات"},"batch_actions":{"button_label":"عملیات‌های دسته‌ای","default_confirmation":"آیا برای اجرای این عملیات اطمینان دارید؟","delete_confirmation":"آیا برای حذف همه رکوردهای %{plural_model} اطمینان دارید؟","succesfully_destroyed":{"one":"1 %{model} با موفقیت حذف شد","other":"%{count} %{plural_model} با موفقت حذف شدند."},"selection_toggle_explanation":"(انتخاب‌ها برعکس شوند)","link":"ایجاد یک رکورد جدید","action_label":"%{title} انتخاب شده است","labels":{"destroy":"حذف"}},"comments":{"resource_type":"نوع رکورد","author_type":"نوع ایجاد کننده","body":"بدنه","author":"ایجاد کننده","title":"کامنت","add":"افزودن کامنت","resource":"رکورد","no_comments_yet":"هنوز هیچ کامنتی نوشته نشده.","author_missing":"بی‌نام","title_content":"کامنت‌ها (%{count})","errors":{"empty_text":"کامنت درج نشد، متن کامنت خالی بود."}},"devise":{"username":{"title":"نام کاربری"},"email":{"title":"ایمیل"},"subdomain":{"title":"Subdomain"},"password":{"title":"کلمه‌عبور"},"sign_up":{"title":"ثبت‌نام","submit":"ثبت‌نام"},"login":{"title":"ورود","remember_me":"مرا به خاطر بسپار","submit":"ورود"},"reset_password":{"title":"کلمه عبور را فراموش کرده‌اید؟","submit":"دریافت کلمه عبور جدید"},"change_password":{"title":"تغییر کلمه عبور","submit":"تغییر کلمه عبور"},"unlock":{"title":"ارسال مجدد دستورالعمل بازگشایی حساب کاربری","submit":"ارسال مجدد دستورالعمل بازگشایی حساب کاربری"},"resend_confirmation_instructions":{"title":"ارسال مجدد تاییدیه ایمیل","submit":"ارسال مجدد تاییدیه ایمیل"},"links":{"sign_in":"ورود","forgot_your_password":"کلمه عبور را فراموش کرده‌اید؟","sign_in_with_omniauth_provider":"ورود با حساب %{provider}"}},"access_denied":{"message":"شما دسترسی لازم برای انجام این عملیات را ندارید."},"index_list":{"table":"جدول","block":"لیست","grid":"گرید","blog":"وبلاگ"}}},"fi":{"active_admin":{"dashboard":"Etusivu","dashboard_welcome":{"welcome":"Tervetuloa! Tämä on Active Adminin oletusetusivu.","call_to_action":"Lisätäksesi etusivun osioita katso: 'app/admin/dashboard.rb'"},"view":"Katso","edit":"Muokkaa","delete":"Poista","delete_confirmation":"Oletko varma, että haluat poistaa tämän?","new_model":"Uusi %{model}","edit_model":"Muokaa %{model}","delete_model":"Poista %{model}","details":"%{model} Tiedot","cancel":"Peruuta","empty":"Tyhjä","previous":"Edellinen","next":"Seuraava","download":"Lataa:","has_many_new":"Lisää uusi %{model}","has_many_delete":"Poista","has_many_remove":"Poista","filters":{"buttons":{"filter":"Hae","clear":"Tyhjennä valinnat"},"predicates":{"contains":"Sisältää","equals":"On yhtä kuin","starts_with":"Alkaa","ends_with":"Päättyy","greater_than":"Suurempi kuin","less_than":"Pienempi kuin"}},"status_tag":{"yes":"Kyllä","no":"Ei"},"main_content":"Ole hyvä, käytä %{model}#main_content:ia nähdäksesi jotain.","logout":"Kirjaudu ulos","powered_by":"Käyttää %{active_admin} %{version}:ia","sidebars":{"filters":"Haku"},"pagination":{"empty":"%{model}:ia ei löytynyt","one":"Näytetään \u003cb\u003e1\u003c/b\u003e %{model}","one_page":"Näytetään \u003cb\u003ekaikki %{n}\u003c/b\u003e %{model}:it","multiple":"Näytetään %{model} \u003cb\u003e%{from}\u0026nbsp;-\u0026nbsp;%{to}\u003c/b\u003e (yhteensä \u003cb\u003e%{total}\u003c/b\u003e)","multiple_without_total":"Näytetään %{model} \u003cb\u003e%{from}\u0026nbsp;-\u0026nbsp;%{to}\u003c/b\u003e","entry":{"one":"syöte","other":"syötteet"}},"any":"mikä vain","blank_slate":{"content":"Järjestelmässä ei ole yhtään %{resource_name}:ia vielä.","link":"Luo ensimmäinen"},"dropdown_actions":{"button_label":"Acciones"},"batch_actions":{"button_label":"Toimet","default_confirmation":"Oletko varma, että haluat tehdä tämän?","delete_confirmation":"Oletko varma, että haluat poistaa nämä %{plural_model}:t?","succesfully_destroyed":{"one":"1 %{model} poistettu","other":"%{count} %{plural_model}:a poistettu"},"selection_toggle_explanation":"(Vaihda valintaa)","link":"Luo","action_label":"%{title} Valittu","labels":{"destroy":"Poista"}},"comments":{"resource_type":"Resurssityyppi","author_type":"Luoja-tyyppi","body":"Runko","author":"Luoja","title":"Kommentti","add":"Lisää kommentti","resource":"Resurssi","no_comments_yet":"Ei kommentteja.","title_content":"Kommentteja (%{count})","errors":{"empty_text":"Kommenttia ei pystytty tallentamaan, et kirjoittanut kommenttitekstiä."}},"devise":{"username":{"title":"Käyttäjänimi"},"email":{"title":"Sähköposti"},"subdomain":{"title":"Subdomain"},"password":{"title":"Salasana"},"login":{"title":"Sisäänkirjautuminen","remember_me":"Muista minut","submit":"Kirjaudu sisään"},"reset_password":{"title":"Unohtunut salasana?","submit":"Resetoi salasana"},"change_password":{"title":"Vaihda salasana","submit":"Vaihda salasana"},"unlock":{"title":"Lähetä ohjeet lukituksen poistoon","submit":"Lähetä ohjeet lukituksen poistoon"},"links":{"sign_in":"Kirjaudu sisään","forgot_your_password":"Unohtunut salasana?","sign_in_with_omniauth_provider":"Kirjaudu sisään %{provider}:ia käyttäen"}},"access_denied":{"message":"Sinulla ei ole oikeuksia suorittaa yrittämääsi toimintoa."},"index_list":{"table":"Taulukko","block":"Lista","grid":"Ruudukko","blog":"Blogi"}}},"he":{"active_admin":{"dashboard":"פנל ניהול","dashboard_welcome":{"welcome":"ברוכים הבאים לאקטיב אדמין. זהו פנל הניהול","call_to_action":"כדי להוסיף אזורים בפנל הניהול, אנא בדוק את,  'app/admin/dashboard.rb'"},"view":"צפייה","edit":"עריכה","delete":"מחיקה","delete_confirmation":"האם אתה בטוח שאתה רוצה למחוק את זה?","new_model":"%{model} חדש","edit_model":"ערוך %{model}","delete_model":"מחיקת %{model}","details":"פרטים על %{model}","cancel":"ביטול","empty":"ריק","previous":"הקודם","next":"הבא","download":"הורד:","has_many_new":"הוספת %{model} חדש","has_many_delete":"מחיקה","has_many_remove":"להסיר","filters":{"buttons":{"filter":"סינון","clear":"איפוס שדות"},"predicates":{"contains":"מכיל","equals":"שווה ל","starts_with":"מתחיל עם","ends_with":"מסתיים ב","greater_than":"גדול מ","less_than":"פחות מ"}},"status_tag":{"yes":"כן","no":"לא"},"main_content":"Please implement %{model}#main_content to display content.","logout":"התנתקות","powered_by":"Powered by %{active_admin} %{version}","sidebars":{"filters":"סינון"},"pagination":{"empty":"אין %{model} בנמצא","one":"מציג \u003cb\u003e1\u003c/b\u003e %{model}","one_page":"הצגת \u003cb\u003eכל %{n}\u003c/b\u003e %{model}","multiple":"מציג %{model} \u003cb\u003e%{from}\u0026nbsp;-\u0026nbsp;%{to}\u003c/b\u003e מתוך \u003cb\u003e%{total}\u003c/b\u003e בסך הכל","multiple_without_total":"מציג %{model} \u003cb\u003e%{from}\u0026nbsp;-\u0026nbsp;%{to}\u003c/b\u003e","entry":{"one":"רשומה בודדה","other":"רשומות"}},"any":"Any","blank_slate":{"content":"כרגע אין עוד אף %{resource_name}.","link":"צור אחד"},"dropdown_actions":{"button_label":"פעולו"},"batch_actions":{"button_label":"פעולות מרובות","default_confirmation":"אתה בטוח שאתה רוצה לעשות את זה?","delete_confirmation":"האם הנך בטוח שאתה רוצה למרוח את %{plural_model}?","succesfully_destroyed":{"one":"1 %{model} נמחק בהצלחה","few":"%{count} %{plural_model} נמחק בהצלחה","many":"%{count} %{plural_model} נמחק בהצלחה","other":"%{count} %{plural_model} נמחק בהצלחה"},"selection_toggle_explanation":"(שינוי בחירה)","link":"צור","action_label":"%{title} נבחר","labels":{"destroy":"מחק"}},"comments":{"body":"תוכן","author":"נוצר ע\"י","title":"תגובה","add":"הוסף תגובה","resource":"Resource","no_comments_yet":"אין עדיין תגובות.","title_content":"תגובות (%{count})","errors":{"empty_text":"התגובה לא נשמרה, שדה התוכן ריק."}},"devise":{"login":{"title":"כניסה","remember_me":"זכור אותי","submit":"הכנס"},"reset_password":{"title":"שכחת סיסמא?","submit":"אפס את הסיסמא שלי"},"change_password":{"title":"שנה את הסיסמא שלך","submit":"שנה את הסיסמא שלי"},"links":{"sign_in":"כניסה","forgot_your_password":"שכחת את הסיסמא שלך?","sign_in_with_omniauth_provider":"%{provider} היכנס עם"}}}},"hr":{"active_admin":{"dashboard":"Upravljačka ploča","dashboard_welcome":{"welcome":"Dobrodošli u Active Admin. Ovo je početna upravljačka ploča.","call_to_action":"Da biste dodali nove odjeljke na upravljačku ploču, pogledajte 'app/admin/dashboard.rb'"},"view":"Pregledaj","edit":"Uredi","delete":"Obriši","delete_confirmation":"Jeste li sigurni da želite ovo obrisati?","new_model":"Novi %{model}","edit_model":"Uredi %{model}","delete_model":"Obriši %{model}","details":"%{model} detalji","cancel":"Odustani","empty":"Prazno","previous":"Prijašnji","next":"Sljedeći","download":"Spremi na računalo:","has_many_new":"Dodaj novi %{model}","has_many_delete":"Obriši","has_many_remove":"Ukloniti","filters":{"buttons":{"filter":"Filtriraj","clear":"Očisti filtere"},"predicates":{"contains":"Sadrži","equals":"Jednako","starts_with":"počinje s","ends_with":"Završava sa","greater_than":"Veće od","less_than":"Manje od"}},"status_tag":{"yes":"Da","no":"Nema"},"main_content":"Molim Vas, implementirajte %{model}#main_content da biste prikazali sadržaj.","logout":"Odjavi se","powered_by":"Powered by %{active_admin} %{version}","sidebars":{"filters":"Filtriranje"},"pagination":{"empty":"Nije pronađen niti jedan %{model}.","one":"Prikazan \u003cb\u003e1\u003c/b\u003e %{model}","one_page":"Prikazano \u003cb\u003esvih %{n}\u003c/b\u003e %{model}","multiple":"Prikazani %{model} \u003cb\u003e%{from}\u0026nbsp;-\u0026nbsp;%{to}\u003c/b\u003e od ukupno \u003cb\u003e%{total}\u003c/b\u003e","multiple_without_total":"Prikazani %{model} \u003cb\u003e%{from}\u0026nbsp;-\u0026nbsp;%{to}\u003c/b\u003e","entry":{"one":"zapis","few":"zapisa","many":"zapisa","other":"zapisa"}},"any":"Bilo koji","blank_slate":{"content":"Još uvijek ne postoji niti jedan zapis tipa %{resource_name}.","link":"Izradi jedan"},"dropdown_actions":{"button_label":"Ukrepi"},"batch_actions":{"button_label":"Grupne akcije","default_confirmation":"Jeste li sigurni da želite to učiniti?","delete_confirmation":"Jeste li sigurni da želite obrisati %{plural_model}?","succesfully_destroyed":{"one":"Uspješno je obrisan 1 %{model}","few":"Uspješno su obrisana %{count} %{plural_model}","many":"Uspješno je obrisano %{count} %{plural_model}","other":"Uspješno je obrisano %{count} %{plural_model}"},"selection_toggle_explanation":"(Izmijeni odabir)","link":"Izradi jedan","action_label":"%{title} označene","labels":{"destroy":"Obriši"}},"comments":{"resource_type":"Tip objekta","author_type":"Tip autora","body":"Sadržaj","author":"Autor","title":"Komentar","add":"Dodaj komentar","resource":"Objekt","no_comments_yet":"Još nema komentara.","author_missing":"Anoniman","title_content":"Komentari (%{count})","errors":{"empty_text":"Komentar nije spremljen, sadržaj je prazan."}},"devise":{"username":{"title":"Korisničko ime"},"email":{"title":"Email"},"subdomain":{"title":"Poddomena"},"password":{"title":"Lozinka"},"sign_up":{"title":"Registracija","submit":"Registruj"},"login":{"title":"Prijava","remember_me":"Zapamti me","submit":"Prijavi se"},"reset_password":{"title":"Zaboravljena lozinka?","submit":"Resetiraj lozinku"},"change_password":{"title":"Izmjena lozinke","submit":"Izmijeni lozinku"},"unlock":{"title":"Ponovno slanje uputstva za otključavanje","submit":"Pošalji"},"resend_confirmation_instructions":{"title":"Ponovno slanje uputstva za potvrdu","submit":"Pošalji"},"links":{"sign_in":"Prijavi se","forgot_your_password":"Zaboravljena lozinka?","sign_in_with_omniauth_provider":"Prijavite se za %{provider}"}},"access_denied":{"message":"Nemaš dopuštenja."},"index_list":{"table":"Tabela","block":"Lista","grid":"Rešetka","blog":"Blog"}}},"ko":{"active_admin":{"dashboard":"대시보드","dashboard_welcome":{"welcome":"ActiveAdmin에 오신 것을 환영합니다. 기본 대시보드 페이지 입니다.","call_to_action":"대시보드에 섹션을 추가하시려면 'app/admin/dashboard.rb' 파일을 수정하십시오."},"view":"보기","edit":"수정","delete":"삭제","delete_confirmation":"정말로 삭제 하시겠습니까?","new_model":"%{model} 추가","edit_model":"%{model} 수정","delete_model":"%{model} 삭제","details":"%{model} 상세보기","cancel":"취소","empty":"내용이 없습니다","previous":"이전","next":"다음","download":"다운로드:","has_many_new":"%{model} 추가","has_many_delete":"삭제","has_many_remove":"삭제","filters":{"buttons":{"filter":"필터","clear":"필터 초기화"},"predicates":{"contains":"포함하는 문구","equals":"일치하는 문구","starts_with":"시작하는 문구","ends_with":"종료하는 문구","greater_than":"초과","less_than":"미만"}},"search_status":{"headline":"검색 상태:","current_scope":"검색 범위:","current_filters":"적용된 필터:","no_current_filters":"현재 적용된 필터가 없습니다"},"status_tag":{"yes":"있음","no":"없음"},"main_content":"내용을 보시려면 %{model}#main_content의 코드를 먼저 구현해 주시기 바랍니다.","logout":"로그아웃","powered_by":"Powered by %{active_admin} %{version}","sidebars":{"filters":"필터 목록","search_status":"검색 상태"},"pagination":{"empty":"%{model} 이/가 없습니다.","one":"\u003cb\u003e1\u003c/b\u003e개 %{model} 표시중","one_page":"\u003cb\u003e%{n}\u003c/b\u003e개 %{model} 표시중","multiple":"\u003cb\u003e%{total}\u003c/b\u003e개 중 \u003cb\u003e%{from}\u0026nbsp;-\u0026nbsp;%{to}\u003c/b\u003e %{model} 표시중","multiple_without_total":"\u003cb\u003e%{from}\u0026nbsp;-\u0026nbsp;%{to}\u003c/b\u003e %{model} 표시중","entry":{"one":"항목","other":"항목들"}},"any":"어떤","blank_slate":{"content":"아직 %{resource_name} 이/가 없습니다.","link":"추가하기"},"dropdown_actions":{"button_label":"작업"},"batch_actions":{"button_label":"배치 작업","default_confirmation":"확실하십니까?","delete_confirmation":"%{plural_model}을/를 삭제하시겠습니까?","succesfully_destroyed":{"one":"성공적으로 1개 %{model}을/를 삭제하였습니다","other":"성공적으로 %{count}개의 %{plural_model}을/를 삭제하였습니다"},"selection_toggle_explanation":"(선택 항목 바꾸기)","link":"만들기","action_label":"%{title} 선택됨","labels":{"destroy":"삭제"}},"comments":{"created_at":"작성시간","resource_type":"첨부파일 형태","author_type":"글쓴이 종류","body":"내용","author":"글쓴이","title":"제목","add":"댓글 추가","resource":"첨부파일","no_comments_yet":"아직 댓글이 없습니다.","title_content":"댓글 (%{count})","errors":{"empty_text":"댓글이 저장되지 않았습니다. 내용을 입력해주세요."}},"devise":{"username":{"title":"아이디"},"email":{"title":"이메일"},"subdomain":{"title":"서브도메인"},"password":{"title":"비밀번호"},"sign_up":{"title":"가입하기","submit":"가입하기"},"login":{"title":"로그인","remember_me":"내 계정 정보 기억","submit":"로그인"},"reset_password":{"title":"비밀번호를 잊으셨나요?","submit":"비밀번호 재설정"},"change_password":{"title":"비밀번호 변경","submit":"내 비밀번호 변경"},"unlock":{"title":"계정 잠금 해제하기","submit":"계정 잠금 해제하기"},"resend_confirmation_instructions":{"title":"계정 승인 요청하기","submit":"계정 승인 요청하기"},"links":{"sign_in":"로그인","forgot_your_password":"비밀번호를 잊으셨나요?","sign_in_with_omniauth_provider":"%{provider} 으로 로그인","resend_unlock_instructions":"계정 잠금 해제하기","resend_confirmation_instructions":"계정 승인 요청하기"}}}},"lt":{"active_admin":{"dashboard":"Valdymo skydelis","dashboard_welcome":{"welcome":"Sveiki atvykę į Active Admin. Tai yra numatytasis valdymo skydelis.","call_to_action":"Norėdami pridėti skydelyje skyrius, žiūrėkite app/admin/dashboard.rb"},"view":"Žiūrėti","edit":"Redaguoti","delete":"Šalinti","delete_confirmation":"Ar jūs tikrai norite tai pašalinti?","new_model":"Naujas %{model}","edit_model":"Redaguoti %{model}","delete_model":"Pašalinti %{model}","details":"%{model} Informacija","cancel":"Atšaukti","empty":"Tuščia","previous":"Atgal","next":"Toliau","download":"Atsisiųsti","has_many_new":"Pridėti naują %{model}","has_many_delete":"Šalinti","has_many_remove":"Pašalinti","filters":{"buttons":{"filter":"Filtras","clear":"Išvalyti filtrus"},"predicates":{"contains":"Sudėtyje yra","equals":"lygus","starts_with":"Prasideda nuo","ends_with":"Baigiasi","greater_than":"didesnis nei","less_than":"mažiau nei"}},"status_tag":{"yes":"Taip","no":"Nėra"},"main_content":"Prašome realizuoti %{model}#main_content turiniui vaizduoti.","logout":"Išeiti","powered_by":"Powered by %{active_admin} %{version}","sidebars":{"filters":"Filtrai"},"pagination":{"empty":"%{model} nerastas","one":"Rodoma \u003cB\u003e 1 \u003c/ b\u003e %{model}","one_page":"Rodoma \u003cb\u003evisi %{n} \u003c/ b\u003e %{model}","multiple":"Rodomi %{model} \u003cb\u003e%{iš}\u0026nbsp;-\u0026nbsp;%{to} \u003c/ b\u003e iš\u003cb\u003e%{total} \u003c/ b\u003e iš viso","multiple_without_total":"Rodomi %{model} \u003cb\u003e%{iš}\u0026nbsp;-\u0026nbsp;%{to} \u003c/ b\u003e ","entry":{"one":"įrašas","other":"įrašai"}},"any":"Bet kokia","blank_slate":{"content":"Nėra %{resource_name}.","link":"Sukurti"},"dropdown_actions":{"button_label":"Veiksmai"},"batch_actions":{"button_label":"Veiksmai su pažymėtais","default_confirmation":"Ar jūs tikrai norite tai padaryti?","delete_confirmation":"Ar jūs tikrai norite pašalinti šiuos %{plural_model}?","succesfully_destroyed":{"one":"Sėkmingai pašalintas 1 %{model}","few":"Sėkmingai pašalinti %{count} %{plural_model}","other":"Sėkmingai pašalinti %{count} %{plural_model}"},"selection_toggle_explanation":"(Žymėti)","link":"Sukurti","action_label":"%{title} Pasirinkta","labels":{"destroy":"Šalinti"}},"comments":{"resource_type":"Resurso Tipas","author_type":"Autoriaus Tipas","body":"Įrašas","author":"Autorius","title":"Komentaras","add":"Pridėti komentarą","resource":"Išteklių","no_comments_yet":"Dar nėra komentarų.","author_missing":"Anonimas","title_content":"Komentarai (%{count})","errors":{"empty_text":"Komentaras neišsaugotas, tekstas buvo tuščias."}},"devise":{"username":{"title":"Vartotojo Vardas"},"email":{"title":"El. paštas"},"subdomain":{"title":"Subdomenas"},"password":{"title":"Slaptažodis"},"sign_up":{"title":"Registracija","submit":"Užsiregistruoti"},"login":{"title":"Prisijungimas","remember_me":"Prisiminti Mane","submit":"Prisijungti"},"reset_password":{"title":"Pamiršote slaptažodį?","submit":"Sukurti Naują Slaptažodį"},"change_password":{"title":"Slaptažodžio Keitimas","submit":"Pakeisti mano slaptažodį"},"unlock":{"title":"Pakartotinio Atrakinimo Instrukcijos","submit":"Pakartotinai siųsti atrakinimo instrukcijas"},"resend_confirmation_instructions":{"title":"Patvirtinimo Instrukcijos","submit":"Siųsti patvirtinimo instructions"},"links":{"sign_in":"Prisijungti","forgot_your_password":"Pamiršote slaptažodį?","sign_in_with_omniauth_provider":"Prisijungti su %{provider}"}},"access_denied":{"message":"Jūs nesate įgaliotas atlikti šį veiksmą."},"index_list":{"table":"Lentelė","block":"Sąrašas","grid":"Tinklelis","blog":"Blog"}}},"lv":{"active_admin":{"dashboard":"Panelis","dashboard_welcome":{"welcome":"Laipni lūgti Active Admin.","call_to_action":"Izmantojiet 'app/admin/dashboard.rb', lai pievienotu sadaļas panelim."},"view":"Apskatīt","edit":"Labot","delete":"Dzēst","delete_confirmation":"Vai Tu tiešām vēlies dzēst?","new_model":"Pievienot '%{model}' ierakstu","edit_model":"Labot '%{model}' ierakstu","delete_model":"Dzēst '%{model}' ierakstu","details":"Apraksts","cancel":"Atcelt","empty":"Tukšs","previous":"Iepriekšējā","next":"Nākošā","download":"Lejuplādēt:","has_many_new":"Pievienot jaunu '%{model}' ierakstu","has_many_delete":"Dzēst","has_many_remove":"Noņemt","filters":{"buttons":{"filter":"Filtrēt","clear":"Novākt filtrus"},"predicates":{"contains":"Satur","equals":"Vienāds ar","starts_with":"Sākas ar","ends_with":"Beidzas ar","greater_than":"Lielāks par","less_than":"Mazāks par"}},"status_tag":{"yes":"Jā","no":"Nē"},"main_content":"Lūdzu implementēt %{model}#main_content, lai rādītos saturs.","logout":"Iziet","powered_by":"Powered by %{active_admin} %{version}","sidebars":{"filters":"Filtri"},"pagination":{"empty":"Nav ierakstu","one":"\u003cb\u003e1\u003c/b\u003e ieraksts","one_page":"\u003cb\u003e%{n}\u003c/b\u003e ieraksti","multiple":"\u003cb\u003e%{from}\u0026nbsp;-\u0026nbsp;%{to}\u003c/b\u003e ieraksti no \u003cb\u003e%{total}\u003c/b\u003e kopā","multiple_without_total":"\u003cb\u003e%{from}\u0026nbsp;-\u0026nbsp;%{to}\u003c/b\u003e","entry":{"one":"ieraksts","other":"ieraksti"}},"any":"Jebkurš","blank_slate":{"content":"Sadaļā '%{resource_name}' nav neviena ieraksta.","link":"Izveidot jaunu"},"dropdown_actions":{"button_label":"Actions"},"batch_actions":{"button_label":"Batch Actions","default_confirmation":"Vai tiešām vēlaties to darīt?","delete_confirmation":"Vai tiešām vēlaties dzēst šos %{plural_model}?","succesfully_destroyed":{"one":"Successfully destroyed 1 %{model}","other":"Successfully destroyed %{count} %{plural_model}"},"selection_toggle_explanation":"(Toggle Selection)","link":"Create one","action_label":"%{title} Selected","labels":{"destroy":"Delete"}},"comments":{"body":"Saturs","author":"Autors","title":"Komentārs","add":"Pievienot komentāru","resource":"Resurss","no_comments_yet":"Nav neviena komentāra.","title_content":"Komentāri (%{count})","errors":{"empty_text":"Komentārs netika saglabāts - nekas nav ierakstīts"}},"devise":{"login":{"title":"Ielogojaties","remember_me":"atcerēties mani","submit":"Ielogojaties"},"reset_password":{"title":"Aizmirsāt savu paroli?","submit":"Atjaunotu savu paroli"},"change_password":{"title":"Nomainīt paroli","submit":"Nomainīt savu paroli"},"links":{"sign_in":"pierakstīties","forgot_your_password":"Aizmirsāt savu paroli?","sign_in_with_omniauth_provider":"Pierakstieties ar %{provider}"}}}},"nb":{"active_admin":{"dashboard":"Oversikt","dashboard_welcome":{"welcome":"Velkommen til Active Admin. Dette er standardoversiktssiden.","call_to_action":"Rediger 'app/admin/dashboard.rb' for å legge til elementer i oversikten."},"view":"Vis","edit":"Rediger","delete":"Slett","delete_confirmation":"Er du sikker på at du vil slette denne?","new_model":"Ny %{model}","edit_model":"Rediger %{model}","delete_model":"Slett %{model}","details":"%{model} Detaljer","cancel":"Avbryt","empty":"Tom","previous":"Forrige","next":"Neste","download":"Last ned:","has_many_new":"Legg til ny %{model}","has_many_delete":"Slett","has_many_remove":"Fjern","filters":{"buttons":{"filter":"Filter","clear":"Fjern filter"},"predicates":{"contains":"Inneholder","equals":"Er lik","starts_with":"Starter med","ends_with":"Slutter med","greater_than":"Større enn","less_than":"Mindre enn"}},"search_status":{"headline":"Søkestatus:","current_scope":"Søkeområde:","current_filters":"Gjeldende filtre:","no_current_filters":"Ingen"},"status_tag":{"yes":"Ja","no":"Nei"},"main_content":"Vennligst implementer %{model}#main_content for å vise innhold.","logout":"Logg ut","powered_by":"Powered by %{active_admin} %{version}","sidebars":{"filters":"Filtere"},"pagination":{"empty":"Fant ingen %{model}","one":"Viser \u003cb\u003e1\u003c/b\u003e %{model}","one_page":"Viser \u003cb\u003ealle %{n}\u003c/b\u003e %{model}","multiple":"Viser %{model} \u003cb\u003e%{from}\u0026nbsp;-\u0026nbsp;%{to}\u003c/b\u003e av \u003cb\u003e%{total}\u003c/b\u003e totalt","multiple_without_total":"Viser %{model} \u003cb\u003e%{from}\u0026nbsp;-\u0026nbsp;%{to}\u003c/b\u003e","entry":{"one":"innslag","other":"innslag"}},"any":"Alle","blank_slate":{"content":"Her er det ingen %{resource_name} enda.","link":"Opprett en"},"dropdown_actions":{"button_label":"Handlinger"},"batch_actions":{"button_label":"Gruppehandlinger","delete_confirmation":"Er du sikker på at du vil slette disse %{plural_model}? Dette kan ikke reverseres.","succesfully_destroyed":{"one":"Slettet én %{model}","other":"Slettet %{count} %{plural_model}"},"selection_toggle_explanation":"(Toggle Selection)","link":"Opprett en","action_label":"%{title} valgt","labels":{"destroy":"Slett"}},"comments":{"body":"Body","author":"Author","title":"Comment","add":"Add Comment","resource":"Resource","no_comments_yet":"No comments yet.","title_content":"Kommentarer (%{count})","errors":{"empty_text":"Kommentar ble ikke lagret, teksten var tom."}},"devise":{"username":{"title":"Brukernavn"},"email":{"title":"E-post"},"subdomain":{"title":"Subdomene"},"password":{"title":"Passord"},"sign_up":{"title":"Opprett brukerkonto","submit":"Opprett"},"login":{"title":"Innlogging","remember_me":"Husk meg","submit":"Logg inn"},"reset_password":{"title":"Glemt passord?","submit":"Tilbakestille passordet mitt"},"change_password":{"title":"Endre passordet","submit":"Endre mitt passord"},"unlock":{"title":"Send info om gjenoppretting på nytt","submit":"Send info om gjenoppretting på nytt"},"resend_confirmation_instructions":{"title":"Send bekreftelsesinformasjon på nytt","submit":"Send bekreftelsesinformasjon på nytt"},"links":{"sign_in":"Logg inn","forgot_your_password":"Glemt passord?","sign_in_with_omniauth_provider":"Logg på med %{provider}"}},"access_denied":{"message":"Du er ikke autorisert til å utføre denne handlingen."},"index_list":{"table":"Tabell","block":"Liste","grid":"Gitter","blog":"Blogg"}}},"pt-PT":{"active_admin":{"dashboard":"Painel de Administração","dashboard_welcome":{"welcome":"Bem-vindo ao Active Admin. Esta é a página padrão.","call_to_action":"Se pretende adicionar seções ao painel, consulte 'app/admin/dashboard.rb'"},"view":"Visualizar","edit":"Editar","delete":"Remover","delete_confirmation":"Não tem a certeza de que deseja remover este ítem?","new_model":"Novo(a) %{model}","edit_model":"Editar %{model}","delete_model":"Remover %{model}","details":"Detalhes do(a) %{model}","cancel":"Cancelar","empty":"Vazio","previous":"Anterior","next":"Próximo","download":"Baixar:","has_many_new":"Adicionar Novo(a) %{model}","has_many_delete":"Remover","has_many_remove":"Remover","filters":{"buttons":{"filter":"Filtrar","clear":"Limpar Filtros"},"predicates":{"contains":"Contém","equals":"Igual A","starts_with":"Começa com","ends_with":"Termina com","greater_than":"Maior Que","less_than":"Menor Que"}},"status_tag":{"yes":"Sim","no":"Não"},"main_content":"Por favor implemente %{model}#main_content para mostrar o conteúdo.","logout":"Sair","powered_by":"Powered by %{active_admin} %{version}","sidebars":{"filters":"Filtros"},"pagination":{"empty":"Nenhum(a) %{model} encontrado(a)","one":"Mostrando \u003cb\u003e1\u003c/b\u003e %{model}","one_page":"Mostrando \u003cb\u003etodos(as) os(as) %{n}\u003c/b\u003e %{model}","multiple":"Mostrando %{model} \u003cb\u003e%{from}\u0026nbsp;-\u0026nbsp;%{to}\u003c/b\u003e de um total de \u003cb\u003e%{total}\u003c/b\u003e","multiple_without_total":"Mostrando %{model} \u003cb\u003e%{from}\u0026nbsp;-\u0026nbsp;%{to}\u003c/b\u003e","entry":{"one":"registro","other":"registros"}},"any":"Qualquer","blank_slate":{"content":"Ainda não existem %{resource_name}.","link":"Novo"},"dropdown_actions":{"button_label":"Ações"},"batch_actions":{"button_label":"Ações em quantidade","default_confirmation":"Tem a certeza que quer fazer isso?","delete_confirmation":"Tem a certeza de que deseja excluir estes %{plural_model}?","succesfully_destroyed":{"one":"Excluiu com sucesso 1 %{model}","other":"Excluiu com sucesso %{count} %{plural_model}"},"selection_toggle_explanation":"(Alternar Seleção)","link":"Novo","action_label":"%{title} Selecionado","labels":{"destroy":"Excluir"}},"comments":{"body":"Conteúdo","author":"Autor","title":"Comentário","add":"Adicionar Comentário","resource":"Objeto","no_comments_yet":"Nenhum comentário.","title_content":"Comentários: %{count}","errors":{"empty_text":"O comentário não foi guardado porque o texto estava vazio."}},"devise":{"login":{"title":"Conta","remember_me":"Lembrar-me","submit":"Entrar"},"reset_password":{"title":"Esqueceu-de da sua senha?","submit":"Reiniciar a minha senha"},"change_password":{"title":"Troque a sua senha","submit":"Trocar a minha senha"},"links":{"sign_in":"Entrar","forgot_your_password":"Esqueceu-se da sua senha?","sign_in_with_omniauth_provider":"Entre com o %{provider}"}}}},"ru":{"active_admin":{"dashboard":"Панель управления","dashboard_welcome":{"welcome":"Добро пожаловать в Active Admin. Это стандартная страница управления сайтом.","call_to_action":"Чтобы добавить сюда что-нибудь загляните в 'app/admin/dashboard.rb'"},"view":"Открыть","edit":"Изменить","delete":"Удалить","delete_confirmation":"Вы уверены, что хотите удалить это?","new_model":"Создать %{model}","edit_model":"Изменить %{model}","delete_model":"Удалить %{model}","details":"%{model} подробнее","cancel":"Отмена","empty":"Пусто","previous":"Пред.","next":"След.","download":"Загрузка:","has_many_new":"Добавить %{model}","has_many_delete":"Удалить","has_many_remove":"Убрать","filters":{"buttons":{"filter":"Фильтровать","clear":"Очистить"},"predicates":{"contains":"Содержит","equals":"Равно","starts_with":"Начинается с","ends_with":"Заканчивается","greater_than":"больше","less_than":"меньше"}},"search_status":{"headline":"Статус поиска:","current_scope":"Область:","current_filters":"Текущий фильтр:","no_current_filters":"Ни один"},"status_tag":{"yes":"Да","no":"Нет"},"main_content":"Создайте %{model}#main_content для отображения содержимого.","logout":"Выйти","powered_by":"Работает на %{active_admin} %{version}","sidebars":{"filters":"Фильтры","search_status":"Статус поиска"},"pagination":{"empty":"%{model} не найдено","one":"Результат: \u003cb\u003e1\u003c/b\u003e %{model}","one_page":"Результат: \u003cb\u003e%{n}\u003c/b\u003e %{model}","multiple":"Результат: %{model} \u003cb\u003e%{from}\u0026nbsp;-\u0026nbsp;%{to}\u003c/b\u003e из \u003cb\u003e%{total}\u003c/b\u003e","multiple_without_total":"Результат: %{model} \u003cb\u003e%{from}\u0026nbsp;-\u0026nbsp;%{to}\u003c/b\u003e","entry":{"one":"запись","few":"записи","many":"записей","other":"записей"}},"any":"Любой","blank_slate":{"content":"Пока нет %{resource_name}.","link":"Создать"},"dropdown_actions":{"button_label":"Oперации"},"batch_actions":{"button_label":"Групповые операции","default_confirmation":"Вы уверены, что вы хотите это сделать?","delete_confirmation":"Вы уверены, что хотите удалить %{plural_model}?","succesfully_destroyed":{"one":"Успешно удалено: 1 %{model}","few":"Успешно удалено: %{count} %{plural_model}","many":"Успешно удалено: %{count} %{plural_model}","other":"Успешно удалено: %{count} %{plural_model}"},"selection_toggle_explanation":"(Отметить всё / Снять выделение)","link":"Создать","action_label":"%{title} выбранное","labels":{"destroy":"Удалить"}},"comments":{"resource_type":"Тип ресурса","author_type":"Тип автора","body":"Текст","author":"Автор","title":"Комментарий","add":"Добавить Комментарий","delete":"Удалить Комментарий","delete_confirmation":"Вы уверены, что хотите удалить этот комментарий?","resource":"Ресурс","no_comments_yet":"Пока нет комментариев.","author_missing":"Аноним","title_content":"Комментарии (%{count})","errors":{"empty_text":"Комментарий не сохранен, текст не должен быть пустым."}},"devise":{"username":{"title":"Имя пользователя"},"email":{"title":"Эл. почта"},"subdomain":{"title":"Поддомен"},"password":{"title":"Пароль"},"sign_up":{"title":"Зарегистрироваться","submit":"Зарегистрироваться"},"login":{"title":"Войти","remember_me":"Запомнить меня","submit":"Войти"},"reset_password":{"title":"Забыли пароль?","submit":"Сбросить пароль"},"change_password":{"title":"Изменение пароля","submit":"Изменение пароля"},"unlock":{"title":"Повторно отправить инструкции по разблокировке","submit":"Повторно отправить инструкции по разблокировке"},"resend_confirmation_instructions":{"title":"Выслать повторно письмо с активацией","submit":"Выслать повторно письмо с активацией"},"links":{"sign_up":"Зарегистрироваться","sign_in":"Войти","forgot_your_password":"Забыли пароль?","sign_in_with_omniauth_provider":"Войти с помощью %{provider}","resend_unlock_instructions":"Повторная отправка инструкций разблокировки","resend_confirmation_instructions":"Повторная отправка инструкций подтверждения"}},"unsupported_browser":{"headline":"Пожалуйста, обратите внимание, что Active Admin больше не поддерживает старые версии Internet Explorer начиная с версии IE 8","recommendation":"Мы рекомендуем обновить версию вашего браузера (\u003ca href=\"http://windows.microsoft.com/ie\"\u003eInternet Explorer\u003c/a\u003e, \u003ca href=\"https://chrome.google.com/\"\u003eGoogle Chrome\u003c/a\u003e, или \u003ca href=\"https://mozilla.org/firefox/\"\u003eFirefox\u003c/a\u003e).","turn_off_compatibility_view":"Если вы используете IE 9 или новее, убедитесь, что \u003ca href=\"http://windows.microsoft.com/en-US/windows7/webpages-look-incorrect-in-Internet-Explorer\"\u003eвы выключили опцию \"Просмотр в режиме совместимости\"\u003c/a\u003e."},"access_denied":{"message":"Вы не авторизованы для выполнения данного действия."},"index_list":{"table":"Таблица","block":"Список","grid":"Сетка","blog":"Блог"}}},"sv-SE":{"active_admin":{"dashboard":"Skrivbord","dashboard_welcome":{"welcome":"Välkommen till Active Admin. Detta är ditt standardskrivbord.","call_to_action":"För att lägga till sektioner, gör en checkout på 'app/admin/dashboard.rb'"},"view":"Visa","edit":"Redigera","delete":"Ta bort","delete_confirmation":"Är du säker att du vill ta bort denna?","new_model":"Ny %{model}","edit_model":"Redigera %{model}","delete_model":"Ta bort %{model}","details":"Detaljvy för %{model}","cancel":"Avbryt","empty":"Tom","previous":"Föregående","next":"Nästa","download":"Ladda ner:","has_many_new":"Skapa en ny %{model}","has_many_delete":"Ta bort","has_many_remove":"Ta bort","filters":{"buttons":{"filter":"Filter","clear":"Rensa filter"},"predicates":{"contains":"Innehåller","equals":"Lika med","starts_with":"Börjar med","ends_with":"Slutar med","greater_than":"Större än","less_than":"Mindre än"}},"search_status":{"headline":"Sök status:","current_scope":"Scope:","current_filters":"Nuvarande filter:","no_current_filters":"Inga"},"status_tag":{"yes":"Ja","no":"Nej"},"main_content":"Implementera %{model}#main_content för att kunna visa något.","logout":"Logga ut","powered_by":"Powered by %{active_admin} %{version}","sidebars":{"filters":"Filter","search_status":"Sök status"},"pagination":{"empty":"Ingen %{model} funnen","one":"Visar \u003cb\u003e1\u003c/b\u003e utav %{model}","one_page":"Visar \u003cb\u003ealla %{n}\u003c/b\u003e utav %{model}","multiple":"Visar %{model} \u003cb\u003e%{from}\u0026nbsp;-\u0026nbsp;%{to}\u003c/b\u003e av \u003cb\u003e%{total}\u003c/b\u003e totalt","multiple_without_total":"Visar %{model} \u003cb\u003e%{from}\u0026nbsp;-\u0026nbsp;%{to}\u003c/b\u003e","entry":{"one":"inlägg","other":"inlägg"}},"any":"Någon","blank_slate":{"content":"Finns inga %{resource_name} än.","link":"Skapa en"},"dropdown_actions":{"button_label":"Behandling"},"batch_actions":{"button_label":"Batch behandling","default_confirmation":"Är du säker på att du vill göra detta?","delete_confirmation":"Är du säker på att du vill radera dessa %{plural_model}?","succesfully_destroyed":{"one":"Lyckades radera 1 %{model}","other":"Lyckades radera %{count} %{plural_model}"},"selection_toggle_explanation":"(Toggle Selection)","link":"Skapa en","action_label":"%{title} Markerad","labels":{"destroy":"Radera"}},"comments":{"created_at":"Skapad","resource_type":"Resurs typ","author_type":"Författar typ","body":"Innehåll","author":"Författare","title":"Kommentar","add":"Lägg till kommentar","resource":"Resurs","no_comments_yet":"Inga kommentarer än.","author_missing":"Anonym","title_content":"Kommentarer (%{count})","errors":{"empty_text":"Kommentaren sparades inte, måste innehålla text."}},"devise":{"username":{"title":"Användarnamn"},"email":{"title":"Epost"},"subdomain":{"title":"Subdomän"},"password":{"title":"Lösenord"},"sign_up":{"title":"Registera","submit":"Registera"},"login":{"title":"Inloggning","remember_me":"Kom ihåg mig","submit":"Inloggning"},"reset_password":{"title":"Glömt ditt lösenord?","submit":"Återställa mitt lösenord"},"change_password":{"title":"Ändra ditt lösenord","submit":"Ändra mitt lösenord"},"unlock":{"title":"Skicka upplåsnings instruktioner","submit":"Skicka upplåsnings instruktioner"},"resend_confirmation_instructions":{"title":"Skicka bekräftnings instruktioner","submit":"Skicka bekräftnings instruktioner"},"links":{"sign_up":"Registera","sign_in":"Logga in","forgot_your_password":"Glömt ditt lösenord?","sign_in_with_omniauth_provider":"Logga in med %{provider}","resend_unlock_instructions":"Skicka upplåsnings instruktioner","resend_confirmation_instructions":"Skicka bekräftnings instruktioner"}},"unsupported_browser":{"headline":"Notera att ActiveAdmin inte längre stödjer Internet Explorer version 8 eller mindre.","recommendation":"Vi rekommenderar dig att uppgradera till den senaste versionen av \u003ca href=\"http://windows.microsoft.com/ie\"\u003eInternet Explorer\u003c/a\u003e, \u003ca href=\"https://chrome.google.com/\"\u003eGoogle Chrome\u003c/a\u003e, eller \u003ca href=\"https://mozilla.org/firefox/\"\u003eFirefox\u003c/a\u003e.","turn_off_compatibility_view":"Om du använder IE 9 eller senare, se till att \u003ca href=\"http://windows.microsoft.com/en-US/windows7/webpages-look-incorrect-in-Internet-Explorer\"\u003estäng av \"Compatibility View\"\u003c/a\u003e."},"access_denied":{"message":"Du har inte rättighet att utföra denna åtgärd."},"index_list":{"table":"Tabell","block":"Lista","grid":"Rutnät","blog":"Blogg"}}},"uk":{"active_admin":{"dashboard":"Панель керування","dashboard_welcome":{"welcome":"Ласкаво просимо до Active Admin. Це стандартна сторінка керування сайтом.","call_to_action":"Щоб додати сюди що-небудь, зазирніть у 'app/admin/dashboard.rb'"},"view":"Переглянути","edit":"Змінити","delete":"Видалити","delete_confirmation":"Ви впевнені, що хочете це видалити?","new_model":"Створити %{model}","edit_model":"Змінити %{model}","delete_model":"Видалити %{model}","details":"%{model} детальніше","cancel":"Скасувати","empty":"Пусто","previous":"Поперед.","next":"Наст.","download":"Завантаження:","has_many_new":"Додати %{model}","has_many_delete":"Прибрати","has_many_remove":"Видалити","filters":{"buttons":{"filter":"Фільтрувати","clear":"Очистити"},"predicates":{"contains":"Містить","equals":"=","starts_with":"Починається з","ends_with":"Закінчується","greater_than":"більше","less_than":"менше"}},"search_status":{"headline":"Статус пошуку:","current_scope":"Область:","current_filters":"Поточний фільтр:","no_current_filters":"Жоден"},"status_tag":{"yes":"Так","no":"Ні"},"main_content":"Створіть %{model}#main_content для відображення вмісту.","logout":"Вийти","powered_by":"Powered by %{active_admin} %{version}","sidebars":{"filters":"Фільтри","search_status":"Статус пошуку"},"pagination":{"empty":"%{model} не знайдено","one":"Результат: \u003cb\u003e1\u003c/b\u003e %{model}","one_page":"Результат: \u003cb\u003e%{n}\u003c/b\u003e %{model}","multiple":"Результат: %{model} \u003cb\u003e%{from}\u0026nbsp;-\u0026nbsp;%{to}\u003c/b\u003e з \u003cb\u003e%{total}\u003c/b\u003e","multiple_without_total":"Результат: %{model} \u003cb\u003e%{from}\u0026nbsp;-\u0026nbsp;%{to}\u003c/b\u003e","entry":{"one":"запис","few":"записи","many":"записів","other":"записів"}},"any":"Будь-який","blank_slate":{"content":"Поки-що немає %{resource_name}.","link":"Створити"},"dropdown_actions":{"button_label":"Oперації"},"batch_actions":{"button_label":"Групові операції","default_confirmation":"Ви справді бажаєте це зробити?","delete_confirmation":"Ви впевнені, що хочете видалити %{plural_model}?","succesfully_destroyed":{"one":"Успішно видалено: 1 %{model}","few":"Успішно видалено: %{count} %{plural_model}","many":"Успішно видалено: %{count} %{plural_model}","other":"Успішно видалено: %{count} %{plural_model}"},"selection_toggle_explanation":"(Скасувати все / Зняти виділення)","link":"Створити","action_label":"%{title} вибране","labels":{"destroy":"Видалити"}},"comments":{"resource_type":"Тип ресурса","author_type":"Тип автора","body":"Текст","author":"Автор","title":"Коментар","add":"Додати Коментар","resource":"Ресурс","no_comments_yet":"Поки-що немає коментарів.","author_missing":"Анонім","title_content":"Коментарі (%{count})","errors":{"empty_text":"Коментар не збережено, текст не повинен бути пустим."}},"devise":{"username":{"title":"Ім'я користувача"},"email":{"title":"Електронна пошта"},"subdomain":{"title":"Піддомен"},"password":{"title":"Пароль"},"sign_up":{"title":"Зареєструватися","submit":"Зареєструватися"},"login":{"title":"Вхід","remember_me":"Запам'ятати мене","submit":"Увійти"},"reset_password":{"title":"Забули пароль?","submit":"Скинути пароль"},"change_password":{"title":"Зміна паролю","submit":"Змінити пароль"},"unlock":{"title":"Відправити повторно інструкції з розблокування","submit":"Відправити повторно інструкції з розблокування"},"resend_confirmation_instructions":{"title":"Відправити повторно листа з активацією","submit":"Відправити повторно листа з активацією"},"links":{"sign_up":"Зареєструватись","sign_in":"Увійти","forgot_your_password":"Забули пароль?","sign_in_with_omniauth_provider":"Увійти з допомогою %{provider}","resend_unlock_instructions":"Повторна відправка інструкцій розблокування","resend_confirmation_instructions":"Повторна відправка інструкцій підтвердження"}},"unsupported_browser":{"headline":"Зверніть, будь-ласка, увагу, що ActiveAdmin більше не підтримує Internet Explorer 8 версії і нижче","recommendation":"Ми рекомендуємо оновити версію вашого браузеру (\u003ca href=\"http://windows.microsoft.com/ie\"\u003eInternet Explorer\u003c/a\u003e, \u003ca href=\"https://chrome.google.com/\"\u003eGoogle Chrome\u003c/a\u003e, або \u003ca href=\"https://mozilla.org/firefox/\"\u003eFirefox\u003c/a\u003e).","turn_off_compatibility_view":"Якщо ви використовуєте IE 9 і вище, переконайтесь, що \u003ca href=\"http://windows.microsoft.com/en-US/windows7/webpages-look-incorrect-in-Internet-Explorer\"\u003eви вимкнули опцію \"Перегляд в режимі сумісності\"\u003c/a\u003e."},"access_denied":{"message":"Ви не авторизовані для виконання даної дії."},"index_list":{"table":"Таблиця","block":"Список","grid":"Сітка","blog":"Блог"}}},"vi":{"active_admin":{"dashboard":"Dashboard","dashboard_welcome":{"welcome":"Chào mừng bạn đến với Active Admin. Đây là trang Dashboard mặc định.","call_to_action":"Để thêm phần phần cho trang Dashboar hãy chỉnh sửa 'app/admin/dashboard.rb'"},"view":"Xem","edit":"Chỉnh sửa","delete":"Xóa","delete_confirmation":"Bạn có chắc chắn rằng mình muốn xóa cái này?","new_model":"Tạo mới %{model}","edit_model":"Chỉnh sửa %{model}","delete_model":"Xóa %{model}","details":"%{model} Chi tiết","cancel":"Hủy","empty":"Trống","previous":"Trước","next":"Tiếp","download":"Download:","has_many_new":"Thêm mới %{model}","has_many_delete":"Xóa","has_many_remove":"Hủy bỏ","filters":{"buttons":{"filter":"Lọc","clear":"Xóa dữ liệu lọc"},"predicates":{"contains":"Thông tin","equals":"Bằng","starts_with":"Bắt đầu với","ends_with":"Kết thúc với việc","greater_than":"Lớn hơn","less_than":"Nhỏ hơn"}},"status_tag":{"yes":"Có","no":"Không Có"},"main_content":"Xin bổ sung %{model}#main_content để hiển thị nội dung.","logout":"Đăng xuất","powered_by":"Powered by %{active_admin} %{version}","sidebars":{"filters":"Bộ Lọc"},"pagination":{"empty":"Không có %{model} nào được tìm thấy","one":"Đang hiển thị \u003cb\u003e1\u003c/b\u003e %{model}","one_page":"Đang hiển thị \u003cb\u003etất cả %{n}\u003c/b\u003e %{model}","multiple":"Đang hiển thị %{model} \u003cb\u003e%{from}\u0026nbsp;-\u0026nbsp;%{to}\u003c/b\u003e of \u003cb\u003e%{total}\u003c/b\u003e trong tất cả.","multiple_without_total":"Đang hiển thị %{model} \u003cb\u003e%{from}\u0026nbsp;-\u0026nbsp;%{to}\u003c/b\u003e.","entry":{"one":"entry","other":"entries"}},"any":"Bất kỳ","blank_slate":{"content":"Chưa có %{resource_name}.","link":"Tạo mới"},"dropdown_actions":{"button_label":"Hành động"},"batch_actions":{"button_label":"Hành động hàng loạt","default_confirmation":"Bạn có chắc bạn muốn làm điều này?","delete_confirmation":"Bạn có chắc chắn muốn xóa những %{plural_model}?","succesfully_destroyed":{"one":"Đã xóa thành công 1 %{model}","other":"Đã xóa thành công %{count} %{plural_model}"},"selection_toggle_explanation":"(Thay đổi lựa chọn)","link":"Tạo mới","action_label":"%{title} được chọn","labels":{"destroy":"Xóa"}},"comments":{"body":"Nội dung","author":"Tác giả","title":"Bình luận","add":"Thêm bình luận","resource":"Tài nguyên","no_comments_yet":"Chưa có bình luận.","title_content":"Bình luận (%{count})","errors":{"empty_text":"Lời bình luận chưa được lưu, vì nội dung còn trống."}},"devise":{"login":{"title":"Đăng nhập","remember_me":"Ghi nhớ tôi","submit":"Đăng nhập"},"reset_password":{"title":"Quên mật khẩu của bạn?","submit":"Thiết lập lại mật khẩu của tôi"},"change_password":{"title":"Thay đổi mật khẩu của bạn","submit":"Thay đổi mật khẩu của tôi"},"links":{"sign_in":"Đăng nhập","forgot_your_password":"Quên mật khẩu của bạn?","sign_in_with_omniauth_provider":"Đăng nhập với %{provider}"}}}},"cs-CZ":{"pageflow":{"public":{"_language":"Česky","audio":"Zvuk","back":"Zpět","back_to_chapter":"Zpět do sekce","before_after":{"drag_hint":"Zmáčkněte levé tlačítko myši a pohybujte se vlevo či vpravo.","hint":"Zobrazení před/po","leave_view":"Opustit zobrazení před/po","start":"Spustit zobrazení před/po","start_title":"Spustit zobrazení před/po"},"chapter":"Kapitola","chart":{"toggle":"Přepnout"},"close":"Zavřít","close_hint":"Zavřít nápovědu","close_navigation":"Zavřít navigaci","close_overview":"Zavřít náhled","deprecated_browser":"\u003cp\u003ePoužíváte zastaralý prohlížeč, je proto možné, že nedokáže tuto stránku zobrazit tak, jak byla navržena. Doporučujeme jej aktualizovat na nejnovější verzi.\u003c/p\u003e","embedded_video":{"leave_video":"Zavřít vložené video"},"enlarge_view":"Zvětšit zobrazení","enter_fullscreen":"Přes celou obrazovku","first_page":"Na titulní stranu","forward":"Vpřed","fullscreen":"Přes celou obrazovku","goto_first_page":"Jít na první stránku","goto_top":"Jít na první stránku","hide_text":"Skrýt text","home":"Začátek","imprint":"Tiráž","javascript_hint":"Tato aplikace vyžaduje pro správné fungování JavaScript. Váš prohlížeč JavaScript nepodporuje, nebo jej máte vypnutý.","languages":{"ar":null,"cs":null,"de":null,"dk":null,"el":null,"en":null,"es":null,"fr":null,"it":null,"nl":null,"pl":null,"pt":null,"ru":null,"sr":null,"tr":null,"unknown":null,"zh":null},"leave_fullscreen":"Opustit režim přes celou obrazovku","lets_go":"Spustit","logo":"Logo","media_quality":null,"mute_off":"Zapnout zvuk","mute_on":"Vypnout zvuk","navigate_top":"Jít na první stránku","navigation":"Navigace","new_pages_box":{"additional_pages_html":"...a \u003cspan\u003e\u003c/span\u003e další","description":"Stránky, které zde přibyly od vaší poslední návštěvy:","title":"Nové stránky"},"notice":"Upozornění","open_audio":null,"open_navigation":"Otevřít navigaci","open_overview":"Otevřít obsah","open_video":null,"overview":"Obsah","panorama":{"close":"Zavřít 360° panorama a zobrazit text","start":"Otevřít 360° panorama"},"play_video":"Přehrát video","scroll_back_indicator":" ","scroll_down":"Scrollujte dolů","scroll_hint":"Procházejte stránky otáčením kolečka myši nebo šipkami na klávesnici","scroll_indicator":"Pokračujte dolů","scroll_left":"Pokračujte scrollováním dolů","scroll_right":"Scrollujte doprava","scroll_up":"Scrollujte nahoru","share":"Sdílejte","share_on_facebook":"Sdílejte na Facebooku","share_on_google":"Sdílejte na Google+ ","share_on_twitter":"Sdílejte na Twitteru","share_this_entry":"Celý příspěvek","share_this_page":"Přímo tuto stránku","show_home":"Start","show_text":"Zobrazit text","skip_links_content":"Přejít na obsah","skip_links_navigation":"Přejít k navigaci","skip_links_top_navigation":"Na hlavní navigaci","sound_hint":"Tato multimediální reportáž obsahuje zvukovou stopu. Máte zapnuté reproduktory, případně nasazená sluchátka?","start_audio":"Poslechněte si","start_video":"Podívejte se","swipe_hint":"Listujte tahem prstu po obrazovce","swipe_indicator":"Pokračujte tahem prstu","text_track_modes":{"auto":null,"auto_off":null,"none":null},"text_tracks":null,"video":"Video","video_qualities":{"annotations":{"4k":null,"fullhd":null,"medium":null},"labels":{"4k":null,"auto":null,"fullhd":null,"medium":null}},"volume":"Hlasitost","vr":{"no_vr":{"link":null,"text":null},"select_quality":null,"start":null,"start_cardboard":null,"video_qualities":{"4k":null,"fullhd":null,"high":null},"video_quality_annotations":{"4k":null,"fullhd":null,"high":null}}}}},"fa-IR":{"pageflow":{"public":{"_language":"انگلیسی","audio":"صدا","back":"بازگشت","back_to_chapter":"برگشت به فصل","before_after":{"drag_hint":null,"hint":"قبل / بعد از نمایش","leave_view":"ترک قبل / بعد از نمایش","start":"شروع قبل / بعد از نمایش","start_title":"شروع قبل / بعد از نمایش"},"chapter":"فصل","chart":{"toggle":"تغییر وضعیت"},"close":"بستن","close_hint":"بستن","close_navigation":"بستن جهت یابی","close_overview":"بستن مرور کلی","deprecated_browser":" این صفحه ممکن است کار کند و در مرورگر شما منسوخ شده است به عنوان در نظر گرفته شده. ما توصیه می کنیم  مرورگر خود را به نسخه های اخیر  به روز رسانی کنید.","embedded_video":{"leave_video":"ترک ویدئو های جاسازی شده"},"enlarge_view":"بزرگ نمایی نمایش","enter_fullscreen":"حالت تمام صفحه ","first_page":"صفحه اول","forward":"رو به جلو","fullscreen":"تمام صفحه","goto_first_page":"برو به صفحه اول","goto_top":"برو به صفحه اول","hide_text":"مخفی کردن متن","home":"شروع","imprint":"منقوش کردن","javascript_hint":"این نرم افزار با بهره گیری از جاوا اسکریپت برای قابلیت های پیشرفته و تجربه کاربر کار می کند . مرورگر شما ممکن است جاوا اسکریپت را پشتیبانی نکند و یا ممکن است غیر فعال شود.","languages":{"ar":null,"cs":null,"de":null,"dk":null,"el":null,"en":null,"es":null,"fr":null,"it":null,"nl":null,"pl":null,"pt":null,"ru":null,"sr":null,"tr":null,"unknown":null,"zh":null},"leave_fullscreen":"خروج از حالت تمام صفحه","lets_go":"بزن بریم","logo":"بوگو / مارک اختصاری","media_quality":null,"mute_off":"باصدا کردن","mute_on":"قطع صدا","navigate_top":"برو به صفحه اول","navigation":"جهت یابی صفحه","new_pages_box":{"additional_pages_html":"و به \u003cspan\u003e \u003c/ span\u003e در بیشتر ...","description":"از آخرین بازدید شما،این صفحات به  pageflow اضافه شده است:","title":"صفحه جدید"},"notice":"یادداشت","open_audio":null,"open_navigation":"بازکردن جهت یابی صفحه","open_overview":"بازکردن نمای کلی","open_video":null,"overview":"نمای کلی","panorama":{"close":"بستن  360 درجه پانوراما و نمایش متن","start":"شروع  360 درجه پانوراما"},"play_video":"پخش ویدئو","scroll_back_indicator":"کلیک کنید تا متن / ترجمه را وارد کنید","scroll_down":"به پایین بروید","scroll_hint":"برای حرکت بین صفحات از چرخ ماوس و یا کلیدهای جهت دار بر روی صفحه کلید خود استفاده  کنید.","scroll_indicator":"برای ادامه به پایین بروید","scroll_left":"حرکت به طرف چپ","scroll_right":"حرکت به طرف راست","scroll_up":"حرکت به طرف بالا","share":" به اشتراک بگذارید","share_on_facebook":"در فیسبوک به اشتراک بگذارید","share_on_google":"در گوگل پلاس به اشتراک بگذارید","share_on_twitter":"در تویتیتر به اشتراک بگذارید","share_this_entry":"این داستان","share_this_page":"این صفحه","show_home":"شروع","show_text":"نمایش متن","skip_links_content":"رفتن بطرف محتوا","skip_links_navigation":"رفتن به جهت یابی صفحه","skip_links_top_navigation":"رفتن به صفحه اصلی جهت یابی صفحه","sound_hint":"این قالب داستان های چند رسانه ای با استفاده از ویدئو و فیلم های صوتی کار می کند. لطفا مطمئن شوید که بلندگوهای کامپیوتر روشن هستند.","start_audio":"شروع پخش صوتی ","start_video":"شروع پخش تصویری","swipe_hint":"حرکت بین صفحات","swipe_indicator":"حرکت برای ادامه","text_track_modes":{"auto":null,"auto_off":null,"none":null},"text_tracks":null,"video":"تصویر","video_qualities":{"annotations":{"4k":null,"fullhd":null,"medium":null},"labels":{"4k":null,"auto":null,"fullhd":null,"medium":null}},"volume":"اندازه (صدا / تصویر)","vr":{"no_vr":{"link":null,"text":null},"select_quality":null,"start":null,"start_cardboard":null,"video_qualities":{"4k":null,"fullhd":null,"high":null},"video_quality_annotations":{"4k":null,"fullhd":null,"high":null}}}}},"gn":{"pageflow":{"public":{"_language":"Guarani","audio":"Re hendu hagũa","back":"Eju jey","back_to_chapter":"Eju jey kapítulope","before_after":{"drag_hint":null,"hint":"Re hecha anteve/upéi rire","leave_view":"Re sé hagũa la anteve/upéi rire gui","start":"Emo ñepyrũ hagũa anteve/upéi rire","start_title":"Emo ñepyrü hagũa anteve/upéi rire"},"chapter":"Kapitulo","chart":{"toggle":"Ejopy"},"close":"Emboty","close_hint":"Emboty ñe’ẽ","close_navigation":"Emboty nde navegador","close_overview":"Emboty paité","deprecated_browser":"\u003cp\u003eKo navegador reipurúva hina itujama ha ikatú ndoikoporái ndeve. E mbo pyahuve vaerã.\u003c/p\u003e","embedded_video":{"leave_video":"Re sẽ hagũa video oñondivepa gui"},"enlarge_view":"Re hecha hagũa tuichave","enter_fullscreen":"Re hecha enteroité nde pantallape","first_page":"Kuatia rogué peteĩ","forward":"Ekorré","fullscreen":"Re hecha paité","goto_first_page":"Jaha kuaatia rogué peteĩpe","goto_top":"Jaha kuaatia rogué peteĩpe","hide_text":"Embokañy kuatia ñe’ẽ","home":"Ñepyrũ","imprint":"Embo haí kuatiápe","javascript_hint":"Ko aplicación oipurú hina JavaScript oiko poräve hagüa ha reipuru porãve hagũa. Ikatú nde navegador itujama ha ndoikoi pype tẽra ikatu oguereko ha reikotevẽ emyandynte.","languages":{"ar":null,"cs":null,"de":null,"dk":null,"el":null,"en":null,"es":null,"fr":null,"it":null,"nl":null,"pl":null,"pt":null,"ru":null,"sr":null,"tr":null,"unknown":null,"zh":null},"leave_fullscreen":"Emboty la rehechava","lets_go":"Ña ñepyrũ","logo":"Ta’anga","media_quality":null,"mute_off":"Ehendú jey","mute_on":"Kirirĩ","navigate_top":"Jaha kuatia rogué peteĩpe","navigation":"Emo ñepyrũ poravokuaa","new_pages_box":{"additional_pages_html":"...oĩ \u003cspan\u003e\u003c/span\u003e ve","description":"Nde reho rire, oĩve ko’ape ipyahuva","title":"Kuatia rogué pyahu"},"notice":"Ñe’ẽ mi","open_audio":null,"open_navigation":"Emoñepyrũ","open_overview":"Rehecha paité hagũa","open_video":null,"overview":"Ehecha paité","panorama":{"close":"Emboty ko jehecha paité ha emboñepyrũ ñe’ẽmi","start":"Emoñepyrũ jehecha paité"},"play_video":"Emoñepyrũ ta’anga omyiva","scroll_back_indicator":"Terehó hapykuépe","scroll_down":"Terehó yvype","scroll_hint":"Reipurú kuaá nde anguja ñerenga tera nde teclado e korre hagũa opá kuatia roguere","scroll_indicator":"Terehó yvyoto re segui hagũa","scroll_left":"Terehó izquierdape","scroll_right":"Terehó derechape","scroll_up":"Terehó yvatepe","share":"Emombe’ú","share_on_facebook":"Emombe’ú Facebookpe","share_on_google":"Emombe’ú Google+pe","share_on_twitter":"Emombe’ú Twitterpe","share_this_entry":"Ko ñemombe’u","share_this_page":"Ko kuatia rogué","show_home":"Ñepyrũ","show_text":"Ehechuka ñe’ẽmi","skip_links_content":"Jaha hyepype","skip_links_navigation":"Jaha menupe","skip_links_top_navigation":"Jaha menu principalpe","sound_hint":"Ko’ape rehechata ha rehenduta ta’anga omyiva ha oñe’eva. Emañamí kena la nde parlantekuéra oĩ porãpa.","start_audio":"Emo ñepyrũ rehendu hagũa","start_video":"Emo ñepyrũ rehecha hagũa","swipe_hint":"Ikatú embohasá nde kuãme","swipe_indicator":"Embohasá nde kuã re seguí hagũa","text_track_modes":{"auto":null,"auto_off":null,"none":null},"text_tracks":null,"video":"Ta’angá omyiva","video_qualities":{"annotations":{"4k":null,"fullhd":null,"medium":null},"labels":{"4k":null,"auto":null,"fullhd":null,"medium":null}},"volume":"Ehendú hagũa","vr":{"no_vr":{"link":null,"text":null},"select_quality":null,"start":null,"start_cardboard":null,"video_qualities":{"4k":null,"fullhd":null,"high":null},"video_quality_annotations":{"4k":null,"fullhd":null,"high":null}}}}},"ms":{"pageflow":{"public":{"_language":"Bahasa Melayu","audio":"Audio","back":"Kembali","back_to_chapter":"Kebali ke bab","before_after":{"drag_hint":null,"hint":"Paparan sebelum/selepas","leave_view":"Tinggalkan paparan sebelum/selepas","start":"Mulakan paparan sebelum/selepas","start_title":"Mulakan paparan sebelum/selepas"},"chapter":"Bab","chart":{"toggle":"Togol"},"close":"Tutup ","close_hint":"Tutup petua","close_navigation":"Tutup navigasi","close_overview":"Tutup gambaran keseluruhan","deprecated_browser":"\u003cp\u003ePelayar anda tidak dikemaskini dan halaman ini mungkin tidak berfungsi seperti yang sepatutnya. Kami mengesyorkan supaya anda menaiktaraf pelayar anda kepada versi yang terkini.\u003c/p\u003e","embedded_video":{"leave_video":"Tinggalkan pautan video"},"enlarge_view":"Besarkan paparan","enter_fullscreen":"Masuki mod paparan penuh","first_page":"Halaman pertama","forward":"Ke hadapan ","fullscreen":"Paparan penuh","goto_first_page":"Pergi ke halaman pertama","goto_top":"Pergi ke halaman pertama","hide_text":"Sembunyikan teks","home":"Mula","imprint":"Tanda","javascript_hint":"Aplikasi ini menggunakan JavaScript untuk mempertingkatkan fungsi dan pengalaman pengguna. Pelayar anda mungkin tidak menyokong JavaScript atau ia telah dimatikan.","languages":{"ar":null,"cs":null,"de":null,"dk":null,"el":null,"en":null,"es":null,"fr":null,"it":null,"nl":null,"pl":null,"pt":null,"ru":null,"sr":null,"tr":null,"unknown":null,"zh":null},"leave_fullscreen":"Tinggalkan mod paparan penuh","lets_go":"Jom","logo":"Logo","media_quality":null,"mute_off":"Nyahbisukan","mute_on":"Bisukan","navigate_top":"Pergi ke halaman pertama","navigation":"Navigasi","new_pages_box":{"additional_pages_html":"...dan \u003cspan\u003e\u003c/span\u003e selebihnya","description":"Sejak kunjungan terakhir anda, halaman baru telah ditambah ke Pageflow ini: ","title":"Halaman Baru"},"notice":"Notis","open_audio":null,"open_navigation":"Buka navigasi","open_overview":"Buka gambaran umum","open_video":null,"overview":"Gambaran umum","panorama":{"close":"Tutup panorama 360° dan paparan teks","start":"Mulakan panorama 360°"},"play_video":"Mainkan video","scroll_back_indicator":"Skrol kembali","scroll_down":"Skrol ke bawah","scroll_hint":"Gunakan roda tetikus atau kekunci anak panah pada papan kekunci anda untuk menelusuri antara halaman.","scroll_indicator":"Skrol ke bawah untuk teruskan","scroll_left":"Skrol ke kiri","scroll_right":"Skrol ke kanan","scroll_up":"Skrol ke atas","share":"Kongsi","share_on_facebook":"Kongsi di Facebook","share_on_google":"Kongsi di Google+","share_on_twitter":"Kongsi di Twitter","share_this_entry":"Cerita ini","share_this_page":"Cerita ini","show_home":"Mula","show_text":"Paparkan teks","skip_links_content":"Pergi ke isi kandungan","skip_links_navigation":"Pergi ke navigasi","skip_links_top_navigation":"Pergi ke navigasi utama","sound_hint":"Format cerita multimedia ini menggunakan rakaman video dan audio. Pastikan pembuka suara anda dihidupkan.","start_audio":"Mulakan audio sekarang","start_video":"Mulakan video sekarang","swipe_hint":"Leret untuk menelusuri antara halaman.","swipe_indicator":"Leret untuk teruskan","text_track_modes":{"auto":null,"auto_off":null,"none":null},"text_tracks":null,"video":"Video","video_qualities":{"annotations":{"4k":null,"fullhd":null,"medium":null},"labels":{"4k":null,"auto":null,"fullhd":null,"medium":null}},"volume":"Kelantangan","vr":{"no_vr":{"link":null,"text":null},"select_quality":null,"start":null,"start_cardboard":null,"video_qualities":{"4k":null,"fullhd":null,"high":null},"video_quality_annotations":{"4k":null,"fullhd":null,"high":null}}}}},"nl-BE":{"pageflow":{"public":{"_language":"Nederlands (België)","audio":"Audio","back":"Terug","back_to_chapter":"Terug naar hoofdstuk","before_after":{"drag_hint":null,"hint":"Voor / na weergave","leave_view":"Verlaat de voor / na weergave ","start":"Start de voor / na weergave","start_title":"Start de voor / na weergave"},"chapter":"Hoofdstuk","chart":{"toggle":"In-/uitschakelen"},"close":"Sluiten","close_hint":"Hint sluiten","close_navigation":"Navigatie sluiten","close_overview":"Overzicht sluiten","deprecated_browser":"\u003cp\u003eUw browser is verouderd en deze pagina werkt mogelijk niet zoals verwacht. We raden u aan uw browser te upgraden naar de nieuwste versie.\u003cp\u003e","embedded_video":{"leave_video":"Ingesloten video verlaten"},"enlarge_view":"Weergave vergroten","enter_fullscreen":"Volledig scherm weergeven","first_page":"Eerste pagina","forward":"Verder","fullscreen":"Volledig scherm","goto_first_page":"Ga naar de eerste pagina","goto_top":"Ga naar de eerste pagina","hide_text":"Tekst verbergen","home":"Starten","imprint":"Colofon","javascript_hint":"Deze toepassing gebruikt JavaScript voor verbeterde functionaliteit en gebruikservaring. Uw browser ondersteunt JavaScript mogelijk niet of het is mogelijk uitgeschakeld.","languages":{"ar":null,"cs":null,"de":null,"dk":null,"el":null,"en":null,"es":null,"fr":null,"it":null,"nl":null,"pl":null,"pt":null,"ru":null,"sr":null,"tr":null,"unknown":null,"zh":null},"leave_fullscreen":"Volledig scherm afsluiten","lets_go":"Hier gaan we","logo":"Logo","media_quality":null,"mute_off":"Dempen uit","mute_on":"Dempen","navigate_top":"Ga naar eerste pagina","navigation":"Navigatie","new_pages_box":{"additional_pages_html":"… en \u003cspan\u003e\u003c/span\u003e meer","description":"Sinds uw laatste bezoek werden er pagina’s toegevoegd aan deze Pageflow:","title":"Nieuwe pagina’s"},"notice":"Opmerking","open_audio":null,"open_navigation":"Navigatie openen","open_overview":"Overzicht openen","open_video":null,"overview":"Overzicht","panorama":{"close":"360° panorama afsluiten en tekst weergeven","start":"360° panorama starten"},"play_video":"Video afspelen","scroll_back_indicator":null,"scroll_down":"Omlaag schuiven","scroll_hint":"Gebruik het muiswiel of de pijltoetsen op uw toetsenbord om tussen pagina’s te navigeren.","scroll_indicator":"Scroll om door te gaan","scroll_left":"Naar links schuiven","scroll_right":"Naar rechts schuiven","scroll_up":"Omhoog schuiven","share":"Delen","share_on_facebook":"Delen op Facebook","share_on_google":"Delen op Google+","share_on_twitter":"Delen op Twitter","share_this_entry":"Dit artikel","share_this_page":"Deze pagina","show_home":"Start","show_text":"Tekst weergeven","skip_links_content":"Ga naar inhoud","skip_links_navigation":"Ga naar navigatie","skip_links_top_navigation":"Ga naar hoofdnavigatie","sound_hint":"Dit multimediaverhaal gebruikt video- en audioclips. Ga na of uw luidsprekers ingeschakeld zijn.","start_audio":"Start audio now","start_video":"Start video now","swipe_hint":"Vegen om tussen pagina‘s te navigeren","swipe_indicator":"Vegen om verder te gaan","text_track_modes":{"auto":null,"auto_off":null,"none":null},"text_tracks":null,"video":"Video","video_qualities":{"annotations":{"4k":null,"fullhd":null,"medium":null},"labels":{"4k":null,"auto":null,"fullhd":null,"medium":null}},"volume":"Volume","vr":{"no_vr":{"link":null,"text":null},"select_quality":null,"start":null,"start_cardboard":null,"video_qualities":{"4k":null,"fullhd":null,"high":null},"video_quality_annotations":{"4k":null,"fullhd":null,"high":null}}}}},"pl-PL":{"pageflow":{"public":{"_language":"Polski","audio":"Audio","back":"Powrót","back_to_chapter":"Powrót do rozdziału","before_after":{"drag_hint":null,"hint":"Przed/po widoku","leave_view":"Po podgląd i pokaż  tekst","start":"Start widok przed/po","start_title":"Start widok przed/po"},"chapter":"Rozdział","chart":{"toggle":"Powiększ lub pomniejsz podgląd"},"close":"Zamknij","close_hint":"Zamknij wskazówkę","close_navigation":"Zamknij nawigację","close_overview":"Zamknij przegląd","deprecated_browser":"\u003cp\u003e Szanowny uzytkowniku, \u003c/p\u003e\u003cp\u003eniestety używasz starej wersji przeglądarki, dlatego przygotowane treści nie  mogą być pokazane prawidłowo.  Prosimy zaktualizować do nowej wersji.\u003c/p\u003e","embedded_video":{"leave_video":"Opuść wbudowane video"},"enlarge_view":"Powiększ podgląd","enter_fullscreen":"Pełny ekran","first_page":"Pierwsza strona","forward":"Do przodu","fullscreen":"Pełny ekran","goto_first_page":"Do pierwszej strony","goto_top":"Do początku","hide_text":"Ukryj tekst","home":"Strona główna","imprint":"Nota","javascript_hint":"Dla poprawnego działania strony potrzebujesz JavaScript.","languages":{"ar":null,"cs":null,"de":null,"dk":null,"el":null,"en":null,"es":null,"fr":null,"it":null,"nl":null,"pl":null,"pt":null,"ru":null,"sr":null,"tr":null,"unknown":null,"zh":null},"leave_fullscreen":"Zakończ odtwarzanie w pełnym ekranie","lets_go":"Rozpocznij","logo":"Logo","media_quality":null,"mute_off":"Włącz dźwięk","mute_on":"Wyłącz dźwięk","navigate_top":"Do początku","navigation":"Nawigacja","new_pages_box":{"additional_pages_html":"...oraz \u003cspan\u003e\u003c/span\u003ekolejne","description":"Od ostatniej wizyty to Pageflow zostały dodane nowe strony:","title":"Nowe strony"},"notice":"Wskazówka","open_audio":null,"open_navigation":"Otwórz nawigację","open_overview":"Otwórz przegląd","open_video":null,"overview":"Przegląd","panorama":{"close":"Opuść widok 360° i pokaż tekst","start":"Otwórz widok 360°"},"play_video":"Odtwórz video","scroll_back_indicator":"Przewijanie wstecz","scroll_down":"Przewiń niżej","scroll_hint":"Poprzez mysz lub strzałki na klawiaturze  zostanie przywołany kolejny rodział strony.","scroll_indicator":"Przewiń aby czytać dalej","scroll_left":"Przewiń w lewo","scroll_right":"Przewiń w prawo","scroll_up":"Przewiń do góry","share":"Udostępnij","share_on_facebook":"Udostępnij w facebook","share_on_google":"Udostępnij w Google+","share_on_twitter":"Udostępnij w Twitter","share_this_entry":"Udsotępnij","share_this_page":"Udostępnij stronę","show_home":"Do strony głównej","show_text":"Pokaż tekst","skip_links_content":"Do treści","skip_links_navigation":"Do nawigacji strony","skip_links_top_navigation":"Do nawigacji górnej","sound_hint":"W tym formacie reportażu udostępniamy obok zdjęć i treści również dźwięk , dlatego prosimy o odpowiednie uistawienie głośników w systemie.","start_audio":"Włącz dźwięk","start_video":"Rozpocznij video","swipe_hint":"Przesunięcie spowoduje przejście do kolejnego rozdziału","swipe_indicator":"Przesuń aby zobaczyć tekst","text_track_modes":{"auto":null,"auto_off":null,"none":null},"text_tracks":null,"video":"Video","video_qualities":{"annotations":{"4k":null,"fullhd":null,"medium":null},"labels":{"4k":null,"auto":null,"fullhd":null,"medium":null}},"volume":"głośność","vr":{"no_vr":{"link":null,"text":null},"select_quality":null,"start":null,"start_cardboard":null,"video_qualities":{"4k":null,"fullhd":null,"high":null},"video_quality_annotations":{"4k":null,"fullhd":null,"high":null}}}}},"rm":{"pageflow":{"public":{"_language":"Rumantsch","audio":"Audio","back":"Enavos","back_to_chapter":"Enavos al chapitel","before_after":{"drag_hint":null,"hint":"Vista avant/suenter","leave_view":"Sortir da la vista avant/suenter","start":"Cumenzar cun vista avant/suenter","start_title":"Cumenzar cun vista avant/suenter"},"chapter":"Chapitel","chart":{"toggle":"midar"},"close":"Serrar","close_hint":"Serrar tip","close_navigation":"Serrar navigaziun","close_overview":"Serrar survista","deprecated_browser":"\u003cp\u003eVoss browser n'è betg pli actual ed i pudess esser, che questa pagina na funcziuna betg sco intenziunà. Nus proponin d'actualisar Voss browser a la versiun la pli actuala.\u003c/p\u003e","embedded_video":{"leave_video":"Sortir da embedded video"},"enlarge_view":"Engrondir la vista","enter_fullscreen":"Entrar en il modus da fullscreen","first_page":"Emprima pagina","forward":"Enavant","fullscreen":"Fullscreen","goto_first_page":"Ir a l'emprima pagina","goto_top":"Ir a l'emprima pagina","hide_text":"Zuppentar il text","home":"Cumenzar","imprint":"Impressum","javascript_hint":"Questa applicaziun fa diever da JavaScript per dapli funcziuns e che la chaussa saja pli pratica per l'utilisader. Forsa na sustegna Voss browser betg JavaScript ni che JavaScript pudess esser deactivà.","languages":{"ar":null,"cs":null,"de":null,"dk":null,"el":null,"en":null,"es":null,"fr":null,"it":null,"nl":null,"pl":null,"pt":null,"ru":null,"sr":null,"tr":null,"unknown":null,"zh":null},"leave_fullscreen":"Sortir dal modus da fullscreen","lets_go":"Giaini!","logo":"Logo","media_quality":null,"mute_off":"Puspè tadlar!","mute_on":"Pssst!","navigate_top":"Ir a l'emprima pagina","navigation":"Navigaziun","new_pages_box":{"additional_pages_html":"...e \u003cspan\u003e\u003c/span\u003e dapli","description":"Dapi Voss'ultima visita èn vegnidas agiuntadas paginas a quest pageflow:","title":"Novas paginas"},"notice":"Avis","open_audio":null,"open_navigation":"Avrir navigaziun","open_overview":"Survista averta","open_video":null,"overview":"Survista","panorama":{"close":"Serrar panorama da 360° e mussar text","start":"Cumenzar panorama da 360°"},"play_video":"Laschar ir video","scroll_back_indicator":" ","scroll_down":"Scrollar engiu","scroll_hint":"Duvrar la roda sin la mieur u las frizzas sin la tastatura per navigar tranter las paginas.","scroll_indicator":"Scrollar engiu per continuar","scroll_left":"Scrollar a la sanestra","scroll_right":"Scrollar a la dretga","scroll_up":"Scrollar ensi","share":"Cundivider","share_on_facebook":"Cundivider sin Facebook","share_on_google":"Cundivider sin Google+","share_on_twitter":"Cundivider sin Twitter","share_this_entry":"Questa istorgia","share_this_page":"Questa pagina","show_home":"Cumenzar","show_text":"Mussar text","skip_links_content":"Ir al cuntegn","skip_links_navigation":"Ir a la navigaziun","skip_links_top_navigation":"Ir a la navigaziun principala","sound_hint":"Questa istorgia multimediala ha videos cun audio. Guardai d'avair activà Voss autpledaders!","start_audio":"Laschar ir l'audio uss","start_video":"Laschar ir video uss","swipe_hint":"Far vi e nà cun il det per navigar tranter paginas","swipe_indicator":"Far vi e nà cun il det per cuntinuar","text_track_modes":{"auto":null,"auto_off":null,"none":null},"text_tracks":null,"video":"Video","video_qualities":{"annotations":{"4k":null,"fullhd":null,"medium":null},"labels":{"4k":null,"auto":null,"fullhd":null,"medium":null}},"volume":"Volumen dal tun","vr":{"no_vr":{"link":null,"text":null},"select_quality":null,"start":null,"start_cardboard":null,"video_qualities":{"4k":null,"fullhd":null,"high":null},"video_quality_annotations":{"4k":null,"fullhd":null,"high":null}}}}},"ru-RU":{"pageflow":{"public":{"_language":"Русский","audio":"Аудио","back":"Назад ","back_to_chapter":"Вернуться в раздел","before_after":{"drag_hint":null,"hint":"Режим до/после","leave_view":"Выйти из режима до/после","start":"Начать просмотр в режиме до/после","start_title":"Начать просмотр в режиме до/после"},"chapter":"Раздел","chart":{"toggle":"Переключиться"},"close":"Закрыть","close_hint":"Закрыть примечание","close_navigation":"Закрыть навигацию","close_overview":"Закрыть обзор","deprecated_browser":"\u003cp\u003eВы используете устаревшую версию браузера, поэтому содержание страницы может отображаться некорректно. Рекомендуем вам установить последнюю версию\u003c/p\u003e","embedded_video":{"leave_video":"Выйти из режима просмотра видео"},"enlarge_view":"Увеличить изображение","enter_fullscreen":"Перейти в полноэкранный режим","first_page":"Первая страница","forward":"Вперед","fullscreen":"Полноэкранный режим","goto_first_page":"На первую страницу","goto_top":"Перейти на первую страницу","hide_text":"Скрыть текст","home":"Главная","imprint":"Выходные данные","javascript_hint":"Для правильного отображения страницы установите JavaScript.","languages":{"ar":null,"cs":null,"de":null,"dk":null,"el":null,"en":null,"es":null,"fr":null,"it":null,"nl":null,"pl":null,"pt":null,"ru":null,"sr":null,"tr":null,"unknown":null,"zh":null},"leave_fullscreen":"Выйти из полноэкранного режима","lets_go":"Старт","logo":"Логотип","media_quality":null,"mute_off":"со звуком","mute_on":"без звука","navigate_top":"Перейти к первой странице","navigation":"Навигация","new_pages_box":{"additional_pages_html":"и текстовый тег \u003cspan\u003e\u003c/span\u003e далее","description":"С момента вашего последнего посещения в этом проекте появились новые страницы:","title":"Новые страницы"},"notice":"Примечание","open_audio":null,"open_navigation":"Открыть навигацию","open_overview":"Открыть обзор","open_video":null,"overview":"Обзор","panorama":{"close":"Закрыть режим 360° и показать текст","start":"Начать просмотр в панорамном режиме 360°"},"play_video":"Смотреть видео","scroll_back_indicator":"Индикатор прокрутки страницы","scroll_down":"Прокрутить вниз","scroll_hint":"Используйте колесо мыши или стрелки на клавиатуре, чтобы переключаться между главами","scroll_indicator":"Прокрутите вниз, чтобы продолжить","scroll_left":"Прокрутить влево","scroll_right":"Прокрутить вправо","scroll_up":"Прокрутить вверх","share":"Поделиться","share_on_facebook":"Поделиться на Facebook","share_on_google":"Поделиться на Google+","share_on_twitter":"Поделиться на Twitter","share_this_entry":"этим материалом","share_this_page":"этой страницей","show_home":"На главную","show_text":"Показать текст","skip_links_content":"Перейти к содержанию","skip_links_navigation":"Перейти к навигации","skip_links_top_navigation":"Перейти к главной навигации","sound_hint":"Этот мультимедийный репортаж содержит аудио- и видеоэлементы. Убедитесь, что на вашем устройстве включен звук","start_audio":"Воспроизвести аудио","start_video":"Воспроизвести видео","swipe_hint":"Проведите пальцем по экрану, чтобы открыть следующую страницу","swipe_indicator":"Проведите пальцем по экрану, чтобы продолжить","text_track_modes":{"auto":null,"auto_off":null,"none":null},"text_tracks":null,"video":"Видео","video_qualities":{"annotations":{"4k":null,"fullhd":null,"medium":null},"labels":{"4k":null,"auto":null,"fullhd":null,"medium":null}},"volume":"Громкость","vr":{"no_vr":{"link":null,"text":null},"select_quality":null,"start":null,"start_cardboard":null,"video_qualities":{"4k":null,"fullhd":null,"high":null},"video_quality_annotations":{"4k":null,"fullhd":null,"high":null}}}}},"sr":{"pageflow":{"public":{"_language":"Srpski","audio":"Zvuk","back":"Nazad","back_to_chapter":"Nazad na sekciju","before_after":{"drag_hint":null,"hint":"Pre/Posle stranice","leave_view":"Napusti pre/posle stranice","start":"Start pre/posle stranice","start_title":"Start pre/posle stranice"},"chapter":"Sekcija","chart":{"toggle":"Toggle"},"close":"Zatvori","close_hint":"Zatvori hint","close_navigation":"Zatvori navigaciju","close_overview":"Zatvori overview","deprecated_browser":"\u003cp\u003eVaš pretraživač je zastareo, ova strana neće raditi kako je planirano. Preporučujemo da skinete poslednju verziju pretraživača.\u003c/p\u003e","embedded_video":{"leave_video":"Napusti embedovan video"},"enlarge_view":"Uvecati stranicu","enter_fullscreen":"Prikaži preko celog ekrana","first_page":"Početna strana","forward":"Napred","fullscreen":"Ceo ekran","goto_first_page":"Idi na početnu stranicu","goto_top":"Idi na prvu stranicu","hide_text":"Sakrij tekst","home":"Start","imprint":"Imprint","javascript_hint":"Ova aplikacija koristi Javascript za poboljšanu funkcionalnost i korisnički interfejs. Vaš browser ne podržava JavaScript ili je možda isključen.","languages":{"ar":null,"cs":null,"de":null,"dk":null,"el":null,"en":null,"es":null,"fr":null,"it":null,"nl":null,"pl":null,"pt":null,"ru":null,"sr":null,"tr":null,"unknown":null,"zh":null},"leave_fullscreen":"Napusti fullscreen mode","lets_go":"Idemo","logo":"Logo","media_quality":null,"mute_off":"Unmute","mute_on":"Mute","navigate_top":"Idi na prvu stranicu","navigation":"Navigacija","new_pages_box":{"additional_pages_html":"...i \u003cspan\u003e\u003c/span\u003e dalje","description":"Od vaše poslednje posete, stranice su dodate u ovaj pageflow:","title":"Nove Stranice"},"notice":"Beleška","open_audio":null,"open_navigation":"Otvori navigaciju","open_overview":"Otvori detaljan pregled","open_video":null,"overview":"Overview","panorama":{"close":"Zatvori 360° panoramu i tekst","start":"Start 360° panoramu"},"play_video":"Play video","scroll_back_indicator":" ","scroll_down":"Skroluj dole","scroll_hint":"Koristi točkić na mišu ili strelice na tastaturi i koristite navigaciju.","scroll_indicator":"Skroluj dole za nastavak","scroll_left":"Skroluj levo","scroll_right":"Skroluj desno","scroll_up":"Skroluj gore","share":"Share","share_on_facebook":"Share on Facebook","share_on_google":"Share on Google+","share_on_twitter":"Share on Twitter","share_this_entry":"Ovaj story","share_this_page":"Ova stranica","show_home":"Start","show_text":"Prikaži tekst","skip_links_content":"Idi na sekciju","skip_links_navigation":"Idi na navigaciju","skip_links_top_navigation":"Idi na glavnu navigaciju","sound_hint":"Ovaj format multimedia story koristi video i audio sadržaj. Molimo vas obratite pažnju da li su vam uključeni zvučnici.","start_audio":"Start audio now","start_video":"Start video now","swipe_hint":"Swipe za navigaciju između strana.","swipe_indicator":"Swipe za nastavak","text_track_modes":{"auto":null,"auto_off":null,"none":null},"text_tracks":null,"video":"Video","video_qualities":{"annotations":{"4k":null,"fullhd":null,"medium":null},"labels":{"4k":null,"auto":null,"fullhd":null,"medium":null}},"volume":"Zvuk","vr":{"no_vr":{"link":null,"text":null},"select_quality":null,"start":null,"start_cardboard":null,"video_qualities":{"4k":null,"fullhd":null,"high":null},"video_quality_annotations":{"4k":null,"fullhd":null,"high":null}}}}},"zh":{"pageflow":{"public":{"_language":"中国","audio":"音频","back":"返回","back_to_chapter":"返回章节","before_after":{"drag_hint":"拖动提示","hint":"前/后 查看","leave_view":"离开 前/后 查看","start":"开始 前/后 查看","start_title":"开始 前/后 查看"},"chapter":"章节","chart":{"toggle":"开关"},"close":"关闭","close_hint":"关闭提示","close_navigation":"关闭导航","close_overview":"关闭概述","deprecated_browser":"\u003cp\u003e您的浏览器已经过时，该界面或许不能正常工作. 我们建议您升级您的浏览器版本\u003c/p\u003e","embedded_video":{"leave_video":"离开嵌入的视频"},"enlarge_view":"进入大图模式","enter_fullscreen":"进入全屏模式","first_page":"首页","forward":"前一页","fullscreen":"全屏","goto_first_page":"进入第一页","goto_top":"进入第一页","hide_text":"隐藏文本","home":"开始","imprint":"盖章","javascript_hint":"本应用使用JavaScript工具增强用户体验和功能。您的浏览器不支持JavaScript或者已禁用。","languages":{"ar":null,"cs":null,"de":null,"dk":null,"el":null,"en":null,"es":null,"fr":null,"it":null,"nl":null,"pl":null,"pt":null,"ru":null,"sr":null,"tr":null,"unknown":null,"zh":null},"leave_fullscreen":"退出全屏","lets_go":"一起走","logo":"标志","media_quality":null,"mute_off":"取消静音","mute_on":"静音","navigate_top":"进入第一页","navigation":"导航","new_pages_box":{"additional_pages_html":"...和 \u003cspan\u003e\u003c/span\u003e 更多","description":"从你上次访问后，界面已经被加到页面流:","title":"新界面"},"notice":"通知","open_audio":null,"open_navigation":"打开导航","open_overview":"打开缩略图","open_video":null,"overview":"缩略图","panorama":{"close":"关闭 360° 全景并显示文字","start":"打开 360° 全景"},"play_video":"播放视频","scroll_back_indicator":" ","scroll_down":"向下滚动","scroll_hint":"使用鼠标滚轮或键盘上的方向键进行界面间的切换。","scroll_indicator":"继续向下滚动","scroll_left":"向左滚动","scroll_right":"向右滚动","scroll_up":"向上滚动","share":"分享","share_on_facebook":"分享到 Facebook","share_on_google":"分享到 Google+","share_on_twitter":"分享到 Twitter","share_this_entry":"这个故事","share_this_page":"这个界面","show_home":"开始","show_text":"显示文字","skip_links_content":"查看内容","skip_links_navigation":"跳转到导航","skip_links_top_navigation":"跳转到主导航","sound_hint":"这个多媒体故事需要音频和视频播放。请确认话筒和音响开启状态。","start_audio":"立即播放音频","start_video":"立即播放视频","swipe_hint":"滑动界面间导航","swipe_indicator":"继续滑动","text_track_modes":{"auto":null,"auto_off":null,"none":null},"text_tracks":null,"video":"视频","video_qualities":{"annotations":{"4k":null,"fullhd":null,"medium":null},"labels":{"4k":null,"auto":null,"fullhd":null,"medium":null}},"volume":"音量","vr":{"no_vr":{"link":null,"text":null},"select_quality":null,"start":null,"start_cardboard":null,"video_qualities":{"4k":null,"fullhd":null,"high":null},"video_quality_annotations":{"4k":null,"fullhd":null,"high":null}}}}}};
//     Cocktail.js 0.3.0
//     (c) 2012 Onsi Fakhouri
//     Cocktail.js may be freely distributed under the MIT license.
//     http://github.com/onsi/cocktail
(function() {
    var Cocktail;

    if (typeof exports !== 'undefined') {
        Cocktail = exports;
    } else {
        Cocktail = this.Cocktail = {};
    }

    Cocktail.mixins = {};

    Cocktail.mixin = function mixin(klass) {
        var mixins = _.chain(arguments).toArray().rest().flatten().value();

        var collisions = {};

        _(mixins).each(function(mixin) {
            if (_.isString(mixin)) {
                mixin = Cocktail.mixins[mixin];
            }
            _(mixin).each(function(value, key) {
                if (_.isFunction(value)) {
                    if (klass.prototype[key]) {
                        collisions[key] = collisions[key] || [klass.prototype[key]];
                        collisions[key].push(value);
                    }
                    klass.prototype[key] = value;
                } else if (_.isObject(value)) {
                    klass.prototype[key] = _.extend({}, value, klass.prototype[key] || {});
                }
            });
        });

        _(collisions).each(function(propertyValues, propertyName) {
            klass.prototype[propertyName] = function() {
                var that = this,
                    args = arguments,
                    returnValue = undefined;

                _(propertyValues).each(function(value) {
                    var returnedValue = _.isFunction(value) ? value.apply(that, args) : value;
                    returnValue = (returnedValue === undefined ? returnValue : returnedValue);
                });

                return returnValue;
            };
        });
    };

    var originalExtend;

    Cocktail.patch = function patch(Backbone) {
        originalExtend = Backbone.Model.extend;

        var extend = function(protoProps, classProps) {
            var klass = originalExtend.call(this, protoProps, classProps);

            var mixins = klass.prototype.mixins;
            if (mixins && klass.prototype.hasOwnProperty('mixins')) {
                Cocktail.mixin(klass, mixins);
            }

            return klass;
        };

        _([Backbone.Model, Backbone.Collection, Backbone.Router, Backbone.View]).each(function(klass) {
            klass.mixin = function mixin() {
                Cocktail.mixin(this, _.toArray(arguments));
            };

            klass.extend = extend;
        });
    };

    Cocktail.unpatch = function unpatch(Backbone) {
        _([Backbone.Model, Backbone.Collection, Backbone.Router, Backbone.View]).each(function(klass) {
            klass.mixin = undefined;
            klass.extend = originalExtend;
        });
    };

    Cocktail.patch(Backbone);
})();
// MarionetteJS (Backbone.Marionette)
// ----------------------------------
// v1.1.0
//
// Copyright (c)2013 Derick Bailey, Muted Solutions, LLC.
// Distributed under MIT license
//
// http://marionettejs.com



/*!
 * Includes BabySitter
 * https://github.com/marionettejs/backbone.babysitter/
 *
 * Includes Wreqr
 * https://github.com/marionettejs/backbone.wreqr/
 */

// Backbone.BabySitter
// -------------------
// v0.0.6
//
// Copyright (c)2013 Derick Bailey, Muted Solutions, LLC.
// Distributed under MIT license
//
// http://github.com/babysitterjs/backbone.babysitter

// Backbone.ChildViewContainer
// ---------------------------
//
// Provide a container to store, retrieve and
// shut down child views.

Backbone.ChildViewContainer = (function(Backbone, _){
  
  // Container Constructor
  // ---------------------

  var Container = function(views){
    this._views = {};
    this._indexByModel = {};
    this._indexByCustom = {};
    this._updateLength();

    _.each(views, this.add, this);
  };

  // Container Methods
  // -----------------

  _.extend(Container.prototype, {

    // Add a view to this container. Stores the view
    // by `cid` and makes it searchable by the model
    // cid (and model itself). Optionally specify
    // a custom key to store an retrieve the view.
    add: function(view, customIndex){
      var viewCid = view.cid;

      // store the view
      this._views[viewCid] = view;

      // index it by model
      if (view.model){
        this._indexByModel[view.model.cid] = viewCid;
      }

      // index by custom
      if (customIndex){
        this._indexByCustom[customIndex] = viewCid;
      }

      this._updateLength();
    },

    // Find a view by the model that was attached to
    // it. Uses the model's `cid` to find it.
    findByModel: function(model){
      return this.findByModelCid(model.cid);
    },

    // Find a view by the `cid` of the model that was attached to
    // it. Uses the model's `cid` to find the view `cid` and
    // retrieve the view using it.
    findByModelCid: function(modelCid){
      var viewCid = this._indexByModel[modelCid];
      return this.findByCid(viewCid);
    },

    // Find a view by a custom indexer.
    findByCustom: function(index){
      var viewCid = this._indexByCustom[index];
      return this.findByCid(viewCid);
    },

    // Find by index. This is not guaranteed to be a
    // stable index.
    findByIndex: function(index){
      return _.values(this._views)[index];
    },

    // retrieve a view by it's `cid` directly
    findByCid: function(cid){
      return this._views[cid];
    },

    // Remove a view
    remove: function(view){
      var viewCid = view.cid;

      // delete model index
      if (view.model){
        delete this._indexByModel[view.model.cid];
      }

      // delete custom index
      _.any(this._indexByCustom, function(cid, key) {
        if (cid === viewCid) {
          delete this._indexByCustom[key];
          return true;
        }
      }, this);

      // remove the view from the container
      delete this._views[viewCid];

      // update the length
      this._updateLength();
    },

    // Call a method on every view in the container,
    // passing parameters to the call method one at a
    // time, like `function.call`.
    call: function(method){
      this.apply(method, _.tail(arguments));
    },

    // Apply a method on every view in the container,
    // passing parameters to the call method one at a
    // time, like `function.apply`.
    apply: function(method, args){
      _.each(this._views, function(view){
        if (_.isFunction(view[method])){
          view[method].apply(view, args || []);
        }
      });
    },

    // Update the `.length` attribute on this container
    _updateLength: function(){
      this.length = _.size(this._views);
    }
  });

  // Borrowing this code from Backbone.Collection:
  // http://backbonejs.org/docs/backbone.html#section-106
  //
  // Mix in methods from Underscore, for iteration, and other
  // collection related features.
  var methods = ['forEach', 'each', 'map', 'find', 'detect', 'filter', 
    'select', 'reject', 'every', 'all', 'some', 'any', 'include', 
    'contains', 'invoke', 'toArray', 'first', 'initial', 'rest', 
    'last', 'without', 'isEmpty', 'pluck'];

  _.each(methods, function(method) {
    Container.prototype[method] = function() {
      var views = _.values(this._views);
      var args = [views].concat(_.toArray(arguments));
      return _[method].apply(_, args);
    };
  });

  // return the public API
  return Container;
})(Backbone, _);

// Backbone.Wreqr (Backbone.Marionette)
// ----------------------------------
// v0.2.0
//
// Copyright (c)2013 Derick Bailey, Muted Solutions, LLC.
// Distributed under MIT license
//
// http://github.com/marionettejs/backbone.wreqr


Backbone.Wreqr = (function(Backbone, Marionette, _){
  "use strict";
  var Wreqr = {};

  // Handlers
// --------
// A registry of functions to call, given a name

Wreqr.Handlers = (function(Backbone, _){
  "use strict";
  
  // Constructor
  // -----------

  var Handlers = function(options){
    this.options = options;
    this._wreqrHandlers = {};
    
    if (_.isFunction(this.initialize)){
      this.initialize(options);
    }
  };

  Handlers.extend = Backbone.Model.extend;

  // Instance Members
  // ----------------

  _.extend(Handlers.prototype, Backbone.Events, {

    // Add multiple handlers using an object literal configuration
    setHandlers: function(handlers){
      _.each(handlers, function(handler, name){
        var context = null;

        if (_.isObject(handler) && !_.isFunction(handler)){
          context = handler.context;
          handler = handler.callback;
        }

        this.setHandler(name, handler, context);
      }, this);
    },

    // Add a handler for the given name, with an
    // optional context to run the handler within
    setHandler: function(name, handler, context){
      var config = {
        callback: handler,
        context: context
      };

      this._wreqrHandlers[name] = config;

      this.trigger("handler:add", name, handler, context);
    },

    // Determine whether or not a handler is registered
    hasHandler: function(name){
      return !! this._wreqrHandlers[name];
    },

    // Get the currently registered handler for
    // the specified name. Throws an exception if
    // no handler is found.
    getHandler: function(name){
      var config = this._wreqrHandlers[name];

      if (!config){
        throw new Error("Handler not found for '" + name + "'");
      }

      return function(){
        var args = Array.prototype.slice.apply(arguments);
        return config.callback.apply(config.context, args);
      };
    },

    // Remove a handler for the specified name
    removeHandler: function(name){
      delete this._wreqrHandlers[name];
    },

    // Remove all handlers from this registry
    removeAllHandlers: function(){
      this._wreqrHandlers = {};
    }
  });

  return Handlers;
})(Backbone, _);

  // Wreqr.CommandStorage
// --------------------
//
// Store and retrieve commands for execution.
Wreqr.CommandStorage = (function(){
  "use strict";

  // Constructor function
  var CommandStorage = function(options){
    this.options = options;
    this._commands = {};

    if (_.isFunction(this.initialize)){
      this.initialize(options);
    }
  };

  // Instance methods
  _.extend(CommandStorage.prototype, Backbone.Events, {

    // Get an object literal by command name, that contains
    // the `commandName` and the `instances` of all commands
    // represented as an array of arguments to process
    getCommands: function(commandName){
      var commands = this._commands[commandName];

      // we don't have it, so add it
      if (!commands){

        // build the configuration
        commands = {
          command: commandName, 
          instances: []
        };

        // store it
        this._commands[commandName] = commands;
      }

      return commands;
    },

    // Add a command by name, to the storage and store the
    // args for the command
    addCommand: function(commandName, args){
      var command = this.getCommands(commandName);
      command.instances.push(args);
    },

    // Clear all commands for the given `commandName`
    clearCommands: function(commandName){
      var command = this.getCommands(commandName);
      command.instances = [];
    }
  });

  return CommandStorage;
})();

  // Wreqr.Commands
// --------------
//
// A simple command pattern implementation. Register a command
// handler and execute it.
Wreqr.Commands = (function(Wreqr){
  "use strict";

  return Wreqr.Handlers.extend({
    // default storage type
    storageType: Wreqr.CommandStorage,

    constructor: function(options){
      this.options = options || {};

      this._initializeStorage(this.options);
      this.on("handler:add", this._executeCommands, this);

      var args = Array.prototype.slice.call(arguments);
      Wreqr.Handlers.prototype.constructor.apply(this, args);
    },

    // Execute a named command with the supplied args
    execute: function(name, args){
      name = arguments[0];
      args = Array.prototype.slice.call(arguments, 1);

      if (this.hasHandler(name)){
        this.getHandler(name).apply(this, args);
      } else {
        this.storage.addCommand(name, args);
      }

    },

    // Internal method to handle bulk execution of stored commands
    _executeCommands: function(name, handler, context){
      var command = this.storage.getCommands(name);

      // loop through and execute all the stored command instances
      _.each(command.instances, function(args){
        handler.apply(context, args);
      });

      this.storage.clearCommands(name);
    },

    // Internal method to initialize storage either from the type's
    // `storageType` or the instance `options.storageType`.
    _initializeStorage: function(options){
      var storage;

      var StorageType = options.storageType || this.storageType;
      if (_.isFunction(StorageType)){
        storage = new StorageType();
      } else {
        storage = StorageType;
      }

      this.storage = storage;
    }
  });

})(Wreqr);

  // Wreqr.RequestResponse
// ---------------------
//
// A simple request/response implementation. Register a
// request handler, and return a response from it
Wreqr.RequestResponse = (function(Wreqr){
  "use strict";

  return Wreqr.Handlers.extend({
    request: function(){
      var name = arguments[0];
      var args = Array.prototype.slice.call(arguments, 1);

      return this.getHandler(name).apply(this, args);
    }
  });

})(Wreqr);

  // Event Aggregator
// ----------------
// A pub-sub object that can be used to decouple various parts
// of an application through event-driven architecture.

Wreqr.EventAggregator = (function(Backbone, _){
  "use strict";
  var EA = function(){};

  // Copy the `extend` function used by Backbone's classes
  EA.extend = Backbone.Model.extend;

  // Copy the basic Backbone.Events on to the event aggregator
  _.extend(EA.prototype, Backbone.Events);

  return EA;
})(Backbone, _);


  return Wreqr;
})(Backbone, Backbone.Marionette, _);

var Marionette = (function(global, Backbone, _){
  "use strict";

  // Define and export the Marionette namespace
  var Marionette = {};
  Backbone.Marionette = Marionette;

  // Get the DOM manipulator for later use
  Marionette.$ = Backbone.$;

// Helpers
// -------

// For slicing `arguments` in functions
var protoSlice = Array.prototype.slice;
function slice(args) {
  return protoSlice.call(args);
}

function throwError(message, name) {
  var error = new Error(message);
  error.name = name || 'Error';
  throw error;
}

// Marionette.extend
// -----------------

// Borrow the Backbone `extend` method so we can use it as needed
Marionette.extend = Backbone.Model.extend;

// Marionette.getOption
// --------------------

// Retrieve an object, function or other value from a target
// object or its `options`, with `options` taking precedence.
Marionette.getOption = function(target, optionName){
  if (!target || !optionName){ return; }
  var value;

  if (target.options && (optionName in target.options) && (target.options[optionName] !== undefined)){
    value = target.options[optionName];
  } else {
    value = target[optionName];
  }

  return value;
};

// Trigger an event and/or a corresponding method name. Examples:
//
// `this.triggerMethod("foo")` will trigger the "foo" event and
// call the "onFoo" method.
//
// `this.triggerMethod("foo:bar") will trigger the "foo:bar" event and
// call the "onFooBar" method.
Marionette.triggerMethod = (function(){

  // split the event name on the :
  var splitter = /(^|:)(\w)/gi;

  // take the event section ("section1:section2:section3")
  // and turn it in to uppercase name
  function getEventName(match, prefix, eventName) {
    return eventName.toUpperCase();
  }

  // actual triggerMethod name
  var triggerMethod = function(event) {
    // get the method name from the event name
    var methodName = 'on' + event.replace(splitter, getEventName);
    var method = this[methodName];

    // trigger the event, if a trigger method exists
    if(_.isFunction(this.trigger)) {
      this.trigger.apply(this, arguments);
    }

    // call the onMethodName if it exists
    if (_.isFunction(method)) {
      // pass all arguments, except the event name
      return method.apply(this, _.tail(arguments));
    }
  };

  return triggerMethod;
})();

// DOMRefresh
// ----------
//
// Monitor a view's state, and after it has been rendered and shown
// in the DOM, trigger a "dom:refresh" event every time it is
// re-rendered.

Marionette.MonitorDOMRefresh = (function(){
  // track when the view has been shown in the DOM,
  // using a Marionette.Region (or by other means of triggering "show")
  function handleShow(view){
    view._isShown = true;
    triggerDOMRefresh(view);
  }

  // track when the view has been rendered
  function handleRender(view){
    view._isRendered = true;
    triggerDOMRefresh(view);
  }

  // Trigger the "dom:refresh" event and corresponding "onDomRefresh" method
  function triggerDOMRefresh(view){
    if (view._isShown && view._isRendered){
      if (_.isFunction(view.triggerMethod)){
        view.triggerMethod("dom:refresh");
      }
    }
  }

  // Export public API
  return function(view){
    view.listenTo(view, "show", function(){
      handleShow(view);
    });

    view.listenTo(view, "render", function(){
      handleRender(view);
    });
  };
})();


// Marionette.bindEntityEvents & unbindEntityEvents
// ---------------------------
//
// These methods are used to bind/unbind a backbone "entity" (collection/model) 
// to methods on a target object. 
//
// The first parameter, `target`, must have a `listenTo` method from the
// EventBinder object.
//
// The second parameter is the entity (Backbone.Model or Backbone.Collection)
// to bind the events from.
//
// The third parameter is a hash of { "event:name": "eventHandler" }
// configuration. Multiple handlers can be separated by a space. A
// function can be supplied instead of a string handler name. 

(function(Marionette){
  "use strict";

  // Bind the event to handlers specified as a string of
  // handler names on the target object
  function bindFromStrings(target, entity, evt, methods){
    var methodNames = methods.split(/\s+/);

    _.each(methodNames,function(methodName) {

      var method = target[methodName];
      if(!method) {
        throwError("Method '"+ methodName +"' was configured as an event handler, but does not exist.");
      }

      target.listenTo(entity, evt, method, target);
    });
  }

  // Bind the event to a supplied callback function
  function bindToFunction(target, entity, evt, method){
      target.listenTo(entity, evt, method, target);
  }

  // Bind the event to handlers specified as a string of
  // handler names on the target object
  function unbindFromStrings(target, entity, evt, methods){
    var methodNames = methods.split(/\s+/);

    _.each(methodNames,function(methodName) {
      var method = target[methodName];
      target.stopListening(entity, evt, method, target);
    });
  }

  // Bind the event to a supplied callback function
  function unbindToFunction(target, entity, evt, method){
      target.stopListening(entity, evt, method, target);
  }

  
  // generic looping function
  function iterateEvents(target, entity, bindings, functionCallback, stringCallback){
    if (!entity || !bindings) { return; }

    // allow the bindings to be a function
    if (_.isFunction(bindings)){
      bindings = bindings.call(target);
    }

    // iterate the bindings and bind them
    _.each(bindings, function(methods, evt){

      // allow for a function as the handler, 
      // or a list of event names as a string
      if (_.isFunction(methods)){
        functionCallback(target, entity, evt, methods);
      } else {
        stringCallback(target, entity, evt, methods);
      }

    });
  }
 
  // Export Public API
  Marionette.bindEntityEvents = function(target, entity, bindings){
    iterateEvents(target, entity, bindings, bindToFunction, bindFromStrings);
  };

  Marionette.unbindEntityEvents = function(target, entity, bindings){
    iterateEvents(target, entity, bindings, unbindToFunction, unbindFromStrings);
  };

})(Marionette);


// Callbacks
// ---------

// A simple way of managing a collection of callbacks
// and executing them at a later point in time, using jQuery's
// `Deferred` object.
Marionette.Callbacks = function(){
  this._deferred = Marionette.$.Deferred();
  this._callbacks = [];
};

_.extend(Marionette.Callbacks.prototype, {

  // Add a callback to be executed. Callbacks added here are
  // guaranteed to execute, even if they are added after the 
  // `run` method is called.
  add: function(callback, contextOverride){
    this._callbacks.push({cb: callback, ctx: contextOverride});

    this._deferred.done(function(context, options){
      if (contextOverride){ context = contextOverride; }
      callback.call(context, options);
    });
  },

  // Run all registered callbacks with the context specified. 
  // Additional callbacks can be added after this has been run 
  // and they will still be executed.
  run: function(options, context){
    this._deferred.resolve(context, options);
  },

  // Resets the list of callbacks to be run, allowing the same list
  // to be run multiple times - whenever the `run` method is called.
  reset: function(){
    var callbacks = this._callbacks;
    this._deferred = Marionette.$.Deferred();
    this._callbacks = [];
    
    _.each(callbacks, function(cb){
      this.add(cb.cb, cb.ctx);
    }, this);
  }
});


// Marionette Controller
// ---------------------
//
// A multi-purpose object to use as a controller for
// modules and routers, and as a mediator for workflow
// and coordination of other objects, views, and more.
Marionette.Controller = function(options){
  this.triggerMethod = Marionette.triggerMethod;
  this.options = options || {};

  if (_.isFunction(this.initialize)){
    this.initialize(this.options);
  }
};

Marionette.Controller.extend = Marionette.extend;

// Controller Methods
// --------------

// Ensure it can trigger events with Backbone.Events
_.extend(Marionette.Controller.prototype, Backbone.Events, {
  close: function(){
    this.stopListening();
    this.triggerMethod("close");
    this.unbind();
  }
});

// Region 
// ------
//
// Manage the visual regions of your composite application. See
// http://lostechies.com/derickbailey/2011/12/12/composite-js-apps-regions-and-region-managers/

Marionette.Region = function(options){
  this.options = options || {};

  this.el = Marionette.getOption(this, "el");

  if (!this.el){
    var err = new Error("An 'el' must be specified for a region.");
    err.name = "NoElError";
    throw err;
  }

  if (this.initialize){
    var args = Array.prototype.slice.apply(arguments);
    this.initialize.apply(this, args);
  }
};


// Region Type methods
// -------------------

_.extend(Marionette.Region, {

  // Build an instance of a region by passing in a configuration object
  // and a default region type to use if none is specified in the config.
  //
  // The config object should either be a string as a jQuery DOM selector,
  // a Region type directly, or an object literal that specifies both
  // a selector and regionType:
  //
  // ```js
  // {
  //   selector: "#foo",
  //   regionType: MyCustomRegion
  // }
  // ```
  //
  buildRegion: function(regionConfig, defaultRegionType){

    var regionIsString = (typeof regionConfig === "string");
    var regionSelectorIsString = (typeof regionConfig.selector === "string");
    var regionTypeIsUndefined = (typeof regionConfig.regionType === "undefined");
    var regionIsType = (typeof regionConfig === "function");

    if (!regionIsType && !regionIsString && !regionSelectorIsString) {
      throw new Error("Region must be specified as a Region type, a selector string or an object with selector property");
    }

    var selector, RegionType;
   
    // get the selector for the region
    
    if (regionIsString) {
      selector = regionConfig;
    } 

    if (regionConfig.selector) {
      selector = regionConfig.selector;
    }

    // get the type for the region
    
    if (regionIsType){
      RegionType = regionConfig;
    }

    if (!regionIsType && regionTypeIsUndefined) {
      RegionType = defaultRegionType;
    }

    if (regionConfig.regionType) {
      RegionType = regionConfig.regionType;
    }
    
    // build the region instance
    var region = new RegionType({
      el: selector
    });

    // override the `getEl` function if we have a parentEl
    // this must be overridden to ensure the selector is found
    // on the first use of the region. if we try to assign the
    // region's `el` to `parentEl.find(selector)` in the object
    // literal to build the region, the element will not be
    // guaranteed to be in the DOM already, and will cause problems
    if (regionConfig.parentEl){

      region.getEl = function(selector) {
        var parentEl = regionConfig.parentEl;
        if (_.isFunction(parentEl)){
          parentEl = parentEl();
        }
        return parentEl.find(selector);
      };
    }

    return region;
  }

});

// Region Instance Methods
// -----------------------

_.extend(Marionette.Region.prototype, Backbone.Events, {

  // Displays a backbone view instance inside of the region.
  // Handles calling the `render` method for you. Reads content
  // directly from the `el` attribute. Also calls an optional
  // `onShow` and `close` method on your view, just after showing
  // or just before closing the view, respectively.
  show: function(view){

    this.ensureEl();

    var isViewClosed = view.isClosed || _.isUndefined(view.$el);

    var isDifferentView = view !== this.currentView;

    if (isDifferentView) {
      this.close();
    }

    view.render();

    if (isDifferentView || isViewClosed) {
      this.open(view);
    }
    
    this.currentView = view;

    Marionette.triggerMethod.call(this, "show", view);
    Marionette.triggerMethod.call(view, "show");
  },

  ensureEl: function(){
    if (!this.$el || this.$el.length === 0){
      this.$el = this.getEl(this.el);
    }
  },

  // Override this method to change how the region finds the
  // DOM element that it manages. Return a jQuery selector object.
  getEl: function(selector){
    return Marionette.$(selector);
  },

  // Override this method to change how the new view is
  // appended to the `$el` that the region is managing
  open: function(view){
    this.$el.empty().append(view.el);
  },

  // Close the current view, if there is one. If there is no
  // current view, it does nothing and returns immediately.
  close: function(){
    var view = this.currentView;
    if (!view || view.isClosed){ return; }

    // call 'close' or 'remove', depending on which is found
    if (view.close) { view.close(); }
    else if (view.remove) { view.remove(); }

    Marionette.triggerMethod.call(this, "close");

    delete this.currentView;
  },

  // Attach an existing view to the region. This 
  // will not call `render` or `onShow` for the new view, 
  // and will not replace the current HTML for the `el`
  // of the region.
  attachView: function(view){
    this.currentView = view;
  },

  // Reset the region by closing any existing view and
  // clearing out the cached `$el`. The next time a view
  // is shown via this region, the region will re-query the
  // DOM for the region's `el`.
  reset: function(){
    this.close();
    delete this.$el;
  }
});

// Copy the `extend` function used by Backbone's classes
Marionette.Region.extend = Marionette.extend;

// Marionette.RegionManager
// ------------------------
//
// Manage one or more related `Marionette.Region` objects.
Marionette.RegionManager = (function(Marionette){

  var RegionManager = Marionette.Controller.extend({
    constructor: function(options){
      this._regions = {};
      Marionette.Controller.prototype.constructor.call(this, options);
    },

    // Add multiple regions using an object literal, where
    // each key becomes the region name, and each value is
    // the region definition.
    addRegions: function(regionDefinitions, defaults){
      var regions = {};

      _.each(regionDefinitions, function(definition, name){
        if (typeof definition === "string"){
          definition = { selector: definition };
        }

        if (definition.selector){
          definition = _.defaults({}, definition, defaults);
        }

        var region = this.addRegion(name, definition);
        regions[name] = region;
      }, this);

      return regions;
    },

    // Add an individual region to the region manager,
    // and return the region instance
    addRegion: function(name, definition){
      var region;

      var isObject = _.isObject(definition);
      var isString = _.isString(definition);
      var hasSelector = !!definition.selector;

      if (isString || (isObject && hasSelector)){
        region = Marionette.Region.buildRegion(definition, Marionette.Region);
      } else if (_.isFunction(definition)){
        region = Marionette.Region.buildRegion(definition, Marionette.Region);
      } else {
        region = definition;
      }

      this._store(name, region);
      this.triggerMethod("region:add", name, region);
      return region;
    },

    // Get a region by name
    get: function(name){
      return this._regions[name];
    },

    // Remove a region by name
    removeRegion: function(name){
      var region = this._regions[name];
      this._remove(name, region);
    },

    // Close all regions in the region manager, and
    // remove them
    removeRegions: function(){
      _.each(this._regions, function(region, name){
        this._remove(name, region);
      }, this);
    },

    // Close all regions in the region manager, but
    // leave them attached
    closeRegions: function(){
      _.each(this._regions, function(region, name){
        region.close();
      }, this);
    },

    // Close all regions and shut down the region
    // manager entirely
    close: function(){
      this.removeRegions();
      var args = Array.prototype.slice.call(arguments);
      Marionette.Controller.prototype.close.apply(this, args);
    },

    // internal method to store regions
    _store: function(name, region){
      this._regions[name] = region;
      this._setLength();
    },

    // internal method to remove a region
    _remove: function(name, region){
      region.close();
      delete this._regions[name];
      this._setLength();
      this.triggerMethod("region:remove", name, region);
    },

    // set the number of regions current held
    _setLength: function(){
      this.length = _.size(this._regions);
    }

  });

  // Borrowing this code from Backbone.Collection:
  // http://backbonejs.org/docs/backbone.html#section-106
  //
  // Mix in methods from Underscore, for iteration, and other
  // collection related features.
  var methods = ['forEach', 'each', 'map', 'find', 'detect', 'filter', 
    'select', 'reject', 'every', 'all', 'some', 'any', 'include', 
    'contains', 'invoke', 'toArray', 'first', 'initial', 'rest', 
    'last', 'without', 'isEmpty', 'pluck'];

  _.each(methods, function(method) {
    RegionManager.prototype[method] = function() {
      var regions = _.values(this._regions);
      var args = [regions].concat(_.toArray(arguments));
      return _[method].apply(_, args);
    };
  });

  return RegionManager;
})(Marionette);


// Template Cache
// --------------

// Manage templates stored in `<script>` blocks,
// caching them for faster access.
Marionette.TemplateCache = function(templateId){
  this.templateId = templateId;
};

// TemplateCache object-level methods. Manage the template
// caches from these method calls instead of creating 
// your own TemplateCache instances
_.extend(Marionette.TemplateCache, {
  templateCaches: {},

  // Get the specified template by id. Either
  // retrieves the cached version, or loads it
  // from the DOM.
  get: function(templateId){
    var cachedTemplate = this.templateCaches[templateId];

    if (!cachedTemplate){
      cachedTemplate = new Marionette.TemplateCache(templateId);
      this.templateCaches[templateId] = cachedTemplate;
    }

    return cachedTemplate.load();
  },

  // Clear templates from the cache. If no arguments
  // are specified, clears all templates:
  // `clear()`
  //
  // If arguments are specified, clears each of the 
  // specified templates from the cache:
  // `clear("#t1", "#t2", "...")`
  clear: function(){
    var i;
    var args = slice(arguments);
    var length = args.length;

    if (length > 0){
      for(i=0; i<length; i++){
        delete this.templateCaches[args[i]];
      }
    } else {
      this.templateCaches = {};
    }
  }
});

// TemplateCache instance methods, allowing each
// template cache object to manage its own state
// and know whether or not it has been loaded
_.extend(Marionette.TemplateCache.prototype, {

  // Internal method to load the template
  load: function(){
    // Guard clause to prevent loading this template more than once
    if (this.compiledTemplate){
      return this.compiledTemplate;
    }

    // Load the template and compile it
    var template = this.loadTemplate(this.templateId);
    this.compiledTemplate = this.compileTemplate(template);

    return this.compiledTemplate;
  },

  // Load a template from the DOM, by default. Override
  // this method to provide your own template retrieval
  // For asynchronous loading with AMD/RequireJS, consider
  // using a template-loader plugin as described here: 
  // https://github.com/marionettejs/backbone.marionette/wiki/Using-marionette-with-requirejs
  loadTemplate: function(templateId){
    var template = Marionette.$(templateId).html();

    if (!template || template.length === 0){
      throwError("Could not find template: '" + templateId + "'", "NoTemplateError");
    }

    return template;
  },

  // Pre-compile the template before caching it. Override
  // this method if you do not need to pre-compile a template
  // (JST / RequireJS for example) or if you want to change
  // the template engine used (Handebars, etc).
  compileTemplate: function(rawTemplate){
    return _.template(rawTemplate);
  }
});


// Renderer
// --------

// Render a template with data by passing in the template
// selector and the data to render.
Marionette.Renderer = {

  // Render a template with data. The `template` parameter is
  // passed to the `TemplateCache` object to retrieve the
  // template function. Override this method to provide your own
  // custom rendering and template handling for all of Marionette.
  render: function(template, data){

    if (!template) {
      var error = new Error("Cannot render the template since it's false, null or undefined.");
      error.name = "TemplateNotFoundError";
      throw error;
    }

    var templateFunc;
    if (typeof template === "function"){
      templateFunc = template;
    } else {
      templateFunc = Marionette.TemplateCache.get(template);
    }

    return templateFunc(data);
  }
};



// Marionette.View
// ---------------

// The core view type that other Marionette views extend from.
Marionette.View = Backbone.View.extend({

  constructor: function(){
    _.bindAll(this, "render");

    var args = Array.prototype.slice.apply(arguments);
    Backbone.View.prototype.constructor.apply(this, args);

    Marionette.MonitorDOMRefresh(this);
    this.listenTo(this, "show", this.onShowCalled, this);
  },

  // import the "triggerMethod" to trigger events with corresponding
  // methods if the method exists 
  triggerMethod: Marionette.triggerMethod,

  // Get the template for this view
  // instance. You can set a `template` attribute in the view
  // definition or pass a `template: "whatever"` parameter in
  // to the constructor options.
  getTemplate: function(){
    return Marionette.getOption(this, "template");
  },

  // Mix in template helper methods. Looks for a
  // `templateHelpers` attribute, which can either be an
  // object literal, or a function that returns an object
  // literal. All methods and attributes from this object
  // are copies to the object passed in.
  mixinTemplateHelpers: function(target){
    target = target || {};
    var templateHelpers = Marionette.getOption(this, "templateHelpers");
    if (_.isFunction(templateHelpers)){
      templateHelpers = templateHelpers.call(this);
    }
    return _.extend(target, templateHelpers);
  },

  // Configure `triggers` to forward DOM events to view
  // events. `triggers: {"click .foo": "do:foo"}`
  configureTriggers: function(){
    if (!this.triggers) { return; }

    var triggerEvents = {};

    // Allow `triggers` to be configured as a function
    var triggers = _.result(this, "triggers");

    // Configure the triggers, prevent default
    // action and stop propagation of DOM events
    _.each(triggers, function(value, key){

      // build the event handler function for the DOM event
      triggerEvents[key] = function(e){

        // stop the event in its tracks
        if (e && e.preventDefault){ e.preventDefault(); }
        if (e && e.stopPropagation){ e.stopPropagation(); }

        // build the args for the event
        var args = {
          view: this,
          model: this.model,
          collection: this.collection
        };

        // trigger the event
        this.triggerMethod(value, args);
      };

    }, this);

    return triggerEvents;
  },

  // Overriding Backbone.View's delegateEvents to handle 
  // the `triggers`, `modelEvents`, and `collectionEvents` configuration
  delegateEvents: function(events){
    this._delegateDOMEvents(events);
    Marionette.bindEntityEvents(this, this.model, Marionette.getOption(this, "modelEvents"));
    Marionette.bindEntityEvents(this, this.collection, Marionette.getOption(this, "collectionEvents"));
  },

  // internal method to delegate DOM events and triggers
  _delegateDOMEvents: function(events){
    events = events || this.events;
    if (_.isFunction(events)){ events = events.call(this); }

    var combinedEvents = {};
    var triggers = this.configureTriggers();
    _.extend(combinedEvents, events, triggers);

    Backbone.View.prototype.delegateEvents.call(this, combinedEvents);
  },

  // Overriding Backbone.View's undelegateEvents to handle unbinding
  // the `triggers`, `modelEvents`, and `collectionEvents` config
  undelegateEvents: function(){
    var args = Array.prototype.slice.call(arguments);
    Backbone.View.prototype.undelegateEvents.apply(this, args);

    Marionette.unbindEntityEvents(this, this.model, Marionette.getOption(this, "modelEvents"));
    Marionette.unbindEntityEvents(this, this.collection, Marionette.getOption(this, "collectionEvents"));
  },

  // Internal method, handles the `show` event.
  onShowCalled: function(){},

  // Default `close` implementation, for removing a view from the
  // DOM and unbinding it. Regions will call this method
  // for you. You can specify an `onClose` method in your view to
  // add custom code that is called after the view is closed.
  close: function(){
    if (this.isClosed) { return; }

    // allow the close to be stopped by returning `false`
    // from the `onBeforeClose` method
    var shouldClose = this.triggerMethod("before:close");
    if (shouldClose === false){
      return;
    }

    // mark as closed before doing the actual close, to
    // prevent infinite loops within "close" event handlers
    // that are trying to close other views
    this.isClosed = true;
    this.triggerMethod("close");

    // unbind UI elements
    this.unbindUIElements();

    // remove the view from the DOM
    this.remove();
  },

  // This method binds the elements specified in the "ui" hash inside the view's code with
  // the associated jQuery selectors.
  bindUIElements: function(){
    if (!this.ui) { return; }

    // store the ui hash in _uiBindings so they can be reset later
    // and so re-rendering the view will be able to find the bindings
    if (!this._uiBindings){
      this._uiBindings = this.ui;
    }

    // get the bindings result, as a function or otherwise
    var bindings = _.result(this, "_uiBindings");

    // empty the ui so we don't have anything to start with
    this.ui = {};

    // bind each of the selectors
    _.each(_.keys(bindings), function(key) {
      var selector = bindings[key];
      this.ui[key] = this.$(selector);
    }, this);
  },

  // This method unbinds the elements specified in the "ui" hash
  unbindUIElements: function(){
    if (!this.ui || !this._uiBindings){ return; }

    // delete all of the existing ui bindings
    _.each(this.ui, function($el, name){
      delete this.ui[name];
    }, this);

    // reset the ui element to the original bindings configuration
    this.ui = this._uiBindings;
    delete this._uiBindings;
  }
});

// Item View
// ---------

// A single item view implementation that contains code for rendering
// with underscore.js templates, serializing the view's model or collection,
// and calling several methods on extended views, such as `onRender`.
Marionette.ItemView = Marionette.View.extend({
  
  // Setting up the inheritance chain which allows changes to 
  // Marionette.View.prototype.constructor which allows overriding
  constructor: function(){
    Marionette.View.prototype.constructor.apply(this, slice(arguments));
  },

  // Serialize the model or collection for the view. If a model is
  // found, `.toJSON()` is called. If a collection is found, `.toJSON()`
  // is also called, but is used to populate an `items` array in the
  // resulting data. If both are found, defaults to the model.
  // You can override the `serializeData` method in your own view
  // definition, to provide custom serialization for your view's data.
  serializeData: function(){
    var data = {};

    if (this.model) {
      data = this.model.toJSON();
    }
    else if (this.collection) {
      data = { items: this.collection.toJSON() };
    }

    return data;
  },

  // Render the view, defaulting to underscore.js templates.
  // You can override this in your view definition to provide
  // a very specific rendering for your view. In general, though,
  // you should override the `Marionette.Renderer` object to
  // change how Marionette renders views.
  render: function(){
    this.isClosed = false;

    this.triggerMethod("before:render", this);
    this.triggerMethod("item:before:render", this);

    var data = this.serializeData();
    data = this.mixinTemplateHelpers(data);

    var template = this.getTemplate();
    var html = Marionette.Renderer.render(template, data);

    this.$el.html(html);
    this.bindUIElements();

    this.triggerMethod("render", this);
    this.triggerMethod("item:rendered", this);

    return this;
  },

  // Override the default close event to add a few
  // more events that are triggered.
  close: function(){
    if (this.isClosed){ return; }

    this.triggerMethod('item:before:close');

    Marionette.View.prototype.close.apply(this, slice(arguments));

    this.triggerMethod('item:closed');
  }
});

// Collection View
// ---------------

// A view that iterates over a Backbone.Collection
// and renders an individual ItemView for each model.
Marionette.CollectionView = Marionette.View.extend({
  // used as the prefix for item view events
  // that are forwarded through the collectionview
  itemViewEventPrefix: "itemview",

  // constructor
  constructor: function(options){
    this._initChildViewStorage();

    Marionette.View.prototype.constructor.apply(this, slice(arguments));

    this._initialEvents();
  },

  // Configured the initial events that the collection view
  // binds to. Override this method to prevent the initial
  // events, or to add your own initial events.
  _initialEvents: function(){
    if (this.collection){
      this.listenTo(this.collection, "add", this.addChildView, this);
      this.listenTo(this.collection, "remove", this.removeItemView, this);
      this.listenTo(this.collection, "reset", this.render, this);
    }
  },

  // Handle a child item added to the collection
  addChildView: function(item, collection, options){
    this.closeEmptyView();
    var ItemView = this.getItemView(item);
    var index = this.collection.indexOf(item);
    this.addItemView(item, ItemView, index);
  },

  // Override from `Marionette.View` to guarantee the `onShow` method
  // of child views is called.
  onShowCalled: function(){
    this.children.each(function(child){
      Marionette.triggerMethod.call(child, "show");
    });
  },

  // Internal method to trigger the before render callbacks
  // and events
  triggerBeforeRender: function(){
    this.triggerMethod("before:render", this);
    this.triggerMethod("collection:before:render", this);
  },

  // Internal method to trigger the rendered callbacks and
  // events
  triggerRendered: function(){
    this.triggerMethod("render", this);
    this.triggerMethod("collection:rendered", this);
  },

  // Render the collection of items. Override this method to
  // provide your own implementation of a render function for
  // the collection view.
  render: function(){
    this.isClosed = false;
    this.triggerBeforeRender();
    this._renderChildren();
    this.triggerRendered();
    return this;
  },

  // Internal method. Separated so that CompositeView can have
  // more control over events being triggered, around the rendering
  // process
  _renderChildren: function(){
    this.closeEmptyView();
    this.closeChildren();

    if (this.collection && this.collection.length > 0) {
      this.showCollection();
    } else {
      this.showEmptyView();
    }
  },

  // Internal method to loop through each item in the
  // collection view and show it
  showCollection: function(){
    var ItemView;
    this.collection.each(function(item, index){
      ItemView = this.getItemView(item);
      this.addItemView(item, ItemView, index);
    }, this);
  },

  // Internal method to show an empty view in place of
  // a collection of item views, when the collection is
  // empty
  showEmptyView: function(){
    var EmptyView = Marionette.getOption(this, "emptyView");

    if (EmptyView && !this._showingEmptyView){
      this._showingEmptyView = true;
      var model = new Backbone.Model();
      this.addItemView(model, EmptyView, 0);
    }
  },

  // Internal method to close an existing emptyView instance
  // if one exists. Called when a collection view has been
  // rendered empty, and then an item is added to the collection.
  closeEmptyView: function(){
    if (this._showingEmptyView){
      this.closeChildren();
      delete this._showingEmptyView;
    }
  },

  // Retrieve the itemView type, either from `this.options.itemView`
  // or from the `itemView` in the object definition. The "options"
  // takes precedence.
  getItemView: function(item){
    var itemView = Marionette.getOption(this, "itemView");

    if (!itemView){
      throwError("An `itemView` must be specified", "NoItemViewError");
    }

    return itemView;
  },

  // Render the child item's view and add it to the
  // HTML for the collection view.
  addItemView: function(item, ItemView, index){
    // get the itemViewOptions if any were specified
    var itemViewOptions = Marionette.getOption(this, "itemViewOptions");
    if (_.isFunction(itemViewOptions)){
      itemViewOptions = itemViewOptions.call(this, item, index);
    }

    // build the view 
    var view = this.buildItemView(item, ItemView, itemViewOptions);
    
    // set up the child view event forwarding
    this.addChildViewEventForwarding(view);

    // this view is about to be added
    this.triggerMethod("before:item:added", view);

    // Store the child view itself so we can properly
    // remove and/or close it later
    this.children.add(view);

    // Render it and show it
    this.renderItemView(view, index);

    // call the "show" method if the collection view
    // has already been shown
    if (this._isShown){
      Marionette.triggerMethod.call(view, "show");
    }

    // this view was added
    this.triggerMethod("after:item:added", view);
  },

  // Set up the child view event forwarding. Uses an "itemview:"
  // prefix in front of all forwarded events.
  addChildViewEventForwarding: function(view){
    var prefix = Marionette.getOption(this, "itemViewEventPrefix");

    // Forward all child item view events through the parent,
    // prepending "itemview:" to the event name
    this.listenTo(view, "all", function(){
      var args = slice(arguments);
      args[0] = prefix + ":" + args[0];
      args.splice(1, 0, view);

      Marionette.triggerMethod.apply(this, args);
    }, this);
  },

  // render the item view
  renderItemView: function(view, index) {
    view.render();
    this.appendHtml(this, view, index);
  },

  // Build an `itemView` for every model in the collection.
  buildItemView: function(item, ItemViewType, itemViewOptions){
    var options = _.extend({model: item}, itemViewOptions);
    return new ItemViewType(options);
  },

  // get the child view by item it holds, and remove it
  removeItemView: function(item){
    var view = this.children.findByModel(item);
    this.removeChildView(view);
    this.checkEmpty();
  },

  // Remove the child view and close it
  removeChildView: function(view){

    // shut down the child view properly,
    // including events that the collection has from it
    if (view){
      this.stopListening(view);

      // call 'close' or 'remove', depending on which is found
      if (view.close) { view.close(); }
      else if (view.remove) { view.remove(); }

      this.children.remove(view);
    }

    this.triggerMethod("item:removed", view);
  },

  // helper to show the empty view if the collection is empty
  checkEmpty: function() {
    // check if we're empty now, and if we are, show the
    // empty view
    if (!this.collection || this.collection.length === 0){
      this.showEmptyView();
    }
  },

  // Append the HTML to the collection's `el`.
  // Override this method to do something other
  // then `.append`.
  appendHtml: function(collectionView, itemView, index){
    collectionView.$el.append(itemView.el);
  },

  // Internal method to set up the `children` object for
  // storing all of the child views
  _initChildViewStorage: function(){
    this.children = new Backbone.ChildViewContainer();
  },

  // Handle cleanup and other closing needs for
  // the collection of views.
  close: function(){
    if (this.isClosed){ return; }

    this.triggerMethod("collection:before:close");
    this.closeChildren();
    this.triggerMethod("collection:closed");

    Marionette.View.prototype.close.apply(this, slice(arguments));
  },

  // Close the child views that this collection view
  // is holding on to, if any
  closeChildren: function(){
    this.children.each(function(child){
      this.removeChildView(child);
    }, this);
    this.checkEmpty();
  }
});


// Composite View
// --------------

// Used for rendering a branch-leaf, hierarchical structure.
// Extends directly from CollectionView and also renders an
// an item view as `modelView`, for the top leaf
Marionette.CompositeView = Marionette.CollectionView.extend({

  // Setting up the inheritance chain which allows changes to
  // Marionette.CollectionView.prototype.constructor which allows overriding
  constructor: function(){
    Marionette.CollectionView.prototype.constructor.apply(this, slice(arguments));
  },

  // Configured the initial events that the composite view
  // binds to. Override this method to prevent the initial
  // events, or to add your own initial events.
  _initialEvents: function(){
    if (this.collection){
      this.listenTo(this.collection, "add", this.addChildView, this);
      this.listenTo(this.collection, "remove", this.removeItemView, this);
      this.listenTo(this.collection, "reset", this._renderChildren, this);
    }
  },

  // Retrieve the `itemView` to be used when rendering each of
  // the items in the collection. The default is to return
  // `this.itemView` or Marionette.CompositeView if no `itemView`
  // has been defined
  getItemView: function(item){
    var itemView = Marionette.getOption(this, "itemView") || this.constructor;

    if (!itemView){
      throwError("An `itemView` must be specified", "NoItemViewError");
    }

    return itemView;
  },

  // Serialize the collection for the view.
  // You can override the `serializeData` method in your own view
  // definition, to provide custom serialization for your view's data.
  serializeData: function(){
    var data = {};

    if (this.model){
      data = this.model.toJSON();
    }

    return data;
  },

  // Renders the model once, and the collection once. Calling
  // this again will tell the model's view to re-render itself
  // but the collection will not re-render.
  render: function(){
    this.isRendered = true;
    this.isClosed = false;
    this.resetItemViewContainer();

    this.triggerBeforeRender();
    var html = this.renderModel();
    this.$el.html(html);
    // the ui bindings is done here and not at the end of render since they
    // will not be available until after the model is rendered, but should be
    // available before the collection is rendered.
    this.bindUIElements();
    this.triggerMethod("composite:model:rendered");

    this._renderChildren();

    this.triggerMethod("composite:rendered");
    this.triggerRendered();
    return this;
  },

  _renderChildren: function(){
    if (this.isRendered){
      Marionette.CollectionView.prototype._renderChildren.call(this);
      this.triggerMethod("composite:collection:rendered");
    }
  },

  // Render an individual model, if we have one, as
  // part of a composite view (branch / leaf). For example:
  // a treeview.
  renderModel: function(){
    var data = {};
    data = this.serializeData();
    data = this.mixinTemplateHelpers(data);

    var template = this.getTemplate();
    return Marionette.Renderer.render(template, data);
  },

  // Appends the `el` of itemView instances to the specified
  // `itemViewContainer` (a jQuery selector). Override this method to
  // provide custom logic of how the child item view instances have their
  // HTML appended to the composite view instance.
  appendHtml: function(cv, iv, index){
    var $container = this.getItemViewContainer(cv);
    $container.append(iv.el);
  },

  // Internal method to ensure an `$itemViewContainer` exists, for the
  // `appendHtml` method to use.
  getItemViewContainer: function(containerView){
    if ("$itemViewContainer" in containerView){
      return containerView.$itemViewContainer;
    }

    var container;
    var itemViewContainer = Marionette.getOption(containerView, "itemViewContainer");
    if (itemViewContainer){

      var selector = _.isFunction(itemViewContainer) ? itemViewContainer() : itemViewContainer;
      container = containerView.$(selector);
      if (container.length <= 0) {
        throwError("The specified `itemViewContainer` was not found: " + containerView.itemViewContainer, "ItemViewContainerMissingError");
      }

    } else {
      container = containerView.$el;
    }

    containerView.$itemViewContainer = container;
    return container;
  },

  // Internal method to reset the `$itemViewContainer` on render
  resetItemViewContainer: function(){
    if (this.$itemViewContainer){
      delete this.$itemViewContainer;
    }
  }
});


// Layout
// ------

// Used for managing application layouts, nested layouts and
// multiple regions within an application or sub-application.
//
// A specialized view type that renders an area of HTML and then
// attaches `Region` instances to the specified `regions`.
// Used for composite view management and sub-application areas.
Marionette.Layout = Marionette.ItemView.extend({
  regionType: Marionette.Region,
  
  // Ensure the regions are available when the `initialize` method
  // is called.
  constructor: function (options) {
    options = options || {};

    this._firstRender = true;
    this._initializeRegions(options);
    
    Marionette.ItemView.prototype.constructor.call(this, options);
  },

  // Layout's render will use the existing region objects the
  // first time it is called. Subsequent calls will close the
  // views that the regions are showing and then reset the `el`
  // for the regions to the newly rendered DOM elements.
  render: function(){

    if (this.isClosed){
      // a previously closed layout means we need to 
      // completely re-initialize the regions
      this._initializeRegions();
    }
    if (this._firstRender) {
      // if this is the first render, don't do anything to
      // reset the regions
      this._firstRender = false;
    } else if (!this.isClosed){
      // If this is not the first render call, then we need to 
      // re-initializing the `el` for each region
      this._reInitializeRegions();
    }

    var args = Array.prototype.slice.apply(arguments);
    var result = Marionette.ItemView.prototype.render.apply(this, args);

    return result;
  },

  // Handle closing regions, and then close the view itself.
  close: function () {
    if (this.isClosed){ return; }
    this.regionManager.close();
    var args = Array.prototype.slice.apply(arguments);
    Marionette.ItemView.prototype.close.apply(this, args);
  },

  // Add a single region, by name, to the layout
  addRegion: function(name, definition){
    var regions = {};
    regions[name] = definition;
    return this._buildRegions(regions)[name];
  },

  // Add multiple regions as a {name: definition, name2: def2} object literal
  addRegions: function(regions){
    this.regions = _.extend({}, this.regions, regions);
    return this._buildRegions(regions);
  },

  // Remove a single region from the Layout, by name
  removeRegion: function(name){
    delete this.regions[name];
    return this.regionManager.removeRegion(name);
  },

  // internal method to build regions
  _buildRegions: function(regions){
    var that = this;

    var defaults = {
      regionType: Marionette.getOption(this, "regionType"),
      parentEl: function(){ return that.$el; }
    };

    return this.regionManager.addRegions(regions, defaults);
  },

  // Internal method to initialize the regions that have been defined in a
  // `regions` attribute on this layout. 
  _initializeRegions: function (options) {
    var regions;
    this._initRegionManager();

    if (_.isFunction(this.regions)) {
      regions = this.regions(options);
    } else {
      regions = this.regions || {};
    }

    this.addRegions(regions);
  },

  // Internal method to re-initialize all of the regions by updating the `el` that
  // they point to
  _reInitializeRegions: function(){
    this.regionManager.closeRegions();
    this.regionManager.each(function(region){
      region.reset();
    });
  },

  // Internal method to initialize the region manager
  // and all regions in it
  _initRegionManager: function(){
    this.regionManager = new Marionette.RegionManager();

    this.listenTo(this.regionManager, "region:add", function(name, region){
      this[name] = region;
      this.trigger("region:add", name, region);
    });

    this.listenTo(this.regionManager, "region:remove", function(name, region){
      delete this[name];
      this.trigger("region:remove", name, region);
    });
  }
});


// AppRouter
// ---------

// Reduce the boilerplate code of handling route events
// and then calling a single method on another object.
// Have your routers configured to call the method on
// your object, directly.
//
// Configure an AppRouter with `appRoutes`.
//
// App routers can only take one `controller` object. 
// It is recommended that you divide your controller
// objects in to smaller pieces of related functionality
// and have multiple routers / controllers, instead of
// just one giant router and controller.
//
// You can also add standard routes to an AppRouter.

Marionette.AppRouter = Backbone.Router.extend({

  constructor: function(options){
    Backbone.Router.prototype.constructor.apply(this, slice(arguments));
	
    this.options = options || {};

    var appRoutes = Marionette.getOption(this, "appRoutes");
    var controller = this._getController();
    this.processAppRoutes(controller, appRoutes);
  },

  // Similar to route method on a Backbone Router but
  // method is called on the controller
  appRoute: function(route, methodName) {
    var controller = this._getController();
    this._addAppRoute(controller, route, methodName);
  },

  // Internal method to process the `appRoutes` for the
  // router, and turn them in to routes that trigger the
  // specified method on the specified `controller`.
  processAppRoutes: function(controller, appRoutes) {
    if (!appRoutes){ return; }

    var routeNames = _.keys(appRoutes).reverse(); // Backbone requires reverted order of routes

    _.each(routeNames, function(route) {
      this._addAppRoute(controller, route, appRoutes[route]);
    }, this);
  },

  _getController: function(){
    return Marionette.getOption(this, "controller");
  },

  _addAppRoute: function(controller, route, methodName){
    var method = controller[methodName];

    if (!method) {
      throw new Error("Method '" + methodName + "' was not found on the controller");
    }

    this.route(route, methodName, _.bind(method, controller));
  }
});


// Application
// -----------

// Contain and manage the composite application as a whole.
// Stores and starts up `Region` objects, includes an
// event aggregator as `app.vent`
Marionette.Application = function(options){
  this._initRegionManager();
  this._initCallbacks = new Marionette.Callbacks();
  this.vent = new Backbone.Wreqr.EventAggregator();
  this.commands = new Backbone.Wreqr.Commands();
  this.reqres = new Backbone.Wreqr.RequestResponse();
  this.submodules = {};

  _.extend(this, options);

  this.triggerMethod = Marionette.triggerMethod;
};

_.extend(Marionette.Application.prototype, Backbone.Events, {
  // Command execution, facilitated by Backbone.Wreqr.Commands
  execute: function(){
    var args = Array.prototype.slice.apply(arguments);
    this.commands.execute.apply(this.commands, args);
  },

  // Request/response, facilitated by Backbone.Wreqr.RequestResponse
  request: function(){
    var args = Array.prototype.slice.apply(arguments);
    return this.reqres.request.apply(this.reqres, args);
  },

  // Add an initializer that is either run at when the `start`
  // method is called, or run immediately if added after `start`
  // has already been called.
  addInitializer: function(initializer){
    this._initCallbacks.add(initializer);
  },

  // kick off all of the application's processes.
  // initializes all of the regions that have been added
  // to the app, and runs all of the initializer functions
  start: function(options){
    this.triggerMethod("initialize:before", options);
    this._initCallbacks.run(options, this);
    this.triggerMethod("initialize:after", options);

    this.triggerMethod("start", options);
  },

  // Add regions to your app. 
  // Accepts a hash of named strings or Region objects
  // addRegions({something: "#someRegion"})
  // addRegions({something: Region.extend({el: "#someRegion"}) });
  addRegions: function(regions){
    return this._regionManager.addRegions(regions);
  },

  // Close all regions in the app, without removing them
  closeRegions: function(){
    this._regionManager.closeRegions();
  },

  // Removes a region from your app, by name
  // Accepts the regions name
  // removeRegion('myRegion')
  removeRegion: function(region) {
    this._regionManager.removeRegion(region);
  },
  
  // Provides alternative access to regions
  // Accepts the region name
  // getRegion('main')
  getRegion: function(region) {
    return this._regionManager.get(region);
  },

  // Create a module, attached to the application
  module: function(moduleNames, moduleDefinition){
    // slice the args, and add this application object as the
    // first argument of the array
    var args = slice(arguments);
    args.unshift(this);

    // see the Marionette.Module object for more information
    return Marionette.Module.create.apply(Marionette.Module, args);
  },

  // Internal method to set up the region manager
  _initRegionManager: function(){
    this._regionManager = new Marionette.RegionManager();

    this.listenTo(this._regionManager, "region:add", function(name, region){
      this[name] = region;
    });

    this.listenTo(this._regionManager, "region:remove", function(name, region){
      delete this[name];
    });
  }
});

// Copy the `extend` function used by Backbone's classes
Marionette.Application.extend = Marionette.extend;

// Module
// ------

// A simple module system, used to create privacy and encapsulation in
// Marionette applications
Marionette.Module = function(moduleName, app){
  this.moduleName = moduleName;

  // store sub-modules
  this.submodules = {};

  this._setupInitializersAndFinalizers();

  // store the configuration for this module
  this.app = app;
  this.startWithParent = true;

  this.triggerMethod = Marionette.triggerMethod;
};

// Extend the Module prototype with events / listenTo, so that the module
// can be used as an event aggregator or pub/sub.
_.extend(Marionette.Module.prototype, Backbone.Events, {

  // Initializer for a specific module. Initializers are run when the
  // module's `start` method is called.
  addInitializer: function(callback){
    this._initializerCallbacks.add(callback);
  },

  // Finalizers are run when a module is stopped. They are used to teardown
  // and finalize any variables, references, events and other code that the
  // module had set up.
  addFinalizer: function(callback){
    this._finalizerCallbacks.add(callback);
  },

  // Start the module, and run all of its initializers
  start: function(options){
    // Prevent re-starting a module that is already started
    if (this._isInitialized){ return; }

    // start the sub-modules (depth-first hierarchy)
    _.each(this.submodules, function(mod){
      // check to see if we should start the sub-module with this parent
      if (mod.startWithParent){
        mod.start(options);
      }
    });

    // run the callbacks to "start" the current module
    this.triggerMethod("before:start", options);

    this._initializerCallbacks.run(options, this);
    this._isInitialized = true;

    this.triggerMethod("start", options);
  },

  // Stop this module by running its finalizers and then stop all of
  // the sub-modules for this module
  stop: function(){
    // if we are not initialized, don't bother finalizing
    if (!this._isInitialized){ return; }
    this._isInitialized = false;

    Marionette.triggerMethod.call(this, "before:stop");

    // stop the sub-modules; depth-first, to make sure the
    // sub-modules are stopped / finalized before parents
    _.each(this.submodules, function(mod){ mod.stop(); });

    // run the finalizers
    this._finalizerCallbacks.run(undefined,this);

    // reset the initializers and finalizers
    this._initializerCallbacks.reset();
    this._finalizerCallbacks.reset();

    Marionette.triggerMethod.call(this, "stop");
  },

  // Configure the module with a definition function and any custom args
  // that are to be passed in to the definition function
  addDefinition: function(moduleDefinition, customArgs){
    this._runModuleDefinition(moduleDefinition, customArgs);
  },

  // Internal method: run the module definition function with the correct
  // arguments
  _runModuleDefinition: function(definition, customArgs){
    if (!definition){ return; }

    // build the correct list of arguments for the module definition
    var args = _.flatten([
      this,
      this.app,
      Backbone,
      Marionette,
      Marionette.$, _,
      customArgs
    ]);

    definition.apply(this, args);
  },

  // Internal method: set up new copies of initializers and finalizers.
  // Calling this method will wipe out all existing initializers and
  // finalizers.
  _setupInitializersAndFinalizers: function(){
    this._initializerCallbacks = new Marionette.Callbacks();
    this._finalizerCallbacks = new Marionette.Callbacks();
  }
});

// Type methods to create modules
_.extend(Marionette.Module, {

  // Create a module, hanging off the app parameter as the parent object.
  create: function(app, moduleNames, moduleDefinition){
    var module = app;

    // get the custom args passed in after the module definition and
    // get rid of the module name and definition function
    var customArgs = slice(arguments);
    customArgs.splice(0, 3);

    // split the module names and get the length
    moduleNames = moduleNames.split(".");
    var length = moduleNames.length;

    // store the module definition for the last module in the chain
    var moduleDefinitions = [];
    moduleDefinitions[length-1] = moduleDefinition;

    // Loop through all the parts of the module definition
    _.each(moduleNames, function(moduleName, i){
      var parentModule = module;
      module = this._getModule(parentModule, moduleName, app);
      this._addModuleDefinition(parentModule, module, moduleDefinitions[i], customArgs);
    }, this);

    // Return the last module in the definition chain
    return module;
  },

  _getModule: function(parentModule, moduleName, app, def, args){
    // Get an existing module of this name if we have one
    var module = parentModule[moduleName];

    if (!module){
      // Create a new module if we don't have one
      module = new Marionette.Module(moduleName, app);
      parentModule[moduleName] = module;
      // store the module on the parent
      parentModule.submodules[moduleName] = module;
    }

    return module;
  },

  _addModuleDefinition: function(parentModule, module, def, args){
    var fn; 
    var startWithParent;

    if (_.isFunction(def)){
      // if a function is supplied for the module definition
      fn = def;
      startWithParent = true;

    } else if (_.isObject(def)){
      // if an object is supplied
      fn = def.define;
      startWithParent = def.startWithParent;
      
    } else {
      // if nothing is supplied
      startWithParent = true;
    }

    // add module definition if needed
    if (fn){
      module.addDefinition(fn, args);
    }

    // `and` the two together, ensuring a single `false` will prevent it
    // from starting with the parent
    module.startWithParent = module.startWithParent && startWithParent;

    // setup auto-start if needed
    if (module.startWithParent && !module.startWithParentIsConfigured){

      // only configure this once
      module.startWithParentIsConfigured = true;

      // add the module initializer config
      parentModule.addInitializer(function(options){
        if (module.startWithParent){
          module.start(options);
        }
      });

    }

  }
});



  return Marionette;
})(this, Backbone, _);
















window.pageflow = window.pageflow || {};
// TODO: in future try to replace most inline compability checks with polyfills for code readability 

// IE8 SUPPORT BLOCK
// You can compile wuthout all this if IE8 is not needed

// addEventListener, removeEventListener
// TODO: make usage of wysihtml5.dom.observe obsolete
(function() {
  if (!Event.prototype.preventDefault) {
    Event.prototype.preventDefault=function() {
      this.returnValue=false;
    };
  }
  if (!Event.prototype.stopPropagation) {
    Event.prototype.stopPropagation=function() {
      this.cancelBubble=true;
    };
  }
  if (!Element.prototype.addEventListener) {
    var eventListeners=[];
    
    var addEventListener=function(type,listener /*, useCapture (will be ignored) */) {
      var self=this;
      var wrapper=function(e) {
        e.target=e.srcElement;
        e.currentTarget=self;
        if (listener.handleEvent) {
          listener.handleEvent(e);
        } else {
          listener.call(self,e);
        }
      };
      if (type=="DOMContentLoaded") {
        var wrapper2=function(e) {
          if (document.readyState=="complete") {
            wrapper(e);
          }
        };
        document.attachEvent("onreadystatechange",wrapper2);
        eventListeners.push({object:this,type:type,listener:listener,wrapper:wrapper2});
        
        if (document.readyState=="complete") {
          var e=new Event();
          e.srcElement=window;
          wrapper2(e);
        }
      } else {
        this.attachEvent("on"+type,wrapper);
        eventListeners.push({object:this,type:type,listener:listener,wrapper:wrapper});
      }
    };
    var removeEventListener=function(type,listener /*, useCapture (will be ignored) */) {
      var counter=0;
      while (counter<eventListeners.length) {
        var eventListener=eventListeners[counter];
        if (eventListener.object==this && eventListener.type==type && eventListener.listener==listener) {
          if (type=="DOMContentLoaded") {
            this.detachEvent("onreadystatechange",eventListener.wrapper);
          } else {
            this.detachEvent("on"+type,eventListener.wrapper);
          }
          eventListeners.splice(counter, 1);
          break;
        }
        ++counter;
      }
    };
    Element.prototype.addEventListener=addEventListener;
    Element.prototype.removeEventListener=removeEventListener;
    if (HTMLDocument) {
      HTMLDocument.prototype.addEventListener=addEventListener;
      HTMLDocument.prototype.removeEventListener=removeEventListener;
    }
    if (Window) {
      Window.prototype.addEventListener=addEventListener;
      Window.prototype.removeEventListener=removeEventListener;
    }
  }
})();

// element.textContent polyfill.
if (Object.defineProperty && Object.getOwnPropertyDescriptor && Object.getOwnPropertyDescriptor(Element.prototype, "textContent") && !Object.getOwnPropertyDescriptor(Element.prototype, "textContent").get) {
	(function() {
		var innerText = Object.getOwnPropertyDescriptor(Element.prototype, "innerText");
		Object.defineProperty(Element.prototype, "textContent",
			{
				get: function() {
					return innerText.get.call(this);
				},
				set: function(s) {
					return innerText.set.call(this, s);
				}
			}
		);
	})();
}

// isArray polyfill for ie8
if(!Array.isArray) {
  Array.isArray = function(arg) {
    return Object.prototype.toString.call(arg) === '[object Array]';
  };
}

// Function.prototype.bind()
// TODO: clean the code from variable 'that' as it can be confusing
if (!Function.prototype.bind) {
  Function.prototype.bind = function(oThis) {
    if (typeof this !== 'function') {
      // closest thing possible to the ECMAScript 5
      // internal IsCallable function
      throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');
    }

    var aArgs   = Array.prototype.slice.call(arguments, 1),
        fToBind = this,
        fNOP    = function() {},
        fBound  = function() {
          return fToBind.apply(this instanceof fNOP && oThis
                 ? this
                 : oThis,
                 aArgs.concat(Array.prototype.slice.call(arguments)));
        };

    fNOP.prototype = this.prototype;
    fBound.prototype = new fNOP();

    return fBound;
  };
};/**
 * @license wysihtml5x v0.4.17
 * https://github.com/Edicy/wysihtml5
 *
 * Author: Christopher Blum (https://github.com/tiff)
 * Secondary author of extended features: Oliver Pulges (https://github.com/pulges)
 *
 * Copyright (C) 2012 XING AG
 * Licensed under the MIT license (MIT)
 *
 */
var wysihtml5 = {
  version: "0.4.17",

  // namespaces
  commands:   {},
  dom:        {},
  quirks:     {},
  toolbar:    {},
  lang:       {},
  selection:  {},
  views:      {},

  INVISIBLE_SPACE: "\uFEFF",
  INVISIBLE_SPACE_REG_EXP: /\uFEFF/g,

  EMPTY_FUNCTION: function() {},

  ELEMENT_NODE: 1,
  TEXT_NODE:    3,

  BACKSPACE_KEY:  8,
  ENTER_KEY:      13,
  ESCAPE_KEY:     27,
  SPACE_KEY:      32,
  TAB_KEY:        9,
  DELETE_KEY:     46
};
;/**
 * Rangy, a cross-browser JavaScript range and selection library
 * https://github.com/timdown/rangy
 *
 * Copyright 2014, Tim Down
 * Licensed under the MIT license.
 * Version: 1.3.0-alpha.20140921
 * Build date: 21 September 2014
 */

(function(factory, root) {
    if (typeof define == "function" && define.amd) {
        // AMD. Register as an anonymous module.
        define(factory);
    } else if (typeof module != "undefined" && typeof exports == "object") {
        // Node/CommonJS style
        module.exports = factory();
    } else {
        // No AMD or CommonJS support so we place Rangy in (probably) the global variable
        root.rangy = factory();
    }
})(function() {

    var OBJECT = "object", FUNCTION = "function", UNDEFINED = "undefined";

    // Minimal set of properties required for DOM Level 2 Range compliance. Comparison constants such as START_TO_START
    // are omitted because ranges in KHTML do not have them but otherwise work perfectly well. See issue 113.
    var domRangeProperties = ["startContainer", "startOffset", "endContainer", "endOffset", "collapsed",
        "commonAncestorContainer"];

    // Minimal set of methods required for DOM Level 2 Range compliance
    var domRangeMethods = ["setStart", "setStartBefore", "setStartAfter", "setEnd", "setEndBefore",
        "setEndAfter", "collapse", "selectNode", "selectNodeContents", "compareBoundaryPoints", "deleteContents",
        "extractContents", "cloneContents", "insertNode", "surroundContents", "cloneRange", "toString", "detach"];

    var textRangeProperties = ["boundingHeight", "boundingLeft", "boundingTop", "boundingWidth", "htmlText", "text"];

    // Subset of TextRange's full set of methods that we're interested in
    var textRangeMethods = ["collapse", "compareEndPoints", "duplicate", "moveToElementText", "parentElement", "select",
        "setEndPoint", "getBoundingClientRect"];

    /*----------------------------------------------------------------------------------------------------------------*/

    // Trio of functions taken from Peter Michaux's article:
    // http://peter.michaux.ca/articles/feature-detection-state-of-the-art-browser-scripting
    function isHostMethod(o, p) {
        var t = typeof o[p];
        return t == FUNCTION || (!!(t == OBJECT && o[p])) || t == "unknown";
    }

    function isHostObject(o, p) {
        return !!(typeof o[p] == OBJECT && o[p]);
    }

    function isHostProperty(o, p) {
        return typeof o[p] != UNDEFINED;
    }

    // Creates a convenience function to save verbose repeated calls to tests functions
    function createMultiplePropertyTest(testFunc) {
        return function(o, props) {
            var i = props.length;
            while (i--) {
                if (!testFunc(o, props[i])) {
                    return false;
                }
            }
            return true;
        };
    }

    // Next trio of functions are a convenience to save verbose repeated calls to previous two functions
    var areHostMethods = createMultiplePropertyTest(isHostMethod);
    var areHostObjects = createMultiplePropertyTest(isHostObject);
    var areHostProperties = createMultiplePropertyTest(isHostProperty);

    function isTextRange(range) {
        return range && areHostMethods(range, textRangeMethods) && areHostProperties(range, textRangeProperties);
    }

    function getBody(doc) {
        return isHostObject(doc, "body") ? doc.body : doc.getElementsByTagName("body")[0];
    }

    var modules = {};

    var isBrowser = (typeof window != UNDEFINED && typeof document != UNDEFINED);

    var util = {
        isHostMethod: isHostMethod,
        isHostObject: isHostObject,
        isHostProperty: isHostProperty,
        areHostMethods: areHostMethods,
        areHostObjects: areHostObjects,
        areHostProperties: areHostProperties,
        isTextRange: isTextRange,
        getBody: getBody
    };

    var api = {
        version: "1.3.0-alpha.20140921",
        initialized: false,
        isBrowser: isBrowser,
        supported: true,
        util: util,
        features: {},
        modules: modules,
        config: {
            alertOnFail: true,
            alertOnWarn: false,
            preferTextRange: false,
            autoInitialize: (typeof rangyAutoInitialize == UNDEFINED) ? true : rangyAutoInitialize
        }
    };

    function consoleLog(msg) {
        if (typeof console != UNDEFINED && isHostMethod(console, "log")) {
            console.log(msg);
        }
    }

    function alertOrLog(msg, shouldAlert) {
        if (isBrowser && shouldAlert) {
            alert(msg);
        } else  {
            consoleLog(msg);
        }
    }

    function fail(reason) {
        api.initialized = true;
        api.supported = false;
        alertOrLog("Rangy is not supported in this environment. Reason: " + reason, api.config.alertOnFail);
    }

    api.fail = fail;

    function warn(msg) {
        alertOrLog("Rangy warning: " + msg, api.config.alertOnWarn);
    }

    api.warn = warn;

    // Add utility extend() method
    var extend;
    if ({}.hasOwnProperty) {
        util.extend = extend = function(obj, props, deep) {
            var o, p;
            for (var i in props) {
                if (props.hasOwnProperty(i)) {
                    o = obj[i];
                    p = props[i];
                    if (deep && o !== null && typeof o == "object" && p !== null && typeof p == "object") {
                        extend(o, p, true);
                    }
                    obj[i] = p;
                }
            }
            // Special case for toString, which does not show up in for...in loops in IE <= 8
            if (props.hasOwnProperty("toString")) {
                obj.toString = props.toString;
            }
            return obj;
        };

        util.createOptions = function(optionsParam, defaults) {
            var options = {};
            extend(options, defaults);
            if (optionsParam) {
                extend(options, optionsParam);
            }
            return options;
        };
    } else {
        fail("hasOwnProperty not supported");
    }
    
    // Test whether we're in a browser and bail out if not
    if (!isBrowser) {
        fail("Rangy can only run in a browser");
    }

    // Test whether Array.prototype.slice can be relied on for NodeLists and use an alternative toArray() if not
    (function() {
        var toArray;

        if (isBrowser) {
            var el = document.createElement("div");
            el.appendChild(document.createElement("span"));
            var slice = [].slice;
            try {
                if (slice.call(el.childNodes, 0)[0].nodeType == 1) {
                    toArray = function(arrayLike) {
                        return slice.call(arrayLike, 0);
                    };
                }
            } catch (e) {}
        }

        if (!toArray) {
            toArray = function(arrayLike) {
                var arr = [];
                for (var i = 0, len = arrayLike.length; i < len; ++i) {
                    arr[i] = arrayLike[i];
                }
                return arr;
            };
        }

        util.toArray = toArray;
    })();

    // Very simple event handler wrapper function that doesn't attempt to solve issues such as "this" handling or
    // normalization of event properties
    var addListener;
    if (isBrowser) {
        if (isHostMethod(document, "addEventListener")) {
            addListener = function(obj, eventType, listener) {
                obj.addEventListener(eventType, listener, false);
            };
        } else if (isHostMethod(document, "attachEvent")) {
            addListener = function(obj, eventType, listener) {
                obj.attachEvent("on" + eventType, listener);
            };
        } else {
            fail("Document does not have required addEventListener or attachEvent method");
        }

        util.addListener = addListener;
    }

    var initListeners = [];

    function getErrorDesc(ex) {
        return ex.message || ex.description || String(ex);
    }

    // Initialization
    function init() {
        if (!isBrowser || api.initialized) {
            return;
        }
        var testRange;
        var implementsDomRange = false, implementsTextRange = false;

        // First, perform basic feature tests

        if (isHostMethod(document, "createRange")) {
            testRange = document.createRange();
            if (areHostMethods(testRange, domRangeMethods) && areHostProperties(testRange, domRangeProperties)) {
                implementsDomRange = true;
            }
        }

        var body = getBody(document);
        if (!body || body.nodeName.toLowerCase() != "body") {
            fail("No body element found");
            return;
        }

        if (body && isHostMethod(body, "createTextRange")) {
            testRange = body.createTextRange();
            if (isTextRange(testRange)) {
                implementsTextRange = true;
            }
        }

        if (!implementsDomRange && !implementsTextRange) {
            fail("Neither Range nor TextRange are available");
            return;
        }

        api.initialized = true;
        api.features = {
            implementsDomRange: implementsDomRange,
            implementsTextRange: implementsTextRange
        };

        // Initialize modules
        var module, errorMessage;
        for (var moduleName in modules) {
            if ( (module = modules[moduleName]) instanceof Module ) {
                module.init(module, api);
            }
        }

        // Call init listeners
        for (var i = 0, len = initListeners.length; i < len; ++i) {
            try {
                initListeners[i](api);
            } catch (ex) {
                errorMessage = "Rangy init listener threw an exception. Continuing. Detail: " + getErrorDesc(ex);
                consoleLog(errorMessage);
            }
        }
    }

    // Allow external scripts to initialize this library in case it's loaded after the document has loaded
    api.init = init;

    // Execute listener immediately if already initialized
    api.addInitListener = function(listener) {
        if (api.initialized) {
            listener(api);
        } else {
            initListeners.push(listener);
        }
    };

    var shimListeners = [];

    api.addShimListener = function(listener) {
        shimListeners.push(listener);
    };

    function shim(win) {
        win = win || window;
        init();

        // Notify listeners
        for (var i = 0, len = shimListeners.length; i < len; ++i) {
            shimListeners[i](win);
        }
    }

    if (isBrowser) {
        api.shim = api.createMissingNativeApi = shim;
    }

    function Module(name, dependencies, initializer) {
        this.name = name;
        this.dependencies = dependencies;
        this.initialized = false;
        this.supported = false;
        this.initializer = initializer;
    }

    Module.prototype = {
        init: function() {
            var requiredModuleNames = this.dependencies || [];
            for (var i = 0, len = requiredModuleNames.length, requiredModule, moduleName; i < len; ++i) {
                moduleName = requiredModuleNames[i];

                requiredModule = modules[moduleName];
                if (!requiredModule || !(requiredModule instanceof Module)) {
                    throw new Error("required module '" + moduleName + "' not found");
                }

                requiredModule.init();

                if (!requiredModule.supported) {
                    throw new Error("required module '" + moduleName + "' not supported");
                }
            }
            
            // Now run initializer
            this.initializer(this);
        },
        
        fail: function(reason) {
            this.initialized = true;
            this.supported = false;
            throw new Error("Module '" + this.name + "' failed to load: " + reason);
        },

        warn: function(msg) {
            api.warn("Module " + this.name + ": " + msg);
        },

        deprecationNotice: function(deprecated, replacement) {
            api.warn("DEPRECATED: " + deprecated + " in module " + this.name + "is deprecated. Please use " +
                replacement + " instead");
        },

        createError: function(msg) {
            return new Error("Error in Rangy " + this.name + " module: " + msg);
        }
    };
    
    function createModule(name, dependencies, initFunc) {
        var newModule = new Module(name, dependencies, function(module) {
            if (!module.initialized) {
                module.initialized = true;
                try {
                    initFunc(api, module);
                    module.supported = true;
                } catch (ex) {
                    var errorMessage = "Module '" + name + "' failed to load: " + getErrorDesc(ex);
                    consoleLog(errorMessage);
                    if (ex.stack) {
                        consoleLog(ex.stack);
                    }
                }
            }
        });
        modules[name] = newModule;
        return newModule;
    }

    api.createModule = function(name) {
        // Allow 2 or 3 arguments (second argument is an optional array of dependencies)
        var initFunc, dependencies;
        if (arguments.length == 2) {
            initFunc = arguments[1];
            dependencies = [];
        } else {
            initFunc = arguments[2];
            dependencies = arguments[1];
        }

        var module = createModule(name, dependencies, initFunc);

        // Initialize the module immediately if the core is already initialized
        if (api.initialized && api.supported) {
            module.init();
        }
    };

    api.createCoreModule = function(name, dependencies, initFunc) {
        createModule(name, dependencies, initFunc);
    };

    /*----------------------------------------------------------------------------------------------------------------*/

    // Ensure rangy.rangePrototype and rangy.selectionPrototype are available immediately

    function RangePrototype() {}
    api.RangePrototype = RangePrototype;
    api.rangePrototype = new RangePrototype();

    function SelectionPrototype() {}
    api.selectionPrototype = new SelectionPrototype();

    /*----------------------------------------------------------------------------------------------------------------*/

    // DOM utility methods used by Rangy
    api.createCoreModule("DomUtil", [], function(api, module) {
        var UNDEF = "undefined";
        var util = api.util;

        // Perform feature tests
        if (!util.areHostMethods(document, ["createDocumentFragment", "createElement", "createTextNode"])) {
            module.fail("document missing a Node creation method");
        }

        if (!util.isHostMethod(document, "getElementsByTagName")) {
            module.fail("document missing getElementsByTagName method");
        }

        var el = document.createElement("div");
        if (!util.areHostMethods(el, ["insertBefore", "appendChild", "cloneNode"] ||
                !util.areHostObjects(el, ["previousSibling", "nextSibling", "childNodes", "parentNode"]))) {
            module.fail("Incomplete Element implementation");
        }

        // innerHTML is required for Range's createContextualFragment method
        if (!util.isHostProperty(el, "innerHTML")) {
            module.fail("Element is missing innerHTML property");
        }

        var textNode = document.createTextNode("test");
        if (!util.areHostMethods(textNode, ["splitText", "deleteData", "insertData", "appendData", "cloneNode"] ||
                !util.areHostObjects(el, ["previousSibling", "nextSibling", "childNodes", "parentNode"]) ||
                !util.areHostProperties(textNode, ["data"]))) {
            module.fail("Incomplete Text Node implementation");
        }

        /*----------------------------------------------------------------------------------------------------------------*/

        // Removed use of indexOf because of a bizarre bug in Opera that is thrown in one of the Acid3 tests. I haven't been
        // able to replicate it outside of the test. The bug is that indexOf returns -1 when called on an Array that
        // contains just the document as a single element and the value searched for is the document.
        var arrayContains = /*Array.prototype.indexOf ?
            function(arr, val) {
                return arr.indexOf(val) > -1;
            }:*/

            function(arr, val) {
                var i = arr.length;
                while (i--) {
                    if (arr[i] === val) {
                        return true;
                    }
                }
                return false;
            };

        // Opera 11 puts HTML elements in the null namespace, it seems, and IE 7 has undefined namespaceURI
        function isHtmlNamespace(node) {
            var ns;
            return typeof node.namespaceURI == UNDEF || ((ns = node.namespaceURI) === null || ns == "http://www.w3.org/1999/xhtml");
        }

        function parentElement(node) {
            var parent = node.parentNode;
            return (parent.nodeType == 1) ? parent : null;
        }

        function getNodeIndex(node) {
            var i = 0;
            while( (node = node.previousSibling) ) {
                ++i;
            }
            return i;
        }

        function getNodeLength(node) {
            switch (node.nodeType) {
                case 7:
                case 10:
                    return 0;
                case 3:
                case 8:
                    return node.length;
                default:
                    return node.childNodes.length;
            }
        }

        function getCommonAncestor(node1, node2) {
            var ancestors = [], n;
            for (n = node1; n; n = n.parentNode) {
                ancestors.push(n);
            }

            for (n = node2; n; n = n.parentNode) {
                if (arrayContains(ancestors, n)) {
                    return n;
                }
            }

            return null;
        }

        function isAncestorOf(ancestor, descendant, selfIsAncestor) {
            var n = selfIsAncestor ? descendant : descendant.parentNode;
            while (n) {
                if (n === ancestor) {
                    return true;
                } else {
                    n = n.parentNode;
                }
            }
            return false;
        }

        function isOrIsAncestorOf(ancestor, descendant) {
            return isAncestorOf(ancestor, descendant, true);
        }

        function getClosestAncestorIn(node, ancestor, selfIsAncestor) {
            var p, n = selfIsAncestor ? node : node.parentNode;
            while (n) {
                p = n.parentNode;
                if (p === ancestor) {
                    return n;
                }
                n = p;
            }
            return null;
        }

        function isCharacterDataNode(node) {
            var t = node.nodeType;
            return t == 3 || t == 4 || t == 8 ; // Text, CDataSection or Comment
        }

        function isTextOrCommentNode(node) {
            if (!node) {
                return false;
            }
            var t = node.nodeType;
            return t == 3 || t == 8 ; // Text or Comment
        }

        function insertAfter(node, precedingNode) {
            var nextNode = precedingNode.nextSibling, parent = precedingNode.parentNode;
            if (nextNode) {
                parent.insertBefore(node, nextNode);
            } else {
                parent.appendChild(node);
            }
            return node;
        }

        // Note that we cannot use splitText() because it is bugridden in IE 9.
        function splitDataNode(node, index, positionsToPreserve) {
            var newNode = node.cloneNode(false);
            newNode.deleteData(0, index);
            node.deleteData(index, node.length - index);
            insertAfter(newNode, node);

            // Preserve positions
            if (positionsToPreserve) {
                for (var i = 0, position; position = positionsToPreserve[i++]; ) {
                    // Handle case where position was inside the portion of node after the split point
                    if (position.node == node && position.offset > index) {
                        position.node = newNode;
                        position.offset -= index;
                    }
                    // Handle the case where the position is a node offset within node's parent
                    else if (position.node == node.parentNode && position.offset > getNodeIndex(node)) {
                        ++position.offset;
                    }
                }
            }
            return newNode;
        }

        function getDocument(node) {
            if (node.nodeType == 9) {
                return node;
            } else if (typeof node.ownerDocument != UNDEF) {
                return node.ownerDocument;
            } else if (typeof node.document != UNDEF) {
                return node.document;
            } else if (node.parentNode) {
                return getDocument(node.parentNode);
            } else {
                throw module.createError("getDocument: no document found for node");
            }
        }

        function getWindow(node) {
            var doc = getDocument(node);
            if (typeof doc.defaultView != UNDEF) {
                return doc.defaultView;
            } else if (typeof doc.parentWindow != UNDEF) {
                return doc.parentWindow;
            } else {
                throw module.createError("Cannot get a window object for node");
            }
        }

        function getIframeDocument(iframeEl) {
            if (typeof iframeEl.contentDocument != UNDEF) {
                return iframeEl.contentDocument;
            } else if (typeof iframeEl.contentWindow != UNDEF) {
                return iframeEl.contentWindow.document;
            } else {
                throw module.createError("getIframeDocument: No Document object found for iframe element");
            }
        }

        function getIframeWindow(iframeEl) {
            if (typeof iframeEl.contentWindow != UNDEF) {
                return iframeEl.contentWindow;
            } else if (typeof iframeEl.contentDocument != UNDEF) {
                return iframeEl.contentDocument.defaultView;
            } else {
                throw module.createError("getIframeWindow: No Window object found for iframe element");
            }
        }

        // This looks bad. Is it worth it?
        function isWindow(obj) {
            return obj && util.isHostMethod(obj, "setTimeout") && util.isHostObject(obj, "document");
        }

        function getContentDocument(obj, module, methodName) {
            var doc;

            if (!obj) {
                doc = document;
            }

            // Test if a DOM node has been passed and obtain a document object for it if so
            else if (util.isHostProperty(obj, "nodeType")) {
                doc = (obj.nodeType == 1 && obj.tagName.toLowerCase() == "iframe") ?
                    getIframeDocument(obj) : getDocument(obj);
            }

            // Test if the doc parameter appears to be a Window object
            else if (isWindow(obj)) {
                doc = obj.document;
            }

            if (!doc) {
                throw module.createError(methodName + "(): Parameter must be a Window object or DOM node");
            }

            return doc;
        }

        function getRootContainer(node) {
            var parent;
            while ( (parent = node.parentNode) ) {
                node = parent;
            }
            return node;
        }

        function comparePoints(nodeA, offsetA, nodeB, offsetB) {
            // See http://www.w3.org/TR/DOM-Level-2-Traversal-Range/ranges.html#Level-2-Range-Comparing
            var nodeC, root, childA, childB, n;
            if (nodeA == nodeB) {
                // Case 1: nodes are the same
                return offsetA === offsetB ? 0 : (offsetA < offsetB) ? -1 : 1;
            } else if ( (nodeC = getClosestAncestorIn(nodeB, nodeA, true)) ) {
                // Case 2: node C (container B or an ancestor) is a child node of A
                return offsetA <= getNodeIndex(nodeC) ? -1 : 1;
            } else if ( (nodeC = getClosestAncestorIn(nodeA, nodeB, true)) ) {
                // Case 3: node C (container A or an ancestor) is a child node of B
                return getNodeIndex(nodeC) < offsetB  ? -1 : 1;
            } else {
                root = getCommonAncestor(nodeA, nodeB);
                if (!root) {
                    throw new Error("comparePoints error: nodes have no common ancestor");
                }

                // Case 4: containers are siblings or descendants of siblings
                childA = (nodeA === root) ? root : getClosestAncestorIn(nodeA, root, true);
                childB = (nodeB === root) ? root : getClosestAncestorIn(nodeB, root, true);

                if (childA === childB) {
                    // This shouldn't be possible
                    throw module.createError("comparePoints got to case 4 and childA and childB are the same!");
                } else {
                    n = root.firstChild;
                    while (n) {
                        if (n === childA) {
                            return -1;
                        } else if (n === childB) {
                            return 1;
                        }
                        n = n.nextSibling;
                    }
                }
            }
        }

        /*----------------------------------------------------------------------------------------------------------------*/

        // Test for IE's crash (IE 6/7) or exception (IE >= 8) when a reference to garbage-collected text node is queried
        var crashyTextNodes = false;

        function isBrokenNode(node) {
            var n;
            try {
                n = node.parentNode;
                return false;
            } catch (e) {
                return true;
            }
        }

        (function() {
            var el = document.createElement("b");
            el.innerHTML = "1";
            var textNode = el.firstChild;
            el.innerHTML = "<br>";
            crashyTextNodes = isBrokenNode(textNode);

            api.features.crashyTextNodes = crashyTextNodes;
        })();

        /*----------------------------------------------------------------------------------------------------------------*/

        function inspectNode(node) {
            if (!node) {
                return "[No node]";
            }
            if (crashyTextNodes && isBrokenNode(node)) {
                return "[Broken node]";
            }
            if (isCharacterDataNode(node)) {
                return '"' + node.data + '"';
            }
            if (node.nodeType == 1) {
                var idAttr = node.id ? ' id="' + node.id + '"' : "";
                return "<" + node.nodeName + idAttr + ">[index:" + getNodeIndex(node) + ",length:" + node.childNodes.length + "][" + (node.innerHTML || "[innerHTML not supported]").slice(0, 25) + "]";
            }
            return node.nodeName;
        }

        function fragmentFromNodeChildren(node) {
            var fragment = getDocument(node).createDocumentFragment(), child;
            while ( (child = node.firstChild) ) {
                fragment.appendChild(child);
            }
            return fragment;
        }

        var getComputedStyleProperty;
        if (typeof window.getComputedStyle != UNDEF) {
            getComputedStyleProperty = function(el, propName) {
                return getWindow(el).getComputedStyle(el, null)[propName];
            };
        } else if (typeof document.documentElement.currentStyle != UNDEF) {
            getComputedStyleProperty = function(el, propName) {
                return el.currentStyle[propName];
            };
        } else {
            module.fail("No means of obtaining computed style properties found");
        }

        function NodeIterator(root) {
            this.root = root;
            this._next = root;
        }

        NodeIterator.prototype = {
            _current: null,

            hasNext: function() {
                return !!this._next;
            },

            next: function() {
                var n = this._current = this._next;
                var child, next;
                if (this._current) {
                    child = n.firstChild;
                    if (child) {
                        this._next = child;
                    } else {
                        next = null;
                        while ((n !== this.root) && !(next = n.nextSibling)) {
                            n = n.parentNode;
                        }
                        this._next = next;
                    }
                }
                return this._current;
            },

            detach: function() {
                this._current = this._next = this.root = null;
            }
        };

        function createIterator(root) {
            return new NodeIterator(root);
        }

        function DomPosition(node, offset) {
            this.node = node;
            this.offset = offset;
        }

        DomPosition.prototype = {
            equals: function(pos) {
                return !!pos && this.node === pos.node && this.offset == pos.offset;
            },

            inspect: function() {
                return "[DomPosition(" + inspectNode(this.node) + ":" + this.offset + ")]";
            },

            toString: function() {
                return this.inspect();
            }
        };

        function DOMException(codeName) {
            this.code = this[codeName];
            this.codeName = codeName;
            this.message = "DOMException: " + this.codeName;
        }

        DOMException.prototype = {
            INDEX_SIZE_ERR: 1,
            HIERARCHY_REQUEST_ERR: 3,
            WRONG_DOCUMENT_ERR: 4,
            NO_MODIFICATION_ALLOWED_ERR: 7,
            NOT_FOUND_ERR: 8,
            NOT_SUPPORTED_ERR: 9,
            INVALID_STATE_ERR: 11,
            INVALID_NODE_TYPE_ERR: 24
        };

        DOMException.prototype.toString = function() {
            return this.message;
        };

        api.dom = {
            arrayContains: arrayContains,
            isHtmlNamespace: isHtmlNamespace,
            parentElement: parentElement,
            getNodeIndex: getNodeIndex,
            getNodeLength: getNodeLength,
            getCommonAncestor: getCommonAncestor,
            isAncestorOf: isAncestorOf,
            isOrIsAncestorOf: isOrIsAncestorOf,
            getClosestAncestorIn: getClosestAncestorIn,
            isCharacterDataNode: isCharacterDataNode,
            isTextOrCommentNode: isTextOrCommentNode,
            insertAfter: insertAfter,
            splitDataNode: splitDataNode,
            getDocument: getDocument,
            getWindow: getWindow,
            getIframeWindow: getIframeWindow,
            getIframeDocument: getIframeDocument,
            getBody: util.getBody,
            isWindow: isWindow,
            getContentDocument: getContentDocument,
            getRootContainer: getRootContainer,
            comparePoints: comparePoints,
            isBrokenNode: isBrokenNode,
            inspectNode: inspectNode,
            getComputedStyleProperty: getComputedStyleProperty,
            fragmentFromNodeChildren: fragmentFromNodeChildren,
            createIterator: createIterator,
            DomPosition: DomPosition
        };

        api.DOMException = DOMException;
    });

    /*----------------------------------------------------------------------------------------------------------------*/

    // Pure JavaScript implementation of DOM Range
    api.createCoreModule("DomRange", ["DomUtil"], function(api, module) {
        var dom = api.dom;
        var util = api.util;
        var DomPosition = dom.DomPosition;
        var DOMException = api.DOMException;

        var isCharacterDataNode = dom.isCharacterDataNode;
        var getNodeIndex = dom.getNodeIndex;
        var isOrIsAncestorOf = dom.isOrIsAncestorOf;
        var getDocument = dom.getDocument;
        var comparePoints = dom.comparePoints;
        var splitDataNode = dom.splitDataNode;
        var getClosestAncestorIn = dom.getClosestAncestorIn;
        var getNodeLength = dom.getNodeLength;
        var arrayContains = dom.arrayContains;
        var getRootContainer = dom.getRootContainer;
        var crashyTextNodes = api.features.crashyTextNodes;

        /*----------------------------------------------------------------------------------------------------------------*/

        // Utility functions

        function isNonTextPartiallySelected(node, range) {
            return (node.nodeType != 3) &&
                   (isOrIsAncestorOf(node, range.startContainer) || isOrIsAncestorOf(node, range.endContainer));
        }

        function getRangeDocument(range) {
            return range.document || getDocument(range.startContainer);
        }

        function getBoundaryBeforeNode(node) {
            return new DomPosition(node.parentNode, getNodeIndex(node));
        }

        function getBoundaryAfterNode(node) {
            return new DomPosition(node.parentNode, getNodeIndex(node) + 1);
        }

        function insertNodeAtPosition(node, n, o) {
            var firstNodeInserted = node.nodeType == 11 ? node.firstChild : node;
            if (isCharacterDataNode(n)) {
                if (o == n.length) {
                    dom.insertAfter(node, n);
                } else {
                    n.parentNode.insertBefore(node, o == 0 ? n : splitDataNode(n, o));
                }
            } else if (o >= n.childNodes.length) {
                n.appendChild(node);
            } else {
                n.insertBefore(node, n.childNodes[o]);
            }
            return firstNodeInserted;
        }

        function rangesIntersect(rangeA, rangeB, touchingIsIntersecting) {
            assertRangeValid(rangeA);
            assertRangeValid(rangeB);

            if (getRangeDocument(rangeB) != getRangeDocument(rangeA)) {
                throw new DOMException("WRONG_DOCUMENT_ERR");
            }

            var startComparison = comparePoints(rangeA.startContainer, rangeA.startOffset, rangeB.endContainer, rangeB.endOffset),
                endComparison = comparePoints(rangeA.endContainer, rangeA.endOffset, rangeB.startContainer, rangeB.startOffset);

            return touchingIsIntersecting ? startComparison <= 0 && endComparison >= 0 : startComparison < 0 && endComparison > 0;
        }

        function cloneSubtree(iterator) {
            var partiallySelected;
            for (var node, frag = getRangeDocument(iterator.range).createDocumentFragment(), subIterator; node = iterator.next(); ) {
                partiallySelected = iterator.isPartiallySelectedSubtree();
                node = node.cloneNode(!partiallySelected);
                if (partiallySelected) {
                    subIterator = iterator.getSubtreeIterator();
                    node.appendChild(cloneSubtree(subIterator));
                    subIterator.detach();
                }

                if (node.nodeType == 10) { // DocumentType
                    throw new DOMException("HIERARCHY_REQUEST_ERR");
                }
                frag.appendChild(node);
            }
            return frag;
        }

        function iterateSubtree(rangeIterator, func, iteratorState) {
            var it, n;
            iteratorState = iteratorState || { stop: false };
            for (var node, subRangeIterator; node = rangeIterator.next(); ) {
                if (rangeIterator.isPartiallySelectedSubtree()) {
                    if (func(node) === false) {
                        iteratorState.stop = true;
                        return;
                    } else {
                        // The node is partially selected by the Range, so we can use a new RangeIterator on the portion of
                        // the node selected by the Range.
                        subRangeIterator = rangeIterator.getSubtreeIterator();
                        iterateSubtree(subRangeIterator, func, iteratorState);
                        subRangeIterator.detach();
                        if (iteratorState.stop) {
                            return;
                        }
                    }
                } else {
                    // The whole node is selected, so we can use efficient DOM iteration to iterate over the node and its
                    // descendants
                    it = dom.createIterator(node);
                    while ( (n = it.next()) ) {
                        if (func(n) === false) {
                            iteratorState.stop = true;
                            return;
                        }
                    }
                }
            }
        }

        function deleteSubtree(iterator) {
            var subIterator;
            while (iterator.next()) {
                if (iterator.isPartiallySelectedSubtree()) {
                    subIterator = iterator.getSubtreeIterator();
                    deleteSubtree(subIterator);
                    subIterator.detach();
                } else {
                    iterator.remove();
                }
            }
        }

        function extractSubtree(iterator) {
            for (var node, frag = getRangeDocument(iterator.range).createDocumentFragment(), subIterator; node = iterator.next(); ) {

                if (iterator.isPartiallySelectedSubtree()) {
                    node = node.cloneNode(false);
                    subIterator = iterator.getSubtreeIterator();
                    node.appendChild(extractSubtree(subIterator));
                    subIterator.detach();
                } else {
                    iterator.remove();
                }
                if (node.nodeType == 10) { // DocumentType
                    throw new DOMException("HIERARCHY_REQUEST_ERR");
                }
                frag.appendChild(node);
            }
            return frag;
        }

        function getNodesInRange(range, nodeTypes, filter) {
            var filterNodeTypes = !!(nodeTypes && nodeTypes.length), regex;
            var filterExists = !!filter;
            if (filterNodeTypes) {
                regex = new RegExp("^(" + nodeTypes.join("|") + ")$");
            }

            var nodes = [];
            iterateSubtree(new RangeIterator(range, false), function(node) {
                if (filterNodeTypes && !regex.test(node.nodeType)) {
                    return;
                }
                if (filterExists && !filter(node)) {
                    return;
                }
                // Don't include a boundary container if it is a character data node and the range does not contain any
                // of its character data. See issue 190.
                var sc = range.startContainer;
                if (node == sc && isCharacterDataNode(sc) && range.startOffset == sc.length) {
                    return;
                }

                var ec = range.endContainer;
                if (node == ec && isCharacterDataNode(ec) && range.endOffset == 0) {
                    return;
                }

                nodes.push(node);
            });
            return nodes;
        }

        function inspect(range) {
            var name = (typeof range.getName == "undefined") ? "Range" : range.getName();
            return "[" + name + "(" + dom.inspectNode(range.startContainer) + ":" + range.startOffset + ", " +
                    dom.inspectNode(range.endContainer) + ":" + range.endOffset + ")]";
        }

        /*----------------------------------------------------------------------------------------------------------------*/

        // RangeIterator code partially borrows from IERange by Tim Ryan (http://github.com/timcameronryan/IERange)

        function RangeIterator(range, clonePartiallySelectedTextNodes) {
            this.range = range;
            this.clonePartiallySelectedTextNodes = clonePartiallySelectedTextNodes;


            if (!range.collapsed) {
                this.sc = range.startContainer;
                this.so = range.startOffset;
                this.ec = range.endContainer;
                this.eo = range.endOffset;
                var root = range.commonAncestorContainer;

                if (this.sc === this.ec && isCharacterDataNode(this.sc)) {
                    this.isSingleCharacterDataNode = true;
                    this._first = this._last = this._next = this.sc;
                } else {
                    this._first = this._next = (this.sc === root && !isCharacterDataNode(this.sc)) ?
                        this.sc.childNodes[this.so] : getClosestAncestorIn(this.sc, root, true);
                    this._last = (this.ec === root && !isCharacterDataNode(this.ec)) ?
                        this.ec.childNodes[this.eo - 1] : getClosestAncestorIn(this.ec, root, true);
                }
            }
        }

        RangeIterator.prototype = {
            _current: null,
            _next: null,
            _first: null,
            _last: null,
            isSingleCharacterDataNode: false,

            reset: function() {
                this._current = null;
                this._next = this._first;
            },

            hasNext: function() {
                return !!this._next;
            },

            next: function() {
                // Move to next node
                var current = this._current = this._next;
                if (current) {
                    this._next = (current !== this._last) ? current.nextSibling : null;

                    // Check for partially selected text nodes
                    if (isCharacterDataNode(current) && this.clonePartiallySelectedTextNodes) {
                        if (current === this.ec) {
                            (current = current.cloneNode(true)).deleteData(this.eo, current.length - this.eo);
                        }
                        if (this._current === this.sc) {
                            (current = current.cloneNode(true)).deleteData(0, this.so);
                        }
                    }
                }

                return current;
            },

            remove: function() {
                var current = this._current, start, end;

                if (isCharacterDataNode(current) && (current === this.sc || current === this.ec)) {
                    start = (current === this.sc) ? this.so : 0;
                    end = (current === this.ec) ? this.eo : current.length;
                    if (start != end) {
                        current.deleteData(start, end - start);
                    }
                } else {
                    if (current.parentNode) {
                        current.parentNode.removeChild(current);
                    } else {
                    }
                }
            },

            // Checks if the current node is partially selected
            isPartiallySelectedSubtree: function() {
                var current = this._current;
                return isNonTextPartiallySelected(current, this.range);
            },

            getSubtreeIterator: function() {
                var subRange;
                if (this.isSingleCharacterDataNode) {
                    subRange = this.range.cloneRange();
                    subRange.collapse(false);
                } else {
                    subRange = new Range(getRangeDocument(this.range));
                    var current = this._current;
                    var startContainer = current, startOffset = 0, endContainer = current, endOffset = getNodeLength(current);

                    if (isOrIsAncestorOf(current, this.sc)) {
                        startContainer = this.sc;
                        startOffset = this.so;
                    }
                    if (isOrIsAncestorOf(current, this.ec)) {
                        endContainer = this.ec;
                        endOffset = this.eo;
                    }

                    updateBoundaries(subRange, startContainer, startOffset, endContainer, endOffset);
                }
                return new RangeIterator(subRange, this.clonePartiallySelectedTextNodes);
            },

            detach: function() {
                this.range = this._current = this._next = this._first = this._last = this.sc = this.so = this.ec = this.eo = null;
            }
        };

        /*----------------------------------------------------------------------------------------------------------------*/

        var beforeAfterNodeTypes = [1, 3, 4, 5, 7, 8, 10];
        var rootContainerNodeTypes = [2, 9, 11];
        var readonlyNodeTypes = [5, 6, 10, 12];
        var insertableNodeTypes = [1, 3, 4, 5, 7, 8, 10, 11];
        var surroundNodeTypes = [1, 3, 4, 5, 7, 8];

        function createAncestorFinder(nodeTypes) {
            return function(node, selfIsAncestor) {
                var t, n = selfIsAncestor ? node : node.parentNode;
                while (n) {
                    t = n.nodeType;
                    if (arrayContains(nodeTypes, t)) {
                        return n;
                    }
                    n = n.parentNode;
                }
                return null;
            };
        }

        var getDocumentOrFragmentContainer = createAncestorFinder( [9, 11] );
        var getReadonlyAncestor = createAncestorFinder(readonlyNodeTypes);
        var getDocTypeNotationEntityAncestor = createAncestorFinder( [6, 10, 12] );

        function assertNoDocTypeNotationEntityAncestor(node, allowSelf) {
            if (getDocTypeNotationEntityAncestor(node, allowSelf)) {
                throw new DOMException("INVALID_NODE_TYPE_ERR");
            }
        }

        function assertValidNodeType(node, invalidTypes) {
            if (!arrayContains(invalidTypes, node.nodeType)) {
                throw new DOMException("INVALID_NODE_TYPE_ERR");
            }
        }

        function assertValidOffset(node, offset) {
            if (offset < 0 || offset > (isCharacterDataNode(node) ? node.length : node.childNodes.length)) {
                throw new DOMException("INDEX_SIZE_ERR");
            }
        }

        function assertSameDocumentOrFragment(node1, node2) {
            if (getDocumentOrFragmentContainer(node1, true) !== getDocumentOrFragmentContainer(node2, true)) {
                throw new DOMException("WRONG_DOCUMENT_ERR");
            }
        }

        function assertNodeNotReadOnly(node) {
            if (getReadonlyAncestor(node, true)) {
                throw new DOMException("NO_MODIFICATION_ALLOWED_ERR");
            }
        }

        function assertNode(node, codeName) {
            if (!node) {
                throw new DOMException(codeName);
            }
        }

        function isOrphan(node) {
            return (crashyTextNodes && dom.isBrokenNode(node)) ||
                !arrayContains(rootContainerNodeTypes, node.nodeType) && !getDocumentOrFragmentContainer(node, true);
        }

        function isValidOffset(node, offset) {
            return offset <= (isCharacterDataNode(node) ? node.length : node.childNodes.length);
        }

        function isRangeValid(range) {
            return (!!range.startContainer && !!range.endContainer &&
                    !isOrphan(range.startContainer) &&
                    !isOrphan(range.endContainer) &&
                    isValidOffset(range.startContainer, range.startOffset) &&
                    isValidOffset(range.endContainer, range.endOffset));
        }

        function assertRangeValid(range) {
            if (!isRangeValid(range)) {
                throw new Error("Range error: Range is no longer valid after DOM mutation (" + range.inspect() + ")");
            }
        }

        /*----------------------------------------------------------------------------------------------------------------*/

        // Test the browser's innerHTML support to decide how to implement createContextualFragment
        var styleEl = document.createElement("style");
        var htmlParsingConforms = false;
        try {
            styleEl.innerHTML = "<b>x</b>";
            htmlParsingConforms = (styleEl.firstChild.nodeType == 3); // Opera incorrectly creates an element node
        } catch (e) {
            // IE 6 and 7 throw
        }

        api.features.htmlParsingConforms = htmlParsingConforms;

        var createContextualFragment = htmlParsingConforms ?

            // Implementation as per HTML parsing spec, trusting in the browser's implementation of innerHTML. See
            // discussion and base code for this implementation at issue 67.
            // Spec: http://html5.org/specs/dom-parsing.html#extensions-to-the-range-interface
            // Thanks to Aleks Williams.
            function(fragmentStr) {
                // "Let node the context object's start's node."
                var node = this.startContainer;
                var doc = getDocument(node);

                // "If the context object's start's node is null, raise an INVALID_STATE_ERR
                // exception and abort these steps."
                if (!node) {
                    throw new DOMException("INVALID_STATE_ERR");
                }

                // "Let element be as follows, depending on node's interface:"
                // Document, Document Fragment: null
                var el = null;

                // "Element: node"
                if (node.nodeType == 1) {
                    el = node;

                // "Text, Comment: node's parentElement"
                } else if (isCharacterDataNode(node)) {
                    el = dom.parentElement(node);
                }

                // "If either element is null or element's ownerDocument is an HTML document
                // and element's local name is "html" and element's namespace is the HTML
                // namespace"
                if (el === null || (
                    el.nodeName == "HTML" &&
                    dom.isHtmlNamespace(getDocument(el).documentElement) &&
                    dom.isHtmlNamespace(el)
                )) {

                // "let element be a new Element with "body" as its local name and the HTML
                // namespace as its namespace.""
                    el = doc.createElement("body");
                } else {
                    el = el.cloneNode(false);
                }

                // "If the node's document is an HTML document: Invoke the HTML fragment parsing algorithm."
                // "If the node's document is an XML document: Invoke the XML fragment parsing algorithm."
                // "In either case, the algorithm must be invoked with fragment as the input
                // and element as the context element."
                el.innerHTML = fragmentStr;

                // "If this raises an exception, then abort these steps. Otherwise, let new
                // children be the nodes returned."

                // "Let fragment be a new DocumentFragment."
                // "Append all new children to fragment."
                // "Return fragment."
                return dom.fragmentFromNodeChildren(el);
            } :

            // In this case, innerHTML cannot be trusted, so fall back to a simpler, non-conformant implementation that
            // previous versions of Rangy used (with the exception of using a body element rather than a div)
            function(fragmentStr) {
                var doc = getRangeDocument(this);
                var el = doc.createElement("body");
                el.innerHTML = fragmentStr;

                return dom.fragmentFromNodeChildren(el);
            };

        function splitRangeBoundaries(range, positionsToPreserve) {
            assertRangeValid(range);

            var sc = range.startContainer, so = range.startOffset, ec = range.endContainer, eo = range.endOffset;
            var startEndSame = (sc === ec);

            if (isCharacterDataNode(ec) && eo > 0 && eo < ec.length) {
                splitDataNode(ec, eo, positionsToPreserve);
            }

            if (isCharacterDataNode(sc) && so > 0 && so < sc.length) {
                sc = splitDataNode(sc, so, positionsToPreserve);
                if (startEndSame) {
                    eo -= so;
                    ec = sc;
                } else if (ec == sc.parentNode && eo >= getNodeIndex(sc)) {
                    eo++;
                }
                so = 0;
            }
            range.setStartAndEnd(sc, so, ec, eo);
        }
        
        function rangeToHtml(range) {
            assertRangeValid(range);
            var container = range.commonAncestorContainer.parentNode.cloneNode(false);
            container.appendChild( range.cloneContents() );
            return container.innerHTML;
        }

        /*----------------------------------------------------------------------------------------------------------------*/

        var rangeProperties = ["startContainer", "startOffset", "endContainer", "endOffset", "collapsed",
            "commonAncestorContainer"];

        var s2s = 0, s2e = 1, e2e = 2, e2s = 3;
        var n_b = 0, n_a = 1, n_b_a = 2, n_i = 3;

        util.extend(api.rangePrototype, {
            compareBoundaryPoints: function(how, range) {
                assertRangeValid(this);
                assertSameDocumentOrFragment(this.startContainer, range.startContainer);

                var nodeA, offsetA, nodeB, offsetB;
                var prefixA = (how == e2s || how == s2s) ? "start" : "end";
                var prefixB = (how == s2e || how == s2s) ? "start" : "end";
                nodeA = this[prefixA + "Container"];
                offsetA = this[prefixA + "Offset"];
                nodeB = range[prefixB + "Container"];
                offsetB = range[prefixB + "Offset"];
                return comparePoints(nodeA, offsetA, nodeB, offsetB);
            },

            insertNode: function(node) {
                assertRangeValid(this);
                assertValidNodeType(node, insertableNodeTypes);
                assertNodeNotReadOnly(this.startContainer);

                if (isOrIsAncestorOf(node, this.startContainer)) {
                    throw new DOMException("HIERARCHY_REQUEST_ERR");
                }

                // No check for whether the container of the start of the Range is of a type that does not allow
                // children of the type of node: the browser's DOM implementation should do this for us when we attempt
                // to add the node

                var firstNodeInserted = insertNodeAtPosition(node, this.startContainer, this.startOffset);
                this.setStartBefore(firstNodeInserted);
            },

            cloneContents: function() {
                assertRangeValid(this);

                var clone, frag;
                if (this.collapsed) {
                    return getRangeDocument(this).createDocumentFragment();
                } else {
                    if (this.startContainer === this.endContainer && isCharacterDataNode(this.startContainer)) {
                        clone = this.startContainer.cloneNode(true);
                        clone.data = clone.data.slice(this.startOffset, this.endOffset);
                        frag = getRangeDocument(this).createDocumentFragment();
                        frag.appendChild(clone);
                        return frag;
                    } else {
                        var iterator = new RangeIterator(this, true);
                        clone = cloneSubtree(iterator);
                        iterator.detach();
                    }
                    return clone;
                }
            },

            canSurroundContents: function() {
                assertRangeValid(this);
                assertNodeNotReadOnly(this.startContainer);
                assertNodeNotReadOnly(this.endContainer);

                // Check if the contents can be surrounded. Specifically, this means whether the range partially selects
                // no non-text nodes.
                var iterator = new RangeIterator(this, true);
                var boundariesInvalid = (iterator._first && (isNonTextPartiallySelected(iterator._first, this)) ||
                        (iterator._last && isNonTextPartiallySelected(iterator._last, this)));
                iterator.detach();
                return !boundariesInvalid;
            },

            surroundContents: function(node) {
                assertValidNodeType(node, surroundNodeTypes);

                if (!this.canSurroundContents()) {
                    throw new DOMException("INVALID_STATE_ERR");
                }

                // Extract the contents
                var content = this.extractContents();

                // Clear the children of the node
                if (node.hasChildNodes()) {
                    while (node.lastChild) {
                        node.removeChild(node.lastChild);
                    }
                }

                // Insert the new node and add the extracted contents
                insertNodeAtPosition(node, this.startContainer, this.startOffset);
                node.appendChild(content);

                this.selectNode(node);
            },

            cloneRange: function() {
                assertRangeValid(this);
                var range = new Range(getRangeDocument(this));
                var i = rangeProperties.length, prop;
                while (i--) {
                    prop = rangeProperties[i];
                    range[prop] = this[prop];
                }
                return range;
            },

            toString: function() {
                assertRangeValid(this);
                var sc = this.startContainer;
                if (sc === this.endContainer && isCharacterDataNode(sc)) {
                    return (sc.nodeType == 3 || sc.nodeType == 4) ? sc.data.slice(this.startOffset, this.endOffset) : "";
                } else {
                    var textParts = [], iterator = new RangeIterator(this, true);
                    iterateSubtree(iterator, function(node) {
                        // Accept only text or CDATA nodes, not comments
                        if (node.nodeType == 3 || node.nodeType == 4) {
                            textParts.push(node.data);
                        }
                    });
                    iterator.detach();
                    return textParts.join("");
                }
            },

            // The methods below are all non-standard. The following batch were introduced by Mozilla but have since
            // been removed from Mozilla.

            compareNode: function(node) {
                assertRangeValid(this);

                var parent = node.parentNode;
                var nodeIndex = getNodeIndex(node);

                if (!parent) {
                    throw new DOMException("NOT_FOUND_ERR");
                }

                var startComparison = this.comparePoint(parent, nodeIndex),
                    endComparison = this.comparePoint(parent, nodeIndex + 1);

                if (startComparison < 0) { // Node starts before
                    return (endComparison > 0) ? n_b_a : n_b;
                } else {
                    return (endComparison > 0) ? n_a : n_i;
                }
            },

            comparePoint: function(node, offset) {
                assertRangeValid(this);
                assertNode(node, "HIERARCHY_REQUEST_ERR");
                assertSameDocumentOrFragment(node, this.startContainer);

                if (comparePoints(node, offset, this.startContainer, this.startOffset) < 0) {
                    return -1;
                } else if (comparePoints(node, offset, this.endContainer, this.endOffset) > 0) {
                    return 1;
                }
                return 0;
            },

            createContextualFragment: createContextualFragment,

            toHtml: function() {
                return rangeToHtml(this);
            },

            // touchingIsIntersecting determines whether this method considers a node that borders a range intersects
            // with it (as in WebKit) or not (as in Gecko pre-1.9, and the default)
            intersectsNode: function(node, touchingIsIntersecting) {
                assertRangeValid(this);
                assertNode(node, "NOT_FOUND_ERR");
                if (getDocument(node) !== getRangeDocument(this)) {
                    return false;
                }

                var parent = node.parentNode, offset = getNodeIndex(node);
                assertNode(parent, "NOT_FOUND_ERR");

                var startComparison = comparePoints(parent, offset, this.endContainer, this.endOffset),
                    endComparison = comparePoints(parent, offset + 1, this.startContainer, this.startOffset);

                return touchingIsIntersecting ? startComparison <= 0 && endComparison >= 0 : startComparison < 0 && endComparison > 0;
            },

            isPointInRange: function(node, offset) {
                assertRangeValid(this);
                assertNode(node, "HIERARCHY_REQUEST_ERR");
                assertSameDocumentOrFragment(node, this.startContainer);

                return (comparePoints(node, offset, this.startContainer, this.startOffset) >= 0) &&
                       (comparePoints(node, offset, this.endContainer, this.endOffset) <= 0);
            },

            // The methods below are non-standard and invented by me.

            // Sharing a boundary start-to-end or end-to-start does not count as intersection.
            intersectsRange: function(range) {
                return rangesIntersect(this, range, false);
            },

            // Sharing a boundary start-to-end or end-to-start does count as intersection.
            intersectsOrTouchesRange: function(range) {
                return rangesIntersect(this, range, true);
            },

            intersection: function(range) {
                if (this.intersectsRange(range)) {
                    var startComparison = comparePoints(this.startContainer, this.startOffset, range.startContainer, range.startOffset),
                        endComparison = comparePoints(this.endContainer, this.endOffset, range.endContainer, range.endOffset);

                    var intersectionRange = this.cloneRange();
                    if (startComparison == -1) {
                        intersectionRange.setStart(range.startContainer, range.startOffset);
                    }
                    if (endComparison == 1) {
                        intersectionRange.setEnd(range.endContainer, range.endOffset);
                    }
                    return intersectionRange;
                }
                return null;
            },

            union: function(range) {
                if (this.intersectsOrTouchesRange(range)) {
                    var unionRange = this.cloneRange();
                    if (comparePoints(range.startContainer, range.startOffset, this.startContainer, this.startOffset) == -1) {
                        unionRange.setStart(range.startContainer, range.startOffset);
                    }
                    if (comparePoints(range.endContainer, range.endOffset, this.endContainer, this.endOffset) == 1) {
                        unionRange.setEnd(range.endContainer, range.endOffset);
                    }
                    return unionRange;
                } else {
                    throw new DOMException("Ranges do not intersect");
                }
            },

            containsNode: function(node, allowPartial) {
                if (allowPartial) {
                    return this.intersectsNode(node, false);
                } else {
                    return this.compareNode(node) == n_i;
                }
            },

            containsNodeContents: function(node) {
                return this.comparePoint(node, 0) >= 0 && this.comparePoint(node, getNodeLength(node)) <= 0;
            },

            containsRange: function(range) {
                var intersection = this.intersection(range);
                return intersection !== null && range.equals(intersection);
            },

            containsNodeText: function(node) {
                var nodeRange = this.cloneRange();
                nodeRange.selectNode(node);
                var textNodes = nodeRange.getNodes([3]);
                if (textNodes.length > 0) {
                    nodeRange.setStart(textNodes[0], 0);
                    var lastTextNode = textNodes.pop();
                    nodeRange.setEnd(lastTextNode, lastTextNode.length);
                    return this.containsRange(nodeRange);
                } else {
                    return this.containsNodeContents(node);
                }
            },

            getNodes: function(nodeTypes, filter) {
                assertRangeValid(this);
                return getNodesInRange(this, nodeTypes, filter);
            },

            getDocument: function() {
                return getRangeDocument(this);
            },

            collapseBefore: function(node) {
                this.setEndBefore(node);
                this.collapse(false);
            },

            collapseAfter: function(node) {
                this.setStartAfter(node);
                this.collapse(true);
            },
            
            getBookmark: function(containerNode) {
                var doc = getRangeDocument(this);
                var preSelectionRange = api.createRange(doc);
                containerNode = containerNode || dom.getBody(doc);
                preSelectionRange.selectNodeContents(containerNode);
                var range = this.intersection(preSelectionRange);
                var start = 0, end = 0;
                if (range) {
                    preSelectionRange.setEnd(range.startContainer, range.startOffset);
                    start = preSelectionRange.toString().length;
                    end = start + range.toString().length;
                }

                return {
                    start: start,
                    end: end,
                    containerNode: containerNode
                };
            },
            
            moveToBookmark: function(bookmark) {
                var containerNode = bookmark.containerNode;
                var charIndex = 0;
                this.setStart(containerNode, 0);
                this.collapse(true);
                var nodeStack = [containerNode], node, foundStart = false, stop = false;
                var nextCharIndex, i, childNodes;

                while (!stop && (node = nodeStack.pop())) {
                    if (node.nodeType == 3) {
                        nextCharIndex = charIndex + node.length;
                        if (!foundStart && bookmark.start >= charIndex && bookmark.start <= nextCharIndex) {
                            this.setStart(node, bookmark.start - charIndex);
                            foundStart = true;
                        }
                        if (foundStart && bookmark.end >= charIndex && bookmark.end <= nextCharIndex) {
                            this.setEnd(node, bookmark.end - charIndex);
                            stop = true;
                        }
                        charIndex = nextCharIndex;
                    } else {
                        childNodes = node.childNodes;
                        i = childNodes.length;
                        while (i--) {
                            nodeStack.push(childNodes[i]);
                        }
                    }
                }
            },

            getName: function() {
                return "DomRange";
            },

            equals: function(range) {
                return Range.rangesEqual(this, range);
            },

            isValid: function() {
                return isRangeValid(this);
            },
            
            inspect: function() {
                return inspect(this);
            },
            
            detach: function() {
                // In DOM4, detach() is now a no-op.
            }
        });

        function copyComparisonConstantsToObject(obj) {
            obj.START_TO_START = s2s;
            obj.START_TO_END = s2e;
            obj.END_TO_END = e2e;
            obj.END_TO_START = e2s;

            obj.NODE_BEFORE = n_b;
            obj.NODE_AFTER = n_a;
            obj.NODE_BEFORE_AND_AFTER = n_b_a;
            obj.NODE_INSIDE = n_i;
        }

        function copyComparisonConstants(constructor) {
            copyComparisonConstantsToObject(constructor);
            copyComparisonConstantsToObject(constructor.prototype);
        }

        function createRangeContentRemover(remover, boundaryUpdater) {
            return function() {
                assertRangeValid(this);

                var sc = this.startContainer, so = this.startOffset, root = this.commonAncestorContainer;

                var iterator = new RangeIterator(this, true);

                // Work out where to position the range after content removal
                var node, boundary;
                if (sc !== root) {
                    node = getClosestAncestorIn(sc, root, true);
                    boundary = getBoundaryAfterNode(node);
                    sc = boundary.node;
                    so = boundary.offset;
                }

                // Check none of the range is read-only
                iterateSubtree(iterator, assertNodeNotReadOnly);

                iterator.reset();

                // Remove the content
                var returnValue = remover(iterator);
                iterator.detach();

                // Move to the new position
                boundaryUpdater(this, sc, so, sc, so);

                return returnValue;
            };
        }

        function createPrototypeRange(constructor, boundaryUpdater) {
            function createBeforeAfterNodeSetter(isBefore, isStart) {
                return function(node) {
                    assertValidNodeType(node, beforeAfterNodeTypes);
                    assertValidNodeType(getRootContainer(node), rootContainerNodeTypes);

                    var boundary = (isBefore ? getBoundaryBeforeNode : getBoundaryAfterNode)(node);
                    (isStart ? setRangeStart : setRangeEnd)(this, boundary.node, boundary.offset);
                };
            }

            function setRangeStart(range, node, offset) {
                var ec = range.endContainer, eo = range.endOffset;
                if (node !== range.startContainer || offset !== range.startOffset) {
                    // Check the root containers of the range and the new boundary, and also check whether the new boundary
                    // is after the current end. In either case, collapse the range to the new position
                    if (getRootContainer(node) != getRootContainer(ec) || comparePoints(node, offset, ec, eo) == 1) {
                        ec = node;
                        eo = offset;
                    }
                    boundaryUpdater(range, node, offset, ec, eo);
                }
            }

            function setRangeEnd(range, node, offset) {
                var sc = range.startContainer, so = range.startOffset;
                if (node !== range.endContainer || offset !== range.endOffset) {
                    // Check the root containers of the range and the new boundary, and also check whether the new boundary
                    // is after the current end. In either case, collapse the range to the new position
                    if (getRootContainer(node) != getRootContainer(sc) || comparePoints(node, offset, sc, so) == -1) {
                        sc = node;
                        so = offset;
                    }
                    boundaryUpdater(range, sc, so, node, offset);
                }
            }

            // Set up inheritance
            var F = function() {};
            F.prototype = api.rangePrototype;
            constructor.prototype = new F();

            util.extend(constructor.prototype, {
                setStart: function(node, offset) {
                    assertNoDocTypeNotationEntityAncestor(node, true);
                    assertValidOffset(node, offset);

                    setRangeStart(this, node, offset);
                },

                setEnd: function(node, offset) {
                    assertNoDocTypeNotationEntityAncestor(node, true);
                    assertValidOffset(node, offset);

                    setRangeEnd(this, node, offset);
                },

                /**
                 * Convenience method to set a range's start and end boundaries. Overloaded as follows:
                 * - Two parameters (node, offset) creates a collapsed range at that position
                 * - Three parameters (node, startOffset, endOffset) creates a range contained with node starting at
                 *   startOffset and ending at endOffset
                 * - Four parameters (startNode, startOffset, endNode, endOffset) creates a range starting at startOffset in
                 *   startNode and ending at endOffset in endNode
                 */
                setStartAndEnd: function() {
                    var args = arguments;
                    var sc = args[0], so = args[1], ec = sc, eo = so;

                    switch (args.length) {
                        case 3:
                            eo = args[2];
                            break;
                        case 4:
                            ec = args[2];
                            eo = args[3];
                            break;
                    }

                    boundaryUpdater(this, sc, so, ec, eo);
                },
                
                setBoundary: function(node, offset, isStart) {
                    this["set" + (isStart ? "Start" : "End")](node, offset);
                },

                setStartBefore: createBeforeAfterNodeSetter(true, true),
                setStartAfter: createBeforeAfterNodeSetter(false, true),
                setEndBefore: createBeforeAfterNodeSetter(true, false),
                setEndAfter: createBeforeAfterNodeSetter(false, false),

                collapse: function(isStart) {
                    assertRangeValid(this);
                    if (isStart) {
                        boundaryUpdater(this, this.startContainer, this.startOffset, this.startContainer, this.startOffset);
                    } else {
                        boundaryUpdater(this, this.endContainer, this.endOffset, this.endContainer, this.endOffset);
                    }
                },

                selectNodeContents: function(node) {
                    assertNoDocTypeNotationEntityAncestor(node, true);

                    boundaryUpdater(this, node, 0, node, getNodeLength(node));
                },

                selectNode: function(node) {
                    assertNoDocTypeNotationEntityAncestor(node, false);
                    assertValidNodeType(node, beforeAfterNodeTypes);

                    var start = getBoundaryBeforeNode(node), end = getBoundaryAfterNode(node);
                    boundaryUpdater(this, start.node, start.offset, end.node, end.offset);
                },

                extractContents: createRangeContentRemover(extractSubtree, boundaryUpdater),

                deleteContents: createRangeContentRemover(deleteSubtree, boundaryUpdater),

                canSurroundContents: function() {
                    assertRangeValid(this);
                    assertNodeNotReadOnly(this.startContainer);
                    assertNodeNotReadOnly(this.endContainer);

                    // Check if the contents can be surrounded. Specifically, this means whether the range partially selects
                    // no non-text nodes.
                    var iterator = new RangeIterator(this, true);
                    var boundariesInvalid = (iterator._first && isNonTextPartiallySelected(iterator._first, this) ||
                            (iterator._last && isNonTextPartiallySelected(iterator._last, this)));
                    iterator.detach();
                    return !boundariesInvalid;
                },

                splitBoundaries: function() {
                    splitRangeBoundaries(this);
                },

                splitBoundariesPreservingPositions: function(positionsToPreserve) {
                    splitRangeBoundaries(this, positionsToPreserve);
                },

                normalizeBoundaries: function() {
                    assertRangeValid(this);

                    var sc = this.startContainer, so = this.startOffset, ec = this.endContainer, eo = this.endOffset;

                    var mergeForward = function(node) {
                        var sibling = node.nextSibling;
                        if (sibling && sibling.nodeType == node.nodeType) {
                            ec = node;
                            eo = node.length;
                            node.appendData(sibling.data);
                            sibling.parentNode.removeChild(sibling);
                        }
                    };

                    var mergeBackward = function(node) {
                        var sibling = node.previousSibling;
                        if (sibling && sibling.nodeType == node.nodeType) {
                            sc = node;
                            var nodeLength = node.length;
                            so = sibling.length;
                            node.insertData(0, sibling.data);
                            sibling.parentNode.removeChild(sibling);
                            if (sc == ec) {
                                eo += so;
                                ec = sc;
                            } else if (ec == node.parentNode) {
                                var nodeIndex = getNodeIndex(node);
                                if (eo == nodeIndex) {
                                    ec = node;
                                    eo = nodeLength;
                                } else if (eo > nodeIndex) {
                                    eo--;
                                }
                            }
                        }
                    };

                    var normalizeStart = true;

                    if (isCharacterDataNode(ec)) {
                        if (ec.length == eo) {
                            mergeForward(ec);
                        }
                    } else {
                        if (eo > 0) {
                            var endNode = ec.childNodes[eo - 1];
                            if (endNode && isCharacterDataNode(endNode)) {
                                mergeForward(endNode);
                            }
                        }
                        normalizeStart = !this.collapsed;
                    }

                    if (normalizeStart) {
                        if (isCharacterDataNode(sc)) {
                            if (so == 0) {
                                mergeBackward(sc);
                            }
                        } else {
                            if (so < sc.childNodes.length) {
                                var startNode = sc.childNodes[so];
                                if (startNode && isCharacterDataNode(startNode)) {
                                    mergeBackward(startNode);
                                }
                            }
                        }
                    } else {
                        sc = ec;
                        so = eo;
                    }

                    boundaryUpdater(this, sc, so, ec, eo);
                },

                collapseToPoint: function(node, offset) {
                    assertNoDocTypeNotationEntityAncestor(node, true);
                    assertValidOffset(node, offset);
                    this.setStartAndEnd(node, offset);
                }
            });

            copyComparisonConstants(constructor);
        }

        /*----------------------------------------------------------------------------------------------------------------*/

        // Updates commonAncestorContainer and collapsed after boundary change
        function updateCollapsedAndCommonAncestor(range) {
            range.collapsed = (range.startContainer === range.endContainer && range.startOffset === range.endOffset);
            range.commonAncestorContainer = range.collapsed ?
                range.startContainer : dom.getCommonAncestor(range.startContainer, range.endContainer);
        }

        function updateBoundaries(range, startContainer, startOffset, endContainer, endOffset) {
            range.startContainer = startContainer;
            range.startOffset = startOffset;
            range.endContainer = endContainer;
            range.endOffset = endOffset;
            range.document = dom.getDocument(startContainer);

            updateCollapsedAndCommonAncestor(range);
        }

        function Range(doc) {
            this.startContainer = doc;
            this.startOffset = 0;
            this.endContainer = doc;
            this.endOffset = 0;
            this.document = doc;
            updateCollapsedAndCommonAncestor(this);
        }

        createPrototypeRange(Range, updateBoundaries);

        util.extend(Range, {
            rangeProperties: rangeProperties,
            RangeIterator: RangeIterator,
            copyComparisonConstants: copyComparisonConstants,
            createPrototypeRange: createPrototypeRange,
            inspect: inspect,
            toHtml: rangeToHtml,
            getRangeDocument: getRangeDocument,
            rangesEqual: function(r1, r2) {
                return r1.startContainer === r2.startContainer &&
                    r1.startOffset === r2.startOffset &&
                    r1.endContainer === r2.endContainer &&
                    r1.endOffset === r2.endOffset;
            }
        });

        api.DomRange = Range;
    });

    /*----------------------------------------------------------------------------------------------------------------*/

    // Wrappers for the browser's native DOM Range and/or TextRange implementation 
    api.createCoreModule("WrappedRange", ["DomRange"], function(api, module) {
        var WrappedRange, WrappedTextRange;
        var dom = api.dom;
        var util = api.util;
        var DomPosition = dom.DomPosition;
        var DomRange = api.DomRange;
        var getBody = dom.getBody;
        var getContentDocument = dom.getContentDocument;
        var isCharacterDataNode = dom.isCharacterDataNode;


        /*----------------------------------------------------------------------------------------------------------------*/

        if (api.features.implementsDomRange) {
            // This is a wrapper around the browser's native DOM Range. It has two aims:
            // - Provide workarounds for specific browser bugs
            // - provide convenient extensions, which are inherited from Rangy's DomRange

            (function() {
                var rangeProto;
                var rangeProperties = DomRange.rangeProperties;

                function updateRangeProperties(range) {
                    var i = rangeProperties.length, prop;
                    while (i--) {
                        prop = rangeProperties[i];
                        range[prop] = range.nativeRange[prop];
                    }
                    // Fix for broken collapsed property in IE 9.
                    range.collapsed = (range.startContainer === range.endContainer && range.startOffset === range.endOffset);
                }

                function updateNativeRange(range, startContainer, startOffset, endContainer, endOffset) {
                    var startMoved = (range.startContainer !== startContainer || range.startOffset != startOffset);
                    var endMoved = (range.endContainer !== endContainer || range.endOffset != endOffset);
                    var nativeRangeDifferent = !range.equals(range.nativeRange);

                    // Always set both boundaries for the benefit of IE9 (see issue 35)
                    if (startMoved || endMoved || nativeRangeDifferent) {
                        range.setEnd(endContainer, endOffset);
                        range.setStart(startContainer, startOffset);
                    }
                }

                var createBeforeAfterNodeSetter;

                WrappedRange = function(range) {
                    if (!range) {
                        throw module.createError("WrappedRange: Range must be specified");
                    }
                    this.nativeRange = range;
                    updateRangeProperties(this);
                };

                DomRange.createPrototypeRange(WrappedRange, updateNativeRange);

                rangeProto = WrappedRange.prototype;

                rangeProto.selectNode = function(node) {
                    this.nativeRange.selectNode(node);
                    updateRangeProperties(this);
                };

                rangeProto.cloneContents = function() {
                    return this.nativeRange.cloneContents();
                };

                // Due to a long-standing Firefox bug that I have not been able to find a reliable way to detect,
                // insertNode() is never delegated to the native range.

                rangeProto.surroundContents = function(node) {
                    this.nativeRange.surroundContents(node);
                    updateRangeProperties(this);
                };

                rangeProto.collapse = function(isStart) {
                    this.nativeRange.collapse(isStart);
                    updateRangeProperties(this);
                };

                rangeProto.cloneRange = function() {
                    return new WrappedRange(this.nativeRange.cloneRange());
                };

                rangeProto.refresh = function() {
                    updateRangeProperties(this);
                };

                rangeProto.toString = function() {
                    return this.nativeRange.toString();
                };

                // Create test range and node for feature detection

                var testTextNode = document.createTextNode("test");
                getBody(document).appendChild(testTextNode);
                var range = document.createRange();

                /*--------------------------------------------------------------------------------------------------------*/

                // Test for Firefox 2 bug that prevents moving the start of a Range to a point after its current end and
                // correct for it

                range.setStart(testTextNode, 0);
                range.setEnd(testTextNode, 0);

                try {
                    range.setStart(testTextNode, 1);

                    rangeProto.setStart = function(node, offset) {
                        this.nativeRange.setStart(node, offset);
                        updateRangeProperties(this);
                    };

                    rangeProto.setEnd = function(node, offset) {
                        this.nativeRange.setEnd(node, offset);
                        updateRangeProperties(this);
                    };

                    createBeforeAfterNodeSetter = function(name) {
                        return function(node) {
                            this.nativeRange[name](node);
                            updateRangeProperties(this);
                        };
                    };

                } catch(ex) {

                    rangeProto.setStart = function(node, offset) {
                        try {
                            this.nativeRange.setStart(node, offset);
                        } catch (ex) {
                            this.nativeRange.setEnd(node, offset);
                            this.nativeRange.setStart(node, offset);
                        }
                        updateRangeProperties(this);
                    };

                    rangeProto.setEnd = function(node, offset) {
                        try {
                            this.nativeRange.setEnd(node, offset);
                        } catch (ex) {
                            this.nativeRange.setStart(node, offset);
                            this.nativeRange.setEnd(node, offset);
                        }
                        updateRangeProperties(this);
                    };

                    createBeforeAfterNodeSetter = function(name, oppositeName) {
                        return function(node) {
                            try {
                                this.nativeRange[name](node);
                            } catch (ex) {
                                this.nativeRange[oppositeName](node);
                                this.nativeRange[name](node);
                            }
                            updateRangeProperties(this);
                        };
                    };
                }

                rangeProto.setStartBefore = createBeforeAfterNodeSetter("setStartBefore", "setEndBefore");
                rangeProto.setStartAfter = createBeforeAfterNodeSetter("setStartAfter", "setEndAfter");
                rangeProto.setEndBefore = createBeforeAfterNodeSetter("setEndBefore", "setStartBefore");
                rangeProto.setEndAfter = createBeforeAfterNodeSetter("setEndAfter", "setStartAfter");

                /*--------------------------------------------------------------------------------------------------------*/

                // Always use DOM4-compliant selectNodeContents implementation: it's simpler and less code than testing
                // whether the native implementation can be trusted
                rangeProto.selectNodeContents = function(node) {
                    this.setStartAndEnd(node, 0, dom.getNodeLength(node));
                };

                /*--------------------------------------------------------------------------------------------------------*/

                // Test for and correct WebKit bug that has the behaviour of compareBoundaryPoints round the wrong way for
                // constants START_TO_END and END_TO_START: https://bugs.webkit.org/show_bug.cgi?id=20738

                range.selectNodeContents(testTextNode);
                range.setEnd(testTextNode, 3);

                var range2 = document.createRange();
                range2.selectNodeContents(testTextNode);
                range2.setEnd(testTextNode, 4);
                range2.setStart(testTextNode, 2);

                if (range.compareBoundaryPoints(range.START_TO_END, range2) == -1 &&
                        range.compareBoundaryPoints(range.END_TO_START, range2) == 1) {
                    // This is the wrong way round, so correct for it

                    rangeProto.compareBoundaryPoints = function(type, range) {
                        range = range.nativeRange || range;
                        if (type == range.START_TO_END) {
                            type = range.END_TO_START;
                        } else if (type == range.END_TO_START) {
                            type = range.START_TO_END;
                        }
                        return this.nativeRange.compareBoundaryPoints(type, range);
                    };
                } else {
                    rangeProto.compareBoundaryPoints = function(type, range) {
                        return this.nativeRange.compareBoundaryPoints(type, range.nativeRange || range);
                    };
                }

                /*--------------------------------------------------------------------------------------------------------*/

                // Test for IE deleteContents() and extractContents() bug and correct it. See issue 107.

                var el = document.createElement("div");
                el.innerHTML = "123";
                var textNode = el.firstChild;
                var body = getBody(document);
                body.appendChild(el);

                range.setStart(textNode, 1);
                range.setEnd(textNode, 2);
                range.deleteContents();

                if (textNode.data == "13") {
                    // Behaviour is correct per DOM4 Range so wrap the browser's implementation of deleteContents() and
                    // extractContents()
                    rangeProto.deleteContents = function() {
                        this.nativeRange.deleteContents();
                        updateRangeProperties(this);
                    };

                    rangeProto.extractContents = function() {
                        var frag = this.nativeRange.extractContents();
                        updateRangeProperties(this);
                        return frag;
                    };
                } else {
                }

                body.removeChild(el);
                body = null;

                /*--------------------------------------------------------------------------------------------------------*/

                // Test for existence of createContextualFragment and delegate to it if it exists
                if (util.isHostMethod(range, "createContextualFragment")) {
                    rangeProto.createContextualFragment = function(fragmentStr) {
                        return this.nativeRange.createContextualFragment(fragmentStr);
                    };
                }

                /*--------------------------------------------------------------------------------------------------------*/

                // Clean up
                getBody(document).removeChild(testTextNode);

                rangeProto.getName = function() {
                    return "WrappedRange";
                };

                api.WrappedRange = WrappedRange;

                api.createNativeRange = function(doc) {
                    doc = getContentDocument(doc, module, "createNativeRange");
                    return doc.createRange();
                };
            })();
        }
        
        if (api.features.implementsTextRange) {
            /*
            This is a workaround for a bug where IE returns the wrong container element from the TextRange's parentElement()
            method. For example, in the following (where pipes denote the selection boundaries):

            <ul id="ul"><li id="a">| a </li><li id="b"> b |</li></ul>

            var range = document.selection.createRange();
            alert(range.parentElement().id); // Should alert "ul" but alerts "b"

            This method returns the common ancestor node of the following:
            - the parentElement() of the textRange
            - the parentElement() of the textRange after calling collapse(true)
            - the parentElement() of the textRange after calling collapse(false)
            */
            var getTextRangeContainerElement = function(textRange) {
                var parentEl = textRange.parentElement();
                var range = textRange.duplicate();
                range.collapse(true);
                var startEl = range.parentElement();
                range = textRange.duplicate();
                range.collapse(false);
                var endEl = range.parentElement();
                var startEndContainer = (startEl == endEl) ? startEl : dom.getCommonAncestor(startEl, endEl);

                return startEndContainer == parentEl ? startEndContainer : dom.getCommonAncestor(parentEl, startEndContainer);
            };

            var textRangeIsCollapsed = function(textRange) {
                return textRange.compareEndPoints("StartToEnd", textRange) == 0;
            };

            // Gets the boundary of a TextRange expressed as a node and an offset within that node. This function started
            // out as an improved version of code found in Tim Cameron Ryan's IERange (http://code.google.com/p/ierange/)
            // but has grown, fixing problems with line breaks in preformatted text, adding workaround for IE TextRange
            // bugs, handling for inputs and images, plus optimizations.
            var getTextRangeBoundaryPosition = function(textRange, wholeRangeContainerElement, isStart, isCollapsed, startInfo) {
                var workingRange = textRange.duplicate();
                workingRange.collapse(isStart);
                var containerElement = workingRange.parentElement();

                // Sometimes collapsing a TextRange that's at the start of a text node can move it into the previous node, so
                // check for that
                if (!dom.isOrIsAncestorOf(wholeRangeContainerElement, containerElement)) {
                    containerElement = wholeRangeContainerElement;
                }


                // Deal with nodes that cannot "contain rich HTML markup". In practice, this means form inputs, images and
                // similar. See http://msdn.microsoft.com/en-us/library/aa703950%28VS.85%29.aspx
                if (!containerElement.canHaveHTML) {
                    var pos = new DomPosition(containerElement.parentNode, dom.getNodeIndex(containerElement));
                    return {
                        boundaryPosition: pos,
                        nodeInfo: {
                            nodeIndex: pos.offset,
                            containerElement: pos.node
                        }
                    };
                }

                var workingNode = dom.getDocument(containerElement).createElement("span");

                // Workaround for HTML5 Shiv's insane violation of document.createElement(). See Rangy issue 104 and HTML5
                // Shiv issue 64: https://github.com/aFarkas/html5shiv/issues/64
                if (workingNode.parentNode) {
                    workingNode.parentNode.removeChild(workingNode);
                }

                var comparison, workingComparisonType = isStart ? "StartToStart" : "StartToEnd";
                var previousNode, nextNode, boundaryPosition, boundaryNode;
                var start = (startInfo && startInfo.containerElement == containerElement) ? startInfo.nodeIndex : 0;
                var childNodeCount = containerElement.childNodes.length;
                var end = childNodeCount;

                // Check end first. Code within the loop assumes that the endth child node of the container is definitely
                // after the range boundary.
                var nodeIndex = end;

                while (true) {
                    if (nodeIndex == childNodeCount) {
                        containerElement.appendChild(workingNode);
                    } else {
                        containerElement.insertBefore(workingNode, containerElement.childNodes[nodeIndex]);
                    }
                    workingRange.moveToElementText(workingNode);
                    comparison = workingRange.compareEndPoints(workingComparisonType, textRange);
                    if (comparison == 0 || start == end) {
                        break;
                    } else if (comparison == -1) {
                        if (end == start + 1) {
                            // We know the endth child node is after the range boundary, so we must be done.
                            break;
                        } else {
                            start = nodeIndex;
                        }
                    } else {
                        end = (end == start + 1) ? start : nodeIndex;
                    }
                    nodeIndex = Math.floor((start + end) / 2);
                    containerElement.removeChild(workingNode);
                }


                // We've now reached or gone past the boundary of the text range we're interested in
                // so have identified the node we want
                boundaryNode = workingNode.nextSibling;

                if (comparison == -1 && boundaryNode && isCharacterDataNode(boundaryNode)) {
                    // This is a character data node (text, comment, cdata). The working range is collapsed at the start of
                    // the node containing the text range's boundary, so we move the end of the working range to the
                    // boundary point and measure the length of its text to get the boundary's offset within the node.
                    workingRange.setEndPoint(isStart ? "EndToStart" : "EndToEnd", textRange);

                    var offset;

                    if (/[\r\n]/.test(boundaryNode.data)) {
                        /*
                        For the particular case of a boundary within a text node containing rendered line breaks (within a
                        <pre> element, for example), we need a slightly complicated approach to get the boundary's offset in
                        IE. The facts:
                        
                        - Each line break is represented as \r in the text node's data/nodeValue properties
                        - Each line break is represented as \r\n in the TextRange's 'text' property
                        - The 'text' property of the TextRange does not contain trailing line breaks
                        
                        To get round the problem presented by the final fact above, we can use the fact that TextRange's
                        moveStart() and moveEnd() methods return the actual number of characters moved, which is not
                        necessarily the same as the number of characters it was instructed to move. The simplest approach is
                        to use this to store the characters moved when moving both the start and end of the range to the
                        start of the document body and subtracting the start offset from the end offset (the
                        "move-negative-gazillion" method). However, this is extremely slow when the document is large and
                        the range is near the end of it. Clearly doing the mirror image (i.e. moving the range boundaries to
                        the end of the document) has the same problem.
                        
                        Another approach that works is to use moveStart() to move the start boundary of the range up to the
                        end boundary one character at a time and incrementing a counter with the value returned by the
                        moveStart() call. However, the check for whether the start boundary has reached the end boundary is
                        expensive, so this method is slow (although unlike "move-negative-gazillion" is largely unaffected
                        by the location of the range within the document).
                        
                        The approach used below is a hybrid of the two methods above. It uses the fact that a string
                        containing the TextRange's 'text' property with each \r\n converted to a single \r character cannot
                        be longer than the text of the TextRange, so the start of the range is moved that length initially
                        and then a character at a time to make up for any trailing line breaks not contained in the 'text'
                        property. This has good performance in most situations compared to the previous two methods.
                        */
                        var tempRange = workingRange.duplicate();
                        var rangeLength = tempRange.text.replace(/\r\n/g, "\r").length;

                        offset = tempRange.moveStart("character", rangeLength);
                        while ( (comparison = tempRange.compareEndPoints("StartToEnd", tempRange)) == -1) {
                            offset++;
                            tempRange.moveStart("character", 1);
                        }
                    } else {
                        offset = workingRange.text.length;
                    }
                    boundaryPosition = new DomPosition(boundaryNode, offset);
                } else {

                    // If the boundary immediately follows a character data node and this is the end boundary, we should favour
                    // a position within that, and likewise for a start boundary preceding a character data node
                    previousNode = (isCollapsed || !isStart) && workingNode.previousSibling;
                    nextNode = (isCollapsed || isStart) && workingNode.nextSibling;
                    if (nextNode && isCharacterDataNode(nextNode)) {
                        boundaryPosition = new DomPosition(nextNode, 0);
                    } else if (previousNode && isCharacterDataNode(previousNode)) {
                        boundaryPosition = new DomPosition(previousNode, previousNode.data.length);
                    } else {
                        boundaryPosition = new DomPosition(containerElement, dom.getNodeIndex(workingNode));
                    }
                }

                // Clean up
                workingNode.parentNode.removeChild(workingNode);

                return {
                    boundaryPosition: boundaryPosition,
                    nodeInfo: {
                        nodeIndex: nodeIndex,
                        containerElement: containerElement
                    }
                };
            };

            // Returns a TextRange representing the boundary of a TextRange expressed as a node and an offset within that
            // node. This function started out as an optimized version of code found in Tim Cameron Ryan's IERange
            // (http://code.google.com/p/ierange/)
            var createBoundaryTextRange = function(boundaryPosition, isStart) {
                var boundaryNode, boundaryParent, boundaryOffset = boundaryPosition.offset;
                var doc = dom.getDocument(boundaryPosition.node);
                var workingNode, childNodes, workingRange = getBody(doc).createTextRange();
                var nodeIsDataNode = isCharacterDataNode(boundaryPosition.node);

                if (nodeIsDataNode) {
                    boundaryNode = boundaryPosition.node;
                    boundaryParent = boundaryNode.parentNode;
                } else {
                    childNodes = boundaryPosition.node.childNodes;
                    boundaryNode = (boundaryOffset < childNodes.length) ? childNodes[boundaryOffset] : null;
                    boundaryParent = boundaryPosition.node;
                }

                // Position the range immediately before the node containing the boundary
                workingNode = doc.createElement("span");

                // Making the working element non-empty element persuades IE to consider the TextRange boundary to be within
                // the element rather than immediately before or after it
                workingNode.innerHTML = "&#feff;";

                // insertBefore is supposed to work like appendChild if the second parameter is null. However, a bug report
                // for IERange suggests that it can crash the browser: http://code.google.com/p/ierange/issues/detail?id=12
                if (boundaryNode) {
                    boundaryParent.insertBefore(workingNode, boundaryNode);
                } else {
                    boundaryParent.appendChild(workingNode);
                }

                workingRange.moveToElementText(workingNode);
                workingRange.collapse(!isStart);

                // Clean up
                boundaryParent.removeChild(workingNode);

                // Move the working range to the text offset, if required
                if (nodeIsDataNode) {
                    workingRange[isStart ? "moveStart" : "moveEnd"]("character", boundaryOffset);
                }

                return workingRange;
            };

            /*------------------------------------------------------------------------------------------------------------*/

            // This is a wrapper around a TextRange, providing full DOM Range functionality using rangy's DomRange as a
            // prototype

            WrappedTextRange = function(textRange) {
                this.textRange = textRange;
                this.refresh();
            };

            WrappedTextRange.prototype = new DomRange(document);

            WrappedTextRange.prototype.refresh = function() {
                var start, end, startBoundary;

                // TextRange's parentElement() method cannot be trusted. getTextRangeContainerElement() works around that.
                var rangeContainerElement = getTextRangeContainerElement(this.textRange);

                if (textRangeIsCollapsed(this.textRange)) {
                    end = start = getTextRangeBoundaryPosition(this.textRange, rangeContainerElement, true,
                        true).boundaryPosition;
                } else {
                    startBoundary = getTextRangeBoundaryPosition(this.textRange, rangeContainerElement, true, false);
                    start = startBoundary.boundaryPosition;

                    // An optimization used here is that if the start and end boundaries have the same parent element, the
                    // search scope for the end boundary can be limited to exclude the portion of the element that precedes
                    // the start boundary
                    end = getTextRangeBoundaryPosition(this.textRange, rangeContainerElement, false, false,
                        startBoundary.nodeInfo).boundaryPosition;
                }

                this.setStart(start.node, start.offset);
                this.setEnd(end.node, end.offset);
            };

            WrappedTextRange.prototype.getName = function() {
                return "WrappedTextRange";
            };

            DomRange.copyComparisonConstants(WrappedTextRange);

            var rangeToTextRange = function(range) {
                if (range.collapsed) {
                    return createBoundaryTextRange(new DomPosition(range.startContainer, range.startOffset), true);
                } else {
                    var startRange = createBoundaryTextRange(new DomPosition(range.startContainer, range.startOffset), true);
                    var endRange = createBoundaryTextRange(new DomPosition(range.endContainer, range.endOffset), false);
                    var textRange = getBody( DomRange.getRangeDocument(range) ).createTextRange();
                    textRange.setEndPoint("StartToStart", startRange);
                    textRange.setEndPoint("EndToEnd", endRange);
                    return textRange;
                }
            };

            WrappedTextRange.rangeToTextRange = rangeToTextRange;

            WrappedTextRange.prototype.toTextRange = function() {
                return rangeToTextRange(this);
            };

            api.WrappedTextRange = WrappedTextRange;

            // IE 9 and above have both implementations and Rangy makes both available. The next few lines sets which
            // implementation to use by default.
            if (!api.features.implementsDomRange || api.config.preferTextRange) {
                // Add WrappedTextRange as the Range property of the global object to allow expression like Range.END_TO_END to work
                var globalObj = (function(f) { return f("return this;")(); })(Function);
                if (typeof globalObj.Range == "undefined") {
                    globalObj.Range = WrappedTextRange;
                }

                api.createNativeRange = function(doc) {
                    doc = getContentDocument(doc, module, "createNativeRange");
                    return getBody(doc).createTextRange();
                };

                api.WrappedRange = WrappedTextRange;
            }
        }

        api.createRange = function(doc) {
            doc = getContentDocument(doc, module, "createRange");
            return new api.WrappedRange(api.createNativeRange(doc));
        };

        api.createRangyRange = function(doc) {
            doc = getContentDocument(doc, module, "createRangyRange");
            return new DomRange(doc);
        };

        api.createIframeRange = function(iframeEl) {
            module.deprecationNotice("createIframeRange()", "createRange(iframeEl)");
            return api.createRange(iframeEl);
        };

        api.createIframeRangyRange = function(iframeEl) {
            module.deprecationNotice("createIframeRangyRange()", "createRangyRange(iframeEl)");
            return api.createRangyRange(iframeEl);
        };

        api.addShimListener(function(win) {
            var doc = win.document;
            if (typeof doc.createRange == "undefined") {
                doc.createRange = function() {
                    return api.createRange(doc);
                };
            }
            doc = win = null;
        });
    });

    /*----------------------------------------------------------------------------------------------------------------*/

    // This module creates a selection object wrapper that conforms as closely as possible to the Selection specification
    // in the HTML Editing spec (http://dvcs.w3.org/hg/editing/raw-file/tip/editing.html#selections)
    api.createCoreModule("WrappedSelection", ["DomRange", "WrappedRange"], function(api, module) {
        api.config.checkSelectionRanges = true;

        var BOOLEAN = "boolean";
        var NUMBER = "number";
        var dom = api.dom;
        var util = api.util;
        var isHostMethod = util.isHostMethod;
        var DomRange = api.DomRange;
        var WrappedRange = api.WrappedRange;
        var DOMException = api.DOMException;
        var DomPosition = dom.DomPosition;
        var getNativeSelection;
        var selectionIsCollapsed;
        var features = api.features;
        var CONTROL = "Control";
        var getDocument = dom.getDocument;
        var getBody = dom.getBody;
        var rangesEqual = DomRange.rangesEqual;


        // Utility function to support direction parameters in the API that may be a string ("backward" or "forward") or a
        // Boolean (true for backwards).
        function isDirectionBackward(dir) {
            return (typeof dir == "string") ? /^backward(s)?$/i.test(dir) : !!dir;
        }

        function getWindow(win, methodName) {
            if (!win) {
                return window;
            } else if (dom.isWindow(win)) {
                return win;
            } else if (win instanceof WrappedSelection) {
                return win.win;
            } else {
                var doc = dom.getContentDocument(win, module, methodName);
                return dom.getWindow(doc);
            }
        }

        function getWinSelection(winParam) {
            return getWindow(winParam, "getWinSelection").getSelection();
        }

        function getDocSelection(winParam) {
            return getWindow(winParam, "getDocSelection").document.selection;
        }
        
        function winSelectionIsBackward(sel) {
            var backward = false;
            if (sel.anchorNode) {
                backward = (dom.comparePoints(sel.anchorNode, sel.anchorOffset, sel.focusNode, sel.focusOffset) == 1);
            }
            return backward;
        }

        // Test for the Range/TextRange and Selection features required
        // Test for ability to retrieve selection
        var implementsWinGetSelection = isHostMethod(window, "getSelection"),
            implementsDocSelection = util.isHostObject(document, "selection");

        features.implementsWinGetSelection = implementsWinGetSelection;
        features.implementsDocSelection = implementsDocSelection;

        var useDocumentSelection = implementsDocSelection && (!implementsWinGetSelection || api.config.preferTextRange);

        if (useDocumentSelection) {
            getNativeSelection = getDocSelection;
            api.isSelectionValid = function(winParam) {
                var doc = getWindow(winParam, "isSelectionValid").document, nativeSel = doc.selection;

                // Check whether the selection TextRange is actually contained within the correct document
                return (nativeSel.type != "None" || getDocument(nativeSel.createRange().parentElement()) == doc);
            };
        } else if (implementsWinGetSelection) {
            getNativeSelection = getWinSelection;
            api.isSelectionValid = function() {
                return true;
            };
        } else {
            module.fail("Neither document.selection or window.getSelection() detected.");
        }

        api.getNativeSelection = getNativeSelection;

        var testSelection = getNativeSelection();
        var testRange = api.createNativeRange(document);
        var body = getBody(document);

        // Obtaining a range from a selection
        var selectionHasAnchorAndFocus = util.areHostProperties(testSelection,
            ["anchorNode", "focusNode", "anchorOffset", "focusOffset"]);

        features.selectionHasAnchorAndFocus = selectionHasAnchorAndFocus;

        // Test for existence of native selection extend() method
        var selectionHasExtend = isHostMethod(testSelection, "extend");
        features.selectionHasExtend = selectionHasExtend;
        
        // Test if rangeCount exists
        var selectionHasRangeCount = (typeof testSelection.rangeCount == NUMBER);
        features.selectionHasRangeCount = selectionHasRangeCount;

        var selectionSupportsMultipleRanges = false;
        var collapsedNonEditableSelectionsSupported = true;

        var addRangeBackwardToNative = selectionHasExtend ?
            function(nativeSelection, range) {
                var doc = DomRange.getRangeDocument(range);
                var endRange = api.createRange(doc);
                endRange.collapseToPoint(range.endContainer, range.endOffset);
                nativeSelection.addRange(getNativeRange(endRange));
                nativeSelection.extend(range.startContainer, range.startOffset);
            } : null;

        if (util.areHostMethods(testSelection, ["addRange", "getRangeAt", "removeAllRanges"]) &&
                typeof testSelection.rangeCount == NUMBER && features.implementsDomRange) {

            (function() {
                // Previously an iframe was used but this caused problems in some circumstances in IE, so tests are
                // performed on the current document's selection. See issue 109.

                // Note also that if a selection previously existed, it is wiped by these tests. This should usually be fine
                // because initialization usually happens when the document loads, but could be a problem for a script that
                // loads and initializes Rangy later. If anyone complains, code could be added to save and restore the
                // selection.
                var sel = window.getSelection();
                if (sel) {
                    // Store the current selection
                    var originalSelectionRangeCount = sel.rangeCount;
                    var selectionHasMultipleRanges = (originalSelectionRangeCount > 1);
                    var originalSelectionRanges = [];
                    var originalSelectionBackward = winSelectionIsBackward(sel); 
                    for (var i = 0; i < originalSelectionRangeCount; ++i) {
                        originalSelectionRanges[i] = sel.getRangeAt(i);
                    }
                    
                    // Create some test elements
                    var body = getBody(document);
                    var testEl = body.appendChild( document.createElement("div") );
                    testEl.contentEditable = "false";
                    var textNode = testEl.appendChild( document.createTextNode("\u00a0\u00a0\u00a0") );

                    // Test whether the native selection will allow a collapsed selection within a non-editable element
                    var r1 = document.createRange();

                    r1.setStart(textNode, 1);
                    r1.collapse(true);
                    sel.addRange(r1);
                    collapsedNonEditableSelectionsSupported = (sel.rangeCount == 1);
                    sel.removeAllRanges();

                    // Test whether the native selection is capable of supporting multiple ranges.
                    if (!selectionHasMultipleRanges) {
                        // Doing the original feature test here in Chrome 36 (and presumably later versions) prints a
                        // console error of "Discontiguous selection is not supported." that cannot be suppressed. There's
                        // nothing we can do about this while retaining the feature test so we have to resort to a browser
                        // sniff. I'm not happy about it. See
                        // https://code.google.com/p/chromium/issues/detail?id=399791
                        var chromeMatch = window.navigator.appVersion.match(/Chrome\/(.*?) /);
                        if (chromeMatch && parseInt(chromeMatch[1]) >= 36) {
                            selectionSupportsMultipleRanges = false;
                        } else {
                            var r2 = r1.cloneRange();
                            r1.setStart(textNode, 0);
                            r2.setEnd(textNode, 3);
                            r2.setStart(textNode, 2);
                            sel.addRange(r1);
                            sel.addRange(r2);
                            selectionSupportsMultipleRanges = (sel.rangeCount == 2);
                        }
                    }

                    // Clean up
                    body.removeChild(testEl);
                    sel.removeAllRanges();

                    for (i = 0; i < originalSelectionRangeCount; ++i) {
                        if (i == 0 && originalSelectionBackward) {
                            if (addRangeBackwardToNative) {
                                addRangeBackwardToNative(sel, originalSelectionRanges[i]);
                            } else {
                                api.warn("Rangy initialization: original selection was backwards but selection has been restored forwards because the browser does not support Selection.extend");
                                sel.addRange(originalSelectionRanges[i]);
                            }
                        } else {
                            sel.addRange(originalSelectionRanges[i]);
                        }
                    }
                }
            })();
        }

        features.selectionSupportsMultipleRanges = selectionSupportsMultipleRanges;
        features.collapsedNonEditableSelectionsSupported = collapsedNonEditableSelectionsSupported;

        // ControlRanges
        var implementsControlRange = false, testControlRange;

        if (body && isHostMethod(body, "createControlRange")) {
            testControlRange = body.createControlRange();
            if (util.areHostProperties(testControlRange, ["item", "add"])) {
                implementsControlRange = true;
            }
        }
        features.implementsControlRange = implementsControlRange;

        // Selection collapsedness
        if (selectionHasAnchorAndFocus) {
            selectionIsCollapsed = function(sel) {
                return sel.anchorNode === sel.focusNode && sel.anchorOffset === sel.focusOffset;
            };
        } else {
            selectionIsCollapsed = function(sel) {
                return sel.rangeCount ? sel.getRangeAt(sel.rangeCount - 1).collapsed : false;
            };
        }

        function updateAnchorAndFocusFromRange(sel, range, backward) {
            var anchorPrefix = backward ? "end" : "start", focusPrefix = backward ? "start" : "end";
            sel.anchorNode = range[anchorPrefix + "Container"];
            sel.anchorOffset = range[anchorPrefix + "Offset"];
            sel.focusNode = range[focusPrefix + "Container"];
            sel.focusOffset = range[focusPrefix + "Offset"];
        }

        function updateAnchorAndFocusFromNativeSelection(sel) {
            var nativeSel = sel.nativeSelection;
            sel.anchorNode = nativeSel.anchorNode;
            sel.anchorOffset = nativeSel.anchorOffset;
            sel.focusNode = nativeSel.focusNode;
            sel.focusOffset = nativeSel.focusOffset;
        }

        function updateEmptySelection(sel) {
            sel.anchorNode = sel.focusNode = null;
            sel.anchorOffset = sel.focusOffset = 0;
            sel.rangeCount = 0;
            sel.isCollapsed = true;
            sel._ranges.length = 0;
        }

        function getNativeRange(range) {
            var nativeRange;
            if (range instanceof DomRange) {
                nativeRange = api.createNativeRange(range.getDocument());
                nativeRange.setEnd(range.endContainer, range.endOffset);
                nativeRange.setStart(range.startContainer, range.startOffset);
            } else if (range instanceof WrappedRange) {
                nativeRange = range.nativeRange;
            } else if (features.implementsDomRange && (range instanceof dom.getWindow(range.startContainer).Range)) {
                nativeRange = range;
            }
            return nativeRange;
        }

        function rangeContainsSingleElement(rangeNodes) {
            if (!rangeNodes.length || rangeNodes[0].nodeType != 1) {
                return false;
            }
            for (var i = 1, len = rangeNodes.length; i < len; ++i) {
                if (!dom.isAncestorOf(rangeNodes[0], rangeNodes[i])) {
                    return false;
                }
            }
            return true;
        }

        function getSingleElementFromRange(range) {
            var nodes = range.getNodes();
            if (!rangeContainsSingleElement(nodes)) {
                throw module.createError("getSingleElementFromRange: range " + range.inspect() + " did not consist of a single element");
            }
            return nodes[0];
        }

        // Simple, quick test which only needs to distinguish between a TextRange and a ControlRange
        function isTextRange(range) {
            return !!range && typeof range.text != "undefined";
        }

        function updateFromTextRange(sel, range) {
            // Create a Range from the selected TextRange
            var wrappedRange = new WrappedRange(range);
            sel._ranges = [wrappedRange];

            updateAnchorAndFocusFromRange(sel, wrappedRange, false);
            sel.rangeCount = 1;
            sel.isCollapsed = wrappedRange.collapsed;
        }

        function updateControlSelection(sel) {
            // Update the wrapped selection based on what's now in the native selection
            sel._ranges.length = 0;
            if (sel.docSelection.type == "None") {
                updateEmptySelection(sel);
            } else {
                var controlRange = sel.docSelection.createRange();
                if (isTextRange(controlRange)) {
                    // This case (where the selection type is "Control" and calling createRange() on the selection returns
                    // a TextRange) can happen in IE 9. It happens, for example, when all elements in the selected
                    // ControlRange have been removed from the ControlRange and removed from the document.
                    updateFromTextRange(sel, controlRange);
                } else {
                    sel.rangeCount = controlRange.length;
                    var range, doc = getDocument(controlRange.item(0));
                    for (var i = 0; i < sel.rangeCount; ++i) {
                        range = api.createRange(doc);
                        range.selectNode(controlRange.item(i));
                        sel._ranges.push(range);
                    }
                    sel.isCollapsed = sel.rangeCount == 1 && sel._ranges[0].collapsed;
                    updateAnchorAndFocusFromRange(sel, sel._ranges[sel.rangeCount - 1], false);
                }
            }
        }

        function addRangeToControlSelection(sel, range) {
            var controlRange = sel.docSelection.createRange();
            var rangeElement = getSingleElementFromRange(range);

            // Create a new ControlRange containing all the elements in the selected ControlRange plus the element
            // contained by the supplied range
            var doc = getDocument(controlRange.item(0));
            var newControlRange = getBody(doc).createControlRange();
            for (var i = 0, len = controlRange.length; i < len; ++i) {
                newControlRange.add(controlRange.item(i));
            }
            try {
                newControlRange.add(rangeElement);
            } catch (ex) {
                throw module.createError("addRange(): Element within the specified Range could not be added to control selection (does it have layout?)");
            }
            newControlRange.select();

            // Update the wrapped selection based on what's now in the native selection
            updateControlSelection(sel);
        }

        var getSelectionRangeAt;

        if (isHostMethod(testSelection, "getRangeAt")) {
            // try/catch is present because getRangeAt() must have thrown an error in some browser and some situation.
            // Unfortunately, I didn't write a comment about the specifics and am now scared to take it out. Let that be a
            // lesson to us all, especially me.
            getSelectionRangeAt = function(sel, index) {
                try {
                    return sel.getRangeAt(index);
                } catch (ex) {
                    return null;
                }
            };
        } else if (selectionHasAnchorAndFocus) {
            getSelectionRangeAt = function(sel) {
                var doc = getDocument(sel.anchorNode);
                var range = api.createRange(doc);
                range.setStartAndEnd(sel.anchorNode, sel.anchorOffset, sel.focusNode, sel.focusOffset);

                // Handle the case when the selection was selected backwards (from the end to the start in the
                // document)
                if (range.collapsed !== this.isCollapsed) {
                    range.setStartAndEnd(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset);
                }

                return range;
            };
        }

        function WrappedSelection(selection, docSelection, win) {
            this.nativeSelection = selection;
            this.docSelection = docSelection;
            this._ranges = [];
            this.win = win;
            this.refresh();
        }

        WrappedSelection.prototype = api.selectionPrototype;

        function deleteProperties(sel) {
            sel.win = sel.anchorNode = sel.focusNode = sel._ranges = null;
            sel.rangeCount = sel.anchorOffset = sel.focusOffset = 0;
            sel.detached = true;
        }

        var cachedRangySelections = [];

        function actOnCachedSelection(win, action) {
            var i = cachedRangySelections.length, cached, sel;
            while (i--) {
                cached = cachedRangySelections[i];
                sel = cached.selection;
                if (action == "deleteAll") {
                    deleteProperties(sel);
                } else if (cached.win == win) {
                    if (action == "delete") {
                        cachedRangySelections.splice(i, 1);
                        return true;
                    } else {
                        return sel;
                    }
                }
            }
            if (action == "deleteAll") {
                cachedRangySelections.length = 0;
            }
            return null;
        }

        var getSelection = function(win) {
            // Check if the parameter is a Rangy Selection object
            if (win && win instanceof WrappedSelection) {
                win.refresh();
                return win;
            }

            win = getWindow(win, "getNativeSelection");

            var sel = actOnCachedSelection(win);
            var nativeSel = getNativeSelection(win), docSel = implementsDocSelection ? getDocSelection(win) : null;
            if (sel) {
                sel.nativeSelection = nativeSel;
                sel.docSelection = docSel;
                sel.refresh();
            } else {
                sel = new WrappedSelection(nativeSel, docSel, win);
                cachedRangySelections.push( { win: win, selection: sel } );
            }
            return sel;
        };

        api.getSelection = getSelection;

        api.getIframeSelection = function(iframeEl) {
            module.deprecationNotice("getIframeSelection()", "getSelection(iframeEl)");
            return api.getSelection(dom.getIframeWindow(iframeEl));
        };

        var selProto = WrappedSelection.prototype;

        function createControlSelection(sel, ranges) {
            // Ensure that the selection becomes of type "Control"
            var doc = getDocument(ranges[0].startContainer);
            var controlRange = getBody(doc).createControlRange();
            for (var i = 0, el, len = ranges.length; i < len; ++i) {
                el = getSingleElementFromRange(ranges[i]);
                try {
                    controlRange.add(el);
                } catch (ex) {
                    throw module.createError("setRanges(): Element within one of the specified Ranges could not be added to control selection (does it have layout?)");
                }
            }
            controlRange.select();

            // Update the wrapped selection based on what's now in the native selection
            updateControlSelection(sel);
        }

        // Selecting a range
        if (!useDocumentSelection && selectionHasAnchorAndFocus && util.areHostMethods(testSelection, ["removeAllRanges", "addRange"])) {
            selProto.removeAllRanges = function() {
                this.nativeSelection.removeAllRanges();
                updateEmptySelection(this);
            };

            var addRangeBackward = function(sel, range) {
                addRangeBackwardToNative(sel.nativeSelection, range);
                sel.refresh();
            };

            if (selectionHasRangeCount) {
                selProto.addRange = function(range, direction) {
                    if (implementsControlRange && implementsDocSelection && this.docSelection.type == CONTROL) {
                        addRangeToControlSelection(this, range);
                    } else {
                        if (isDirectionBackward(direction) && selectionHasExtend) {
                            addRangeBackward(this, range);
                        } else {
                            var previousRangeCount;
                            if (selectionSupportsMultipleRanges) {
                                previousRangeCount = this.rangeCount;
                            } else {
                                this.removeAllRanges();
                                previousRangeCount = 0;
                            }
                            // Clone the native range so that changing the selected range does not affect the selection.
                            // This is contrary to the spec but is the only way to achieve consistency between browsers. See
                            // issue 80.
                            var clonedNativeRange = getNativeRange(range).cloneRange();
                            try {
                                this.nativeSelection.addRange(clonedNativeRange);
                            } catch (ex) {
                            }

                            // Check whether adding the range was successful
                            this.rangeCount = this.nativeSelection.rangeCount;

                            if (this.rangeCount == previousRangeCount + 1) {
                                // The range was added successfully

                                // Check whether the range that we added to the selection is reflected in the last range extracted from
                                // the selection
                                if (api.config.checkSelectionRanges) {
                                    var nativeRange = getSelectionRangeAt(this.nativeSelection, this.rangeCount - 1);
                                    if (nativeRange && !rangesEqual(nativeRange, range)) {
                                        // Happens in WebKit with, for example, a selection placed at the start of a text node
                                        range = new WrappedRange(nativeRange);
                                    }
                                }
                                this._ranges[this.rangeCount - 1] = range;
                                updateAnchorAndFocusFromRange(this, range, selectionIsBackward(this.nativeSelection));
                                this.isCollapsed = selectionIsCollapsed(this);
                            } else {
                                // The range was not added successfully. The simplest thing is to refresh
                                this.refresh();
                            }
                        }
                    }
                };
            } else {
                selProto.addRange = function(range, direction) {
                    if (isDirectionBackward(direction) && selectionHasExtend) {
                        addRangeBackward(this, range);
                    } else {
                        this.nativeSelection.addRange(getNativeRange(range));
                        this.refresh();
                    }
                };
            }

            selProto.setRanges = function(ranges) {
                if (implementsControlRange && implementsDocSelection && ranges.length > 1) {
                    createControlSelection(this, ranges);
                } else {
                    this.removeAllRanges();
                    for (var i = 0, len = ranges.length; i < len; ++i) {
                        this.addRange(ranges[i]);
                    }
                }
            };
        } else if (isHostMethod(testSelection, "empty") && isHostMethod(testRange, "select") &&
                   implementsControlRange && useDocumentSelection) {

            selProto.removeAllRanges = function() {
                // Added try/catch as fix for issue #21
                try {
                    this.docSelection.empty();

                    // Check for empty() not working (issue #24)
                    if (this.docSelection.type != "None") {
                        // Work around failure to empty a control selection by instead selecting a TextRange and then
                        // calling empty()
                        var doc;
                        if (this.anchorNode) {
                            doc = getDocument(this.anchorNode);
                        } else if (this.docSelection.type == CONTROL) {
                            var controlRange = this.docSelection.createRange();
                            if (controlRange.length) {
                                doc = getDocument( controlRange.item(0) );
                            }
                        }
                        if (doc) {
                            var textRange = getBody(doc).createTextRange();
                            textRange.select();
                            this.docSelection.empty();
                        }
                    }
                } catch(ex) {}
                updateEmptySelection(this);
            };

            selProto.addRange = function(range) {
                if (this.docSelection.type == CONTROL) {
                    addRangeToControlSelection(this, range);
                } else {
                    api.WrappedTextRange.rangeToTextRange(range).select();
                    this._ranges[0] = range;
                    this.rangeCount = 1;
                    this.isCollapsed = this._ranges[0].collapsed;
                    updateAnchorAndFocusFromRange(this, range, false);
                }
            };

            selProto.setRanges = function(ranges) {
                this.removeAllRanges();
                var rangeCount = ranges.length;
                if (rangeCount > 1) {
                    createControlSelection(this, ranges);
                } else if (rangeCount) {
                    this.addRange(ranges[0]);
                }
            };
        } else {
            module.fail("No means of selecting a Range or TextRange was found");
            return false;
        }

        selProto.getRangeAt = function(index) {
            if (index < 0 || index >= this.rangeCount) {
                throw new DOMException("INDEX_SIZE_ERR");
            } else {
                // Clone the range to preserve selection-range independence. See issue 80.
                return this._ranges[index].cloneRange();
            }
        };

        var refreshSelection;

        if (useDocumentSelection) {
            refreshSelection = function(sel) {
                var range;
                if (api.isSelectionValid(sel.win)) {
                    range = sel.docSelection.createRange();
                } else {
                    range = getBody(sel.win.document).createTextRange();
                    range.collapse(true);
                }

                if (sel.docSelection.type == CONTROL) {
                    updateControlSelection(sel);
                } else if (isTextRange(range)) {
                    updateFromTextRange(sel, range);
                } else {
                    updateEmptySelection(sel);
                }
            };
        } else if (isHostMethod(testSelection, "getRangeAt") && typeof testSelection.rangeCount == NUMBER) {
            refreshSelection = function(sel) {
                if (implementsControlRange && implementsDocSelection && sel.docSelection.type == CONTROL) {
                    updateControlSelection(sel);
                } else {
                    sel._ranges.length = sel.rangeCount = sel.nativeSelection.rangeCount;
                    if (sel.rangeCount) {
                        for (var i = 0, len = sel.rangeCount; i < len; ++i) {
                            sel._ranges[i] = new api.WrappedRange(sel.nativeSelection.getRangeAt(i));
                        }
                        updateAnchorAndFocusFromRange(sel, sel._ranges[sel.rangeCount - 1], selectionIsBackward(sel.nativeSelection));
                        sel.isCollapsed = selectionIsCollapsed(sel);
                    } else {
                        updateEmptySelection(sel);
                    }
                }
            };
        } else if (selectionHasAnchorAndFocus && typeof testSelection.isCollapsed == BOOLEAN && typeof testRange.collapsed == BOOLEAN && features.implementsDomRange) {
            refreshSelection = function(sel) {
                var range, nativeSel = sel.nativeSelection;
                if (nativeSel.anchorNode) {
                    range = getSelectionRangeAt(nativeSel, 0);
                    sel._ranges = [range];
                    sel.rangeCount = 1;
                    updateAnchorAndFocusFromNativeSelection(sel);
                    sel.isCollapsed = selectionIsCollapsed(sel);
                } else {
                    updateEmptySelection(sel);
                }
            };
        } else {
            module.fail("No means of obtaining a Range or TextRange from the user's selection was found");
            return false;
        }

        selProto.refresh = function(checkForChanges) {
            var oldRanges = checkForChanges ? this._ranges.slice(0) : null;
            var oldAnchorNode = this.anchorNode, oldAnchorOffset = this.anchorOffset;

            refreshSelection(this);
            if (checkForChanges) {
                // Check the range count first
                var i = oldRanges.length;
                if (i != this._ranges.length) {
                    return true;
                }

                // Now check the direction. Checking the anchor position is the same is enough since we're checking all the
                // ranges after this
                if (this.anchorNode != oldAnchorNode || this.anchorOffset != oldAnchorOffset) {
                    return true;
                }

                // Finally, compare each range in turn
                while (i--) {
                    if (!rangesEqual(oldRanges[i], this._ranges[i])) {
                        return true;
                    }
                }
                return false;
            }
        };

        // Removal of a single range
        var removeRangeManually = function(sel, range) {
            var ranges = sel.getAllRanges();
            sel.removeAllRanges();
            for (var i = 0, len = ranges.length; i < len; ++i) {
                if (!rangesEqual(range, ranges[i])) {
                    sel.addRange(ranges[i]);
                }
            }
            if (!sel.rangeCount) {
                updateEmptySelection(sel);
            }
        };

        if (implementsControlRange && implementsDocSelection) {
            selProto.removeRange = function(range) {
                if (this.docSelection.type == CONTROL) {
                    var controlRange = this.docSelection.createRange();
                    var rangeElement = getSingleElementFromRange(range);

                    // Create a new ControlRange containing all the elements in the selected ControlRange minus the
                    // element contained by the supplied range
                    var doc = getDocument(controlRange.item(0));
                    var newControlRange = getBody(doc).createControlRange();
                    var el, removed = false;
                    for (var i = 0, len = controlRange.length; i < len; ++i) {
                        el = controlRange.item(i);
                        if (el !== rangeElement || removed) {
                            newControlRange.add(controlRange.item(i));
                        } else {
                            removed = true;
                        }
                    }
                    newControlRange.select();

                    // Update the wrapped selection based on what's now in the native selection
                    updateControlSelection(this);
                } else {
                    removeRangeManually(this, range);
                }
            };
        } else {
            selProto.removeRange = function(range) {
                removeRangeManually(this, range);
            };
        }

        // Detecting if a selection is backward
        var selectionIsBackward;
        if (!useDocumentSelection && selectionHasAnchorAndFocus && features.implementsDomRange) {
            selectionIsBackward = winSelectionIsBackward;

            selProto.isBackward = function() {
                return selectionIsBackward(this);
            };
        } else {
            selectionIsBackward = selProto.isBackward = function() {
                return false;
            };
        }

        // Create an alias for backwards compatibility. From 1.3, everything is "backward" rather than "backwards"
        selProto.isBackwards = selProto.isBackward;

        // Selection stringifier
        // This is conformant to the old HTML5 selections draft spec but differs from WebKit and Mozilla's implementation.
        // The current spec does not yet define this method.
        selProto.toString = function() {
            var rangeTexts = [];
            for (var i = 0, len = this.rangeCount; i < len; ++i) {
                rangeTexts[i] = "" + this._ranges[i];
            }
            return rangeTexts.join("");
        };

        function assertNodeInSameDocument(sel, node) {
            if (sel.win.document != getDocument(node)) {
                throw new DOMException("WRONG_DOCUMENT_ERR");
            }
        }

        // No current browser conforms fully to the spec for this method, so Rangy's own method is always used
        selProto.collapse = function(node, offset) {
            assertNodeInSameDocument(this, node);
            var range = api.createRange(node);
            range.collapseToPoint(node, offset);
            this.setSingleRange(range);
            this.isCollapsed = true;
        };

        selProto.collapseToStart = function() {
            if (this.rangeCount) {
                var range = this._ranges[0];
                this.collapse(range.startContainer, range.startOffset);
            } else {
                throw new DOMException("INVALID_STATE_ERR");
            }
        };

        selProto.collapseToEnd = function() {
            if (this.rangeCount) {
                var range = this._ranges[this.rangeCount - 1];
                this.collapse(range.endContainer, range.endOffset);
            } else {
                throw new DOMException("INVALID_STATE_ERR");
            }
        };

        // The spec is very specific on how selectAllChildren should be implemented so the native implementation is
        // never used by Rangy.
        selProto.selectAllChildren = function(node) {
            assertNodeInSameDocument(this, node);
            var range = api.createRange(node);
            range.selectNodeContents(node);
            this.setSingleRange(range);
        };

        selProto.deleteFromDocument = function() {
            // Sepcial behaviour required for IE's control selections
            if (implementsControlRange && implementsDocSelection && this.docSelection.type == CONTROL) {
                var controlRange = this.docSelection.createRange();
                var element;
                while (controlRange.length) {
                    element = controlRange.item(0);
                    controlRange.remove(element);
                    element.parentNode.removeChild(element);
                }
                this.refresh();
            } else if (this.rangeCount) {
                var ranges = this.getAllRanges();
                if (ranges.length) {
                    this.removeAllRanges();
                    for (var i = 0, len = ranges.length; i < len; ++i) {
                        ranges[i].deleteContents();
                    }
                    // The spec says nothing about what the selection should contain after calling deleteContents on each
                    // range. Firefox moves the selection to where the final selected range was, so we emulate that
                    this.addRange(ranges[len - 1]);
                }
            }
        };

        // The following are non-standard extensions
        selProto.eachRange = function(func, returnValue) {
            for (var i = 0, len = this._ranges.length; i < len; ++i) {
                if ( func( this.getRangeAt(i) ) ) {
                    return returnValue;
                }
            }
        };

        selProto.getAllRanges = function() {
            var ranges = [];
            this.eachRange(function(range) {
                ranges.push(range);
            });
            return ranges;
        };

        selProto.setSingleRange = function(range, direction) {
            this.removeAllRanges();
            this.addRange(range, direction);
        };

        selProto.callMethodOnEachRange = function(methodName, params) {
            var results = [];
            this.eachRange( function(range) {
                results.push( range[methodName].apply(range, params) );
            } );
            return results;
        };
        
        function createStartOrEndSetter(isStart) {
            return function(node, offset) {
                var range;
                if (this.rangeCount) {
                    range = this.getRangeAt(0);
                    range["set" + (isStart ? "Start" : "End")](node, offset);
                } else {
                    range = api.createRange(this.win.document);
                    range.setStartAndEnd(node, offset);
                }
                this.setSingleRange(range, this.isBackward());
            };
        }

        selProto.setStart = createStartOrEndSetter(true);
        selProto.setEnd = createStartOrEndSetter(false);
        
        // Add select() method to Range prototype. Any existing selection will be removed.
        api.rangePrototype.select = function(direction) {
            getSelection( this.getDocument() ).setSingleRange(this, direction);
        };

        selProto.changeEachRange = function(func) {
            var ranges = [];
            var backward = this.isBackward();

            this.eachRange(function(range) {
                func(range);
                ranges.push(range);
            });

            this.removeAllRanges();
            if (backward && ranges.length == 1) {
                this.addRange(ranges[0], "backward");
            } else {
                this.setRanges(ranges);
            }
        };

        selProto.containsNode = function(node, allowPartial) {
            return this.eachRange( function(range) {
                return range.containsNode(node, allowPartial);
            }, true ) || false;
        };

        selProto.getBookmark = function(containerNode) {
            return {
                backward: this.isBackward(),
                rangeBookmarks: this.callMethodOnEachRange("getBookmark", [containerNode])
            };
        };

        selProto.moveToBookmark = function(bookmark) {
            var selRanges = [];
            for (var i = 0, rangeBookmark, range; rangeBookmark = bookmark.rangeBookmarks[i++]; ) {
                range = api.createRange(this.win);
                range.moveToBookmark(rangeBookmark);
                selRanges.push(range);
            }
            if (bookmark.backward) {
                this.setSingleRange(selRanges[0], "backward");
            } else {
                this.setRanges(selRanges);
            }
        };

        selProto.toHtml = function() {
            var rangeHtmls = [];
            this.eachRange(function(range) {
                rangeHtmls.push( DomRange.toHtml(range) );
            });
            return rangeHtmls.join("");
        };

        if (features.implementsTextRange) {
            selProto.getNativeTextRange = function() {
                var sel, textRange;
                if ( (sel = this.docSelection) ) {
                    var range = sel.createRange();
                    if (isTextRange(range)) {
                        return range;
                    } else {
                        throw module.createError("getNativeTextRange: selection is a control selection"); 
                    }
                } else if (this.rangeCount > 0) {
                    return api.WrappedTextRange.rangeToTextRange( this.getRangeAt(0) );
                } else {
                    throw module.createError("getNativeTextRange: selection contains no range");
                }
            };
        }

        function inspect(sel) {
            var rangeInspects = [];
            var anchor = new DomPosition(sel.anchorNode, sel.anchorOffset);
            var focus = new DomPosition(sel.focusNode, sel.focusOffset);
            var name = (typeof sel.getName == "function") ? sel.getName() : "Selection";

            if (typeof sel.rangeCount != "undefined") {
                for (var i = 0, len = sel.rangeCount; i < len; ++i) {
                    rangeInspects[i] = DomRange.inspect(sel.getRangeAt(i));
                }
            }
            return "[" + name + "(Ranges: " + rangeInspects.join(", ") +
                    ")(anchor: " + anchor.inspect() + ", focus: " + focus.inspect() + "]";
        }

        selProto.getName = function() {
            return "WrappedSelection";
        };

        selProto.inspect = function() {
            return inspect(this);
        };

        selProto.detach = function() {
            actOnCachedSelection(this.win, "delete");
            deleteProperties(this);
        };

        WrappedSelection.detachAll = function() {
            actOnCachedSelection(null, "deleteAll");
        };

        WrappedSelection.inspect = inspect;
        WrappedSelection.isDirectionBackward = isDirectionBackward;

        api.Selection = WrappedSelection;

        api.selectionPrototype = selProto;

        api.addShimListener(function(win) {
            if (typeof win.getSelection == "undefined") {
                win.getSelection = function() {
                    return getSelection(win);
                };
            }
            win = null;
        });
    });
    

    /*----------------------------------------------------------------------------------------------------------------*/

    // Wait for document to load before initializing
    var docReady = false;

    var loadHandler = function(e) {
        if (!docReady) {
            docReady = true;
            if (!api.initialized && api.config.autoInitialize) {
                init();
            }
        }
    };

    if (isBrowser) {
        // Test whether the document has already been loaded and initialize immediately if so
        if (document.readyState == "complete") {
            loadHandler();
        } else {
            if (isHostMethod(document, "addEventListener")) {
                document.addEventListener("DOMContentLoaded", loadHandler, false);
            }

            // Add a fallback in case the DOMContentLoaded event isn't supported
            addListener(window, "load", loadHandler);
        }
    }

    return api;
}, this);;/**
 * Selection save and restore module for Rangy.
 * Saves and restores user selections using marker invisible elements in the DOM.
 *
 * Part of Rangy, a cross-browser JavaScript range and selection library
 * https://github.com/timdown/rangy
 *
 * Depends on Rangy core.
 *
 * Copyright 2014, Tim Down
 * Licensed under the MIT license.
 * Version: 1.3.0-alpha.20140921
 * Build date: 21 September 2014
 */
(function(factory, root) {
    if (typeof define == "function" && define.amd) {
        // AMD. Register as an anonymous module with a dependency on Rangy.
        define(["./rangy-core"], factory);
    } else if (typeof module != "undefined" && typeof exports == "object") {
        // Node/CommonJS style
        module.exports = factory( require("rangy") );
    } else {
        // No AMD or CommonJS support so we use the rangy property of root (probably the global variable)
        factory(root.rangy);
    }
})(function(rangy) {
    rangy.createModule("SaveRestore", ["WrappedRange"], function(api, module) {
        var dom = api.dom;

        var markerTextChar = "\ufeff";

        function gEBI(id, doc) {
            return (doc || document).getElementById(id);
        }

        function insertRangeBoundaryMarker(range, atStart) {
            var markerId = "selectionBoundary_" + (+new Date()) + "_" + ("" + Math.random()).slice(2);
            var markerEl;
            var doc = dom.getDocument(range.startContainer);

            // Clone the Range and collapse to the appropriate boundary point
            var boundaryRange = range.cloneRange();
            boundaryRange.collapse(atStart);

            // Create the marker element containing a single invisible character using DOM methods and insert it
            markerEl = doc.createElement("span");
            markerEl.id = markerId;
            markerEl.style.lineHeight = "0";
            markerEl.style.display = "none";
            markerEl.className = "rangySelectionBoundary";
            markerEl.appendChild(doc.createTextNode(markerTextChar));

            boundaryRange.insertNode(markerEl);
            return markerEl;
        }

        function setRangeBoundary(doc, range, markerId, atStart) {
            var markerEl = gEBI(markerId, doc);
            if (markerEl) {
                range[atStart ? "setStartBefore" : "setEndBefore"](markerEl);
                markerEl.parentNode.removeChild(markerEl);
            } else {
                module.warn("Marker element has been removed. Cannot restore selection.");
            }
        }

        function compareRanges(r1, r2) {
            return r2.compareBoundaryPoints(r1.START_TO_START, r1);
        }

        function saveRange(range, backward) {
            var startEl, endEl, doc = api.DomRange.getRangeDocument(range), text = range.toString();

            if (range.collapsed) {
                endEl = insertRangeBoundaryMarker(range, false);
                return {
                    document: doc,
                    markerId: endEl.id,
                    collapsed: true
                };
            } else {
                endEl = insertRangeBoundaryMarker(range, false);
                startEl = insertRangeBoundaryMarker(range, true);

                return {
                    document: doc,
                    startMarkerId: startEl.id,
                    endMarkerId: endEl.id,
                    collapsed: false,
                    backward: backward,
                    toString: function() {
                        return "original text: '" + text + "', new text: '" + range.toString() + "'";
                    }
                };
            }
        }

        function restoreRange(rangeInfo, normalize) {
            var doc = rangeInfo.document;
            if (typeof normalize == "undefined") {
                normalize = true;
            }
            var range = api.createRange(doc);
            if (rangeInfo.collapsed) {
                var markerEl = gEBI(rangeInfo.markerId, doc);
                if (markerEl) {
                    markerEl.style.display = "inline";
                    var previousNode = markerEl.previousSibling;

                    // Workaround for issue 17
                    if (previousNode && previousNode.nodeType == 3) {
                        markerEl.parentNode.removeChild(markerEl);
                        range.collapseToPoint(previousNode, previousNode.length);
                    } else {
                        range.collapseBefore(markerEl);
                        markerEl.parentNode.removeChild(markerEl);
                    }
                } else {
                    module.warn("Marker element has been removed. Cannot restore selection.");
                }
            } else {
                setRangeBoundary(doc, range, rangeInfo.startMarkerId, true);
                setRangeBoundary(doc, range, rangeInfo.endMarkerId, false);
            }

            if (normalize) {
                range.normalizeBoundaries();
            }

            return range;
        }

        function saveRanges(ranges, backward) {
            var rangeInfos = [], range, doc;

            // Order the ranges by position within the DOM, latest first, cloning the array to leave the original untouched
            ranges = ranges.slice(0);
            ranges.sort(compareRanges);

            for (var i = 0, len = ranges.length; i < len; ++i) {
                rangeInfos[i] = saveRange(ranges[i], backward);
            }

            // Now that all the markers are in place and DOM manipulation over, adjust each range's boundaries to lie
            // between its markers
            for (i = len - 1; i >= 0; --i) {
                range = ranges[i];
                doc = api.DomRange.getRangeDocument(range);
                if (range.collapsed) {
                    range.collapseAfter(gEBI(rangeInfos[i].markerId, doc));
                } else {
                    range.setEndBefore(gEBI(rangeInfos[i].endMarkerId, doc));
                    range.setStartAfter(gEBI(rangeInfos[i].startMarkerId, doc));
                }
            }

            return rangeInfos;
        }

        function saveSelection(win) {
            if (!api.isSelectionValid(win)) {
                module.warn("Cannot save selection. This usually happens when the selection is collapsed and the selection document has lost focus.");
                return null;
            }
            var sel = api.getSelection(win);
            var ranges = sel.getAllRanges();
            var backward = (ranges.length == 1 && sel.isBackward());

            var rangeInfos = saveRanges(ranges, backward);

            // Ensure current selection is unaffected
            if (backward) {
                sel.setSingleRange(ranges[0], "backward");
            } else {
                sel.setRanges(ranges);
            }

            return {
                win: win,
                rangeInfos: rangeInfos,
                restored: false
            };
        }

        function restoreRanges(rangeInfos) {
            var ranges = [];

            // Ranges are in reverse order of appearance in the DOM. We want to restore earliest first to avoid
            // normalization affecting previously restored ranges.
            var rangeCount = rangeInfos.length;

            for (var i = rangeCount - 1; i >= 0; i--) {
                ranges[i] = restoreRange(rangeInfos[i], true);
            }

            return ranges;
        }

        function restoreSelection(savedSelection, preserveDirection) {
            if (!savedSelection.restored) {
                var rangeInfos = savedSelection.rangeInfos;
                var sel = api.getSelection(savedSelection.win);
                var ranges = restoreRanges(rangeInfos), rangeCount = rangeInfos.length;

                if (rangeCount == 1 && preserveDirection && api.features.selectionHasExtend && rangeInfos[0].backward) {
                    sel.removeAllRanges();
                    sel.addRange(ranges[0], true);
                } else {
                    sel.setRanges(ranges);
                }

                savedSelection.restored = true;
            }
        }

        function removeMarkerElement(doc, markerId) {
            var markerEl = gEBI(markerId, doc);
            if (markerEl) {
                markerEl.parentNode.removeChild(markerEl);
            }
        }

        function removeMarkers(savedSelection) {
            var rangeInfos = savedSelection.rangeInfos;
            for (var i = 0, len = rangeInfos.length, rangeInfo; i < len; ++i) {
                rangeInfo = rangeInfos[i];
                if (rangeInfo.collapsed) {
                    removeMarkerElement(savedSelection.doc, rangeInfo.markerId);
                } else {
                    removeMarkerElement(savedSelection.doc, rangeInfo.startMarkerId);
                    removeMarkerElement(savedSelection.doc, rangeInfo.endMarkerId);
                }
            }
        }

        api.util.extend(api, {
            saveRange: saveRange,
            restoreRange: restoreRange,
            saveRanges: saveRanges,
            restoreRanges: restoreRanges,
            saveSelection: saveSelection,
            restoreSelection: restoreSelection,
            removeMarkerElement: removeMarkerElement,
            removeMarkers: removeMarkers
        });
    });
    
}, this);;/*
	Base.js, version 1.1a
	Copyright 2006-2010, Dean Edwards
	License: http://www.opensource.org/licenses/mit-license.php
*/

var Base = function() {
	// dummy
};

Base.extend = function(_instance, _static) { // subclass
	var extend = Base.prototype.extend;
	
	// build the prototype
	Base._prototyping = true;
	var proto = new this;
	extend.call(proto, _instance);
  proto.base = function() {
    // call this method from any other method to invoke that method's ancestor
  };
	delete Base._prototyping;
	
	// create the wrapper for the constructor function
	//var constructor = proto.constructor.valueOf(); //-dean
	var constructor = proto.constructor;
	var klass = proto.constructor = function() {
		if (!Base._prototyping) {
			if (this._constructing || this.constructor == klass) { // instantiation
				this._constructing = true;
				constructor.apply(this, arguments);
				delete this._constructing;
			} else if (arguments[0] != null) { // casting
				return (arguments[0].extend || extend).call(arguments[0], proto);
			}
		}
	};
	
	// build the class interface
	klass.ancestor = this;
	klass.extend = this.extend;
	klass.forEach = this.forEach;
	klass.implement = this.implement;
	klass.prototype = proto;
	klass.toString = this.toString;
	klass.valueOf = function(type) {
		//return (type == "object") ? klass : constructor; //-dean
		return (type == "object") ? klass : constructor.valueOf();
	};
	extend.call(klass, _static);
	// class initialisation
	if (typeof klass.init == "function") klass.init();
	return klass;
};

Base.prototype = {	
	extend: function(source, value) {
		if (arguments.length > 1) { // extending with a name/value pair
			var ancestor = this[source];
			if (ancestor && (typeof value == "function") && // overriding a method?
				// the valueOf() comparison is to avoid circular references
				(!ancestor.valueOf || ancestor.valueOf() != value.valueOf()) &&
				/\bbase\b/.test(value)) {
				// get the underlying method
				var method = value.valueOf();
				// override
				value = function() {
					var previous = this.base || Base.prototype.base;
					this.base = ancestor;
					var returnValue = method.apply(this, arguments);
					this.base = previous;
					return returnValue;
				};
				// point to the underlying method
				value.valueOf = function(type) {
					return (type == "object") ? value : method;
				};
				value.toString = Base.toString;
			}
			this[source] = value;
		} else if (source) { // extending with an object literal
			var extend = Base.prototype.extend;
			// if this object has a customised extend method then use it
			if (!Base._prototyping && typeof this != "function") {
				extend = this.extend || extend;
			}
			var proto = {toSource: null};
			// do the "toString" and other methods manually
			var hidden = ["constructor", "toString", "valueOf"];
			// if we are prototyping then include the constructor
			var i = Base._prototyping ? 0 : 1;
			while (key = hidden[i++]) {
				if (source[key] != proto[key]) {
					extend.call(this, key, source[key]);

				}
			}
			// copy each of the source object's properties to this object
			for (var key in source) {
				if (!proto[key]) extend.call(this, key, source[key]);
			}
		}
		return this;
	}
};

// initialise
Base = Base.extend({
	constructor: function() {
		this.extend(arguments[0]);
	}
}, {
	ancestor: Object,
	version: "1.1",
	
	forEach: function(object, block, context) {
		for (var key in object) {
			if (this.prototype[key] === undefined) {
				block.call(context, object[key], key, object);
			}
		}
	},
		
	implement: function() {
		for (var i = 0; i < arguments.length; i++) {
			if (typeof arguments[i] == "function") {
				// if it's a function, call it
				arguments[i](this.prototype);
			} else {
				// add the interface using the extend method
				this.prototype.extend(arguments[i]);
			}
		}
		return this;
	},
	
	toString: function() {
		return String(this.valueOf());
	}
});;/**
 * Detect browser support for specific features
 */
wysihtml5.browser = (function() {
  var userAgent   = navigator.userAgent,
      testElement = document.createElement("div"),
      // Browser sniffing is unfortunately needed since some behaviors are impossible to feature detect
      isGecko     = userAgent.indexOf("Gecko")        !== -1 && userAgent.indexOf("KHTML") === -1,
      isWebKit    = userAgent.indexOf("AppleWebKit/") !== -1,
      isChrome    = userAgent.indexOf("Chrome/")      !== -1,
      isOpera     = userAgent.indexOf("Opera/")       !== -1;

  function iosVersion(userAgent) {
    return +((/ipad|iphone|ipod/.test(userAgent) && userAgent.match(/ os (\d+).+? like mac os x/)) || [undefined, 0])[1];
  }

  function androidVersion(userAgent) {
    return +(userAgent.match(/android (\d+)/) || [undefined, 0])[1];
  }

  function isIE(version, equation) {
    var rv = -1,
        re;

    if (navigator.appName == 'Microsoft Internet Explorer') {
      re = new RegExp("MSIE ([0-9]{1,}[\.0-9]{0,})");
    } else if (navigator.appName == 'Netscape') {
      re = new RegExp("Trident/.*rv:([0-9]{1,}[\.0-9]{0,})");
    }

    if (re && re.exec(navigator.userAgent) != null) {
      rv = parseFloat(RegExp.$1);
    }

    if (rv === -1) { return false; }
    if (!version) { return true; }
    if (!equation) { return version === rv; }
    if (equation === "<") { return version < rv; }
    if (equation === ">") { return version > rv; }
    if (equation === "<=") { return version <= rv; }
    if (equation === ">=") { return version >= rv; }
  }

  return {
    // Static variable needed, publicly accessible, to be able override it in unit tests
    USER_AGENT: userAgent,

    /**
     * Exclude browsers that are not capable of displaying and handling
     * contentEditable as desired:
     *    - iPhone, iPad (tested iOS 4.2.2) and Android (tested 2.2) refuse to make contentEditables focusable
     *    - IE < 8 create invalid markup and crash randomly from time to time
     *
     * @return {Boolean}
     */
    supported: function() {
      var userAgent                   = this.USER_AGENT.toLowerCase(),
          // Essential for making html elements editable
          hasContentEditableSupport   = "contentEditable" in testElement,
          // Following methods are needed in order to interact with the contentEditable area
          hasEditingApiSupport        = document.execCommand && document.queryCommandSupported && document.queryCommandState,
          // document selector apis are only supported by IE 8+, Safari 4+, Chrome and Firefox 3.5+
          hasQuerySelectorSupport     = document.querySelector && document.querySelectorAll,
          // contentEditable is unusable in mobile browsers (tested iOS 4.2.2, Android 2.2, Opera Mobile, WebOS 3.05)
          isIncompatibleMobileBrowser = (this.isIos() && iosVersion(userAgent) < 5) || (this.isAndroid() && androidVersion(userAgent) < 4) || userAgent.indexOf("opera mobi") !== -1 || userAgent.indexOf("hpwos/") !== -1;
      return hasContentEditableSupport
        && hasEditingApiSupport
        && hasQuerySelectorSupport
        && !isIncompatibleMobileBrowser;
    },

    isTouchDevice: function() {
      return this.supportsEvent("touchmove");
    },

    isIos: function() {
      return (/ipad|iphone|ipod/i).test(this.USER_AGENT);
    },

    isAndroid: function() {
      return this.USER_AGENT.indexOf("Android") !== -1;
    },

    /**
     * Whether the browser supports sandboxed iframes
     * Currently only IE 6+ offers such feature <iframe security="restricted">
     *
     * http://msdn.microsoft.com/en-us/library/ms534622(v=vs.85).aspx
     * http://blogs.msdn.com/b/ie/archive/2008/01/18/using-frames-more-securely.aspx
     *
     * HTML5 sandboxed iframes are still buggy and their DOM is not reachable from the outside (except when using postMessage)
     */
    supportsSandboxedIframes: function() {
      return isIE();
    },

    /**
     * IE6+7 throw a mixed content warning when the src of an iframe
     * is empty/unset or about:blank
     * window.querySelector is implemented as of IE8
     */
    throwsMixedContentWarningWhenIframeSrcIsEmpty: function() {
      return !("querySelector" in document);
    },

    /**
     * Whether the caret is correctly displayed in contentEditable elements
     * Firefox sometimes shows a huge caret in the beginning after focusing
     */
    displaysCaretInEmptyContentEditableCorrectly: function() {
      return isIE();
    },

    /**
     * Opera and IE are the only browsers who offer the css value
     * in the original unit, thx to the currentStyle object
     * All other browsers provide the computed style in px via window.getComputedStyle
     */
    hasCurrentStyleProperty: function() {
      return "currentStyle" in testElement;
    },

    /**
     * Whether the browser inserts a <br> when pressing enter in a contentEditable element
     */
    insertsLineBreaksOnReturn: function() {
      return isGecko;
    },

    supportsPlaceholderAttributeOn: function(element) {
      return "placeholder" in element;
    },

    supportsEvent: function(eventName) {
      return "on" + eventName in testElement || (function() {
        testElement.setAttribute("on" + eventName, "return;");
        return typeof(testElement["on" + eventName]) === "function";
      })();
    },

    /**
     * Opera doesn't correctly fire focus/blur events when clicking in- and outside of iframe
     */
    supportsEventsInIframeCorrectly: function() {
      return !isOpera;
    },

    /**
     * Everything below IE9 doesn't know how to treat HTML5 tags
     *
     * @param {Object} context The document object on which to check HTML5 support
     *
     * @example
     *    wysihtml5.browser.supportsHTML5Tags(document);
     */
    supportsHTML5Tags: function(context) {
      var element = context.createElement("div"),
          html5   = "<article>foo</article>";
      element.innerHTML = html5;
      return element.innerHTML.toLowerCase() === html5;
    },

    /**
     * Checks whether a document supports a certain queryCommand
     * In particular, Opera needs a reference to a document that has a contentEditable in it's dom tree
     * in oder to report correct results
     *
     * @param {Object} doc Document object on which to check for a query command
     * @param {String} command The query command to check for
     * @return {Boolean}
     *
     * @example
     *    wysihtml5.browser.supportsCommand(document, "bold");
     */
    supportsCommand: (function() {
      // Following commands are supported but contain bugs in some browsers
      var buggyCommands = {
        // formatBlock fails with some tags (eg. <blockquote>)
        "formatBlock":          isIE(10, "<="),
         // When inserting unordered or ordered lists in Firefox, Chrome or Safari, the current selection or line gets
         // converted into a list (<ul><li>...</li></ul>, <ol><li>...</li></ol>)
         // IE and Opera act a bit different here as they convert the entire content of the current block element into a list
        "insertUnorderedList":  isIE(),
        "insertOrderedList":    isIE()
      };

      // Firefox throws errors for queryCommandSupported, so we have to build up our own object of supported commands
      var supported = {
        "insertHTML": isGecko
      };

      return function(doc, command) {
        var isBuggy = buggyCommands[command];
        if (!isBuggy) {
          // Firefox throws errors when invoking queryCommandSupported or queryCommandEnabled
          try {
            return doc.queryCommandSupported(command);
          } catch(e1) {}

          try {
            return doc.queryCommandEnabled(command);
          } catch(e2) {
            return !!supported[command];
          }
        }
        return false;
      };
    })(),

    /**
     * IE: URLs starting with:
     *    www., http://, https://, ftp://, gopher://, mailto:, new:, snews:, telnet:, wasis:, file://,
     *    nntp://, newsrc:, ldap://, ldaps://, outlook:, mic:// and url:
     * will automatically be auto-linked when either the user inserts them via copy&paste or presses the
     * space bar when the caret is directly after such an url.
     * This behavior cannot easily be avoided in IE < 9 since the logic is hardcoded in the mshtml.dll
     * (related blog post on msdn
     * http://blogs.msdn.com/b/ieinternals/archive/2009/09/17/prevent-automatic-hyperlinking-in-contenteditable-html.aspx).
     */
    doesAutoLinkingInContentEditable: function() {
      return isIE();
    },

    /**
     * As stated above, IE auto links urls typed into contentEditable elements
     * Since IE9 it's possible to prevent this behavior
     */
    canDisableAutoLinking: function() {
      return this.supportsCommand(document, "AutoUrlDetect");
    },

    /**
     * IE leaves an empty paragraph in the contentEditable element after clearing it
     * Chrome/Safari sometimes an empty <div>
     */
    clearsContentEditableCorrectly: function() {
      return isGecko || isOpera || isWebKit;
    },

    /**
     * IE gives wrong results for getAttribute
     */
    supportsGetAttributeCorrectly: function() {
      var td = document.createElement("td");
      return td.getAttribute("rowspan") != "1";
    },

    /**
     * When clicking on images in IE, Opera and Firefox, they are selected, which makes it easy to interact with them.
     * Chrome and Safari both don't support this
     */
    canSelectImagesInContentEditable: function() {
      return isGecko || isIE() || isOpera;
    },

    /**
     * All browsers except Safari and Chrome automatically scroll the range/caret position into view
     */
    autoScrollsToCaret: function() {
      return !isWebKit;
    },

    /**
     * Check whether the browser automatically closes tags that don't need to be opened
     */
    autoClosesUnclosedTags: function() {
      var clonedTestElement = testElement.cloneNode(false),
          returnValue,
          innerHTML;

      clonedTestElement.innerHTML = "<p><div></div>";
      innerHTML                   = clonedTestElement.innerHTML.toLowerCase();
      returnValue                 = innerHTML === "<p></p><div></div>" || innerHTML === "<p><div></div></p>";

      // Cache result by overwriting current function
      this.autoClosesUnclosedTags = function() { return returnValue; };

      return returnValue;
    },

    /**
     * Whether the browser supports the native document.getElementsByClassName which returns live NodeLists
     */
    supportsNativeGetElementsByClassName: function() {
      return String(document.getElementsByClassName).indexOf("[native code]") !== -1;
    },

    /**
     * As of now (19.04.2011) only supported by Firefox 4 and Chrome
     * See https://developer.mozilla.org/en/DOM/Selection/modify
     */
    supportsSelectionModify: function() {
      return "getSelection" in window && "modify" in window.getSelection();
    },

    /**
     * Opera needs a white space after a <br> in order to position the caret correctly
     */
    needsSpaceAfterLineBreak: function() {
      return isOpera;
    },

    /**
     * Whether the browser supports the speech api on the given element
     * See http://mikepultz.com/2011/03/accessing-google-speech-api-chrome-11/
     *
     * @example
     *    var input = document.createElement("input");
     *    if (wysihtml5.browser.supportsSpeechApiOn(input)) {
     *      // ...
     *    }
     */
    supportsSpeechApiOn: function(input) {
      var chromeVersion = userAgent.match(/Chrome\/(\d+)/) || [undefined, 0];
      return chromeVersion[1] >= 11 && ("onwebkitspeechchange" in input || "speech" in input);
    },

    /**
     * IE9 crashes when setting a getter via Object.defineProperty on XMLHttpRequest or XDomainRequest
     * See https://connect.microsoft.com/ie/feedback/details/650112
     * or try the POC http://tifftiff.de/ie9_crash/
     */
    crashesWhenDefineProperty: function(property) {
      return isIE(9) && (property === "XMLHttpRequest" || property === "XDomainRequest");
    },

    /**
     * IE is the only browser who fires the "focus" event not immediately when .focus() is called on an element
     */
    doesAsyncFocus: function() {
      return isIE();
    },

    /**
     * In IE it's impssible for the user and for the selection library to set the caret after an <img> when it's the lastChild in the document
     */
    hasProblemsSettingCaretAfterImg: function() {
      return isIE();
    },

    hasUndoInContextMenu: function() {
      return isGecko || isChrome || isOpera;
    },

    /**
     * Opera sometimes doesn't insert the node at the right position when range.insertNode(someNode)
     * is used (regardless if rangy or native)
     * This especially happens when the caret is positioned right after a <br> because then
     * insertNode() will insert the node right before the <br>
     */
    hasInsertNodeIssue: function() {
      return isOpera;
    },

    /**
     * IE 8+9 don't fire the focus event of the <body> when the iframe gets focused (even though the caret gets set into the <body>)
     */
    hasIframeFocusIssue: function() {
      return isIE();
    },

    /**
     * Chrome + Safari create invalid nested markup after paste
     *
     *  <p>
     *    foo
     *    <p>bar</p> <!-- BOO! -->
     *  </p>
     */
    createsNestedInvalidMarkupAfterPaste: function() {
      return isWebKit;
    },

    supportsMutationEvents: function() {
        return ("MutationEvent" in window);
    },

    /**
      IE (at least up to 11) does not support clipboardData on event.
      It is on window but cannot return text/html
      Should actually check for clipboardData on paste event, but cannot in firefox
    */
    supportsModenPaste: function () {
      return !("clipboardData" in window);
    }
  };
})();
;wysihtml5.lang.array = function(arr) {
  return {
    /**
     * Check whether a given object exists in an array
     *
     * @example
     *    wysihtml5.lang.array([1, 2]).contains(1);
     *    // => true
     *
     * Can be used to match array with array. If intersection is found true is returned
     */
    contains: function(needle) {
      if (Array.isArray(needle)) {
        for (var i = needle.length; i--;) {
          if (wysihtml5.lang.array(arr).indexOf(needle[i]) !== -1) {
            return true;
          }
        }
        return false;
      } else {
        return wysihtml5.lang.array(arr).indexOf(needle) !== -1;
      }
    },

    /**
     * Check whether a given object exists in an array and return index
     * If no elelemt found returns -1
     *
     * @example
     *    wysihtml5.lang.array([1, 2]).indexOf(2);
     *    // => 1
     */
    indexOf: function(needle) {
        if (arr.indexOf) {
          return arr.indexOf(needle);
        } else {
          for (var i=0, length=arr.length; i<length; i++) {
            if (arr[i] === needle) { return i; }
          }
          return -1;
        }
    },

    /**
     * Substract one array from another
     *
     * @example
     *    wysihtml5.lang.array([1, 2, 3, 4]).without([3, 4]);
     *    // => [1, 2]
     */
    without: function(arrayToSubstract) {
      arrayToSubstract = wysihtml5.lang.array(arrayToSubstract);
      var newArr  = [],
          i       = 0,
          length  = arr.length;
      for (; i<length; i++) {
        if (!arrayToSubstract.contains(arr[i])) {
          newArr.push(arr[i]);
        }
      }
      return newArr;
    },

    /**
     * Return a clean native array
     *
     * Following will convert a Live NodeList to a proper Array
     * @example
     *    var childNodes = wysihtml5.lang.array(document.body.childNodes).get();
     */
    get: function() {
      var i        = 0,
          length   = arr.length,
          newArray = [];
      for (; i<length; i++) {
        newArray.push(arr[i]);
      }
      return newArray;
    },

    /**
     * Creates a new array with the results of calling a provided function on every element in this array.
     * optionally this can be provided as second argument
     *
     * @example
     *    var childNodes = wysihtml5.lang.array([1,2,3,4]).map(function (value, index, array) {
            return value * 2;
     *    });
     *    // => [2,4,6,8]
     */
    map: function(callback, thisArg) {
      if (Array.prototype.map) {
        return arr.map(callback, thisArg);
      } else {
        var len = arr.length >>> 0,
            A = new Array(len),
            i = 0;
        for (; i < len; i++) {
           A[i] = callback.call(thisArg, arr[i], i, arr);
        }
        return A;
      }
    },

    /* ReturnS new array without duplicate entries
     *
     * @example
     *    var uniq = wysihtml5.lang.array([1,2,3,2,1,4]).unique();
     *    // => [1,2,3,4]
     */
    unique: function() {
      var vals = [],
          max = arr.length,
          idx = 0;

      while (idx < max) {
        if (!wysihtml5.lang.array(vals).contains(arr[idx])) {
          vals.push(arr[idx]);
        }
        idx++;
      }
      return vals;
    }

  };
};
;wysihtml5.lang.Dispatcher = Base.extend(
  /** @scope wysihtml5.lang.Dialog.prototype */ {
  on: function(eventName, handler) {
    this.events = this.events || {};
    this.events[eventName] = this.events[eventName] || [];
    this.events[eventName].push(handler);
    return this;
  },

  off: function(eventName, handler) {
    this.events = this.events || {};
    var i = 0,
        handlers,
        newHandlers;
    if (eventName) {
      handlers    = this.events[eventName] || [],
      newHandlers = [];
      for (; i<handlers.length; i++) {
        if (handlers[i] !== handler && handler) {
          newHandlers.push(handlers[i]);
        }
      }
      this.events[eventName] = newHandlers;
    } else {
      // Clean up all events
      this.events = {};
    }
    return this;
  },

  fire: function(eventName, payload) {
    this.events = this.events || {};
    var handlers = this.events[eventName] || [],
        i        = 0;
    for (; i<handlers.length; i++) {
      handlers[i].call(this, payload);
    }
    return this;
  },

  // deprecated, use .on()
  observe: function() {
    return this.on.apply(this, arguments);
  },

  // deprecated, use .off()
  stopObserving: function() {
    return this.off.apply(this, arguments);
  }
});
;wysihtml5.lang.object = function(obj) {
  return {
    /**
     * @example
     *    wysihtml5.lang.object({ foo: 1, bar: 1 }).merge({ bar: 2, baz: 3 }).get();
     *    // => { foo: 1, bar: 2, baz: 3 }
     */
    merge: function(otherObj) {
      for (var i in otherObj) {
        obj[i] = otherObj[i];
      }
      return this;
    },

    get: function() {
      return obj;
    },

    /**
     * @example
     *    wysihtml5.lang.object({ foo: 1 }).clone();
     *    // => { foo: 1 }
     *
     *    v0.4.14 adds options for deep clone : wysihtml5.lang.object({ foo: 1 }).clone(true);
     */
    clone: function(deep) {
      var newObj = {},
          i;

      if (obj === null || !wysihtml5.lang.object(obj).isPlainObject()) {
        return obj;
      }

      for (i in obj) {
        if(obj.hasOwnProperty(i)) {
          if (deep) {
            newObj[i] = wysihtml5.lang.object(obj[i]).clone(deep);
          } else {
            newObj[i] = obj[i];
          }
        }
      }
      return newObj;
    },

    /**
     * @example
     *    wysihtml5.lang.object([]).isArray();
     *    // => true
     */
    isArray: function() {
      return Object.prototype.toString.call(obj) === "[object Array]";
    },

    /**
     * @example
     *    wysihtml5.lang.object(function() {}).isFunction();
     *    // => true
     */
    isFunction: function() {
      return Object.prototype.toString.call(obj) === '[object Function]';
    },

    isPlainObject: function () {
      return Object.prototype.toString.call(obj) === '[object Object]';
    }
  };
};
;(function() {
  var WHITE_SPACE_START = /^\s+/,
      WHITE_SPACE_END   = /\s+$/,
      ENTITY_REG_EXP    = /[&<>\t"]/g,
      ENTITY_MAP = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': "&quot;",
        '\t':"&nbsp; "
      };
  wysihtml5.lang.string = function(str) {
    str = String(str);
    return {
      /**
       * @example
       *    wysihtml5.lang.string("   foo   ").trim();
       *    // => "foo"
       */
      trim: function() {
        return str.replace(WHITE_SPACE_START, "").replace(WHITE_SPACE_END, "");
      },

      /**
       * @example
       *    wysihtml5.lang.string("Hello #{name}").interpolate({ name: "Christopher" });
       *    // => "Hello Christopher"
       */
      interpolate: function(vars) {
        for (var i in vars) {
          str = this.replace("#{" + i + "}").by(vars[i]);
        }
        return str;
      },

      /**
       * @example
       *    wysihtml5.lang.string("Hello Tom").replace("Tom").with("Hans");
       *    // => "Hello Hans"
       */
      replace: function(search) {
        return {
          by: function(replace) {
            return str.split(search).join(replace);
          }
        };
      },

      /**
       * @example
       *    wysihtml5.lang.string("hello<br>").escapeHTML();
       *    // => "hello&lt;br&gt;"
       */
      escapeHTML: function(linebreaks, convertSpaces) {
        var html = str.replace(ENTITY_REG_EXP, function(c) { return ENTITY_MAP[c]; });
        if (linebreaks) {
          html = html.replace(/(?:\r\n|\r|\n)/g, '<br />');
        }
        if (convertSpaces) {
          html = html.replace(/  /gi, "&nbsp; ");
        }
        return html;
      }
    };
  };
})();
;/**
 * Find urls in descendant text nodes of an element and auto-links them
 * Inspired by http://james.padolsey.com/javascript/find-and-replace-text-with-javascript/
 *
 * @param {Element} element Container element in which to search for urls
 *
 * @example
 *    <div id="text-container">Please click here: www.google.com</div>
 *    <script>wysihtml5.dom.autoLink(document.getElementById("text-container"));</script>
 */
(function(wysihtml5) {
  var /**
       * Don't auto-link urls that are contained in the following elements:
       */
      IGNORE_URLS_IN        = wysihtml5.lang.array(["CODE", "PRE", "A", "SCRIPT", "HEAD", "TITLE", "STYLE"]),
      /**
       * revision 1:
       *    /(\S+\.{1}[^\s\,\.\!]+)/g
       *
       * revision 2:
       *    /(\b(((https?|ftp):\/\/)|(www\.))[-A-Z0-9+&@#\/%?=~_|!:,.;\[\]]*[-A-Z0-9+&@#\/%=~_|])/gim
       *
       * put this in the beginning if you don't wan't to match within a word
       *    (^|[\>\(\{\[\s\>])
       */
      URL_REG_EXP           = /((https?:\/\/|www\.)[^\s<]{3,})/gi,
      TRAILING_CHAR_REG_EXP = /([^\w\/\-](,?))$/i,
      MAX_DISPLAY_LENGTH    = 100,
      BRACKETS              = { ")": "(", "]": "[", "}": "{" };

  function autoLink(element, ignoreInClasses) {
    if (_hasParentThatShouldBeIgnored(element, ignoreInClasses)) {
      return element;
    }

    if (element === element.ownerDocument.documentElement) {
      element = element.ownerDocument.body;
    }

    return _parseNode(element, ignoreInClasses);
  }

  /**
   * This is basically a rebuild of
   * the rails auto_link_urls text helper
   */
  function _convertUrlsToLinks(str) {
    return str.replace(URL_REG_EXP, function(match, url) {
      var punctuation = (url.match(TRAILING_CHAR_REG_EXP) || [])[1] || "",
          opening     = BRACKETS[punctuation];
      url = url.replace(TRAILING_CHAR_REG_EXP, "");

      if (url.split(opening).length > url.split(punctuation).length) {
        url = url + punctuation;
        punctuation = "";
      }
      var realUrl    = url,
          displayUrl = url;
      if (url.length > MAX_DISPLAY_LENGTH) {
        displayUrl = displayUrl.substr(0, MAX_DISPLAY_LENGTH) + "...";
      }
      // Add http prefix if necessary
      if (realUrl.substr(0, 4) === "www.") {
        realUrl = "http://" + realUrl;
      }

      return '<a href="' + realUrl + '">' + displayUrl + '</a>' + punctuation;
    });
  }

  /**
   * Creates or (if already cached) returns a temp element
   * for the given document object
   */
  function _getTempElement(context) {
    var tempElement = context._wysihtml5_tempElement;
    if (!tempElement) {
      tempElement = context._wysihtml5_tempElement = context.createElement("div");
    }
    return tempElement;
  }

  /**
   * Replaces the original text nodes with the newly auto-linked dom tree
   */
  function _wrapMatchesInNode(textNode) {
    var parentNode  = textNode.parentNode,
        nodeValue   = wysihtml5.lang.string(textNode.data).escapeHTML(),
        tempElement = _getTempElement(parentNode.ownerDocument);

    // We need to insert an empty/temporary <span /> to fix IE quirks
    // Elsewise IE would strip white space in the beginning
    tempElement.innerHTML = "<span></span>" + _convertUrlsToLinks(nodeValue);
    tempElement.removeChild(tempElement.firstChild);

    while (tempElement.firstChild) {
      // inserts tempElement.firstChild before textNode
      parentNode.insertBefore(tempElement.firstChild, textNode);
    }
    parentNode.removeChild(textNode);
  }

  function _hasParentThatShouldBeIgnored(node, ignoreInClasses) {
    var nodeName;
    while (node.parentNode) {
      node = node.parentNode;
      nodeName = node.nodeName;
      if (node.className && wysihtml5.lang.array(node.className.split(' ')).contains(ignoreInClasses)) {
        return true;
      }
      if (IGNORE_URLS_IN.contains(nodeName)) {
        return true;
      } else if (nodeName === "body") {
        return false;
      }
    }
    return false;
  }

  function _parseNode(element, ignoreInClasses) {
    if (IGNORE_URLS_IN.contains(element.nodeName)) {
      return;
    }

    if (element.className && wysihtml5.lang.array(element.className.split(' ')).contains(ignoreInClasses)) {
      return;
    }

    if (element.nodeType === wysihtml5.TEXT_NODE && element.data.match(URL_REG_EXP)) {
      _wrapMatchesInNode(element);
      return;
    }

    var childNodes        = wysihtml5.lang.array(element.childNodes).get(),
        childNodesLength  = childNodes.length,
        i                 = 0;

    for (; i<childNodesLength; i++) {
      _parseNode(childNodes[i], ignoreInClasses);
    }

    return element;
  }

  wysihtml5.dom.autoLink = autoLink;

  // Reveal url reg exp to the outside
  wysihtml5.dom.autoLink.URL_REG_EXP = URL_REG_EXP;
})(wysihtml5);
;(function(wysihtml5) {
  var api = wysihtml5.dom;

  api.addClass = function(element, className) {
    var classList = element.classList;
    if (classList) {
      return classList.add(className);
    }
    if (api.hasClass(element, className)) {
      return;
    }
    element.className += " " + className;
  };

  api.removeClass = function(element, className) {
    var classList = element.classList;
    if (classList) {
      return classList.remove(className);
    }

    element.className = element.className.replace(new RegExp("(^|\\s+)" + className + "(\\s+|$)"), " ");
  };

  api.hasClass = function(element, className) {
    var classList = element.classList;
    if (classList) {
      return classList.contains(className);
    }

    var elementClassName = element.className;
    return (elementClassName.length > 0 && (elementClassName == className || new RegExp("(^|\\s)" + className + "(\\s|$)").test(elementClassName)));
  };
})(wysihtml5);
;wysihtml5.dom.contains = (function() {
  var documentElement = document.documentElement;
  if (documentElement.contains) {
    return function(container, element) {
      if (element.nodeType !== wysihtml5.ELEMENT_NODE) {
        element = element.parentNode;
      }
      return container !== element && container.contains(element);
    };
  } else if (documentElement.compareDocumentPosition) {
    return function(container, element) {
      // https://developer.mozilla.org/en/DOM/Node.compareDocumentPosition
      return !!(container.compareDocumentPosition(element) & 16);
    };
  }
})();
;/**
 * Converts an HTML fragment/element into a unordered/ordered list
 *
 * @param {Element} element The element which should be turned into a list
 * @param {String} listType The list type in which to convert the tree (either "ul" or "ol")
 * @return {Element} The created list
 *
 * @example
 *    <!-- Assume the following dom: -->
 *    <span id="pseudo-list">
 *      eminem<br>
 *      dr. dre
 *      <div>50 Cent</div>
 *    </span>
 *
 *    <script>
 *      wysihtml5.dom.convertToList(document.getElementById("pseudo-list"), "ul");
 *    </script>
 *
 *    <!-- Will result in: -->
 *    <ul>
 *      <li>eminem</li>
 *      <li>dr. dre</li>
 *      <li>50 Cent</li>
 *    </ul>
 */
wysihtml5.dom.convertToList = (function() {
  function _createListItem(doc, list) {
    var listItem = doc.createElement("li");
    list.appendChild(listItem);
    return listItem;
  }

  function _createList(doc, type) {
    return doc.createElement(type);
  }

  function convertToList(element, listType, uneditableClass) {
    if (element.nodeName === "UL" || element.nodeName === "OL" || element.nodeName === "MENU") {
      // Already a list
      return element;
    }

    var doc               = element.ownerDocument,
        list              = _createList(doc, listType),
        lineBreaks        = element.querySelectorAll("br"),
        lineBreaksLength  = lineBreaks.length,
        childNodes,
        childNodesLength,
        childNode,
        lineBreak,
        parentNode,
        isBlockElement,
        isLineBreak,
        currentListItem,
        i;

    // First find <br> at the end of inline elements and move them behind them
    for (i=0; i<lineBreaksLength; i++) {
      lineBreak = lineBreaks[i];
      while ((parentNode = lineBreak.parentNode) && parentNode !== element && parentNode.lastChild === lineBreak) {
        if (wysihtml5.dom.getStyle("display").from(parentNode) === "block") {
          parentNode.removeChild(lineBreak);
          break;
        }
        wysihtml5.dom.insert(lineBreak).after(lineBreak.parentNode);
      }
    }

    childNodes        = wysihtml5.lang.array(element.childNodes).get();
    childNodesLength  = childNodes.length;

    for (i=0; i<childNodesLength; i++) {
      currentListItem   = currentListItem || _createListItem(doc, list);
      childNode         = childNodes[i];
      isBlockElement    = wysihtml5.dom.getStyle("display").from(childNode) === "block";
      isLineBreak       = childNode.nodeName === "BR";

      // consider uneditable as an inline element
      if (isBlockElement && (!uneditableClass || !wysihtml5.dom.hasClass(childNode, uneditableClass))) {
        // Append blockElement to current <li> if empty, otherwise create a new one
        currentListItem = currentListItem.firstChild ? _createListItem(doc, list) : currentListItem;
        currentListItem.appendChild(childNode);
        currentListItem = null;
        continue;
      }

      if (isLineBreak) {
        // Only create a new list item in the next iteration when the current one has already content
        currentListItem = currentListItem.firstChild ? null : currentListItem;
        continue;
      }

      currentListItem.appendChild(childNode);
    }

    if (childNodes.length === 0) {
      _createListItem(doc, list);
    }

    element.parentNode.replaceChild(list, element);
    return list;
  }

  return convertToList;
})();
;/**
 * Copy a set of attributes from one element to another
 *
 * @param {Array} attributesToCopy List of attributes which should be copied
 * @return {Object} Returns an object which offers the "from" method which can be invoked with the element where to
 *    copy the attributes from., this again returns an object which provides a method named "to" which can be invoked
 *    with the element where to copy the attributes to (see example)
 *
 * @example
 *    var textarea    = document.querySelector("textarea"),
 *        div         = document.querySelector("div[contenteditable=true]"),
 *        anotherDiv  = document.querySelector("div.preview");
 *    wysihtml5.dom.copyAttributes(["spellcheck", "value", "placeholder"]).from(textarea).to(div).andTo(anotherDiv);
 *
 */
wysihtml5.dom.copyAttributes = function(attributesToCopy) {
  return {
    from: function(elementToCopyFrom) {
      return {
        to: function(elementToCopyTo) {
          var attribute,
              i         = 0,
              length    = attributesToCopy.length;
          for (; i<length; i++) {
            attribute = attributesToCopy[i];
            if (typeof(elementToCopyFrom[attribute]) !== "undefined" && elementToCopyFrom[attribute] !== "") {
              elementToCopyTo[attribute] = elementToCopyFrom[attribute];
            }
          }
          return { andTo: arguments.callee };
        }
      };
    }
  };
};
;/**
 * Copy a set of styles from one element to another
 * Please note that this only works properly across browsers when the element from which to copy the styles
 * is in the dom
 *
 * Interesting article on how to copy styles
 *
 * @param {Array} stylesToCopy List of styles which should be copied
 * @return {Object} Returns an object which offers the "from" method which can be invoked with the element where to
 *    copy the styles from., this again returns an object which provides a method named "to" which can be invoked
 *    with the element where to copy the styles to (see example)
 *
 * @example
 *    var textarea    = document.querySelector("textarea"),
 *        div         = document.querySelector("div[contenteditable=true]"),
 *        anotherDiv  = document.querySelector("div.preview");
 *    wysihtml5.dom.copyStyles(["overflow-y", "width", "height"]).from(textarea).to(div).andTo(anotherDiv);
 *
 */
(function(dom) {

  /**
   * Mozilla, WebKit and Opera recalculate the computed width when box-sizing: boder-box; is set
   * So if an element has "width: 200px; -moz-box-sizing: border-box; border: 1px;" then
   * its computed css width will be 198px
   *
   * See https://bugzilla.mozilla.org/show_bug.cgi?id=520992
   */
  var BOX_SIZING_PROPERTIES = ["-webkit-box-sizing", "-moz-box-sizing", "-ms-box-sizing", "box-sizing"];

  var shouldIgnoreBoxSizingBorderBox = function(element) {
    if (hasBoxSizingBorderBox(element)) {
       return parseInt(dom.getStyle("width").from(element), 10) < element.offsetWidth;
    }
    return false;
  };

  var hasBoxSizingBorderBox = function(element) {
    var i       = 0,
        length  = BOX_SIZING_PROPERTIES.length;
    for (; i<length; i++) {
      if (dom.getStyle(BOX_SIZING_PROPERTIES[i]).from(element) === "border-box") {
        return BOX_SIZING_PROPERTIES[i];
      }
    }
  };

  dom.copyStyles = function(stylesToCopy) {
    return {
      from: function(element) {
        if (shouldIgnoreBoxSizingBorderBox(element)) {
          stylesToCopy = wysihtml5.lang.array(stylesToCopy).without(BOX_SIZING_PROPERTIES);
        }

        var cssText = "",
            length  = stylesToCopy.length,
            i       = 0,
            property;
        for (; i<length; i++) {
          property = stylesToCopy[i];
          cssText += property + ":" + dom.getStyle(property).from(element) + ";";
        }

        return {
          to: function(element) {
            dom.setStyles(cssText).on(element);
            return { andTo: arguments.callee };
          }
        };
      }
    };
  };
})(wysihtml5.dom);
;/**
 * Event Delegation
 *
 * @example
 *    wysihtml5.dom.delegate(document.body, "a", "click", function() {
 *      // foo
 *    });
 */
(function(wysihtml5) {

  wysihtml5.dom.delegate = function(container, selector, eventName, handler) {
    return wysihtml5.dom.observe(container, eventName, function(event) {
      var target    = event.target,
          match     = wysihtml5.lang.array(container.querySelectorAll(selector));

      while (target && target !== container) {
        if (match.contains(target)) {
          handler.call(target, event);
          break;
        }
        target = target.parentNode;
      }
    });
  };

})(wysihtml5);
;// TODO: Refactor dom tree traversing here
(function(wysihtml5) {
  wysihtml5.dom.domNode = function(node) {
    var defaultNodeTypes = [wysihtml5.ELEMENT_NODE, wysihtml5.TEXT_NODE];

    var _isBlankText = function(node) {
      return node.nodeType === wysihtml5.TEXT_NODE && (/^\s*$/g).test(node.data);
    };

    return {

      // var node = wysihtml5.dom.domNode(element).prev({nodeTypes: [1,3], ignoreBlankTexts: true});
      prev: function(options) {
        var prevNode = node.previousSibling,
            types = (options && options.nodeTypes) ? options.nodeTypes : defaultNodeTypes;
        
        if (!prevNode) {
          return null;
        }

        if (
          (!wysihtml5.lang.array(types).contains(prevNode.nodeType)) || // nodeTypes check.
          (options && options.ignoreBlankTexts && _isBlankText(prevNode)) // Blank text nodes bypassed if set
        ) {
          return wysihtml5.dom.domNode(prevNode).prev(options);
        }
        
        return prevNode;
      },

      // var node = wysihtml5.dom.domNode(element).next({nodeTypes: [1,3], ignoreBlankTexts: true});
      next: function(options) {
        var nextNode = node.nextSibling,
            types = (options && options.nodeTypes) ? options.nodeTypes : defaultNodeTypes;
        
        if (!nextNode) {
          return null;
        }

        if (
          (!wysihtml5.lang.array(types).contains(nextNode.nodeType)) || // nodeTypes check.
          (options && options.ignoreBlankTexts && _isBlankText(nextNode)) // blank text nodes bypassed if set
        ) {
          return wysihtml5.dom.domNode(nextNode).next(options);
        }
        
        return nextNode;
      },

      // Traverses a node for last children and their chidren (including itself), and finds the last node that has no children.
      // Array of classes for forced last-leaves (ex: uneditable-container) can be defined (options = {leafClasses: [...]})
      // Useful for finding the actually visible element before cursor
      lastLeafNode: function(options) {
        var lastChild;

        // Returns non-element nodes
        if (node.nodeType !== 1) {
          return node;
        }

        // Returns if element is leaf
        lastChild = node.lastChild;
        if (!lastChild) {
          return node;
        }

        // Returns if element is of of options.leafClasses leaf
        if (options && options.leafClasses) {
          for (var i = options.leafClasses.length; i--;) {
            if (wysihtml5.dom.hasClass(node, options.leafClasses[i])) {
              return node;
            }
          }
        }

        return wysihtml5.dom.domNode(lastChild).lastLeafNode(options);
      }

    };
  };
})(wysihtml5);;/**
 * Returns the given html wrapped in a div element
 *
 * Fixing IE's inability to treat unknown elements (HTML5 section, article, ...) correctly
 * when inserted via innerHTML
 *
 * @param {String} html The html which should be wrapped in a dom element
 * @param {Obejct} [context] Document object of the context the html belongs to
 *
 * @example
 *    wysihtml5.dom.getAsDom("<article>foo</article>");
 */
wysihtml5.dom.getAsDom = (function() {

  var _innerHTMLShiv = function(html, context) {
    var tempElement = context.createElement("div");
    tempElement.style.display = "none";
    context.body.appendChild(tempElement);
    // IE throws an exception when trying to insert <frameset></frameset> via innerHTML
    try { tempElement.innerHTML = html; } catch(e) {}
    context.body.removeChild(tempElement);
    return tempElement;
  };

  /**
   * Make sure IE supports HTML5 tags, which is accomplished by simply creating one instance of each element
   */
  var _ensureHTML5Compatibility = function(context) {
    if (context._wysihtml5_supportsHTML5Tags) {
      return;
    }
    for (var i=0, length=HTML5_ELEMENTS.length; i<length; i++) {
      context.createElement(HTML5_ELEMENTS[i]);
    }
    context._wysihtml5_supportsHTML5Tags = true;
  };


  /**
   * List of html5 tags
   * taken from http://simon.html5.org/html5-elements
   */
  var HTML5_ELEMENTS = [
    "abbr", "article", "aside", "audio", "bdi", "canvas", "command", "datalist", "details", "figcaption",
    "figure", "footer", "header", "hgroup", "keygen", "mark", "meter", "nav", "output", "progress",
    "rp", "rt", "ruby", "svg", "section", "source", "summary", "time", "track", "video", "wbr"
  ];

  return function(html, context) {
    context = context || document;
    var tempElement;
    if (typeof(html) === "object" && html.nodeType) {
      tempElement = context.createElement("div");
      tempElement.appendChild(html);
    } else if (wysihtml5.browser.supportsHTML5Tags(context)) {
      tempElement = context.createElement("div");
      tempElement.innerHTML = html;
    } else {
      _ensureHTML5Compatibility(context);
      tempElement = _innerHTMLShiv(html, context);
    }
    return tempElement;
  };
})();
;/**
 * Walks the dom tree from the given node up until it finds a match
 * Designed for optimal performance.
 *
 * @param {Element} node The from which to check the parent nodes
 * @param {Object} matchingSet Object to match against (possible properties: nodeName, className, classRegExp)
 * @param {Number} [levels] How many parents should the function check up from the current node (defaults to 50)
 * @return {null|Element} Returns the first element that matched the desiredNodeName(s)
 * @example
 *    var listElement = wysihtml5.dom.getParentElement(document.querySelector("li"), { nodeName: ["MENU", "UL", "OL"] });
 *    // ... or ...
 *    var unorderedListElement = wysihtml5.dom.getParentElement(document.querySelector("li"), { nodeName: "UL" });
 *    // ... or ...
 *    var coloredElement = wysihtml5.dom.getParentElement(myTextNode, { nodeName: "SPAN", className: "wysiwyg-color-red", classRegExp: /wysiwyg-color-[a-z]/g });
 */
wysihtml5.dom.getParentElement = (function() {

  function _isSameNodeName(nodeName, desiredNodeNames) {
    if (!desiredNodeNames || !desiredNodeNames.length) {
      return true;
    }

    if (typeof(desiredNodeNames) === "string") {
      return nodeName === desiredNodeNames;
    } else {
      return wysihtml5.lang.array(desiredNodeNames).contains(nodeName);
    }
  }

  function _isElement(node) {
    return node.nodeType === wysihtml5.ELEMENT_NODE;
  }

  function _hasClassName(element, className, classRegExp) {
    var classNames = (element.className || "").match(classRegExp) || [];
    if (!className) {
      return !!classNames.length;
    }
    return classNames[classNames.length - 1] === className;
  }

  function _hasStyle(element, cssStyle, styleRegExp) {
    var styles = (element.getAttribute('style') || "").match(styleRegExp) || [];
    if (!cssStyle) {
      return !!styles.length;
    }
    return styles[styles.length - 1] === cssStyle;
  }

  return function(node, matchingSet, levels, container) {
    var findByStyle = (matchingSet.cssStyle || matchingSet.styleRegExp),
        findByClass = (matchingSet.className || matchingSet.classRegExp);

    levels = levels || 50; // Go max 50 nodes upwards from current node

    // make the matching class regex from class name if omitted
    if (findByClass && !matchingSet.classRegExp) {
      matchingSet.classRegExp = new RegExp(matchingSet.className);
    }

    while (levels-- && node && node.nodeName !== "BODY" && (!container || node !== container)) {
      if (_isElement(node) && (!matchingSet.nodeName || _isSameNodeName(node.nodeName, matchingSet.nodeName)) &&
          (!findByStyle || _hasStyle(node, matchingSet.cssStyle, matchingSet.styleRegExp)) &&
          (!findByClass || _hasClassName(node, matchingSet.className, matchingSet.classRegExp))
      ) {
        return node;
      }
      node = node.parentNode;
    }
    return null;
  };
})();
;/**
 * Get element's style for a specific css property
 *
 * @param {Element} element The element on which to retrieve the style
 * @param {String} property The CSS property to retrieve ("float", "display", "text-align", ...)
 *
 * @example
 *    wysihtml5.dom.getStyle("display").from(document.body);
 *    // => "block"
 */
wysihtml5.dom.getStyle = (function() {
  var stylePropertyMapping = {
        "float": ("styleFloat" in document.createElement("div").style) ? "styleFloat" : "cssFloat"
      },
      REG_EXP_CAMELIZE = /\-[a-z]/g;

  function camelize(str) {
    return str.replace(REG_EXP_CAMELIZE, function(match) {
      return match.charAt(1).toUpperCase();
    });
  }

  return function(property) {
    return {
      from: function(element) {
        if (element.nodeType !== wysihtml5.ELEMENT_NODE) {
          return;
        }

        var doc               = element.ownerDocument,
            camelizedProperty = stylePropertyMapping[property] || camelize(property),
            style             = element.style,
            currentStyle      = element.currentStyle,
            styleValue        = style[camelizedProperty];
        if (styleValue) {
          return styleValue;
        }

        // currentStyle is no standard and only supported by Opera and IE but it has one important advantage over the standard-compliant
        // window.getComputedStyle, since it returns css property values in their original unit:
        // If you set an elements width to "50%", window.getComputedStyle will give you it's current width in px while currentStyle
        // gives you the original "50%".
        // Opera supports both, currentStyle and window.getComputedStyle, that's why checking for currentStyle should have higher prio
        if (currentStyle) {
          try {
            return currentStyle[camelizedProperty];
          } catch(e) {
            //ie will occasionally fail for unknown reasons. swallowing exception
          }
        }

        var win                 = doc.defaultView || doc.parentWindow,
            needsOverflowReset  = (property === "height" || property === "width") && element.nodeName === "TEXTAREA",
            originalOverflow,
            returnValue;

        if (win.getComputedStyle) {
          // Chrome and Safari both calculate a wrong width and height for textareas when they have scroll bars
          // therfore we remove and restore the scrollbar and calculate the value in between
          if (needsOverflowReset) {
            originalOverflow = style.overflow;
            style.overflow = "hidden";
          }
          returnValue = win.getComputedStyle(element, null).getPropertyValue(property);
          if (needsOverflowReset) {
            style.overflow = originalOverflow || "";
          }
          return returnValue;
        }
      }
    };
  };
})();
;wysihtml5.dom.getTextNodes = function(node, ingoreEmpty){
  var all = [];
  for (node=node.firstChild;node;node=node.nextSibling){
    if (node.nodeType == 3) {
      if (!ingoreEmpty || !(/^\s*$/).test(node.innerText || node.textContent)) {
        all.push(node);
      }
    } else {
      all = all.concat(wysihtml5.dom.getTextNodes(node, ingoreEmpty));
    }
  }
  return all;
};;/**
 * High performant way to check whether an element with a specific tag name is in the given document
 * Optimized for being heavily executed
 * Unleashes the power of live node lists
 *
 * @param {Object} doc The document object of the context where to check
 * @param {String} tagName Upper cased tag name
 * @example
 *    wysihtml5.dom.hasElementWithTagName(document, "IMG");
 */
wysihtml5.dom.hasElementWithTagName = (function() {
  var LIVE_CACHE          = {},
      DOCUMENT_IDENTIFIER = 1;

  function _getDocumentIdentifier(doc) {
    return doc._wysihtml5_identifier || (doc._wysihtml5_identifier = DOCUMENT_IDENTIFIER++);
  }

  return function(doc, tagName) {
    var key         = _getDocumentIdentifier(doc) + ":" + tagName,
        cacheEntry  = LIVE_CACHE[key];
    if (!cacheEntry) {
      cacheEntry = LIVE_CACHE[key] = doc.getElementsByTagName(tagName);
    }

    return cacheEntry.length > 0;
  };
})();
;/**
 * High performant way to check whether an element with a specific class name is in the given document
 * Optimized for being heavily executed
 * Unleashes the power of live node lists
 *
 * @param {Object} doc The document object of the context where to check
 * @param {String} tagName Upper cased tag name
 * @example
 *    wysihtml5.dom.hasElementWithClassName(document, "foobar");
 */
(function(wysihtml5) {
  var LIVE_CACHE          = {},
      DOCUMENT_IDENTIFIER = 1;

  function _getDocumentIdentifier(doc) {
    return doc._wysihtml5_identifier || (doc._wysihtml5_identifier = DOCUMENT_IDENTIFIER++);
  }

  wysihtml5.dom.hasElementWithClassName = function(doc, className) {
    // getElementsByClassName is not supported by IE<9
    // but is sometimes mocked via library code (which then doesn't return live node lists)
    if (!wysihtml5.browser.supportsNativeGetElementsByClassName()) {
      return !!doc.querySelector("." + className);
    }

    var key         = _getDocumentIdentifier(doc) + ":" + className,
        cacheEntry  = LIVE_CACHE[key];
    if (!cacheEntry) {
      cacheEntry = LIVE_CACHE[key] = doc.getElementsByClassName(className);
    }

    return cacheEntry.length > 0;
  };
})(wysihtml5);
;wysihtml5.dom.insert = function(elementToInsert) {
  return {
    after: function(element) {
      element.parentNode.insertBefore(elementToInsert, element.nextSibling);
    },

    before: function(element) {
      element.parentNode.insertBefore(elementToInsert, element);
    },

    into: function(element) {
      element.appendChild(elementToInsert);
    }
  };
};
;wysihtml5.dom.insertCSS = function(rules) {
  rules = rules.join("\n");

  return {
    into: function(doc) {
      var styleElement = doc.createElement("style");
      styleElement.type = "text/css";

      if (styleElement.styleSheet) {
        styleElement.styleSheet.cssText = rules;
      } else {
        styleElement.appendChild(doc.createTextNode(rules));
      }

      var link = doc.querySelector("head link");
      if (link) {
        link.parentNode.insertBefore(styleElement, link);
        return;
      } else {
        var head = doc.querySelector("head");
        if (head) {
          head.appendChild(styleElement);
        }
      }
    }
  };
};
;// TODO: Refactor dom tree traversing here
(function(wysihtml5) {
  wysihtml5.dom.lineBreaks = function(node) {

    function _isLineBreak(n) {
      return n.nodeName === "BR";
    }

    /**
     * Checks whether the elment causes a visual line break
     * (<br> or block elements)
     */
    function _isLineBreakOrBlockElement(element) {
      if (_isLineBreak(element)) {
        return true;
      }

      if (wysihtml5.dom.getStyle("display").from(element) === "block") {
        return true;
      }

      return false;
    }

    return {

      /* wysihtml5.dom.lineBreaks(element).add();
       *
       * Adds line breaks before and after the given node if the previous and next siblings
       * aren't already causing a visual line break (block element or <br>)
       */
      add: function(options) {
        var doc             = node.ownerDocument,
          nextSibling     = wysihtml5.dom.domNode(node).next({ignoreBlankTexts: true}),
          previousSibling = wysihtml5.dom.domNode(node).prev({ignoreBlankTexts: true});

        if (nextSibling && !_isLineBreakOrBlockElement(nextSibling)) {
          wysihtml5.dom.insert(doc.createElement("br")).after(node);
        }
        if (previousSibling && !_isLineBreakOrBlockElement(previousSibling)) {
          wysihtml5.dom.insert(doc.createElement("br")).before(node);
        }
      },

      /* wysihtml5.dom.lineBreaks(element).remove();
       *
       * Removes line breaks before and after the given node
       */
      remove: function(options) {
        var nextSibling     = wysihtml5.dom.domNode(node).next({ignoreBlankTexts: true}),
            previousSibling = wysihtml5.dom.domNode(node).prev({ignoreBlankTexts: true});

        if (nextSibling && _isLineBreak(nextSibling)) {
          nextSibling.parentNode.removeChild(nextSibling);
        }
        if (previousSibling && _isLineBreak(previousSibling)) {
          previousSibling.parentNode.removeChild(previousSibling);
        }
      }
    };
  };
})(wysihtml5);;/**
 * Method to set dom events
 *
 * @example
 *    wysihtml5.dom.observe(iframe.contentWindow.document.body, ["focus", "blur"], function() { ... });
 */
wysihtml5.dom.observe = function(element, eventNames, handler) {
  eventNames = typeof(eventNames) === "string" ? [eventNames] : eventNames;

  var handlerWrapper,
      eventName,
      i       = 0,
      length  = eventNames.length;

  for (; i<length; i++) {
    eventName = eventNames[i];
    if (element.addEventListener) {
      element.addEventListener(eventName, handler, false);
    } else {
      handlerWrapper = function(event) {
        if (!("target" in event)) {
          event.target = event.srcElement;
        }
        event.preventDefault = event.preventDefault || function() {
          this.returnValue = false;
        };
        event.stopPropagation = event.stopPropagation || function() {
          this.cancelBubble = true;
        };
        handler.call(element, event);
      };
      element.attachEvent("on" + eventName, handlerWrapper);
    }
  }

  return {
    stop: function() {
      var eventName,
          i       = 0,
          length  = eventNames.length;
      for (; i<length; i++) {
        eventName = eventNames[i];
        if (element.removeEventListener) {
          element.removeEventListener(eventName, handler, false);
        } else {
          element.detachEvent("on" + eventName, handlerWrapper);
        }
      }
    }
  };
};
;/**
 * HTML Sanitizer
 * Rewrites the HTML based on given rules
 *
 * @param {Element|String} elementOrHtml HTML String to be sanitized OR element whose content should be sanitized
 * @param {Object} [rules] List of rules for rewriting the HTML, if there's no rule for an element it will
 *    be converted to a "span". Each rule is a key/value pair where key is the tag to convert, and value the
 *    desired substitution.
 * @param {Object} context Document object in which to parse the html, needed to sandbox the parsing
 *
 * @return {Element|String} Depends on the elementOrHtml parameter. When html then the sanitized html as string elsewise the element.
 *
 * @example
 *    var userHTML = '<div id="foo" onclick="alert(1);"><p><font color="red">foo</font><script>alert(1);</script></p></div>';
 *    wysihtml5.dom.parse(userHTML, {
 *      tags {
 *        p:      "div",      // Rename p tags to div tags
 *        font:   "span"      // Rename font tags to span tags
 *        div:    true,       // Keep them, also possible (same result when passing: "div" or true)
 *        script: undefined   // Remove script elements
 *      }
 *    });
 *    // => <div><div><span>foo bar</span></div></div>
 *
 *    var userHTML = '<table><tbody><tr><td>I'm a table!</td></tr></tbody></table>';
 *    wysihtml5.dom.parse(userHTML);
 *    // => '<span><span><span><span>I'm a table!</span></span></span></span>'
 *
 *    var userHTML = '<div>foobar<br>foobar</div>';
 *    wysihtml5.dom.parse(userHTML, {
 *      tags: {
 *        div: undefined,
 *        br:  true
 *      }
 *    });
 *    // => ''
 *
 *    var userHTML = '<div class="red">foo</div><div class="pink">bar</div>';
 *    wysihtml5.dom.parse(userHTML, {
 *      classes: {
 *        red:    1,
 *        green:  1
 *      },
 *      tags: {
 *        div: {
 *          rename_tag:     "p"
 *        }
 *      }
 *    });
 *    // => '<p class="red">foo</p><p>bar</p>'
 */

wysihtml5.dom.parse = function(elementOrHtml_current, config_current) {
  /* TODO: Currently escaped module pattern as otherwise folloowing default swill be shared among multiple editors.
   * Refactor whole code as this method while workind is kind of awkward too */

  /**
   * It's not possible to use a XMLParser/DOMParser as HTML5 is not always well-formed XML
   * new DOMParser().parseFromString('<img src="foo.gif">') will cause a parseError since the
   * node isn't closed
   *
   * Therefore we've to use the browser's ordinary HTML parser invoked by setting innerHTML.
   */
  var NODE_TYPE_MAPPING = {
        "1": _handleElement,
        "3": _handleText,
        "8": _handleComment
      },
      // Rename unknown tags to this
      DEFAULT_NODE_NAME   = "span",
      WHITE_SPACE_REG_EXP = /\s+/,
      defaultRules        = { tags: {}, classes: {} },
      currentRules        = {},
      blockElements       = ["ADDRESS" ,"BLOCKQUOTE" ,"CENTER" ,"DIR" ,"DIV" ,"DL" ,"FIELDSET" ,
                             "FORM", "H1" ,"H2" ,"H3" ,"H4" ,"H5" ,"H6" ,"ISINDEX" ,"MENU",
                             "NOFRAMES", "NOSCRIPT" ,"OL" ,"P" ,"PRE","TABLE", "UL"];

  /**
   * Iterates over all childs of the element, recreates them, appends them into a document fragment
   * which later replaces the entire body content
   */
   function parse(elementOrHtml, config) {
    wysihtml5.lang.object(currentRules).merge(defaultRules).merge(config.rules).get();

    var context       = config.context || elementOrHtml.ownerDocument || document,
        fragment      = context.createDocumentFragment(),
        isString      = typeof(elementOrHtml) === "string",
        clearInternals = false,
        element,
        newNode,
        firstChild;

    if (config.clearInternals === true) {
      clearInternals = true;
    }

    if (isString) {
      element = wysihtml5.dom.getAsDom(elementOrHtml, context);
    } else {
      element = elementOrHtml;
    }

    if (currentRules.selectors) {
      _applySelectorRules(element, currentRules.selectors);
    }

    while (element.firstChild) {
      firstChild = element.firstChild;
      newNode = _convert(firstChild, config.cleanUp, clearInternals, config.uneditableClass);
      if (newNode) {
        fragment.appendChild(newNode);
      }
      if (firstChild !== newNode) {
        element.removeChild(firstChild);
      }
    }

    if (config.unjoinNbsps) {
      // replace joined non-breakable spaces with unjoined
      var txtnodes = wysihtml5.dom.getTextNodes(fragment);
      for (var n = txtnodes.length; n--;) {
        txtnodes[n].nodeValue = txtnodes[n].nodeValue.replace(/([\S\u00A0])\u00A0/gi, "$1 ");
      }
    }

    // Clear element contents
    element.innerHTML = "";

    // Insert new DOM tree
    element.appendChild(fragment);

    return isString ? wysihtml5.quirks.getCorrectInnerHTML(element) : element;
  }

  function _convert(oldNode, cleanUp, clearInternals, uneditableClass) {
    var oldNodeType     = oldNode.nodeType,
        oldChilds       = oldNode.childNodes,
        oldChildsLength = oldChilds.length,
        method          = NODE_TYPE_MAPPING[oldNodeType],
        i               = 0,
        fragment,
        newNode,
        newChild,
        nodeDisplay;

    // Passes directly elemets with uneditable class
    if (uneditableClass && oldNodeType === 1 && wysihtml5.dom.hasClass(oldNode, uneditableClass)) {
        return oldNode;
    }

    newNode = method && method(oldNode, clearInternals);

    // Remove or unwrap node in case of return value null or false
    if (!newNode) {
        if (newNode === false) {
            // false defines that tag should be removed but contents should remain (unwrap)
            fragment = oldNode.ownerDocument.createDocumentFragment();

            for (i = oldChildsLength; i--;) {
              if (oldChilds[i]) {
                newChild = _convert(oldChilds[i], cleanUp, clearInternals, uneditableClass);
                if (newChild) {
                  if (oldChilds[i] === newChild) {
                    i--;
                  }
                  fragment.insertBefore(newChild, fragment.firstChild);
                }
              }
            }

            nodeDisplay = wysihtml5.dom.getStyle("display").from(oldNode);

            if (nodeDisplay === '') {
              // Handle display style when element not in dom
              nodeDisplay = wysihtml5.lang.array(blockElements).contains(oldNode.tagName) ? "block" : "";
            }
            if (wysihtml5.lang.array(["block", "flex", "table"]).contains(nodeDisplay)) {
              fragment.appendChild(oldNode.ownerDocument.createElement("br"));
            }

            // TODO: try to minimize surplus spaces
            if (wysihtml5.lang.array([
                "div", "pre", "p",
                "table", "td", "th",
                "ul", "ol", "li",
                "dd", "dl",
                "footer", "header", "section",
                "h1", "h2", "h3", "h4", "h5", "h6"
            ]).contains(oldNode.nodeName.toLowerCase()) && oldNode.parentNode.lastChild !== oldNode) {
                // add space at first when unwraping non-textflow elements
                if (!oldNode.nextSibling || oldNode.nextSibling.nodeType !== 3 || !(/^\s/).test(oldNode.nextSibling.nodeValue)) {
                  fragment.appendChild(oldNode.ownerDocument.createTextNode(" "));
                }
            }

            if (fragment.normalize) {
              fragment.normalize();
            }
            return fragment;
        } else {
          // Remove
          return null;
        }
    }

    // Converts all childnodes
    for (i=0; i<oldChildsLength; i++) {
      if (oldChilds[i]) {
        newChild = _convert(oldChilds[i], cleanUp, clearInternals, uneditableClass);
        if (newChild) {
          if (oldChilds[i] === newChild) {
            i--;
          }
          newNode.appendChild(newChild);
        }
      }
    }

    // Cleanup senseless <span> elements
    if (cleanUp &&
        newNode.nodeName.toLowerCase() === DEFAULT_NODE_NAME &&
        (!newNode.childNodes.length ||
         ((/^\s*$/gi).test(newNode.innerHTML) && (clearInternals || (oldNode.className !== "_wysihtml5-temp-placeholder" && oldNode.className !== "rangySelectionBoundary"))) ||
         !newNode.attributes.length)
        ) {
      fragment = newNode.ownerDocument.createDocumentFragment();
      while (newNode.firstChild) {
        fragment.appendChild(newNode.firstChild);
      }
      if (fragment.normalize) {
        fragment.normalize();
      }
      return fragment;
    }

    if (newNode.normalize) {
      newNode.normalize();
    }
    return newNode;
  }

  function _applySelectorRules (element, selectorRules) {
    var sel, method, els;

    for (sel in selectorRules) {
      if (selectorRules.hasOwnProperty(sel)) {
        if (wysihtml5.lang.object(selectorRules[sel]).isFunction()) {
          method = selectorRules[sel];
        } else if (typeof(selectorRules[sel]) === "string" && elementHandlingMethods[selectorRules[sel]]) {
          method = elementHandlingMethods[selectorRules[sel]];
        }
        els = element.querySelectorAll(sel);
        for (var i = els.length; i--;) {
          method(els[i]);
        }
      }
    }
  }

  function _handleElement(oldNode, clearInternals) {
    var rule,
        newNode,
        tagRules    = currentRules.tags,
        nodeName    = oldNode.nodeName.toLowerCase(),
        scopeName   = oldNode.scopeName,
        renameTag;

    /**
     * We already parsed that element
     * ignore it! (yes, this sometimes happens in IE8 when the html is invalid)
     */
    if (oldNode._wysihtml5) {
      return null;
    }
    oldNode._wysihtml5 = 1;

    if (oldNode.className === "wysihtml5-temp") {
      return null;
    }

    /**
     * IE is the only browser who doesn't include the namespace in the
     * nodeName, that's why we have to prepend it by ourselves
     * scopeName is a proprietary IE feature
     * read more here http://msdn.microsoft.com/en-us/library/ms534388(v=vs.85).aspx
     */
    if (scopeName && scopeName != "HTML") {
      nodeName = scopeName + ":" + nodeName;
    }
    /**
     * Repair node
     * IE is a bit bitchy when it comes to invalid nested markup which includes unclosed tags
     * A <p> doesn't need to be closed according HTML4-5 spec, we simply replace it with a <div> to preserve its content and layout
     */
    if ("outerHTML" in oldNode) {
      if (!wysihtml5.browser.autoClosesUnclosedTags() &&
          oldNode.nodeName === "P" &&
          oldNode.outerHTML.slice(-4).toLowerCase() !== "</p>") {
        nodeName = "div";
      }
    }

    if (nodeName in tagRules) {
      rule = tagRules[nodeName];
      if (!rule || rule.remove) {
        return null;
      } else if (rule.unwrap) {
        return false;
      }
      rule = typeof(rule) === "string" ? { rename_tag: rule } : rule;
    } else if (oldNode.firstChild) {
      rule = { rename_tag: DEFAULT_NODE_NAME };
    } else {
      // Remove empty unknown elements
      return null;
    }

    // tests if type condition is met or node should be removed/unwrapped/renamed
    if (rule.one_of_type && !_testTypes(oldNode, currentRules, rule.one_of_type, clearInternals)) {
      if (rule.remove_action) {
        if (rule.remove_action === "unwrap") {
          return false;
        } else if (rule.remove_action === "rename") {
          renameTag = rule.remove_action_rename_to || DEFAULT_NODE_NAME;
        } else {
          return null;
        }
      } else {
        return null;
      }
    }

    newNode = oldNode.ownerDocument.createElement(renameTag || rule.rename_tag || nodeName);
    _handleAttributes(oldNode, newNode, rule, clearInternals);
    _handleStyles(oldNode, newNode, rule);

    oldNode = null;

    if (newNode.normalize) { newNode.normalize(); }
    return newNode;
  }

  function _testTypes(oldNode, rules, types, clearInternals) {
    var definition, type;

    // do not interfere with placeholder span or pasting caret position is not maintained
    if (oldNode.nodeName === "SPAN" && !clearInternals && (oldNode.className === "_wysihtml5-temp-placeholder" || oldNode.className === "rangySelectionBoundary")) {
      return true;
    }

    for (type in types) {
      if (types.hasOwnProperty(type) && rules.type_definitions && rules.type_definitions[type]) {
        definition = rules.type_definitions[type];
        if (_testType(oldNode, definition)) {
          return true;
        }
      }
    }
    return false;
  }

  function array_contains(a, obj) {
      var i = a.length;
      while (i--) {
         if (a[i] === obj) {
             return true;
         }
      }
      return false;
  }

  function _testType(oldNode, definition) {

    var nodeClasses = oldNode.getAttribute("class"),
        nodeStyles =  oldNode.getAttribute("style"),
        classesLength, s, s_corrected, a, attr, currentClass, styleProp;

    // test for methods
    if (definition.methods) {
      for (var m in definition.methods) {
        if (definition.methods.hasOwnProperty(m) && typeCeckMethods[m]) {

          if (typeCeckMethods[m](oldNode)) {
            return true;
          }
        }
      }
    }

    // test for classes, if one found return true
    if (nodeClasses && definition.classes) {
      nodeClasses = nodeClasses.replace(/^\s+/g, '').replace(/\s+$/g, '').split(WHITE_SPACE_REG_EXP);
      classesLength = nodeClasses.length;
      for (var i = 0; i < classesLength; i++) {
        if (definition.classes[nodeClasses[i]]) {
          return true;
        }
      }
    }

    // test for styles, if one found return true
    if (nodeStyles && definition.styles) {

      nodeStyles = nodeStyles.split(';');
      for (s in definition.styles) {
        if (definition.styles.hasOwnProperty(s)) {
          for (var sp = nodeStyles.length; sp--;) {
            styleProp = nodeStyles[sp].split(':');

            if (styleProp[0].replace(/\s/g, '').toLowerCase() === s) {
              if (definition.styles[s] === true || definition.styles[s] === 1 || wysihtml5.lang.array(definition.styles[s]).contains(styleProp[1].replace(/\s/g, '').toLowerCase()) ) {
                return true;
              }
            }
          }
        }
      }
    }

    // test for attributes in general against regex match
    if (definition.attrs) {
        for (a in definition.attrs) {
            if (definition.attrs.hasOwnProperty(a)) {
                attr = wysihtml5.dom.getAttribute(oldNode, a);
                if (typeof(attr) === "string") {
                    if (attr.search(definition.attrs[a]) > -1) {
                        return true;
                    }
                }
            }
        }
    }
    return false;
  }

  function _handleStyles(oldNode, newNode, rule) {
    var s, v;
    if(rule && rule.keep_styles) {
      for (s in rule.keep_styles) {
        if (rule.keep_styles.hasOwnProperty(s)) {
          v = (s === "float") ? oldNode.style.styleFloat || oldNode.style.cssFloat : oldNode.style[s];
          // value can be regex and if so should match or style skipped
          if (rule.keep_styles[s] instanceof RegExp && !(rule.keep_styles[s].test(v))) {
            continue;
          }
          if (s === "float") {
            // IE compability
            newNode.style[(oldNode.style.styleFloat) ? 'styleFloat': 'cssFloat'] = v;
           } else if (oldNode.style[s]) {
             newNode.style[s] = v;
           }
        }
      }
    }
  };

  function _getAttributesBeginningWith(beginning, attributes) {
    var returnAttributes = [];
    for (var attr in attributes) {
      if (attributes.hasOwnProperty(attr) && attr.indexOf(beginning) === 0) {
        returnAttributes.push(attr);
      }
    }
    return returnAttributes;
  }

  function _checkAttribute(attributeName, attributeValue, methodName, nodeName) {
    var method = attributeCheckMethods[methodName],
        newAttributeValue;

    if (method) {
      if (attributeValue || (attributeName === "alt" && nodeName == "IMG")) {
        newAttributeValue = method(attributeValue);
        if (typeof(newAttributeValue) === "string") {
          return newAttributeValue;
        }
      }
    }

    return false;
  }

  function _checkAttributes(oldNode, local_attributes) {
    var globalAttributes  = wysihtml5.lang.object(currentRules.attributes || {}).clone(), // global values for check/convert values of attributes
        checkAttributes   = wysihtml5.lang.object(globalAttributes).merge( wysihtml5.lang.object(local_attributes || {}).clone()).get(),
        attributes        = {},
        oldAttributes     = wysihtml5.dom.getAttributes(oldNode),
        attributeName, newValue, matchingAttributes;

    for (attributeName in checkAttributes) {
      if ((/\*$/).test(attributeName)) {

        matchingAttributes = _getAttributesBeginningWith(attributeName.slice(0,-1), oldAttributes);
        for (var i = 0, imax = matchingAttributes.length; i < imax; i++) {

          newValue = _checkAttribute(matchingAttributes[i], oldAttributes[matchingAttributes[i]], checkAttributes[attributeName], oldNode.nodeName);
          if (newValue !== false) {
            attributes[matchingAttributes[i]] = newValue;
          }
        }
      } else {
        newValue = _checkAttribute(attributeName, oldAttributes[attributeName], checkAttributes[attributeName], oldNode.nodeName);
        if (newValue !== false) {
          attributes[attributeName] = newValue;
        }
      }
    }

    return attributes;
  }

  // TODO: refactor. Too long to read
  function _handleAttributes(oldNode, newNode, rule, clearInternals) {
    var attributes          = {},                         // fresh new set of attributes to set on newNode
        setClass            = rule.set_class,             // classes to set
        addClass            = rule.add_class,             // add classes based on existing attributes
        addStyle            = rule.add_style,             // add styles based on existing attributes
        setAttributes       = rule.set_attributes,        // attributes to set on the current node
        allowedClasses      = currentRules.classes,
        i                   = 0,
        classes             = [],
        styles              = [],
        newClasses          = [],
        oldClasses          = [],
        classesLength,
        newClassesLength,
        currentClass,
        newClass,
        attributeName,
        method;

    if (setAttributes) {
      attributes = wysihtml5.lang.object(setAttributes).clone();
    }

    // check/convert values of attributes
    attributes = wysihtml5.lang.object(attributes).merge(_checkAttributes(oldNode,  rule.check_attributes)).get();

    if (setClass) {
      classes.push(setClass);
    }

    if (addClass) {
      for (attributeName in addClass) {
        method = addClassMethods[addClass[attributeName]];
        if (!method) {
          continue;
        }
        newClass = method(wysihtml5.dom.getAttribute(oldNode, attributeName));
        if (typeof(newClass) === "string") {
          classes.push(newClass);
        }
      }
    }

    if (addStyle) {
      for (attributeName in addStyle) {
        method = addStyleMethods[addStyle[attributeName]];
        if (!method) {
          continue;
        }

        newStyle = method(wysihtml5.dom.getAttribute(oldNode, attributeName));
        if (typeof(newStyle) === "string") {
          styles.push(newStyle);
        }
      }
    }


    if (typeof(allowedClasses) === "string" && allowedClasses === "any" && oldNode.getAttribute("class")) {
      if (currentRules.classes_blacklist) {
        oldClasses = oldNode.getAttribute("class");
        if (oldClasses) {
          classes = classes.concat(oldClasses.split(WHITE_SPACE_REG_EXP));
        }

        classesLength = classes.length;
        for (; i<classesLength; i++) {
          currentClass = classes[i];
          if (!currentRules.classes_blacklist[currentClass]) {
            newClasses.push(currentClass);
          }
        }

        if (newClasses.length) {
          attributes["class"] = wysihtml5.lang.array(newClasses).unique().join(" ");
        }

      } else {
        attributes["class"] = oldNode.getAttribute("class");
      }
    } else {
      // make sure that wysihtml5 temp class doesn't get stripped out
      if (!clearInternals) {
        allowedClasses["_wysihtml5-temp-placeholder"] = 1;
        allowedClasses["_rangySelectionBoundary"] = 1;
        allowedClasses["wysiwyg-tmp-selected-cell"] = 1;
      }

      // add old classes last
      oldClasses = oldNode.getAttribute("class");
      if (oldClasses) {
        classes = classes.concat(oldClasses.split(WHITE_SPACE_REG_EXP));
      }
      classesLength = classes.length;
      for (; i<classesLength; i++) {
        currentClass = classes[i];
        if (allowedClasses[currentClass]) {
          newClasses.push(currentClass);
        }
      }

      if (newClasses.length) {
        attributes["class"] = wysihtml5.lang.array(newClasses).unique().join(" ");
      }
    }

    // remove table selection class if present
    if (attributes["class"] && clearInternals) {
      attributes["class"] = attributes["class"].replace("wysiwyg-tmp-selected-cell", "");
      if ((/^\s*$/g).test(attributes["class"])) {
        delete attributes["class"];
      }
    }

    if (styles.length) {
      attributes["style"] = wysihtml5.lang.array(styles).unique().join(" ");
    }

    // set attributes on newNode
    for (attributeName in attributes) {
      // Setting attributes can cause a js error in IE under certain circumstances
      // eg. on a <img> under https when it's new attribute value is non-https
      // TODO: Investigate this further and check for smarter handling
      try {
        newNode.setAttribute(attributeName, attributes[attributeName]);
      } catch(e) {}
    }

    // IE8 sometimes loses the width/height attributes when those are set before the "src"
    // so we make sure to set them again
    if (attributes.src) {
      if (typeof(attributes.width) !== "undefined") {
        newNode.setAttribute("width", attributes.width);
      }
      if (typeof(attributes.height) !== "undefined") {
        newNode.setAttribute("height", attributes.height);
      }
    }
  }

  function _handleText(oldNode) {
    var nextSibling = oldNode.nextSibling;
    if (nextSibling && nextSibling.nodeType === wysihtml5.TEXT_NODE) {
      // Concatenate text nodes
      nextSibling.data = oldNode.data.replace(wysihtml5.INVISIBLE_SPACE_REG_EXP, "") + nextSibling.data.replace(wysihtml5.INVISIBLE_SPACE_REG_EXP, "");
    } else {
      // \uFEFF = wysihtml5.INVISIBLE_SPACE (used as a hack in certain rich text editing situations)
      var data = oldNode.data.replace(wysihtml5.INVISIBLE_SPACE_REG_EXP, "");
      return oldNode.ownerDocument.createTextNode(data);
    }
  }

  function _handleComment(oldNode) {
    if (currentRules.comments) {
      return oldNode.ownerDocument.createComment(oldNode.nodeValue);
    }
  }

  // ------------ attribute checks ------------ \\
  var attributeCheckMethods = {
    url: (function() {
      var REG_EXP = /^https?:\/\//i;
      return function(attributeValue) {
        if (!attributeValue || !attributeValue.match(REG_EXP)) {
          return null;
        }
        return attributeValue.replace(REG_EXP, function(match) {
          return match.toLowerCase();
        });
      };
    })(),

    src: (function() {
      var REG_EXP = /^(\/|https?:\/\/)/i;
      return function(attributeValue) {
        if (!attributeValue || !attributeValue.match(REG_EXP)) {
          return null;
        }
        return attributeValue.replace(REG_EXP, function(match) {
          return match.toLowerCase();
        });
      };
    })(),

    href: (function() {
      var REG_EXP = /^(#|\/|https?:\/\/|mailto:)/i;
      return function(attributeValue) {
        if (!attributeValue || !attributeValue.match(REG_EXP)) {
          return null;
        }
        return attributeValue.replace(REG_EXP, function(match) {
          return match.toLowerCase();
        });
      };
    })(),

    alt: (function() {
      var REG_EXP = /[^ a-z0-9_\-]/gi;
      return function(attributeValue) {
        if (!attributeValue) {
          return "";
        }
        return attributeValue.replace(REG_EXP, "");
      };
    })(),

    numbers: (function() {
      var REG_EXP = /\D/g;
      return function(attributeValue) {
        attributeValue = (attributeValue || "").replace(REG_EXP, "");
        return attributeValue || null;
      };
    })(),

    any: (function() {
      return function(attributeValue) {
        return attributeValue;
      };
    })()
  };

  // ------------ style converter (converts an html attribute to a style) ------------ \\
  var addStyleMethods = {
    align_text: (function() {
      var mapping = {
        left:     "text-align: left;",
        right:    "text-align: right;",
        center:   "text-align: center;"
      };
      return function(attributeValue) {
        return mapping[String(attributeValue).toLowerCase()];
      };
    })(),
  };

  // ------------ class converter (converts an html attribute to a class name) ------------ \\
  var addClassMethods = {
    align_img: (function() {
      var mapping = {
        left:   "wysiwyg-float-left",
        right:  "wysiwyg-float-right"
      };
      return function(attributeValue) {
        return mapping[String(attributeValue).toLowerCase()];
      };
    })(),

    align_text: (function() {
      var mapping = {
        left:     "wysiwyg-text-align-left",
        right:    "wysiwyg-text-align-right",
        center:   "wysiwyg-text-align-center",
        justify:  "wysiwyg-text-align-justify"
      };
      return function(attributeValue) {
        return mapping[String(attributeValue).toLowerCase()];
      };
    })(),

    clear_br: (function() {
      var mapping = {
        left:   "wysiwyg-clear-left",
        right:  "wysiwyg-clear-right",
        both:   "wysiwyg-clear-both",
        all:    "wysiwyg-clear-both"
      };
      return function(attributeValue) {
        return mapping[String(attributeValue).toLowerCase()];
      };
    })(),

    size_font: (function() {
      var mapping = {
        "1": "wysiwyg-font-size-xx-small",
        "2": "wysiwyg-font-size-small",
        "3": "wysiwyg-font-size-medium",
        "4": "wysiwyg-font-size-large",
        "5": "wysiwyg-font-size-x-large",
        "6": "wysiwyg-font-size-xx-large",
        "7": "wysiwyg-font-size-xx-large",
        "-": "wysiwyg-font-size-smaller",
        "+": "wysiwyg-font-size-larger"
      };
      return function(attributeValue) {
        return mapping[String(attributeValue).charAt(0)];
      };
    })()
  };

  // checks if element is possibly visible
  var typeCeckMethods = {
    has_visible_contet: (function() {
      var txt,
          isVisible = false,
          visibleElements = ['img', 'video', 'picture', 'br', 'script', 'noscript',
                             'style', 'table', 'iframe', 'object', 'embed', 'audio',
                             'svg', 'input', 'button', 'select','textarea', 'canvas'];

      return function(el) {

        // has visible innertext. so is visible
        txt = (el.innerText || el.textContent).replace(/\s/g, '');
        if (txt && txt.length > 0) {
          return true;
        }

        // matches list of visible dimensioned elements
        for (var i = visibleElements.length; i--;) {
          if (el.querySelector(visibleElements[i])) {
            return true;
          }
        }

        // try to measure dimesions in last resort. (can find only of elements in dom)
        if (el.offsetWidth && el.offsetWidth > 0 && el.offsetHeight && el.offsetHeight > 0) {
          return true;
        }

        return false;
      };
    })()
  };

  var elementHandlingMethods = {
    unwrap: function (element) {
      wysihtml5.dom.unwrap(element);
    },

    remove: function (element) {
      element.parentNode.removeChild(element);
    }
  };

  return parse(elementOrHtml_current, config_current);
};
;/**
 * Checks for empty text node childs and removes them
 *
 * @param {Element} node The element in which to cleanup
 * @example
 *    wysihtml5.dom.removeEmptyTextNodes(element);
 */
wysihtml5.dom.removeEmptyTextNodes = function(node) {
  var childNode,
      childNodes        = wysihtml5.lang.array(node.childNodes).get(),
      childNodesLength  = childNodes.length,
      i                 = 0;
  for (; i<childNodesLength; i++) {
    childNode = childNodes[i];
    if (childNode.nodeType === wysihtml5.TEXT_NODE && childNode.data === "") {
      childNode.parentNode.removeChild(childNode);
    }
  }
};
;/**
 * Renames an element (eg. a <div> to a <p>) and keeps its childs
 *
 * @param {Element} element The list element which should be renamed
 * @param {Element} newNodeName The desired tag name
 *
 * @example
 *    <!-- Assume the following dom: -->
 *    <ul id="list">
 *      <li>eminem</li>
 *      <li>dr. dre</li>
 *      <li>50 Cent</li>
 *    </ul>
 *
 *    <script>
 *      wysihtml5.dom.renameElement(document.getElementById("list"), "ol");
 *    </script>
 *
 *    <!-- Will result in: -->
 *    <ol>
 *      <li>eminem</li>
 *      <li>dr. dre</li>
 *      <li>50 Cent</li>
 *    </ol>
 */
wysihtml5.dom.renameElement = function(element, newNodeName) {
  var newElement = element.ownerDocument.createElement(newNodeName),
      firstChild;
  while (firstChild = element.firstChild) {
    newElement.appendChild(firstChild);
  }
  wysihtml5.dom.copyAttributes(["align", "className"]).from(element).to(newElement);
  element.parentNode.replaceChild(newElement, element);
  return newElement;
};
;/**
 * Takes an element, removes it and replaces it with it's childs
 *
 * @param {Object} node The node which to replace with it's child nodes
 * @example
 *    <div id="foo">
 *      <span>hello</span>
 *    </div>
 *    <script>
 *      // Remove #foo and replace with it's children
 *      wysihtml5.dom.replaceWithChildNodes(document.getElementById("foo"));
 *    </script>
 */
wysihtml5.dom.replaceWithChildNodes = function(node) {
  if (!node.parentNode) {
    return;
  }

  if (!node.firstChild) {
    node.parentNode.removeChild(node);
    return;
  }

  var fragment = node.ownerDocument.createDocumentFragment();
  while (node.firstChild) {
    fragment.appendChild(node.firstChild);
  }
  node.parentNode.replaceChild(fragment, node);
  node = fragment = null;
};
;/**
 * Unwraps an unordered/ordered list
 *
 * @param {Element} element The list element which should be unwrapped
 *
 * @example
 *    <!-- Assume the following dom: -->
 *    <ul id="list">
 *      <li>eminem</li>
 *      <li>dr. dre</li>
 *      <li>50 Cent</li>
 *    </ul>
 *
 *    <script>
 *      wysihtml5.dom.resolveList(document.getElementById("list"));
 *    </script>
 *
 *    <!-- Will result in: -->
 *    eminem<br>
 *    dr. dre<br>
 *    50 Cent<br>
 */
(function(dom) {
  function _isBlockElement(node) {
    return dom.getStyle("display").from(node) === "block";
  }

  function _isLineBreak(node) {
    return node.nodeName === "BR";
  }

  function _appendLineBreak(element) {
    var lineBreak = element.ownerDocument.createElement("br");
    element.appendChild(lineBreak);
  }

  function resolveList(list, useLineBreaks) {
    if (!list.nodeName.match(/^(MENU|UL|OL)$/)) {
      return;
    }

    var doc             = list.ownerDocument,
        fragment        = doc.createDocumentFragment(),
        previousSibling = wysihtml5.dom.domNode(list).prev({ignoreBlankTexts: true}),
        firstChild,
        lastChild,
        isLastChild,
        shouldAppendLineBreak,
        paragraph,
        listItem;

    if (useLineBreaks) {
      // Insert line break if list is after a non-block element
      if (previousSibling && !_isBlockElement(previousSibling) && !_isLineBreak(previousSibling)) {
        _appendLineBreak(fragment);
      }

      while (listItem = (list.firstElementChild || list.firstChild)) {
        lastChild = listItem.lastChild;
        while (firstChild = listItem.firstChild) {
          isLastChild           = firstChild === lastChild;
          // This needs to be done before appending it to the fragment, as it otherwise will lose style information
          shouldAppendLineBreak = isLastChild && !_isBlockElement(firstChild) && !_isLineBreak(firstChild);
          fragment.appendChild(firstChild);
          if (shouldAppendLineBreak) {
            _appendLineBreak(fragment);
          }
        }

        listItem.parentNode.removeChild(listItem);
      }
    } else {
      while (listItem = (list.firstElementChild || list.firstChild)) {
        if (listItem.querySelector && listItem.querySelector("div, p, ul, ol, menu, blockquote, h1, h2, h3, h4, h5, h6")) {
          while (firstChild = listItem.firstChild) {
            fragment.appendChild(firstChild);
          }
        } else {
          paragraph = doc.createElement("p");
          while (firstChild = listItem.firstChild) {
            paragraph.appendChild(firstChild);
          }
          fragment.appendChild(paragraph);
        }
        listItem.parentNode.removeChild(listItem);
      }
    }

    list.parentNode.replaceChild(fragment, list);
  }

  dom.resolveList = resolveList;
})(wysihtml5.dom);
;/**
 * Sandbox for executing javascript, parsing css styles and doing dom operations in a secure way
 *
 * Browser Compatibility:
 *  - Secure in MSIE 6+, but only when the user hasn't made changes to his security level "restricted"
 *  - Partially secure in other browsers (Firefox, Opera, Safari, Chrome, ...)
 *
 * Please note that this class can't benefit from the HTML5 sandbox attribute for the following reasons:
 *    - sandboxing doesn't work correctly with inlined content (src="javascript:'<html>...</html>'")
 *    - sandboxing of physical documents causes that the dom isn't accessible anymore from the outside (iframe.contentWindow, ...)
 *    - setting the "allow-same-origin" flag would fix that, but then still javascript and dom events refuse to fire
 *    - therefore the "allow-scripts" flag is needed, which then would deactivate any security, as the js executed inside the iframe
 *      can do anything as if the sandbox attribute wasn't set
 *
 * @param {Function} [readyCallback] Method that gets invoked when the sandbox is ready
 * @param {Object} [config] Optional parameters
 *
 * @example
 *    new wysihtml5.dom.Sandbox(function(sandbox) {
 *      sandbox.getWindow().document.body.innerHTML = '<img src=foo.gif onerror="alert(document.cookie)">';
 *    });
 */
(function(wysihtml5) {
  var /**
       * Default configuration
       */
      doc                 = document,
      /**
       * Properties to unset/protect on the window object
       */
      windowProperties    = [
        "parent", "top", "opener", "frameElement", "frames",
        "localStorage", "globalStorage", "sessionStorage", "indexedDB"
      ],
      /**
       * Properties on the window object which are set to an empty function
       */
      windowProperties2   = [
        "open", "close", "openDialog", "showModalDialog",
        "alert", "confirm", "prompt",
        "openDatabase", "postMessage",
        "XMLHttpRequest", "XDomainRequest"
      ],
      /**
       * Properties to unset/protect on the document object
       */
      documentProperties  = [
        "referrer",
        "write", "open", "close"
      ];

  wysihtml5.dom.Sandbox = Base.extend(
    /** @scope wysihtml5.dom.Sandbox.prototype */ {

    constructor: function(readyCallback, config) {
      this.callback = readyCallback || wysihtml5.EMPTY_FUNCTION;
      this.config   = wysihtml5.lang.object({}).merge(config).get();
      this.editableArea   = this._createIframe();
    },

    insertInto: function(element) {
      if (typeof(element) === "string") {
        element = doc.getElementById(element);
      }

      element.appendChild(this.editableArea);
    },

    getIframe: function() {
      return this.editableArea;
    },

    getWindow: function() {
      this._readyError();
    },

    getDocument: function() {
      this._readyError();
    },

    destroy: function() {
      var iframe = this.getIframe();
      iframe.parentNode.removeChild(iframe);
    },

    _readyError: function() {
      throw new Error("wysihtml5.Sandbox: Sandbox iframe isn't loaded yet");
    },

    /**
     * Creates the sandbox iframe
     *
     * Some important notes:
     *  - We can't use HTML5 sandbox for now:
     *    setting it causes that the iframe's dom can't be accessed from the outside
     *    Therefore we need to set the "allow-same-origin" flag which enables accessing the iframe's dom
     *    But then there's another problem, DOM events (focus, blur, change, keypress, ...) aren't fired.
     *    In order to make this happen we need to set the "allow-scripts" flag.
     *    A combination of allow-scripts and allow-same-origin is almost the same as setting no sandbox attribute at all.
     *  - Chrome & Safari, doesn't seem to support sandboxing correctly when the iframe's html is inlined (no physical document)
     *  - IE needs to have the security="restricted" attribute set before the iframe is
     *    inserted into the dom tree
     *  - Believe it or not but in IE "security" in document.createElement("iframe") is false, even
     *    though it supports it
     *  - When an iframe has security="restricted", in IE eval() & execScript() don't work anymore
     *  - IE doesn't fire the onload event when the content is inlined in the src attribute, therefore we rely
     *    on the onreadystatechange event
     */
    _createIframe: function() {
      var that   = this,
          iframe = doc.createElement("iframe");
      iframe.className = "wysihtml5-sandbox";
      wysihtml5.dom.setAttributes({
        "security":           "restricted",
        "allowtransparency":  "true",
        "frameborder":        0,
        "width":              0,
        "height":             0,
        "marginwidth":        0,
        "marginheight":       0
      }).on(iframe);

      // Setting the src like this prevents ssl warnings in IE6
      if (wysihtml5.browser.throwsMixedContentWarningWhenIframeSrcIsEmpty()) {
        iframe.src = "javascript:'<html></html>'";
      }

      iframe.onload = function() {
        iframe.onreadystatechange = iframe.onload = null;
        that._onLoadIframe(iframe);
      };

      iframe.onreadystatechange = function() {
        if (/loaded|complete/.test(iframe.readyState)) {
          iframe.onreadystatechange = iframe.onload = null;
          that._onLoadIframe(iframe);
        }
      };

      return iframe;
    },

    /**
     * Callback for when the iframe has finished loading
     */
    _onLoadIframe: function(iframe) {
      // don't resume when the iframe got unloaded (eg. by removing it from the dom)
      if (!wysihtml5.dom.contains(doc.documentElement, iframe)) {
        return;
      }

      var that           = this,
          iframeWindow   = iframe.contentWindow,
          iframeDocument = iframe.contentWindow.document,
          charset        = doc.characterSet || doc.charset || "utf-8",
          sandboxHtml    = this._getHtml({
            charset:      charset,
            stylesheets:  this.config.stylesheets
          });

      // Create the basic dom tree including proper DOCTYPE and charset
      iframeDocument.open("text/html", "replace");
      iframeDocument.write(sandboxHtml);
      iframeDocument.close();

      this.getWindow = function() { return iframe.contentWindow; };
      this.getDocument = function() { return iframe.contentWindow.document; };

      // Catch js errors and pass them to the parent's onerror event
      // addEventListener("error") doesn't work properly in some browsers
      // TODO: apparently this doesn't work in IE9!
      iframeWindow.onerror = function(errorMessage, fileName, lineNumber) {
        throw new Error("wysihtml5.Sandbox: " + errorMessage, fileName, lineNumber);
      };

      if (!wysihtml5.browser.supportsSandboxedIframes()) {
        // Unset a bunch of sensitive variables
        // Please note: This isn't hack safe!
        // It more or less just takes care of basic attacks and prevents accidental theft of sensitive information
        // IE is secure though, which is the most important thing, since IE is the only browser, who
        // takes over scripts & styles into contentEditable elements when copied from external websites
        // or applications (Microsoft Word, ...)
        var i, length;
        for (i=0, length=windowProperties.length; i<length; i++) {
          this._unset(iframeWindow, windowProperties[i]);
        }
        for (i=0, length=windowProperties2.length; i<length; i++) {
          this._unset(iframeWindow, windowProperties2[i], wysihtml5.EMPTY_FUNCTION);
        }
        for (i=0, length=documentProperties.length; i<length; i++) {
          this._unset(iframeDocument, documentProperties[i]);
        }
        // This doesn't work in Safari 5
        // See http://stackoverflow.com/questions/992461/is-it-possible-to-override-document-cookie-in-webkit
        this._unset(iframeDocument, "cookie", "", true);
      }

      this.loaded = true;

      // Trigger the callback
      setTimeout(function() { that.callback(that); }, 0);
    },

    _getHtml: function(templateVars) {
      var stylesheets = templateVars.stylesheets,
          html        = "",
          i           = 0,
          length;
      stylesheets = typeof(stylesheets) === "string" ? [stylesheets] : stylesheets;
      if (stylesheets) {
        length = stylesheets.length;
        for (; i<length; i++) {
          html += '<link rel="stylesheet" href="' + stylesheets[i] + '">';
        }
      }
      templateVars.stylesheets = html;

      return wysihtml5.lang.string(
        '<!DOCTYPE html><html><head>'
        + '<meta charset="#{charset}">#{stylesheets}</head>'
        + '<body></body></html>'
      ).interpolate(templateVars);
    },

    /**
     * Method to unset/override existing variables
     * @example
     *    // Make cookie unreadable and unwritable
     *    this._unset(document, "cookie", "", true);
     */
    _unset: function(object, property, value, setter) {
      try { object[property] = value; } catch(e) {}

      try { object.__defineGetter__(property, function() { return value; }); } catch(e) {}
      if (setter) {
        try { object.__defineSetter__(property, function() {}); } catch(e) {}
      }

      if (!wysihtml5.browser.crashesWhenDefineProperty(property)) {
        try {
          var config = {
            get: function() { return value; }
          };
          if (setter) {
            config.set = function() {};
          }
          Object.defineProperty(object, property, config);
        } catch(e) {}
      }
    }
  });
})(wysihtml5);
;(function(wysihtml5) {
  var doc = document;
  wysihtml5.dom.ContentEditableArea = Base.extend({
      getContentEditable: function() {
        return this.element;
      },

      getWindow: function() {
        return this.element.ownerDocument.defaultView;
      },

      getDocument: function() {
        return this.element.ownerDocument;
      },

      constructor: function(readyCallback, config, contentEditable) {
        this.callback = readyCallback || wysihtml5.EMPTY_FUNCTION;
        this.config   = wysihtml5.lang.object({}).merge(config).get();
        if (contentEditable) {
            this.element = this._bindElement(contentEditable);
        } else {
            this.element = this._createElement();
        }
      },

      // creates a new contenteditable and initiates it
      _createElement: function() {
        var element = doc.createElement("div");
        element.className = "wysihtml5-sandbox";
        this._loadElement(element);
        return element;
      },

      // initiates an allready existent contenteditable
      _bindElement: function(contentEditable) {
        contentEditable.className = (contentEditable.className && contentEditable.className != '') ? contentEditable.className + " wysihtml5-sandbox" : "wysihtml5-sandbox";
        this._loadElement(contentEditable, true);
        return contentEditable;
      },

      _loadElement: function(element, contentExists) {
          var that = this;
        if (!contentExists) {
            var sandboxHtml = this._getHtml();
            element.innerHTML = sandboxHtml;
        }

        this.getWindow = function() { return element.ownerDocument.defaultView; };
        this.getDocument = function() { return element.ownerDocument; };

        // Catch js errors and pass them to the parent's onerror event
        // addEventListener("error") doesn't work properly in some browsers
        // TODO: apparently this doesn't work in IE9!
        // TODO: figure out and bind the errors logic for contenteditble mode
        /*iframeWindow.onerror = function(errorMessage, fileName, lineNumber) {
          throw new Error("wysihtml5.Sandbox: " + errorMessage, fileName, lineNumber);
        }
        */
        this.loaded = true;
        // Trigger the callback
        setTimeout(function() { that.callback(that); }, 0);
      },

      _getHtml: function(templateVars) {
        return '';
      }

  });
})(wysihtml5);
;(function() {
  var mapping = {
    "className": "class"
  };
  wysihtml5.dom.setAttributes = function(attributes) {
    return {
      on: function(element) {
        for (var i in attributes) {
          element.setAttribute(mapping[i] || i, attributes[i]);
        }
      }
    };
  };
})();
;wysihtml5.dom.setStyles = function(styles) {
  return {
    on: function(element) {
      var style = element.style;
      if (typeof(styles) === "string") {
        style.cssText += ";" + styles;
        return;
      }
      for (var i in styles) {
        if (i === "float") {
          style.cssFloat = styles[i];
          style.styleFloat = styles[i];
        } else {
          style[i] = styles[i];
        }
      }
    }
  };
};
;/**
 * Simulate HTML5 placeholder attribute
 *
 * Needed since
 *    - div[contentEditable] elements don't support it
 *    - older browsers (such as IE8 and Firefox 3.6) don't support it at all
 *
 * @param {Object} parent Instance of main wysihtml5.Editor class
 * @param {Element} view Instance of wysihtml5.views.* class
 * @param {String} placeholderText
 *
 * @example
 *    wysihtml.dom.simulatePlaceholder(this, composer, "Foobar");
 */
(function(dom) {
  dom.simulatePlaceholder = function(editor, view, placeholderText) {
    var CLASS_NAME = "placeholder",
        unset = function() {
          var composerIsVisible   = view.element.offsetWidth > 0 && view.element.offsetHeight > 0;
          if (view.hasPlaceholderSet()) {
            view.clear();
            view.element.focus();
            if (composerIsVisible ) {
              setTimeout(function() {
                var sel = view.selection.getSelection();
                if (!sel.focusNode || !sel.anchorNode) {
                  view.selection.selectNode(view.element.firstChild || view.element);
                }
              }, 0);
            }
          }
          view.placeholderSet = false;
          dom.removeClass(view.element, CLASS_NAME);
        },
        set = function() {
          if (view.isEmpty()) {
            view.placeholderSet = true;
            view.setValue(placeholderText);
            dom.addClass(view.element, CLASS_NAME);
          }
        };

    editor
      .on("set_placeholder", set)
      .on("unset_placeholder", unset)
      .on("focus:composer", unset)
      .on("paste:composer", unset)
      .on("blur:composer", set);

    set();
  };
})(wysihtml5.dom);
;(function(dom) {
  var documentElement = document.documentElement;
  if ("textContent" in documentElement) {
    dom.setTextContent = function(element, text) {
      element.textContent = text;
    };

    dom.getTextContent = function(element) {
      return element.textContent;
    };
  } else if ("innerText" in documentElement) {
    dom.setTextContent = function(element, text) {
      element.innerText = text;
    };

    dom.getTextContent = function(element) {
      return element.innerText;
    };
  } else {
    dom.setTextContent = function(element, text) {
      element.nodeValue = text;
    };

    dom.getTextContent = function(element) {
      return element.nodeValue;
    };
  }
})(wysihtml5.dom);

;/**
 * Get a set of attribute from one element
 *
 * IE gives wrong results for hasAttribute/getAttribute, for example:
 *    var td = document.createElement("td");
 *    td.getAttribute("rowspan"); // => "1" in IE
 *
 * Therefore we have to check the element's outerHTML for the attribute
*/

wysihtml5.dom.getAttribute = function(node, attributeName) {
  var HAS_GET_ATTRIBUTE_BUG = !wysihtml5.browser.supportsGetAttributeCorrectly();
  attributeName = attributeName.toLowerCase();
  var nodeName = node.nodeName;
  if (nodeName == "IMG" && attributeName == "src" && wysihtml5.dom.isLoadedImage(node) === true) {
    // Get 'src' attribute value via object property since this will always contain the
    // full absolute url (http://...)
    // this fixes a very annoying bug in firefox (ver 3.6 & 4) and IE 8 where images copied from the same host
    // will have relative paths, which the sanitizer strips out (see attributeCheckMethods.url)
    return node.src;
  } else if (HAS_GET_ATTRIBUTE_BUG && "outerHTML" in node) {
    // Don't trust getAttribute/hasAttribute in IE 6-8, instead check the element's outerHTML
    var outerHTML      = node.outerHTML.toLowerCase(),
        // TODO: This might not work for attributes without value: <input disabled>
        hasAttribute   = outerHTML.indexOf(" " + attributeName +  "=") != -1;

    return hasAttribute ? node.getAttribute(attributeName) : null;
  } else{
    return node.getAttribute(attributeName);
  }
};
;/**
 * Get all attributes of an element
 *
 * IE gives wrong results for hasAttribute/getAttribute, for example:
 *    var td = document.createElement("td");
 *    td.getAttribute("rowspan"); // => "1" in IE
 *
 * Therefore we have to check the element's outerHTML for the attribute
*/

wysihtml5.dom.getAttributes = function(node) {
  var HAS_GET_ATTRIBUTE_BUG = !wysihtml5.browser.supportsGetAttributeCorrectly(),
      nodeName = node.nodeName,
      attributes = [],
      attr;

  for (attr in node.attributes) {
    if ((node.attributes.hasOwnProperty && node.attributes.hasOwnProperty(attr)) || (!node.attributes.hasOwnProperty && Object.prototype.hasOwnProperty.call(node.attributes, attr)))  {
      if (node.attributes[attr].specified) {
        if (nodeName == "IMG" && node.attributes[attr].name.toLowerCase() == "src" && wysihtml5.dom.isLoadedImage(node) === true) {
          attributes['src'] = node.src;
        } else if (wysihtml5.lang.array(['rowspan', 'colspan']).contains(node.attributes[attr].name.toLowerCase()) && HAS_GET_ATTRIBUTE_BUG) {
          if (node.attributes[attr].value !== 1) {
            attributes[node.attributes[attr].name] = node.attributes[attr].value;
          }
        } else {
          attributes[node.attributes[attr].name] = node.attributes[attr].value;
        }
      }
    }
  }
  return attributes;
};;/**
   * Check whether the given node is a proper loaded image
   * FIXME: Returns undefined when unknown (Chrome, Safari)
*/

wysihtml5.dom.isLoadedImage = function (node) {
  try {
    return node.complete && !node.mozMatchesSelector(":-moz-broken");
  } catch(e) {
    if (node.complete && node.readyState === "complete") {
      return true;
    }
  }
};
;(function(wysihtml5) {

    var api = wysihtml5.dom;

    var MapCell = function(cell) {
      this.el = cell;
      this.isColspan= false;
      this.isRowspan= false;
      this.firstCol= true;
      this.lastCol= true;
      this.firstRow= true;
      this.lastRow= true;
      this.isReal= true;
      this.spanCollection= [];
      this.modified = false;
    };

    var TableModifyerByCell = function (cell, table) {
        if (cell) {
            this.cell = cell;
            this.table = api.getParentElement(cell, { nodeName: ["TABLE"] });
        } else if (table) {
            this.table = table;
            this.cell = this.table.querySelectorAll('th, td')[0];
        }
    };

    function queryInList(list, query) {
        var ret = [],
            q;
        for (var e = 0, len = list.length; e < len; e++) {
            q = list[e].querySelectorAll(query);
            if (q) {
                for(var i = q.length; i--; ret.unshift(q[i]));
            }
        }
        return ret;
    }

    function removeElement(el) {
        el.parentNode.removeChild(el);
    }

    function insertAfter(referenceNode, newNode) {
        referenceNode.parentNode.insertBefore(newNode, referenceNode.nextSibling);
    }

    function nextNode(node, tag) {
        var element = node.nextSibling;
        while (element.nodeType !=1) {
            element = element.nextSibling;
            if (!tag || tag == element.tagName.toLowerCase()) {
                return element;
            }
        }
        return null;
    }

    TableModifyerByCell.prototype = {

        addSpannedCellToMap: function(cell, map, r, c, cspan, rspan) {
            var spanCollect = [],
                rmax = r + ((rspan) ? parseInt(rspan, 10) - 1 : 0),
                cmax = c + ((cspan) ? parseInt(cspan, 10) - 1 : 0);

            for (var rr = r; rr <= rmax; rr++) {
                if (typeof map[rr] == "undefined") { map[rr] = []; }
                for (var cc = c; cc <= cmax; cc++) {
                    map[rr][cc] = new MapCell(cell);
                    map[rr][cc].isColspan = (cspan && parseInt(cspan, 10) > 1);
                    map[rr][cc].isRowspan = (rspan && parseInt(rspan, 10) > 1);
                    map[rr][cc].firstCol = cc == c;
                    map[rr][cc].lastCol = cc == cmax;
                    map[rr][cc].firstRow = rr == r;
                    map[rr][cc].lastRow = rr == rmax;
                    map[rr][cc].isReal = cc == c && rr == r;
                    map[rr][cc].spanCollection = spanCollect;

                    spanCollect.push(map[rr][cc]);
                }
            }
        },

        setCellAsModified: function(cell) {
            cell.modified = true;
            if (cell.spanCollection.length > 0) {
              for (var s = 0, smax = cell.spanCollection.length; s < smax; s++) {
                cell.spanCollection[s].modified = true;
              }
            }
        },

        setTableMap: function() {
            var map = [];
            var tableRows = this.getTableRows(),
                ridx, row, cells, cidx, cell,
                c,
                cspan, rspan;

            for (ridx = 0; ridx < tableRows.length; ridx++) {
                row = tableRows[ridx];
                cells = this.getRowCells(row);
                c = 0;
                if (typeof map[ridx] == "undefined") { map[ridx] = []; }
                for (cidx = 0; cidx < cells.length; cidx++) {
                    cell = cells[cidx];

                    // If cell allready set means it is set by col or rowspan,
                    // so increase cols index until free col is found
                    while (typeof map[ridx][c] != "undefined") { c++; }

                    cspan = api.getAttribute(cell, 'colspan');
                    rspan = api.getAttribute(cell, 'rowspan');

                    if (cspan || rspan) {
                        this.addSpannedCellToMap(cell, map, ridx, c, cspan, rspan);
                        c = c + ((cspan) ? parseInt(cspan, 10) : 1);
                    } else {
                        map[ridx][c] = new MapCell(cell);
                        c++;
                    }
                }
            }
            this.map = map;
            return map;
        },

        getRowCells: function(row) {
            var inlineTables = this.table.querySelectorAll('table'),
                inlineCells = (inlineTables) ? queryInList(inlineTables, 'th, td') : [],
                allCells = row.querySelectorAll('th, td'),
                tableCells = (inlineCells.length > 0) ? wysihtml5.lang.array(allCells).without(inlineCells) : allCells;

            return tableCells;
        },

        getTableRows: function() {
          var inlineTables = this.table.querySelectorAll('table'),
              inlineRows = (inlineTables) ? queryInList(inlineTables, 'tr') : [],
              allRows = this.table.querySelectorAll('tr'),
              tableRows = (inlineRows.length > 0) ? wysihtml5.lang.array(allRows).without(inlineRows) : allRows;

          return tableRows;
        },

        getMapIndex: function(cell) {
          var r_length = this.map.length,
              c_length = (this.map && this.map[0]) ? this.map[0].length : 0;

          for (var r_idx = 0;r_idx < r_length; r_idx++) {
              for (var c_idx = 0;c_idx < c_length; c_idx++) {
                  if (this.map[r_idx][c_idx].el === cell) {
                      return {'row': r_idx, 'col': c_idx};
                  }
              }
          }
          return false;
        },

        getElementAtIndex: function(idx) {
            this.setTableMap();
            if (this.map[idx.row] && this.map[idx.row][idx.col] && this.map[idx.row][idx.col].el) {
                return this.map[idx.row][idx.col].el;
            }
            return null;
        },

        getMapElsTo: function(to_cell) {
            var els = [];
            this.setTableMap();
            this.idx_start = this.getMapIndex(this.cell);
            this.idx_end = this.getMapIndex(to_cell);

            // switch indexes if start is bigger than end
            if (this.idx_start.row > this.idx_end.row || (this.idx_start.row == this.idx_end.row && this.idx_start.col > this.idx_end.col)) {
                var temp_idx = this.idx_start;
                this.idx_start = this.idx_end;
                this.idx_end = temp_idx;
            }
            if (this.idx_start.col > this.idx_end.col) {
                var temp_cidx = this.idx_start.col;
                this.idx_start.col = this.idx_end.col;
                this.idx_end.col = temp_cidx;
            }

            if (this.idx_start != null && this.idx_end != null) {
                for (var row = this.idx_start.row, maxr = this.idx_end.row; row <= maxr; row++) {
                    for (var col = this.idx_start.col, maxc = this.idx_end.col; col <= maxc; col++) {
                        els.push(this.map[row][col].el);
                    }
                }
            }
            return els;
        },

        orderSelectionEnds: function(secondcell) {
            this.setTableMap();
            this.idx_start = this.getMapIndex(this.cell);
            this.idx_end = this.getMapIndex(secondcell);

            // switch indexes if start is bigger than end
            if (this.idx_start.row > this.idx_end.row || (this.idx_start.row == this.idx_end.row && this.idx_start.col > this.idx_end.col)) {
                var temp_idx = this.idx_start;
                this.idx_start = this.idx_end;
                this.idx_end = temp_idx;
            }
            if (this.idx_start.col > this.idx_end.col) {
                var temp_cidx = this.idx_start.col;
                this.idx_start.col = this.idx_end.col;
                this.idx_end.col = temp_cidx;
            }

            return {
                "start": this.map[this.idx_start.row][this.idx_start.col].el,
                "end": this.map[this.idx_end.row][this.idx_end.col].el
            };
        },

        createCells: function(tag, nr, attrs) {
            var doc = this.table.ownerDocument,
                frag = doc.createDocumentFragment(),
                cell;
            for (var i = 0; i < nr; i++) {
                cell = doc.createElement(tag);

                if (attrs) {
                    for (var attr in attrs) {
                        if (attrs.hasOwnProperty(attr)) {
                            cell.setAttribute(attr, attrs[attr]);
                        }
                    }
                }

                // add non breaking space
                cell.appendChild(document.createTextNode("\u00a0"));

                frag.appendChild(cell);
            }
            return frag;
        },

        // Returns next real cell (not part of spanned cell unless first) on row if selected index is not real. I no real cells -1 will be returned
        correctColIndexForUnreals: function(col, row) {
            var r = this.map[row],
                corrIdx = -1;
            for (var i = 0, max = col; i < col; i++) {
                if (r[i].isReal){
                    corrIdx++;
                }
            }
            return corrIdx;
        },

        getLastNewCellOnRow: function(row, rowLimit) {
            var cells = this.getRowCells(row),
                cell, idx;

            for (var cidx = 0, cmax = cells.length; cidx < cmax; cidx++) {
                cell = cells[cidx];
                idx = this.getMapIndex(cell);
                if (idx === false || (typeof rowLimit != "undefined" && idx.row != rowLimit)) {
                    return cell;
                }
            }
            return null;
        },

        removeEmptyTable: function() {
            var cells = this.table.querySelectorAll('td, th');
            if (!cells || cells.length == 0) {
                removeElement(this.table);
                return true;
            } else {
                return false;
            }
        },

        // Splits merged cell on row to unique cells
        splitRowToCells: function(cell) {
            if (cell.isColspan) {
                var colspan = parseInt(api.getAttribute(cell.el, 'colspan') || 1, 10),
                    cType = cell.el.tagName.toLowerCase();
                if (colspan > 1) {
                    var newCells = this.createCells(cType, colspan -1);
                    insertAfter(cell.el, newCells);
                }
                cell.el.removeAttribute('colspan');
            }
        },

        getRealRowEl: function(force, idx) {
            var r = null,
                c = null;

            idx = idx || this.idx;

            for (var cidx = 0, cmax = this.map[idx.row].length; cidx < cmax; cidx++) {
                c = this.map[idx.row][cidx];
                if (c.isReal) {
                    r = api.getParentElement(c.el, { nodeName: ["TR"] });
                    if (r) {
                        return r;
                    }
                }
            }

            if (r === null && force) {
                r = api.getParentElement(this.map[idx.row][idx.col].el, { nodeName: ["TR"] }) || null;
            }

            return r;
        },

        injectRowAt: function(row, col, colspan, cType, c) {
            var r = this.getRealRowEl(false, {'row': row, 'col': col}),
                new_cells = this.createCells(cType, colspan);

            if (r) {
                var n_cidx = this.correctColIndexForUnreals(col, row);
                if (n_cidx >= 0) {
                    insertAfter(this.getRowCells(r)[n_cidx], new_cells);
                } else {
                    r.insertBefore(new_cells, r.firstChild);
                }
            } else {
                var rr = this.table.ownerDocument.createElement('tr');
                rr.appendChild(new_cells);
                insertAfter(api.getParentElement(c.el, { nodeName: ["TR"] }), rr);
            }
        },

        canMerge: function(to) {
            this.to = to;
            this.setTableMap();
            this.idx_start = this.getMapIndex(this.cell);
            this.idx_end = this.getMapIndex(this.to);

            // switch indexes if start is bigger than end
            if (this.idx_start.row > this.idx_end.row || (this.idx_start.row == this.idx_end.row && this.idx_start.col > this.idx_end.col)) {
                var temp_idx = this.idx_start;
                this.idx_start = this.idx_end;
                this.idx_end = temp_idx;
            }
            if (this.idx_start.col > this.idx_end.col) {
                var temp_cidx = this.idx_start.col;
                this.idx_start.col = this.idx_end.col;
                this.idx_end.col = temp_cidx;
            }

            for (var row = this.idx_start.row, maxr = this.idx_end.row; row <= maxr; row++) {
                for (var col = this.idx_start.col, maxc = this.idx_end.col; col <= maxc; col++) {
                    if (this.map[row][col].isColspan || this.map[row][col].isRowspan) {
                        return false;
                    }
                }
            }
            return true;
        },

        decreaseCellSpan: function(cell, span) {
            var nr = parseInt(api.getAttribute(cell.el, span), 10) - 1;
            if (nr >= 1) {
                cell.el.setAttribute(span, nr);
            } else {
                cell.el.removeAttribute(span);
                if (span == 'colspan') {
                    cell.isColspan = false;
                }
                if (span == 'rowspan') {
                    cell.isRowspan = false;
                }
                cell.firstCol = true;
                cell.lastCol = true;
                cell.firstRow = true;
                cell.lastRow = true;
                cell.isReal = true;
            }
        },

        removeSurplusLines: function() {
            var row, cell, ridx, rmax, cidx, cmax, allRowspan;

            this.setTableMap();
            if (this.map) {
                ridx = 0;
                rmax = this.map.length;
                for (;ridx < rmax; ridx++) {
                    row = this.map[ridx];
                    allRowspan = true;
                    cidx = 0;
                    cmax = row.length;
                    for (; cidx < cmax; cidx++) {
                        cell = row[cidx];
                        if (!(api.getAttribute(cell.el, "rowspan") && parseInt(api.getAttribute(cell.el, "rowspan"), 10) > 1 && cell.firstRow !== true)) {
                            allRowspan = false;
                            break;
                        }
                    }
                    if (allRowspan) {
                        cidx = 0;
                        for (; cidx < cmax; cidx++) {
                            this.decreaseCellSpan(row[cidx], 'rowspan');
                        }
                    }
                }

                // remove rows without cells
                var tableRows = this.getTableRows();
                ridx = 0;
                rmax = tableRows.length;
                for (;ridx < rmax; ridx++) {
                    row = tableRows[ridx];
                    if (row.childNodes.length == 0 && (/^\s*$/.test(row.textContent || row.innerText))) {
                        removeElement(row);
                    }
                }
            }
        },

        fillMissingCells: function() {
            var r_max = 0,
                c_max = 0,
                prevcell = null;

            this.setTableMap();
            if (this.map) {

                // find maximal dimensions of broken table
                r_max = this.map.length;
                for (var ridx = 0; ridx < r_max; ridx++) {
                    if (this.map[ridx].length > c_max) { c_max = this.map[ridx].length; }
                }

                for (var row = 0; row < r_max; row++) {
                    for (var col = 0; col < c_max; col++) {
                        if (this.map[row] && !this.map[row][col]) {
                            if (col > 0) {
                                this.map[row][col] = new MapCell(this.createCells('td', 1));
                                prevcell = this.map[row][col-1];
                                if (prevcell && prevcell.el && prevcell.el.parent) { // if parent does not exist element is removed from dom
                                    insertAfter(this.map[row][col-1].el, this.map[row][col].el);
                                }
                            }
                        }
                    }
                }
            }
        },

        rectify: function() {
            if (!this.removeEmptyTable()) {
                this.removeSurplusLines();
                this.fillMissingCells();
                return true;
            } else {
                return false;
            }
        },

        unmerge: function() {
            if (this.rectify()) {
                this.setTableMap();
                this.idx = this.getMapIndex(this.cell);

                if (this.idx) {
                    var thisCell = this.map[this.idx.row][this.idx.col],
                        colspan = (api.getAttribute(thisCell.el, "colspan")) ? parseInt(api.getAttribute(thisCell.el, "colspan"), 10) : 1,
                        cType = thisCell.el.tagName.toLowerCase();

                    if (thisCell.isRowspan) {
                        var rowspan = parseInt(api.getAttribute(thisCell.el, "rowspan"), 10);
                        if (rowspan > 1) {
                            for (var nr = 1, maxr = rowspan - 1; nr <= maxr; nr++){
                                this.injectRowAt(this.idx.row + nr, this.idx.col, colspan, cType, thisCell);
                            }
                        }
                        thisCell.el.removeAttribute('rowspan');
                    }
                    this.splitRowToCells(thisCell);
                }
            }
        },

        // merges cells from start cell (defined in creating obj) to "to" cell
        merge: function(to) {
            if (this.rectify()) {
                if (this.canMerge(to)) {
                    var rowspan = this.idx_end.row - this.idx_start.row + 1,
                        colspan = this.idx_end.col - this.idx_start.col + 1;

                    for (var row = this.idx_start.row, maxr = this.idx_end.row; row <= maxr; row++) {
                        for (var col = this.idx_start.col, maxc = this.idx_end.col; col <= maxc; col++) {

                            if (row == this.idx_start.row && col == this.idx_start.col) {
                                if (rowspan > 1) {
                                    this.map[row][col].el.setAttribute('rowspan', rowspan);
                                }
                                if (colspan > 1) {
                                    this.map[row][col].el.setAttribute('colspan', colspan);
                                }
                            } else {
                                // transfer content
                                if (!(/^\s*<br\/?>\s*$/.test(this.map[row][col].el.innerHTML.toLowerCase()))) {
                                    this.map[this.idx_start.row][this.idx_start.col].el.innerHTML += ' ' + this.map[row][col].el.innerHTML;
                                }
                                removeElement(this.map[row][col].el);
                            }
                        }
                    }
                    this.rectify();
                } else {
                    if (window.console) {
                        console.log('Do not know how to merge allready merged cells.');
                    }
                }
            }
        },

        // Decreases rowspan of a cell if it is done on first cell of rowspan row (real cell)
        // Cell is moved to next row (if it is real)
        collapseCellToNextRow: function(cell) {
            var cellIdx = this.getMapIndex(cell.el),
                newRowIdx = cellIdx.row + 1,
                newIdx = {'row': newRowIdx, 'col': cellIdx.col};

            if (newRowIdx < this.map.length) {

                var row = this.getRealRowEl(false, newIdx);
                if (row !== null) {
                    var n_cidx = this.correctColIndexForUnreals(newIdx.col, newIdx.row);
                    if (n_cidx >= 0) {
                        insertAfter(this.getRowCells(row)[n_cidx], cell.el);
                    } else {
                        var lastCell = this.getLastNewCellOnRow(row, newRowIdx);
                        if (lastCell !== null) {
                            insertAfter(lastCell, cell.el);
                        } else {
                            row.insertBefore(cell.el, row.firstChild);
                        }
                    }
                    if (parseInt(api.getAttribute(cell.el, 'rowspan'), 10) > 2) {
                        cell.el.setAttribute('rowspan', parseInt(api.getAttribute(cell.el, 'rowspan'), 10) - 1);
                    } else {
                        cell.el.removeAttribute('rowspan');
                    }
                }
            }
        },

        // Removes a cell when removing a row
        // If is rowspan cell then decreases the rowspan
        // and moves cell to next row if needed (is first cell of rowspan)
        removeRowCell: function(cell) {
            if (cell.isReal) {
               if (cell.isRowspan) {
                   this.collapseCellToNextRow(cell);
               } else {
                   removeElement(cell.el);
               }
            } else {
                if (parseInt(api.getAttribute(cell.el, 'rowspan'), 10) > 2) {
                    cell.el.setAttribute('rowspan', parseInt(api.getAttribute(cell.el, 'rowspan'), 10) - 1);
                } else {
                    cell.el.removeAttribute('rowspan');
                }
            }
        },

        getRowElementsByCell: function() {
            var cells = [];
            this.setTableMap();
            this.idx = this.getMapIndex(this.cell);
            if (this.idx !== false) {
                var modRow = this.map[this.idx.row];
                for (var cidx = 0, cmax = modRow.length; cidx < cmax; cidx++) {
                    if (modRow[cidx].isReal) {
                        cells.push(modRow[cidx].el);
                    }
                }
            }
            return cells;
        },

        getColumnElementsByCell: function() {
            var cells = [];
            this.setTableMap();
            this.idx = this.getMapIndex(this.cell);
            if (this.idx !== false) {
                for (var ridx = 0, rmax = this.map.length; ridx < rmax; ridx++) {
                    if (this.map[ridx][this.idx.col] && this.map[ridx][this.idx.col].isReal) {
                        cells.push(this.map[ridx][this.idx.col].el);
                    }
                }
            }
            return cells;
        },

        // Removes the row of selected cell
        removeRow: function() {
            var oldRow = api.getParentElement(this.cell, { nodeName: ["TR"] });
            if (oldRow) {
                this.setTableMap();
                this.idx = this.getMapIndex(this.cell);
                if (this.idx !== false) {
                    var modRow = this.map[this.idx.row];
                    for (var cidx = 0, cmax = modRow.length; cidx < cmax; cidx++) {
                        if (!modRow[cidx].modified) {
                            this.setCellAsModified(modRow[cidx]);
                            this.removeRowCell(modRow[cidx]);
                        }
                    }
                }
                removeElement(oldRow);
            }
        },

        removeColCell: function(cell) {
            if (cell.isColspan) {
                if (parseInt(api.getAttribute(cell.el, 'colspan'), 10) > 2) {
                    cell.el.setAttribute('colspan', parseInt(api.getAttribute(cell.el, 'colspan'), 10) - 1);
                } else {
                    cell.el.removeAttribute('colspan');
                }
            } else if (cell.isReal) {
                removeElement(cell.el);
            }
        },

        removeColumn: function() {
            this.setTableMap();
            this.idx = this.getMapIndex(this.cell);
            if (this.idx !== false) {
                for (var ridx = 0, rmax = this.map.length; ridx < rmax; ridx++) {
                    if (!this.map[ridx][this.idx.col].modified) {
                        this.setCellAsModified(this.map[ridx][this.idx.col]);
                        this.removeColCell(this.map[ridx][this.idx.col]);
                    }
                }
            }
        },

        // removes row or column by selected cell element
        remove: function(what) {
            if (this.rectify()) {
                switch (what) {
                    case 'row':
                        this.removeRow();
                    break;
                    case 'column':
                        this.removeColumn();
                    break;
                }
                this.rectify();
            }
        },

        addRow: function(where) {
            var doc = this.table.ownerDocument;

            this.setTableMap();
            this.idx = this.getMapIndex(this.cell);
            if (where == "below" && api.getAttribute(this.cell, 'rowspan')) {
                this.idx.row = this.idx.row + parseInt(api.getAttribute(this.cell, 'rowspan'), 10) - 1;
            }

            if (this.idx !== false) {
                var modRow = this.map[this.idx.row],
                    newRow = doc.createElement('tr');

                for (var ridx = 0, rmax = modRow.length; ridx < rmax; ridx++) {
                    if (!modRow[ridx].modified) {
                        this.setCellAsModified(modRow[ridx]);
                        this.addRowCell(modRow[ridx], newRow, where);
                    }
                }

                switch (where) {
                    case 'below':
                        insertAfter(this.getRealRowEl(true), newRow);
                    break;
                    case 'above':
                        var cr = api.getParentElement(this.map[this.idx.row][this.idx.col].el, { nodeName: ["TR"] });
                        if (cr) {
                            cr.parentNode.insertBefore(newRow, cr);
                        }
                    break;
                }
            }
        },

        addRowCell: function(cell, row, where) {
            var colSpanAttr = (cell.isColspan) ? {"colspan" : api.getAttribute(cell.el, 'colspan')} : null;
            if (cell.isReal) {
                if (where != 'above' && cell.isRowspan) {
                    cell.el.setAttribute('rowspan', parseInt(api.getAttribute(cell.el,'rowspan'), 10) + 1);
                } else {
                    row.appendChild(this.createCells('td', 1, colSpanAttr));
                }
            } else {
                if (where != 'above' && cell.isRowspan && cell.lastRow) {
                    row.appendChild(this.createCells('td', 1, colSpanAttr));
                } else if (c.isRowspan) {
                    cell.el.attr('rowspan', parseInt(api.getAttribute(cell.el, 'rowspan'), 10) + 1);
                }
            }
        },

        add: function(where) {
            if (this.rectify()) {
                if (where == 'below' || where == 'above') {
                    this.addRow(where);
                }
                if (where == 'before' || where == 'after') {
                    this.addColumn(where);
                }
            }
        },

        addColCell: function (cell, ridx, where) {
            var doAdd,
                cType = cell.el.tagName.toLowerCase();

            // defines add cell vs expand cell conditions
            // true means add
            switch (where) {
                case "before":
                    doAdd = (!cell.isColspan || cell.firstCol);
                break;
                case "after":
                    doAdd = (!cell.isColspan || cell.lastCol || (cell.isColspan && c.el == this.cell));
                break;
            }

            if (doAdd){
                // adds a cell before or after current cell element
                switch (where) {
                    case "before":
                        cell.el.parentNode.insertBefore(this.createCells(cType, 1), cell.el);
                    break;
                    case "after":
                        insertAfter(cell.el, this.createCells(cType, 1));
                    break;
                }

                // handles if cell has rowspan
                if (cell.isRowspan) {
                    this.handleCellAddWithRowspan(cell, ridx+1, where);
                }

            } else {
                // expands cell
                cell.el.setAttribute('colspan',  parseInt(api.getAttribute(cell.el, 'colspan'), 10) + 1);
            }
        },

        addColumn: function(where) {
            var row, modCell;

            this.setTableMap();
            this.idx = this.getMapIndex(this.cell);
            if (where == "after" && api.getAttribute(this.cell, 'colspan')) {
              this.idx.col = this.idx.col + parseInt(api.getAttribute(this.cell, 'colspan'), 10) - 1;
            }

            if (this.idx !== false) {
                for (var ridx = 0, rmax = this.map.length; ridx < rmax; ridx++ ) {
                    row = this.map[ridx];
                    if (row[this.idx.col]) {
                        modCell = row[this.idx.col];
                        if (!modCell.modified) {
                            this.setCellAsModified(modCell);
                            this.addColCell(modCell, ridx , where);
                        }
                    }
                }
            }
        },

        handleCellAddWithRowspan: function (cell, ridx, where) {
            var addRowsNr = parseInt(api.getAttribute(this.cell, 'rowspan'), 10) - 1,
                crow = api.getParentElement(cell.el, { nodeName: ["TR"] }),
                cType = cell.el.tagName.toLowerCase(),
                cidx, temp_r_cells,
                doc = this.table.ownerDocument,
                nrow;

            for (var i = 0; i < addRowsNr; i++) {
                cidx = this.correctColIndexForUnreals(this.idx.col, (ridx + i));
                crow = nextNode(crow, 'tr');
                if (crow) {
                    if (cidx > 0) {
                        switch (where) {
                            case "before":
                                temp_r_cells = this.getRowCells(crow);
                                if (cidx > 0 && this.map[ridx + i][this.idx.col].el != temp_r_cells[cidx] && cidx == temp_r_cells.length - 1) {
                                     insertAfter(temp_r_cells[cidx], this.createCells(cType, 1));
                                } else {
                                    temp_r_cells[cidx].parentNode.insertBefore(this.createCells(cType, 1), temp_r_cells[cidx]);
                                }

                            break;
                            case "after":
                                insertAfter(this.getRowCells(crow)[cidx], this.createCells(cType, 1));
                            break;
                        }
                    } else {
                        crow.insertBefore(this.createCells(cType, 1), crow.firstChild);
                    }
                } else {
                    nrow = doc.createElement('tr');
                    nrow.appendChild(this.createCells(cType, 1));
                    this.table.appendChild(nrow);
                }
            }
        }
    };

    api.table = {
        getCellsBetween: function(cell1, cell2) {
            var c1 = new TableModifyerByCell(cell1);
            return c1.getMapElsTo(cell2);
        },

        addCells: function(cell, where) {
            var c = new TableModifyerByCell(cell);
            c.add(where);
        },

        removeCells: function(cell, what) {
            var c = new TableModifyerByCell(cell);
            c.remove(what);
        },

        mergeCellsBetween: function(cell1, cell2) {
            var c1 = new TableModifyerByCell(cell1);
            c1.merge(cell2);
        },

        unmergeCell: function(cell) {
            var c = new TableModifyerByCell(cell);
            c.unmerge();
        },

        orderSelectionEnds: function(cell, cell2) {
            var c = new TableModifyerByCell(cell);
            return c.orderSelectionEnds(cell2);
        },

        indexOf: function(cell) {
            var c = new TableModifyerByCell(cell);
            c.setTableMap();
            return c.getMapIndex(cell);
        },

        findCell: function(table, idx) {
            var c = new TableModifyerByCell(null, table);
            return c.getElementAtIndex(idx);
        },

        findRowByCell: function(cell) {
            var c = new TableModifyerByCell(cell);
            return c.getRowElementsByCell();
        },

        findColumnByCell: function(cell) {
            var c = new TableModifyerByCell(cell);
            return c.getColumnElementsByCell();
        },

        canMerge: function(cell1, cell2) {
            var c = new TableModifyerByCell(cell1);
            return c.canMerge(cell2);
        }
    };



})(wysihtml5);
;// does a selector query on element or array of elements

wysihtml5.dom.query = function(elements, query) {
    var ret = [],
        q;

    if (elements.nodeType) {
        elements = [elements];
    }

    for (var e = 0, len = elements.length; e < len; e++) {
        q = elements[e].querySelectorAll(query);
        if (q) {
            for(var i = q.length; i--; ret.unshift(q[i]));
        }
    }
    return ret;
};
;wysihtml5.dom.compareDocumentPosition = (function() {
  var documentElement = document.documentElement;
  if (documentElement.compareDocumentPosition) {
    return function(container, element) {
      return container.compareDocumentPosition(element);
    };
  } else {
    return function( container, element ) {
      // implementation borrowed from https://github.com/tmpvar/jsdom/blob/681a8524b663281a0f58348c6129c8c184efc62c/lib/jsdom/level3/core.js // MIT license
      var thisOwner, otherOwner;

      if( container.nodeType === 9) // Node.DOCUMENT_NODE
        thisOwner = container;
      else
        thisOwner = container.ownerDocument;

      if( element.nodeType === 9) // Node.DOCUMENT_NODE
        otherOwner = element;
      else
        otherOwner = element.ownerDocument;

      if( container === element ) return 0;
      if( container === element.ownerDocument ) return 4 + 16; //Node.DOCUMENT_POSITION_FOLLOWING + Node.DOCUMENT_POSITION_CONTAINED_BY;
      if( container.ownerDocument === element ) return 2 + 8;  //Node.DOCUMENT_POSITION_PRECEDING + Node.DOCUMENT_POSITION_CONTAINS;
      if( thisOwner !== otherOwner ) return 1; // Node.DOCUMENT_POSITION_DISCONNECTED;

      // Text nodes for attributes does not have a _parentNode. So we need to find them as attribute child.
      if( container.nodeType === 2 /*Node.ATTRIBUTE_NODE*/ && container.childNodes && wysihtml5.lang.array(container.childNodes).indexOf( element ) !== -1)
        return 4 + 16; //Node.DOCUMENT_POSITION_FOLLOWING + Node.DOCUMENT_POSITION_CONTAINED_BY;

      if( element.nodeType === 2 /*Node.ATTRIBUTE_NODE*/ && element.childNodes && wysihtml5.lang.array(element.childNodes).indexOf( container ) !== -1)
        return 2 + 8; //Node.DOCUMENT_POSITION_PRECEDING + Node.DOCUMENT_POSITION_CONTAINS;

      var point = container;
      var parents = [ ];
      var previous = null;
      while( point ) {
        if( point == element ) return 2 + 8; //Node.DOCUMENT_POSITION_PRECEDING + Node.DOCUMENT_POSITION_CONTAINS;
        parents.push( point );
        point = point.parentNode;
      }
      point = element;
      previous = null;
      while( point ) {
        if( point == container ) return 4 + 16; //Node.DOCUMENT_POSITION_FOLLOWING + Node.DOCUMENT_POSITION_CONTAINED_BY;
        var location_index = wysihtml5.lang.array(parents).indexOf( point );
        if( location_index !== -1) {
         var smallest_common_ancestor = parents[ location_index ];
         var this_index = wysihtml5.lang.array(smallest_common_ancestor.childNodes).indexOf( parents[location_index - 1]);//smallest_common_ancestor.childNodes.toArray().indexOf( parents[location_index - 1] );
         var other_index = wysihtml5.lang.array(smallest_common_ancestor.childNodes).indexOf( previous ); //smallest_common_ancestor.childNodes.toArray().indexOf( previous );
         if( this_index > other_index ) {
               return 2; //Node.DOCUMENT_POSITION_PRECEDING;
         }
         else {
           return 4; //Node.DOCUMENT_POSITION_FOLLOWING;
         }
        }
        previous = point;
        point = point.parentNode;
      }
      return 1; //Node.DOCUMENT_POSITION_DISCONNECTED;
    };
  }
})();
;wysihtml5.dom.unwrap = function(node) {
  if (node.parentNode) {
    while (node.lastChild) {
      wysihtml5.dom.insert(node.lastChild).after(node);
    }
    node.parentNode.removeChild(node);
  }
};;/* 
 * Methods for fetching pasted html before it gets inserted into content
**/

/* Modern event.clipboardData driven approach.
 * Advantage is that it does not have to loose selection or modify dom to catch the data. 
 * IE does not support though.
**/
wysihtml5.dom.getPastedHtml = function(event) {
  var html;
  if (event.clipboardData) {
    if (wysihtml5.lang.array(event.clipboardData.types).contains('text/html')) {
      html = event.clipboardData.getData('text/html');
    } else if (wysihtml5.lang.array(event.clipboardData.types).contains('text/plain')) {
      html = wysihtml5.lang.string(event.clipboardData.getData('text/plain')).escapeHTML(true, true);
    }
  }
  return html;
};

/* Older temprorary contenteditable as paste source catcher method for fallbacks */
wysihtml5.dom.getPastedHtmlWithDiv = function (composer, f) {
  var selBookmark = composer.selection.getBookmark(),
      doc = composer.element.ownerDocument,
      cleanerDiv = doc.createElement('DIV');
  
  doc.body.appendChild(cleanerDiv);

  cleanerDiv.style.width = "1px";
  cleanerDiv.style.height = "1px";
  cleanerDiv.style.overflow = "hidden";

  cleanerDiv.setAttribute('contenteditable', 'true');
  cleanerDiv.focus();

  setTimeout(function () {
    composer.selection.setBookmark(selBookmark);
    f(cleanerDiv.innerHTML);
    cleanerDiv.parentNode.removeChild(cleanerDiv);
  }, 0);
};;/**
 * Fix most common html formatting misbehaviors of browsers implementation when inserting
 * content via copy & paste contentEditable
 *
 * @author Christopher Blum
 */
wysihtml5.quirks.cleanPastedHTML = (function() {

  var styleToRegex = function (styleStr) {
    var trimmedStr = wysihtml5.lang.string(styleStr).trim(),
        escapedStr = trimmedStr.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");

    return new RegExp("^((?!^" + escapedStr + "$).)*$", "i");
  };

  var extendRulesWithStyleExceptions = function (rules, exceptStyles) {
    var newRules = wysihtml5.lang.object(rules).clone(true),
        tag, style;

    for (tag in newRules.tags) {

      if (newRules.tags.hasOwnProperty(tag)) {
        if (newRules.tags[tag].keep_styles) {
          for (style in newRules.tags[tag].keep_styles) {
            if (newRules.tags[tag].keep_styles.hasOwnProperty(style)) {
              if (exceptStyles[style]) {
                newRules.tags[tag].keep_styles[style] = styleToRegex(exceptStyles[style]);
              }
            }
          }
        }
      }
    }

    return newRules;
  };

  var pickRuleset = function(ruleset, html) {
    var pickedSet, defaultSet;

    if (!ruleset) {
      return null;
    }

    for (var i = 0, max = ruleset.length; i < max; i++) {
      if (!ruleset[i].condition) {
        defaultSet = ruleset[i].set;
      }
      if (ruleset[i].condition && ruleset[i].condition.test(html)) {
        return ruleset[i].set;
      }
    }

    return defaultSet;
  };

  return function(html, options) {
    var exceptStyles = {
          'color': wysihtml5.dom.getStyle("color").from(options.referenceNode),
          'fontSize': wysihtml5.dom.getStyle("font-size").from(options.referenceNode)
        },
        rules = extendRulesWithStyleExceptions(pickRuleset(options.rules, html) || {}, exceptStyles),
        newHtml;

    newHtml = wysihtml5.dom.parse(html, {
      "rules": rules,
      "cleanUp": true, // <span> elements, empty or without attributes, should be removed/replaced with their content
      "context": options.referenceNode.ownerDocument,
      "uneditableClass": options.uneditableClass,
      "clearInternals" : true, // don't paste temprorary selection and other markings
      "unjoinNbsps" : true
    });

    return newHtml;
  };

})();;/**
 * IE and Opera leave an empty paragraph in the contentEditable element after clearing it
 *
 * @param {Object} contentEditableElement The contentEditable element to observe for clearing events
 * @exaple
 *    wysihtml5.quirks.ensureProperClearing(myContentEditableElement);
 */
wysihtml5.quirks.ensureProperClearing = (function() {
  var clearIfNecessary = function() {
    var element = this;
    setTimeout(function() {
      var innerHTML = element.innerHTML.toLowerCase();
      if (innerHTML == "<p>&nbsp;</p>" ||
          innerHTML == "<p>&nbsp;</p><p>&nbsp;</p>") {
        element.innerHTML = "";
      }
    }, 0);
  };

  return function(composer) {
    wysihtml5.dom.observe(composer.element, ["cut", "keydown"], clearIfNecessary);
  };
})();
;// See https://bugzilla.mozilla.org/show_bug.cgi?id=664398
//
// In Firefox this:
//      var d = document.createElement("div");
//      d.innerHTML ='<a href="~"></a>';
//      d.innerHTML;
// will result in:
//      <a href="%7E"></a>
// which is wrong
(function(wysihtml5) {
  var TILDE_ESCAPED = "%7E";
  wysihtml5.quirks.getCorrectInnerHTML = function(element) {
    var innerHTML = element.innerHTML;
    if (innerHTML.indexOf(TILDE_ESCAPED) === -1) {
      return innerHTML;
    }

    var elementsWithTilde = element.querySelectorAll("[href*='~'], [src*='~']"),
        url,
        urlToSearch,
        length,
        i;
    for (i=0, length=elementsWithTilde.length; i<length; i++) {
      url         = elementsWithTilde[i].href || elementsWithTilde[i].src;
      urlToSearch = wysihtml5.lang.string(url).replace("~").by(TILDE_ESCAPED);
      innerHTML   = wysihtml5.lang.string(innerHTML).replace(urlToSearch).by(url);
    }
    return innerHTML;
  };
})(wysihtml5);
;/**
 * Force rerendering of a given element
 * Needed to fix display misbehaviors of IE
 *
 * @param {Element} element The element object which needs to be rerendered
 * @example
 *    wysihtml5.quirks.redraw(document.body);
 */
(function(wysihtml5) {
  var CLASS_NAME = "wysihtml5-quirks-redraw";

  wysihtml5.quirks.redraw = function(element) {
    wysihtml5.dom.addClass(element, CLASS_NAME);
    wysihtml5.dom.removeClass(element, CLASS_NAME);

    // Following hack is needed for firefox to make sure that image resize handles are properly removed
    try {
      var doc = element.ownerDocument;
      doc.execCommand("italic", false, null);
      doc.execCommand("italic", false, null);
    } catch(e) {}
  };
})(wysihtml5);
;wysihtml5.quirks.tableCellsSelection = function(editable, editor) {

    var dom = wysihtml5.dom,
        select = {
            table: null,
            start: null,
            end: null,
            cells: null,
            select: selectCells
        },
        selection_class = "wysiwyg-tmp-selected-cell",
        moveHandler = null,
        upHandler = null;

    function init () {

        dom.observe(editable, "mousedown", function(event) {
          var target = wysihtml5.dom.getParentElement(event.target, { nodeName: ["TD", "TH"] });
          if (target) {
              handleSelectionMousedown(target);
          }
        });

        return select;
    }

    function handleSelectionMousedown (target) {
      select.start = target;
      select.end = target;
      select.cells = [target];
      select.table = dom.getParentElement(select.start, { nodeName: ["TABLE"] });

      if (select.table) {
        removeCellSelections();
        dom.addClass(target, selection_class);
        moveHandler = dom.observe(editable, "mousemove", handleMouseMove);
        upHandler = dom.observe(editable, "mouseup", handleMouseUp);
        editor.fire("tableselectstart").fire("tableselectstart:composer");
      }
    }

    // remove all selection classes
    function removeCellSelections () {
        if (editable) {
            var selectedCells = editable.querySelectorAll('.' + selection_class);
            if (selectedCells.length > 0) {
              for (var i = 0; i < selectedCells.length; i++) {
                  dom.removeClass(selectedCells[i], selection_class);
              }
            }
        }
    }

    function addSelections (cells) {
      for (var i = 0; i < cells.length; i++) {
        dom.addClass(cells[i], selection_class);
      }
    }

    function handleMouseMove (event) {
      var curTable = null,
          cell = dom.getParentElement(event.target, { nodeName: ["TD","TH"] }),
          oldEnd;

      if (cell && select.table && select.start) {
        curTable =  dom.getParentElement(cell, { nodeName: ["TABLE"] });
        if (curTable && curTable === select.table) {
          removeCellSelections();
          oldEnd = select.end;
          select.end = cell;
          select.cells = dom.table.getCellsBetween(select.start, cell);
          if (select.cells.length > 1) {
            editor.composer.selection.deselect();
          }
          addSelections(select.cells);
          if (select.end !== oldEnd) {
            editor.fire("tableselectchange").fire("tableselectchange:composer");
          }
        }
      }
    }

    function handleMouseUp (event) {
      moveHandler.stop();
      upHandler.stop();
      editor.fire("tableselect").fire("tableselect:composer");
      setTimeout(function() {
        bindSideclick();
      },0);
    }

    function bindSideclick () {
        var sideClickHandler = dom.observe(editable.ownerDocument, "click", function(event) {
          sideClickHandler.stop();
          if (dom.getParentElement(event.target, { nodeName: ["TABLE"] }) != select.table) {
              removeCellSelections();
              select.table = null;
              select.start = null;
              select.end = null;
              editor.fire("tableunselect").fire("tableunselect:composer");
          }
        });
    }

    function selectCells (start, end) {
        select.start = start;
        select.end = end;
        select.table = dom.getParentElement(select.start, { nodeName: ["TABLE"] });
        selectedCells = dom.table.getCellsBetween(select.start, select.end);
        addSelections(selectedCells);
        bindSideclick();
        editor.fire("tableselect").fire("tableselect:composer");
    }

    return init();

};
;(function(wysihtml5) {
  var RGBA_REGEX     = /^rgba\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*([\d\.]+)\s*\)/i,
      RGB_REGEX      = /^rgb\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*\)/i,
      HEX6_REGEX     = /^#([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])/i,
      HEX3_REGEX     = /^#([0-9a-f])([0-9a-f])([0-9a-f])/i;

  var param_REGX = function (p) {
    return new RegExp("(^|\\s|;)" + p + "\\s*:\\s*[^;$]+" , "gi");
  };

  wysihtml5.quirks.styleParser = {

    parseColor: function(stylesStr, paramName) {
      var paramRegex = param_REGX(paramName),
          params = stylesStr.match(paramRegex),
          radix = 10,
          str, colorMatch;

      if (params) {
        for (var i = params.length; i--;) {
          params[i] = wysihtml5.lang.string(params[i].split(':')[1]).trim();
        }
        str = params[params.length-1];

        if (RGBA_REGEX.test(str)) {
          colorMatch = str.match(RGBA_REGEX);
        } else if (RGB_REGEX.test(str)) {
          colorMatch = str.match(RGB_REGEX);
        } else if (HEX6_REGEX.test(str)) {
          colorMatch = str.match(HEX6_REGEX);
          radix = 16;
        } else if (HEX3_REGEX.test(str)) {
          colorMatch = str.match(HEX3_REGEX);
          colorMatch.shift();
          colorMatch.push(1);
          return wysihtml5.lang.array(colorMatch).map(function(d, idx) {
            return (idx < 3) ? (parseInt(d, 16) * 16) + parseInt(d, 16): parseFloat(d);
          });
        }

        if (colorMatch) {
          colorMatch.shift();
          if (!colorMatch[3]) {
            colorMatch.push(1);
          }
          return wysihtml5.lang.array(colorMatch).map(function(d, idx) {
            return (idx < 3) ? parseInt(d, radix): parseFloat(d);
          });
        }
      }
      return false;
    },

    unparseColor: function(val, props) {
      if (props) {
        if (props == "hex") {
          return (val[0].toString(16).toUpperCase()) + (val[1].toString(16).toUpperCase()) + (val[2].toString(16).toUpperCase());
        } else if (props == "hash") {
          return "#" + (val[0].toString(16).toUpperCase()) + (val[1].toString(16).toUpperCase()) + (val[2].toString(16).toUpperCase());
        } else if (props == "rgb") {
          return "rgb(" + val[0] + "," + val[1] + "," + val[2] + ")";
        } else if (props == "rgba") {
          return "rgba(" + val[0] + "," + val[1] + "," + val[2] + "," + val[3] + ")";
        } else if (props == "csv") {
          return  val[0] + "," + val[1] + "," + val[2] + "," + val[3];
        }
      }

      if (val[3] && val[3] !== 1) {
        return "rgba(" + val[0] + "," + val[1] + "," + val[2] + "," + val[3] + ")";
      } else {
        return "rgb(" + val[0] + "," + val[1] + "," + val[2] + ")";
      }
    },

    parseFontSize: function(stylesStr) {
      var params = stylesStr.match(param_REGX('font-size'));
      if (params) {
        return wysihtml5.lang.string(params[params.length - 1].split(':')[1]).trim();
      }
      return false;
    }
  };

})(wysihtml5);
;/**
 * Selection API
 *
 * @example
 *    var selection = new wysihtml5.Selection(editor);
 */
(function(wysihtml5) {
  var dom = wysihtml5.dom;

  function _getCumulativeOffsetTop(element) {
    var top = 0;
    if (element.parentNode) {
      do {
        top += element.offsetTop || 0;
        element = element.offsetParent;
      } while (element);
    }
    return top;
  }

  // Provides the depth of ``descendant`` relative to ``ancestor``
  function getDepth(ancestor, descendant) {
      var ret = 0;
      while (descendant !== ancestor) {
          ret++;
          descendant = descendant.parentNode;
          if (!descendant)
              throw new Error("not a descendant of ancestor!");
      }
      return ret;
  }

  // Should fix the obtained ranges that cannot surrond contents normally to apply changes upon
  // Being considerate to firefox that sets range start start out of span and end inside on doubleclick initiated selection
  function expandRangeToSurround(range) {
      if (range.canSurroundContents()) return;

      var common = range.commonAncestorContainer,
          start_depth = getDepth(common, range.startContainer),
          end_depth = getDepth(common, range.endContainer);

      while(!range.canSurroundContents()) {
        // In the following branches, we cannot just decrement the depth variables because the setStartBefore/setEndAfter may move the start or end of the range more than one level relative to ``common``. So we need to recompute the depth.
        if (start_depth > end_depth) {
            range.setStartBefore(range.startContainer);
            start_depth = getDepth(common, range.startContainer);
        }
        else {
            range.setEndAfter(range.endContainer);
            end_depth = getDepth(common, range.endContainer);
        }
      }
  }

  wysihtml5.Selection = Base.extend(
    /** @scope wysihtml5.Selection.prototype */ {
    constructor: function(editor, contain, unselectableClass) {
      // Make sure that our external range library is initialized
      window.rangy.init();

      this.editor   = editor;
      this.composer = editor.composer;
      this.doc      = this.composer.doc;
      this.contain = contain;
      this.unselectableClass = unselectableClass || false;
    },

    /**
     * Get the current selection as a bookmark to be able to later restore it
     *
     * @return {Object} An object that represents the current selection
     */
    getBookmark: function() {
      var range = this.getRange();
      if (range) expandRangeToSurround(range);
      return range && range.cloneRange();
    },

    /**
     * Restore a selection retrieved via wysihtml5.Selection.prototype.getBookmark
     *
     * @param {Object} bookmark An object that represents the current selection
     */
    setBookmark: function(bookmark) {
      if (!bookmark) {
        return;
      }

      this.setSelection(bookmark);
    },

    /**
     * Set the caret in front of the given node
     *
     * @param {Object} node The element or text node where to position the caret in front of
     * @example
     *    selection.setBefore(myElement);
     */
    setBefore: function(node) {
      var range = rangy.createRange(this.doc);
      range.setStartBefore(node);
      range.setEndBefore(node);
      return this.setSelection(range);
    },

    // Constructs a self removing whitespace (ain absolute positioned span) for placing selection caret when normal methods fail.
    // Webkit has an issue with placing caret into places where there are no textnodes near by.
    creteTemporaryCaretSpaceAfter: function (node) {
      var caretPlaceholder = this.doc.createElement('span'),
          caretPlaceholderText = this.doc.createTextNode(wysihtml5.INVISIBLE_SPACE),
          placeholderRemover = (function(event) {
            // Self-destructs the caret and keeps the text inserted into it by user
            var lastChild;

            this.contain.removeEventListener('mouseup', placeholderRemover);
            this.contain.removeEventListener('keydown', keyDownHandler);
            this.contain.removeEventListener('touchstart', placeholderRemover);
            this.contain.removeEventListener('focus', placeholderRemover);
            this.contain.removeEventListener('blur', placeholderRemover);
            this.contain.removeEventListener('paste', delayedPlaceholderRemover);
            this.contain.removeEventListener('drop', delayedPlaceholderRemover);
            this.contain.removeEventListener('beforepaste', delayedPlaceholderRemover);

            // If user inserted sth it is in the placeholder and sgould be unwrapped and stripped of invisible whitespace hack
            // Otherwise the wrapper can just be removed
            if (caretPlaceholder && caretPlaceholder.parentNode) {
              caretPlaceholder.innerHTML = caretPlaceholder.innerHTML.replace(wysihtml5.INVISIBLE_SPACE_REG_EXP, "");
              if ((/[^\s]+/).test(caretPlaceholder.innerHTML)) {
                lastChild = caretPlaceholder.lastChild;
                wysihtml5.dom.unwrap(caretPlaceholder);
                this.setAfter(lastChild);
              } else {
                caretPlaceholder.parentNode.removeChild(caretPlaceholder);
              }

            }
          }).bind(this),
          delayedPlaceholderRemover = function (event) {
            if (caretPlaceholder && caretPlaceholder.parentNode) {
              setTimeout(placeholderRemover, 0);
            }
          },
          keyDownHandler = function(event) {
            if (event.which !== 8 && event.which !== 91 && event.which !== 17 && (event.which !== 86 || (!event.ctrlKey && !event.metaKey))) {
              placeholderRemover();
            }
          };

      caretPlaceholder.style.position = 'absolute';
      caretPlaceholder.style.display = 'block';
      caretPlaceholder.style.minWidth = '1px';
      caretPlaceholder.style.zIndex = '99999';
      caretPlaceholder.appendChild(caretPlaceholderText);

      node.parentNode.insertBefore(caretPlaceholder, node.nextSibling);
      this.setBefore(caretPlaceholderText);

      // Remove the caret fix on any of the following events (some are delayed as content change happens after event)
      this.contain.addEventListener('mouseup', placeholderRemover);
      this.contain.addEventListener('keydown', keyDownHandler);
      this.contain.addEventListener('touchstart', placeholderRemover);
      this.contain.addEventListener('focus', placeholderRemover);
      this.contain.addEventListener('blur', placeholderRemover);
      this.contain.addEventListener('paste', delayedPlaceholderRemover);
      this.contain.addEventListener('drop', delayedPlaceholderRemover);
      this.contain.addEventListener('beforepaste', delayedPlaceholderRemover);

      return caretPlaceholder;
    },

    /**
     * Set the caret after the given node
     *
     * @param {Object} node The element or text node where to position the caret in front of
     * @example
     *    selection.setBefore(myElement);
     */
    setAfter: function(node) {
      var range = rangy.createRange(this.doc),
          originalScrollTop = this.doc.documentElement.scrollTop || this.doc.body.scrollTop || this.doc.defaultView.pageYOffset,
          originalScrollLeft = this.doc.documentElement.scrollLeft || this.doc.body.scrollLeft || this.doc.defaultView.pageXOffset,
          sel;

      range.setStartAfter(node);
      range.setEndAfter(node);
      this.composer.element.focus();
      this.doc.defaultView.scrollTo(originalScrollLeft, originalScrollTop);
      sel = this.setSelection(range);

      // Webkit fails to add selection if there are no textnodes in that region
      // (like an uneditable container at the end of content).
      if (!sel) {
        this.creteTemporaryCaretSpaceAfter(node);
      }
      return sel;
    },

    /**
     * Ability to select/mark nodes
     *
     * @param {Element} node The node/element to select
     * @example
     *    selection.selectNode(document.getElementById("my-image"));
     */
    selectNode: function(node, avoidInvisibleSpace) {
      var range           = rangy.createRange(this.doc),
          isElement       = node.nodeType === wysihtml5.ELEMENT_NODE,
          canHaveHTML     = "canHaveHTML" in node ? node.canHaveHTML : (node.nodeName !== "IMG"),
          content         = isElement ? node.innerHTML : node.data,
          isEmpty         = (content === "" || content === wysihtml5.INVISIBLE_SPACE),
          displayStyle    = dom.getStyle("display").from(node),
          isBlockElement  = (displayStyle === "block" || displayStyle === "list-item");

      if (isEmpty && isElement && canHaveHTML && !avoidInvisibleSpace) {
        // Make sure that caret is visible in node by inserting a zero width no breaking space
        try { node.innerHTML = wysihtml5.INVISIBLE_SPACE; } catch(e) {}
      }

      if (canHaveHTML) {
        range.selectNodeContents(node);
      } else {
        range.selectNode(node);
      }

      if (canHaveHTML && isEmpty && isElement) {
        range.collapse(isBlockElement);
      } else if (canHaveHTML && isEmpty) {
        range.setStartAfter(node);
        range.setEndAfter(node);
      }

      this.setSelection(range);
    },

    /**
     * Get the node which contains the selection
     *
     * @param {Boolean} [controlRange] (only IE) Whether it should return the selected ControlRange element when the selection type is a "ControlRange"
     * @return {Object} The node that contains the caret
     * @example
     *    var nodeThatContainsCaret = selection.getSelectedNode();
     */
    getSelectedNode: function(controlRange) {
      var selection,
          range;

      if (controlRange && this.doc.selection && this.doc.selection.type === "Control") {
        range = this.doc.selection.createRange();
        if (range && range.length) {
          return range.item(0);
        }
      }

      selection = this.getSelection(this.doc);
      if (selection.focusNode === selection.anchorNode) {
        return selection.focusNode;
      } else {
        range = this.getRange(this.doc);
        return range ? range.commonAncestorContainer : this.doc.body;
      }
    },

    fixSelBorders: function() {
      var range = this.getRange();
      expandRangeToSurround(range);
      this.setSelection(range);
    },

    getSelectedOwnNodes: function(controlRange) {
      var selection,
          ranges = this.getOwnRanges(),
          ownNodes = [];

      for (var i = 0, maxi = ranges.length; i < maxi; i++) {
          ownNodes.push(ranges[i].commonAncestorContainer || this.doc.body);
      }
      return ownNodes;
    },

    findNodesInSelection: function(nodeTypes) {
      var ranges = this.getOwnRanges(),
          nodes = [], curNodes;
      for (var i = 0, maxi = ranges.length; i < maxi; i++) {
        curNodes = ranges[i].getNodes([1], function(node) {
            return wysihtml5.lang.array(nodeTypes).contains(node.nodeName);
        });
        nodes = nodes.concat(curNodes);
      }
      return nodes;
    },

    containsUneditable: function() {
      var uneditables = this.getOwnUneditables(),
          selection = this.getSelection();

      for (var i = 0, maxi = uneditables.length; i < maxi; i++) {
        if (selection.containsNode(uneditables[i])) {
          return true;
        }
      }

      return false;
    },

    // Deletes selection contents making sure uneditables/unselectables are not partially deleted
    // Triggers wysihtml5:uneditable:delete custom event on all deleted uneditables if customevents suppoorted
    deleteContents: function()  {
      var range = this.getRange(),
          startParent, endParent, uneditables, ev;

      if (this.unselectableClass) {
        if ((startParent = wysihtml5.dom.getParentElement(range.startContainer, { className: this.unselectableClass }, false, this.contain))) {
          range.setStartBefore(startParent);
        }
        if ((endParent = wysihtml5.dom.getParentElement(range.endContainer, { className: this.unselectableClass }, false, this.contain))) {
          range.setEndAfter(endParent);
        }

        // If customevents present notify uneditable elements of being deleted
        uneditables = range.getNodes([1], (function (node) {
          return wysihtml5.dom.hasClass(node, this.unselectableClass);
        }).bind(this));
        for (var i = uneditables.length; i--;) {
          try {
            ev = new CustomEvent("wysihtml5:uneditable:delete");
            uneditables[i].dispatchEvent(ev);
          } catch (err) {}
        }

      }
      range.deleteContents();
      this.setSelection(range);
    },

    getPreviousNode: function(node, ignoreEmpty) {
      var displayStyle;
      if (!node) {
        var selection = this.getSelection();
        node = selection.anchorNode;
      }

      if (node === this.contain) {
          return false;
      }

      var ret = node.previousSibling,
          parent;

      if (ret === this.contain) {
          return false;
      }

      if (ret && ret.nodeType !== 3 && ret.nodeType !== 1) {
         // do not count comments and other node types
         ret = this.getPreviousNode(ret, ignoreEmpty);
      } else if (ret && ret.nodeType === 3 && (/^\s*$/).test(ret.textContent)) {
        // do not count empty textnodes as previous nodes
        ret = this.getPreviousNode(ret, ignoreEmpty);
      } else if (ignoreEmpty && ret && ret.nodeType === 1) {
        // Do not count empty nodes if param set.
        // Contenteditable tends to bypass and delete these silently when deleting with caret when element is inline-like
        displayStyle = wysihtml5.dom.getStyle("display").from(ret);
        if (
            !wysihtml5.lang.array(["BR", "HR", "IMG"]).contains(ret.nodeName) &&
            !wysihtml5.lang.array(["block", "inline-block", "flex", "list-item", "table"]).contains(displayStyle) &&
            (/^[\s]*$/).test(ret.innerHTML)
          ) {
            ret = this.getPreviousNode(ret, ignoreEmpty);
          }
      } else if (!ret && node !== this.contain) {
        parent = node.parentNode;
        if (parent !== this.contain) {
            ret = this.getPreviousNode(parent, ignoreEmpty);
        }
      }

      return (ret !== this.contain) ? ret : false;
    },

    getSelectionParentsByTag: function(tagName) {
      var nodes = this.getSelectedOwnNodes(),
          curEl, parents = [];

      for (var i = 0, maxi = nodes.length; i < maxi; i++) {
        curEl = (nodes[i].nodeName &&  nodes[i].nodeName === 'LI') ? nodes[i] : wysihtml5.dom.getParentElement(nodes[i], { nodeName: ['LI']}, false, this.contain);
        if (curEl) {
          parents.push(curEl);
        }
      }
      return (parents.length) ? parents : null;
    },

    getRangeToNodeEnd: function() {
      if (this.isCollapsed()) {
        var range = this.getRange(),
            sNode = range.startContainer,
            pos = range.startOffset,
            lastR = rangy.createRange(this.doc);

        lastR.selectNodeContents(sNode);
        lastR.setStart(sNode, pos);
        return lastR;
      }
    },

    caretIsLastInSelection: function() {
      var r = rangy.createRange(this.doc),
          s = this.getSelection(),
          endc = this.getRangeToNodeEnd().cloneContents(),
          endtxt = endc.textContent;

      return (/^\s*$/).test(endtxt);
    },

    caretIsFirstInSelection: function() {
      var r = rangy.createRange(this.doc),
          s = this.getSelection(),
          range = this.getRange(),
          startNode = range.startContainer;
      
      if (startNode) {
        if (startNode.nodeType === wysihtml5.TEXT_NODE) {
          return this.isCollapsed() && (startNode.nodeType === wysihtml5.TEXT_NODE && (/^\s*$/).test(startNode.data.substr(0,range.startOffset)));
        } else {
          r.selectNodeContents(this.getRange().commonAncestorContainer);
          r.collapse(true);
          return (this.isCollapsed() && (r.startContainer === s.anchorNode || r.endContainer === s.anchorNode) && r.startOffset === s.anchorOffset);
        }
      }
    },

    caretIsInTheBeginnig: function(ofNode) {
        var selection = this.getSelection(),
            node = selection.anchorNode,
            offset = selection.anchorOffset;
        if (ofNode && node) {
          return (offset === 0 && (node.nodeName && node.nodeName === ofNode.toUpperCase() || wysihtml5.dom.getParentElement(node.parentNode, { nodeName: ofNode }, 1)));
        } else if (node) {
          return (offset === 0 && !this.getPreviousNode(node, true));
        }
    },

    caretIsBeforeUneditable: function() {
      var selection = this.getSelection(),
          node = selection.anchorNode,
          offset = selection.anchorOffset,
          childNodes = [],
          range, contentNodes, lastNode;

      if (node) {
        if (offset === 0) {
          var prevNode = this.getPreviousNode(node, true),
              prevLeaf = prevNode ? wysihtml5.dom.domNode(prevNode).lastLeafNode((this.unselectableClass) ? {leafClasses: [this.unselectableClass]} : false) : null;
          if (prevLeaf) {
            var uneditables = this.getOwnUneditables();
            for (var i = 0, maxi = uneditables.length; i < maxi; i++) {
              if (prevLeaf === uneditables[i]) {
                return uneditables[i];
              }
            }
          }
        } else {
          range = selection.getRangeAt(0);
          range.setStart(range.startContainer, range.startOffset - 1);
          // TODO: make getting children on range a separate funtion
          if (range) {
            contentNodes = range.getNodes([1,3]);
            for (var n = 0, max = contentNodes.length; n < max; n++) {
              if (contentNodes[n].parentNode && contentNodes[n].parentNode === node) {
                childNodes.push(contentNodes[n]);
              }
            }
          }
          lastNode = childNodes.length > 0 ? childNodes[childNodes.length -1] : null;
          if (lastNode && lastNode.nodeType === 1 && wysihtml5.dom.hasClass(lastNode, this.unselectableClass)) {
            return lastNode;
          }

        }
      }
      return false;
    },

    // TODO: Figure out a method from following 2 that would work universally
    executeAndRestoreRangy: function(method, restoreScrollPosition) {
      var win = this.doc.defaultView || this.doc.parentWindow,
          sel = rangy.saveSelection(win);

      if (!sel) {
        method();
      } else {
        try {
          method();
        } catch(e) {
          setTimeout(function() { throw e; }, 0);
        }
      }
      rangy.restoreSelection(sel);
    },

    // TODO: has problems in chrome 12. investigate block level and uneditable area inbetween
    executeAndRestore: function(method, restoreScrollPosition) {
      var body                  = this.doc.body,
          oldScrollTop          = restoreScrollPosition && body.scrollTop,
          oldScrollLeft         = restoreScrollPosition && body.scrollLeft,
          className             = "_wysihtml5-temp-placeholder",
          placeholderHtml       = '<span class="' + className + '">' + wysihtml5.INVISIBLE_SPACE + '</span>',
          range                 = this.getRange(true),
          caretPlaceholder,
          newCaretPlaceholder,
          nextSibling, prevSibling,
          node, node2, range2,
          newRange;

      // Nothing selected, execute and say goodbye
      if (!range) {
        method(body, body);
        return;
      }

      if (!range.collapsed) {
        range2 = range.cloneRange();
        node2 = range2.createContextualFragment(placeholderHtml);
        range2.collapse(false);
        range2.insertNode(node2);
        range2.detach();
      }

      node = range.createContextualFragment(placeholderHtml);
      range.insertNode(node);

      if (node2) {
        caretPlaceholder = this.contain.querySelectorAll("." + className);
        range.setStartBefore(caretPlaceholder[0]);
        range.setEndAfter(caretPlaceholder[caretPlaceholder.length -1]);
      }
      this.setSelection(range);

      // Make sure that a potential error doesn't cause our placeholder element to be left as a placeholder
      try {
        method(range.startContainer, range.endContainer);
      } catch(e) {
        setTimeout(function() { throw e; }, 0);
      }
      caretPlaceholder = this.contain.querySelectorAll("." + className);
      if (caretPlaceholder && caretPlaceholder.length) {
        newRange = rangy.createRange(this.doc);
        nextSibling = caretPlaceholder[0].nextSibling;
        if (caretPlaceholder.length > 1) {
          prevSibling = caretPlaceholder[caretPlaceholder.length -1].previousSibling;
        }
        if (prevSibling && nextSibling) {
          newRange.setStartBefore(nextSibling);
          newRange.setEndAfter(prevSibling);
        } else {
          newCaretPlaceholder = this.doc.createTextNode(wysihtml5.INVISIBLE_SPACE);
          dom.insert(newCaretPlaceholder).after(caretPlaceholder[0]);
          newRange.setStartBefore(newCaretPlaceholder);
          newRange.setEndAfter(newCaretPlaceholder);
        }
        this.setSelection(newRange);
        for (var i = caretPlaceholder.length; i--;) {
         caretPlaceholder[i].parentNode.removeChild(caretPlaceholder[i]);
        }

      } else {
        // fallback for when all hell breaks loose
        this.contain.focus();
      }

      if (restoreScrollPosition) {
        body.scrollTop  = oldScrollTop;
        body.scrollLeft = oldScrollLeft;
      }

      // Remove it again, just to make sure that the placeholder is definitely out of the dom tree
      try {
        caretPlaceholder.parentNode.removeChild(caretPlaceholder);
      } catch(e2) {}
    },

    set: function(node, offset) {
      var newRange = rangy.createRange(this.doc);
      newRange.setStart(node, offset || 0);
      this.setSelection(newRange);
    },

    /**
     * Insert html at the caret position and move the cursor after the inserted html
     *
     * @param {String} html HTML string to insert
     * @example
     *    selection.insertHTML("<p>foobar</p>");
     */
    insertHTML: function(html) {
      var range     = rangy.createRange(this.doc),
          node = this.doc.createElement('DIV'),
          fragment = this.doc.createDocumentFragment(),
          lastChild;

      node.innerHTML = html;
      lastChild = node.lastChild;

      while (node.firstChild) {
        fragment.appendChild(node.firstChild);
      }
      this.insertNode(fragment);

      if (lastChild) {
        this.setAfter(lastChild);
      }
    },

    /**
     * Insert a node at the caret position and move the cursor behind it
     *
     * @param {Object} node HTML string to insert
     * @example
     *    selection.insertNode(document.createTextNode("foobar"));
     */
    insertNode: function(node) {
      var range = this.getRange();
      if (range) {
        range.insertNode(node);
      }
    },

    /**
     * Wraps current selection with the given node
     *
     * @param {Object} node The node to surround the selected elements with
     */
    surround: function(nodeOptions) {
      var ranges = this.getOwnRanges(),
          node, nodes = [];
      if (ranges.length == 0) {
        return nodes;
      }

      for (var i = ranges.length; i--;) {
        node = this.doc.createElement(nodeOptions.nodeName);
        nodes.push(node);
        if (nodeOptions.className) {
          node.className = nodeOptions.className;
        }
        if (nodeOptions.cssStyle) {
          node.setAttribute('style', nodeOptions.cssStyle);
        }
        try {
          // This only works when the range boundaries are not overlapping other elements
          ranges[i].surroundContents(node);
          this.selectNode(node);
        } catch(e) {
          // fallback
          node.appendChild(ranges[i].extractContents());
          ranges[i].insertNode(node);
        }
      }
      return nodes;
    },

    deblockAndSurround: function(nodeOptions) {
      var tempElement = this.doc.createElement('div'),
          range = rangy.createRange(this.doc),
          tempDivElements,
          tempElements,
          firstChild;

      tempElement.className = nodeOptions.className;

      this.composer.commands.exec("formatBlock", nodeOptions.nodeName, nodeOptions.className);
      tempDivElements = this.contain.querySelectorAll("." + nodeOptions.className);
      if (tempDivElements[0]) {
        tempDivElements[0].parentNode.insertBefore(tempElement, tempDivElements[0]);

        range.setStartBefore(tempDivElements[0]);
        range.setEndAfter(tempDivElements[tempDivElements.length - 1]);
        tempElements = range.extractContents();

        while (tempElements.firstChild) {
          firstChild = tempElements.firstChild;
          if (firstChild.nodeType == 1 && wysihtml5.dom.hasClass(firstChild, nodeOptions.className)) {
            while (firstChild.firstChild) {
              tempElement.appendChild(firstChild.firstChild);
            }
            if (firstChild.nodeName !== "BR") { tempElement.appendChild(this.doc.createElement('br')); }
            tempElements.removeChild(firstChild);
          } else {
            tempElement.appendChild(firstChild);
          }
        }
      } else {
        tempElement = null;
      }

      return tempElement;
    },

    /**
     * Scroll the current caret position into the view
     * FIXME: This is a bit hacky, there might be a smarter way of doing this
     *
     * @example
     *    selection.scrollIntoView();
     */
    scrollIntoView: function() {
      var doc           = this.doc,
          tolerance     = 5, // px
          hasScrollBars = doc.documentElement.scrollHeight > doc.documentElement.offsetHeight,
          tempElement   = doc._wysihtml5ScrollIntoViewElement = doc._wysihtml5ScrollIntoViewElement || (function() {
            var element = doc.createElement("span");
            // The element needs content in order to be able to calculate it's position properly
            element.innerHTML = wysihtml5.INVISIBLE_SPACE;
            return element;
          })(),
          offsetTop;

      if (hasScrollBars) {
        this.insertNode(tempElement);
        offsetTop = _getCumulativeOffsetTop(tempElement);
        tempElement.parentNode.removeChild(tempElement);
        if (offsetTop >= (doc.body.scrollTop + doc.documentElement.offsetHeight - tolerance)) {
          doc.body.scrollTop = offsetTop;
        }
      }
    },

    /**
     * Select line where the caret is in
     */
    selectLine: function() {
      if (wysihtml5.browser.supportsSelectionModify()) {
        this._selectLine_W3C();
      } else if (this.doc.selection) {
        this._selectLine_MSIE();
      }
    },

    /**
     * See https://developer.mozilla.org/en/DOM/Selection/modify
     */
    _selectLine_W3C: function() {
      var win       = this.doc.defaultView,
          selection = win.getSelection();
      selection.modify("move", "left", "lineboundary");
      selection.modify("extend", "right", "lineboundary");
    },

    // collapses selection to current line beginning or end
    toLineBoundary: function (location, collapse) {
      collapse = (typeof collapse === 'undefined') ? false : collapse;
      if (wysihtml5.browser.supportsSelectionModify()) {
        var win = this.doc.defaultView,
            selection = win.getSelection();

        selection.modify("extend", location, "lineboundary");
        if (collapse) {
          if (location === "left") {
            selection.collapseToStart();
          } else if (location === "right") {
            selection.collapseToEnd();
          }
        }
      }
    },

    _selectLine_MSIE: function() {
      var range       = this.doc.selection.createRange(),
          rangeTop    = range.boundingTop,
          scrollWidth = this.doc.body.scrollWidth,
          rangeBottom,
          rangeEnd,
          measureNode,
          i,
          j;

      if (!range.moveToPoint) {
        return;
      }

      if (rangeTop === 0) {
        // Don't know why, but when the selection ends at the end of a line
        // range.boundingTop is 0
        measureNode = this.doc.createElement("span");
        this.insertNode(measureNode);
        rangeTop = measureNode.offsetTop;
        measureNode.parentNode.removeChild(measureNode);
      }

      rangeTop += 1;

      for (i=-10; i<scrollWidth; i+=2) {
        try {
          range.moveToPoint(i, rangeTop);
          break;
        } catch(e1) {}
      }

      // Investigate the following in order to handle multi line selections
      // rangeBottom = rangeTop + (rangeHeight ? (rangeHeight - 1) : 0);
      rangeBottom = rangeTop;
      rangeEnd = this.doc.selection.createRange();
      for (j=scrollWidth; j>=0; j--) {
        try {
          rangeEnd.moveToPoint(j, rangeBottom);
          break;
        } catch(e2) {}
      }

      range.setEndPoint("EndToEnd", rangeEnd);
      range.select();
    },

    getText: function() {
      var selection = this.getSelection();
      return selection ? selection.toString() : "";
    },

    getNodes: function(nodeType, filter) {
      var range = this.getRange();
      if (range) {
        return range.getNodes([nodeType], filter);
      } else {
        return [];
      }
    },

    fixRangeOverflow: function(range) {
      if (this.contain && this.contain.firstChild && range) {
        var containment = range.compareNode(this.contain);
        if (containment !== 2) {
          if (containment === 1) {
            range.setStartBefore(this.contain.firstChild);
          }
          if (containment === 0) {
            range.setEndAfter(this.contain.lastChild);
          }
          if (containment === 3) {
            range.setStartBefore(this.contain.firstChild);
            range.setEndAfter(this.contain.lastChild);
          }
        } else if (this._detectInlineRangeProblems(range)) {
          var previousElementSibling = range.endContainer.previousElementSibling;
          if (previousElementSibling) {
            range.setEnd(previousElementSibling, this._endOffsetForNode(previousElementSibling));
          }
        }
      }
    },

    _endOffsetForNode: function(node) {
      var range = document.createRange();
      range.selectNodeContents(node);
      return range.endOffset;
    },

    _detectInlineRangeProblems: function(range) {
      var position = dom.compareDocumentPosition(range.startContainer, range.endContainer);
      return (
        range.endOffset == 0 &&
        position & 4 //Node.DOCUMENT_POSITION_FOLLOWING
      );
    },

    getRange: function(dontFix) {
      var selection = this.getSelection(),
          range = selection && selection.rangeCount && selection.getRangeAt(0);

      if (dontFix !== true) {
        this.fixRangeOverflow(range);
      }

      return range;
    },

    getOwnUneditables: function() {
      var allUneditables = dom.query(this.contain, '.' + this.unselectableClass),
          deepUneditables = dom.query(allUneditables, '.' + this.unselectableClass);

      return wysihtml5.lang.array(allUneditables).without(deepUneditables);
    },

    // Returns an array of ranges that belong only to this editable
    // Needed as uneditable block in contenteditabel can split range into pieces
    // If manipulating content reverse loop is usually needed as manipulation can shift subsequent ranges
    getOwnRanges: function()  {
      var ranges = [],
          r = this.getRange(),
          tmpRanges;

      if (r) { ranges.push(r); }

      if (this.unselectableClass && this.contain && r) {
          var uneditables = this.getOwnUneditables(),
              tmpRange;
          if (uneditables.length > 0) {
            for (var i = 0, imax = uneditables.length; i < imax; i++) {
              tmpRanges = [];
              for (var j = 0, jmax = ranges.length; j < jmax; j++) {
                if (ranges[j]) {
                  switch (ranges[j].compareNode(uneditables[i])) {
                    case 2:
                      // all selection inside uneditable. remove
                    break;
                    case 3:
                      //section begins before and ends after uneditable. spilt
                      tmpRange = ranges[j].cloneRange();
                      tmpRange.setEndBefore(uneditables[i]);
                      tmpRanges.push(tmpRange);

                      tmpRange = ranges[j].cloneRange();
                      tmpRange.setStartAfter(uneditables[i]);
                      tmpRanges.push(tmpRange);
                    break;
                    default:
                      // in all other cases uneditable does not touch selection. dont modify
                      tmpRanges.push(ranges[j]);
                  }
                }
                ranges = tmpRanges;
              }
            }
          }
      }
      return ranges;
    },

    getSelection: function() {
      return rangy.getSelection(this.doc.defaultView || this.doc.parentWindow);
    },

    // Sets selection in document to a given range
    // Set selection method detects if it fails to set any selection in document and returns null on fail
    // (especially needed in webkit where some ranges just can not create selection for no reason)
    setSelection: function(range) {
      var win       = this.doc.defaultView || this.doc.parentWindow,
          selection = rangy.getSelection(win);
      selection.setSingleRange(range);
      return (selection && selection.anchorNode && selection.focusNode) ? selection : null;
    },

    createRange: function() {
      return rangy.createRange(this.doc);
    },

    isCollapsed: function() {
        return this.getSelection().isCollapsed;
    },

    getHtml: function() {
      return this.getSelection().toHtml();
    },

    getPlainText: function () {
      return this.getSelection().toString();
    },

    isEndToEndInNode: function(nodeNames) {
      var range = this.getRange(),
          parentElement = range.commonAncestorContainer,
          startNode = range.startContainer,
          endNode = range.endContainer;


        if (parentElement.nodeType === wysihtml5.TEXT_NODE) {
          parentElement = parentElement.parentNode;
        }

        if (startNode.nodeType === wysihtml5.TEXT_NODE && !(/^\s*$/).test(startNode.data.substr(range.startOffset))) {
          return false;
        }

        if (endNode.nodeType === wysihtml5.TEXT_NODE && !(/^\s*$/).test(endNode.data.substr(range.endOffset))) {
          return false;
        }

        while (startNode && startNode !== parentElement) {
          if (startNode.nodeType !== wysihtml5.TEXT_NODE && !wysihtml5.dom.contains(parentElement, startNode)) {
            return false;
          }
          if (wysihtml5.dom.domNode(startNode).prev({ignoreBlankTexts: true})) {
            return false;
          }
          startNode = startNode.parentNode;
        }

        while (endNode && endNode !== parentElement) {
          if (endNode.nodeType !== wysihtml5.TEXT_NODE && !wysihtml5.dom.contains(parentElement, endNode)) {
            return false;
          }
          if (wysihtml5.dom.domNode(endNode).next({ignoreBlankTexts: true})) {
            return false;
          }
          endNode = endNode.parentNode;
        }

        return (wysihtml5.lang.array(nodeNames).contains(parentElement.nodeName)) ? parentElement : false;
    },

    deselect: function() {
      var sel = this.getSelection();
      sel && sel.removeAllRanges();
    }
  });

})(wysihtml5);
;/**
 * Inspired by the rangy CSS Applier module written by Tim Down and licensed under the MIT license.
 * http://code.google.com/p/rangy/
 *
 * changed in order to be able ...
 *    - to use custom tags
 *    - to detect and replace similar css classes via reg exp
 */
(function(wysihtml5, rangy) {
  var defaultTagName = "span";

  var REG_EXP_WHITE_SPACE = /\s+/g;

  function hasClass(el, cssClass, regExp) {
    if (!el.className) {
      return false;
    }

    var matchingClassNames = el.className.match(regExp) || [];
    return matchingClassNames[matchingClassNames.length - 1] === cssClass;
  }

  function hasStyleAttr(el, regExp) {
    if (!el.getAttribute || !el.getAttribute('style')) {
      return false;
    }
    var matchingStyles = el.getAttribute('style').match(regExp);
    return  (el.getAttribute('style').match(regExp)) ? true : false;
  }

  function addStyle(el, cssStyle, regExp) {
    if (el.getAttribute('style')) {
      removeStyle(el, regExp);
      if (el.getAttribute('style') && !(/^\s*$/).test(el.getAttribute('style'))) {
        el.setAttribute('style', cssStyle + ";" + el.getAttribute('style'));
      } else {
        el.setAttribute('style', cssStyle);
      }
    } else {
      el.setAttribute('style', cssStyle);
    }
  }

  function addClass(el, cssClass, regExp) {
    if (el.className) {
      removeClass(el, regExp);
      el.className += " " + cssClass;
    } else {
      el.className = cssClass;
    }
  }

  function removeClass(el, regExp) {
    if (el.className) {
      el.className = el.className.replace(regExp, "");
    }
  }

  function removeStyle(el, regExp) {
    var s,
        s2 = [];
    if (el.getAttribute('style')) {
      s = el.getAttribute('style').split(';');
      for (var i = s.length; i--;) {
        if (!s[i].match(regExp) && !(/^\s*$/).test(s[i])) {
          s2.push(s[i]);
        }
      }
      if (s2.length) {
        el.setAttribute('style', s2.join(';'));
      } else {
        el.removeAttribute('style');
      }
    }
  }

  function getMatchingStyleRegexp(el, style) {
    var regexes = [],
        sSplit = style.split(';'),
        elStyle = el.getAttribute('style');

    if (elStyle) {
      elStyle = elStyle.replace(/\s/gi, '').toLowerCase();
      regexes.push(new RegExp("(^|\\s|;)" + style.replace(/\s/gi, '').replace(/([\(\)])/gi, "\\$1").toLowerCase().replace(";", ";?").replace(/rgb\\\((\d+),(\d+),(\d+)\\\)/gi, "\\s?rgb\\($1,\\s?$2,\\s?$3\\)"), "gi"));

      for (var i = sSplit.length; i-- > 0;) {
        if (!(/^\s*$/).test(sSplit[i])) {
          regexes.push(new RegExp("(^|\\s|;)" + sSplit[i].replace(/\s/gi, '').replace(/([\(\)])/gi, "\\$1").toLowerCase().replace(";", ";?").replace(/rgb\\\((\d+),(\d+),(\d+)\\\)/gi, "\\s?rgb\\($1,\\s?$2,\\s?$3\\)"), "gi"));
        }
      }
      for (var j = 0, jmax = regexes.length; j < jmax; j++) {
        if (elStyle.match(regexes[j])) {
          return regexes[j];
        }
      }
    }

    return false;
  }

  function isMatchingAllready(node, tags, style, className) {
    if (style) {
      return getMatchingStyleRegexp(node, style);
    } else if (className) {
      return wysihtml5.dom.hasClass(node, className);
    } else {
      return rangy.dom.arrayContains(tags, node.tagName.toLowerCase());
    }
  }

  function areMatchingAllready(nodes, tags, style, className) {
    for (var i = nodes.length; i--;) {
      if (!isMatchingAllready(nodes[i], tags, style, className)) {
        return false;
      }
    }
    return nodes.length ? true : false;
  }

  function removeOrChangeStyle(el, style, regExp) {

    var exactRegex = getMatchingStyleRegexp(el, style);
    if (exactRegex) {
      // adding same style value on property again removes style
      removeStyle(el, exactRegex);
      return "remove";
    } else {
      // adding new style value changes value
      addStyle(el, style, regExp);
      return "change";
    }
  }

  function hasSameClasses(el1, el2) {
    return el1.className.replace(REG_EXP_WHITE_SPACE, " ") == el2.className.replace(REG_EXP_WHITE_SPACE, " ");
  }

  function replaceWithOwnChildren(el) {
    var parent = el.parentNode;
    while (el.firstChild) {
      parent.insertBefore(el.firstChild, el);
    }
    parent.removeChild(el);
  }

  function elementsHaveSameNonClassAttributes(el1, el2) {
    if (el1.attributes.length != el2.attributes.length) {
      return false;
    }
    for (var i = 0, len = el1.attributes.length, attr1, attr2, name; i < len; ++i) {
      attr1 = el1.attributes[i];
      name = attr1.name;
      if (name != "class") {
        attr2 = el2.attributes.getNamedItem(name);
        if (attr1.specified != attr2.specified) {
          return false;
        }
        if (attr1.specified && attr1.nodeValue !== attr2.nodeValue) {
          return false;
        }
      }
    }
    return true;
  }

  function isSplitPoint(node, offset) {
    if (rangy.dom.isCharacterDataNode(node)) {
      if (offset == 0) {
        return !!node.previousSibling;
      } else if (offset == node.length) {
        return !!node.nextSibling;
      } else {
        return true;
      }
    }

    return offset > 0 && offset < node.childNodes.length;
  }

  function splitNodeAt(node, descendantNode, descendantOffset, container) {
    var newNode;
    if (rangy.dom.isCharacterDataNode(descendantNode)) {
      if (descendantOffset == 0) {
        descendantOffset = rangy.dom.getNodeIndex(descendantNode);
        descendantNode = descendantNode.parentNode;
      } else if (descendantOffset == descendantNode.length) {
        descendantOffset = rangy.dom.getNodeIndex(descendantNode) + 1;
        descendantNode = descendantNode.parentNode;
      } else {
        newNode = rangy.dom.splitDataNode(descendantNode, descendantOffset);
      }
    }
    if (!newNode) {
      if (!container || descendantNode !== container) {

        newNode = descendantNode.cloneNode(false);
        if (newNode.id) {
          newNode.removeAttribute("id");
        }
        var child;
        while ((child = descendantNode.childNodes[descendantOffset])) {
          newNode.appendChild(child);
        }
        rangy.dom.insertAfter(newNode, descendantNode);

      }
    }
    return (descendantNode == node) ? newNode :  splitNodeAt(node, newNode.parentNode, rangy.dom.getNodeIndex(newNode), container);
  }

  function Merge(firstNode) {
    this.isElementMerge = (firstNode.nodeType == wysihtml5.ELEMENT_NODE);
    this.firstTextNode = this.isElementMerge ? firstNode.lastChild : firstNode;
    this.textNodes = [this.firstTextNode];
  }

  Merge.prototype = {
    doMerge: function() {
      var textBits = [], textNode, parent, text;
      for (var i = 0, len = this.textNodes.length; i < len; ++i) {
        textNode = this.textNodes[i];
        parent = textNode.parentNode;
        textBits[i] = textNode.data;
        if (i) {
          parent.removeChild(textNode);
          if (!parent.hasChildNodes()) {
            parent.parentNode.removeChild(parent);
          }
        }
      }
      this.firstTextNode.data = text = textBits.join("");
      return text;
    },

    getLength: function() {
      var i = this.textNodes.length, len = 0;
      while (i--) {
        len += this.textNodes[i].length;
      }
      return len;
    },

    toString: function() {
      var textBits = [];
      for (var i = 0, len = this.textNodes.length; i < len; ++i) {
        textBits[i] = "'" + this.textNodes[i].data + "'";
      }
      return "[Merge(" + textBits.join(",") + ")]";
    }
  };

  function HTMLApplier(tagNames, cssClass, similarClassRegExp, normalize, cssStyle, similarStyleRegExp, container) {
    this.tagNames = tagNames || [defaultTagName];
    this.cssClass = cssClass || ((cssClass === false) ? false : "");
    this.similarClassRegExp = similarClassRegExp;
    this.cssStyle = cssStyle || "";
    this.similarStyleRegExp = similarStyleRegExp;
    this.normalize = normalize;
    this.applyToAnyTagName = false;
    this.container = container;
  }

  HTMLApplier.prototype = {
    getAncestorWithClass: function(node) {
      var cssClassMatch;
      while (node) {
        cssClassMatch = this.cssClass ? hasClass(node, this.cssClass, this.similarClassRegExp) : (this.cssStyle !== "") ? false : true;
        if (node.nodeType == wysihtml5.ELEMENT_NODE && node.getAttribute("contenteditable") != "false" &&  rangy.dom.arrayContains(this.tagNames, node.tagName.toLowerCase()) && cssClassMatch) {
          return node;
        }
        node = node.parentNode;
      }
      return false;
    },

    // returns parents of node with given style attribute
    getAncestorWithStyle: function(node) {
      var cssStyleMatch;
      while (node) {
        cssStyleMatch = this.cssStyle ? hasStyleAttr(node, this.similarStyleRegExp) : false;

        if (node.nodeType == wysihtml5.ELEMENT_NODE && node.getAttribute("contenteditable") != "false" && rangy.dom.arrayContains(this.tagNames, node.tagName.toLowerCase()) && cssStyleMatch) {
          return node;
        }
        node = node.parentNode;
      }
      return false;
    },

    getMatchingAncestor: function(node) {
      var ancestor = this.getAncestorWithClass(node),
          matchType = false;

      if (!ancestor) {
        ancestor = this.getAncestorWithStyle(node);
        if (ancestor) {
          matchType = "style";
        }
      } else {
        if (this.cssStyle) {
          matchType = "class";
        }
      }

      return {
        "element": ancestor,
        "type": matchType
      };
    },

    // Normalizes nodes after applying a CSS class to a Range.
    postApply: function(textNodes, range) {
      var firstNode = textNodes[0], lastNode = textNodes[textNodes.length - 1];

      var merges = [], currentMerge;

      var rangeStartNode = firstNode, rangeEndNode = lastNode;
      var rangeStartOffset = 0, rangeEndOffset = lastNode.length;

      var textNode, precedingTextNode;

      for (var i = 0, len = textNodes.length; i < len; ++i) {
        textNode = textNodes[i];
        precedingTextNode = null;
        if (textNode && textNode.parentNode) {
          precedingTextNode = this.getAdjacentMergeableTextNode(textNode.parentNode, false);
        }
        if (precedingTextNode) {
          if (!currentMerge) {
            currentMerge = new Merge(precedingTextNode);
            merges.push(currentMerge);
          }
          currentMerge.textNodes.push(textNode);
          if (textNode === firstNode) {
            rangeStartNode = currentMerge.firstTextNode;
            rangeStartOffset = rangeStartNode.length;
          }
          if (textNode === lastNode) {
            rangeEndNode = currentMerge.firstTextNode;
            rangeEndOffset = currentMerge.getLength();
          }
        } else {
          currentMerge = null;
        }
      }
      // Test whether the first node after the range needs merging
      if(lastNode && lastNode.parentNode) {
        var nextTextNode = this.getAdjacentMergeableTextNode(lastNode.parentNode, true);
        if (nextTextNode) {
          if (!currentMerge) {
            currentMerge = new Merge(lastNode);
            merges.push(currentMerge);
          }
          currentMerge.textNodes.push(nextTextNode);
        }
      }
      // Do the merges
      if (merges.length) {
        for (i = 0, len = merges.length; i < len; ++i) {
          merges[i].doMerge();
        }
        // Set the range boundaries
        range.setStart(rangeStartNode, rangeStartOffset);
        range.setEnd(rangeEndNode, rangeEndOffset);
      }
    },

    getAdjacentMergeableTextNode: function(node, forward) {
        var isTextNode = (node.nodeType == wysihtml5.TEXT_NODE);
        var el = isTextNode ? node.parentNode : node;
        var adjacentNode;
        var propName = forward ? "nextSibling" : "previousSibling";
        if (isTextNode) {
          // Can merge if the node's previous/next sibling is a text node
          adjacentNode = node[propName];
          if (adjacentNode && adjacentNode.nodeType == wysihtml5.TEXT_NODE) {
            return adjacentNode;
          }
        } else {
          // Compare element with its sibling
          adjacentNode = el[propName];
          if (adjacentNode && this.areElementsMergeable(node, adjacentNode)) {
            return adjacentNode[forward ? "firstChild" : "lastChild"];
          }
        }
        return null;
    },

    areElementsMergeable: function(el1, el2) {
      return rangy.dom.arrayContains(this.tagNames, (el1.tagName || "").toLowerCase())
        && rangy.dom.arrayContains(this.tagNames, (el2.tagName || "").toLowerCase())
        && hasSameClasses(el1, el2)
        && elementsHaveSameNonClassAttributes(el1, el2);
    },

    createContainer: function(doc) {
      var el = doc.createElement(this.tagNames[0]);
      if (this.cssClass) {
        el.className = this.cssClass;
      }
      if (this.cssStyle) {
        el.setAttribute('style', this.cssStyle);
      }
      return el;
    },

    applyToTextNode: function(textNode) {
      var parent = textNode.parentNode;
      if (parent.childNodes.length == 1 && rangy.dom.arrayContains(this.tagNames, parent.tagName.toLowerCase())) {

        if (this.cssClass) {
          addClass(parent, this.cssClass, this.similarClassRegExp);
        }
        if (this.cssStyle) {
          addStyle(parent, this.cssStyle, this.similarStyleRegExp);
        }
      } else {
        var el = this.createContainer(rangy.dom.getDocument(textNode));
        textNode.parentNode.insertBefore(el, textNode);
        el.appendChild(textNode);
      }
    },

    isRemovable: function(el) {
      return rangy.dom.arrayContains(this.tagNames, el.tagName.toLowerCase()) &&
              wysihtml5.lang.string(el.className).trim() === "" &&
              (
                !el.getAttribute('style') ||
                wysihtml5.lang.string(el.getAttribute('style')).trim() === ""
              );
    },

    undoToTextNode: function(textNode, range, ancestorWithClass, ancestorWithStyle) {
      var styleMode = (ancestorWithClass) ? false : true,
          ancestor = ancestorWithClass || ancestorWithStyle,
          styleChanged = false;
      if (!range.containsNode(ancestor)) {
        // Split out the portion of the ancestor from which we can remove the CSS class
        var ancestorRange = range.cloneRange();
            ancestorRange.selectNode(ancestor);

        if (ancestorRange.isPointInRange(range.endContainer, range.endOffset) && isSplitPoint(range.endContainer, range.endOffset)) {
            splitNodeAt(ancestor, range.endContainer, range.endOffset, this.container);
            range.setEndAfter(ancestor);
        }
        if (ancestorRange.isPointInRange(range.startContainer, range.startOffset) && isSplitPoint(range.startContainer, range.startOffset)) {
            ancestor = splitNodeAt(ancestor, range.startContainer, range.startOffset, this.container);
        }
      }

      if (!styleMode && this.similarClassRegExp) {
        removeClass(ancestor, this.similarClassRegExp);
      }

      if (styleMode && this.similarStyleRegExp) {
        styleChanged = (removeOrChangeStyle(ancestor, this.cssStyle, this.similarStyleRegExp) === "change");
      }
      if (this.isRemovable(ancestor) && !styleChanged) {
        replaceWithOwnChildren(ancestor);
      }
    },

    applyToRange: function(range) {
        var textNodes;
        for (var ri = range.length; ri--;) {
            textNodes = range[ri].getNodes([wysihtml5.TEXT_NODE]);

            if (!textNodes.length) {
              try {
                var node = this.createContainer(range[ri].endContainer.ownerDocument);
                range[ri].surroundContents(node);
                this.selectNode(range[ri], node);
                return;
              } catch(e) {}
            }

            range[ri].splitBoundaries();
            textNodes = range[ri].getNodes([wysihtml5.TEXT_NODE]);
            if (textNodes.length) {
              var textNode;

              for (var i = 0, len = textNodes.length; i < len; ++i) {
                textNode = textNodes[i];
                if (!this.getMatchingAncestor(textNode).element) {
                  this.applyToTextNode(textNode);
                }
              }

              range[ri].setStart(textNodes[0], 0);
              textNode = textNodes[textNodes.length - 1];
              range[ri].setEnd(textNode, textNode.length);

              if (this.normalize) {
                this.postApply(textNodes, range[ri]);
              }
            }

        }
    },

    undoToRange: function(range) {
      var textNodes, textNode, ancestorWithClass, ancestorWithStyle, ancestor;
      for (var ri = range.length; ri--;) {

          textNodes = range[ri].getNodes([wysihtml5.TEXT_NODE]);
          if (textNodes.length) {
            range[ri].splitBoundaries();
            textNodes = range[ri].getNodes([wysihtml5.TEXT_NODE]);
          } else {
            var doc = range[ri].endContainer.ownerDocument,
                node = doc.createTextNode(wysihtml5.INVISIBLE_SPACE);
            range[ri].insertNode(node);
            range[ri].selectNode(node);
            textNodes = [node];
          }

          for (var i = 0, len = textNodes.length; i < len; ++i) {
            if (range[ri].isValid()) {
              textNode = textNodes[i];

              ancestor = this.getMatchingAncestor(textNode);
              if (ancestor.type === "style") {
                this.undoToTextNode(textNode, range[ri], false, ancestor.element);
              } else if (ancestor.element) {
                this.undoToTextNode(textNode, range[ri], ancestor.element);
              }
            }
          }

          if (len == 1) {
            this.selectNode(range[ri], textNodes[0]);
          } else {
            range[ri].setStart(textNodes[0], 0);
            textNode = textNodes[textNodes.length - 1];
            range[ri].setEnd(textNode, textNode.length);

            if (this.normalize) {
              this.postApply(textNodes, range[ri]);
            }
          }

      }
    },

    selectNode: function(range, node) {
      var isElement       = node.nodeType === wysihtml5.ELEMENT_NODE,
          canHaveHTML     = "canHaveHTML" in node ? node.canHaveHTML : true,
          content         = isElement ? node.innerHTML : node.data,
          isEmpty         = (content === "" || content === wysihtml5.INVISIBLE_SPACE);

      if (isEmpty && isElement && canHaveHTML) {
        // Make sure that caret is visible in node by inserting a zero width no breaking space
        try { node.innerHTML = wysihtml5.INVISIBLE_SPACE; } catch(e) {}
      }
      range.selectNodeContents(node);
      if (isEmpty && isElement) {
        range.collapse(false);
      } else if (isEmpty) {
        range.setStartAfter(node);
        range.setEndAfter(node);
      }
    },

    getTextSelectedByRange: function(textNode, range) {
      var textRange = range.cloneRange();
      textRange.selectNodeContents(textNode);

      var intersectionRange = textRange.intersection(range);
      var text = intersectionRange ? intersectionRange.toString() : "";
      textRange.detach();

      return text;
    },

    isAppliedToRange: function(range) {
      var ancestors = [],
          appliedType = "full",
          ancestor, styleAncestor, textNodes;

      for (var ri = range.length; ri--;) {

        textNodes = range[ri].getNodes([wysihtml5.TEXT_NODE]);
        if (!textNodes.length) {
          ancestor = this.getMatchingAncestor(range[ri].startContainer).element;

          return (ancestor) ? {
            "elements": [ancestor],
            "coverage": appliedType
          } : false;
        }

        for (var i = 0, len = textNodes.length, selectedText; i < len; ++i) {
          selectedText = this.getTextSelectedByRange(textNodes[i], range[ri]);
          ancestor = this.getMatchingAncestor(textNodes[i]).element;
          if (ancestor && selectedText != "") {
            ancestors.push(ancestor);

            if (wysihtml5.dom.getTextNodes(ancestor, true).length === 1) {
              appliedType = "full";
            } else if (appliedType === "full") {
              appliedType = "inline";
            }
          } else if (!ancestor) {
            appliedType = "partial";
          }
        }

      }

      return (ancestors.length) ? {
        "elements": ancestors,
        "coverage": appliedType
      } : false;
    },

    toggleRange: function(range) {
      var isApplied = this.isAppliedToRange(range),
          parentsExactMatch;

      if (isApplied) {
        if (isApplied.coverage === "full") {
          this.undoToRange(range);
        } else if (isApplied.coverage === "inline") {
          parentsExactMatch = areMatchingAllready(isApplied.elements, this.tagNames, this.cssStyle, this.cssClass);
          this.undoToRange(range);
          if (!parentsExactMatch) {
            this.applyToRange(range);
          }
        } else {
          // partial
          if (!areMatchingAllready(isApplied.elements, this.tagNames, this.cssStyle, this.cssClass)) {
            this.undoToRange(range);
          }
          this.applyToRange(range);
        }
      } else {
        this.applyToRange(range);
      }
    }
  };

  wysihtml5.selection.HTMLApplier = HTMLApplier;

})(wysihtml5, rangy);
;/**
 * Rich Text Query/Formatting Commands
 *
 * @example
 *    var commands = new wysihtml5.Commands(editor);
 */
wysihtml5.Commands = Base.extend(
  /** @scope wysihtml5.Commands.prototype */ {
  constructor: function(editor) {
    this.editor   = editor;
    this.composer = editor.composer;
    this.doc      = this.composer.doc;
  },

  /**
   * Check whether the browser supports the given command
   *
   * @param {String} command The command string which to check (eg. "bold", "italic", "insertUnorderedList")
   * @example
   *    commands.supports("createLink");
   */
  support: function(command) {
    return wysihtml5.browser.supportsCommand(this.doc, command);
  },

  /**
   * Check whether the browser supports the given command
   *
   * @param {String} command The command string which to execute (eg. "bold", "italic", "insertUnorderedList")
   * @param {String} [value] The command value parameter, needed for some commands ("createLink", "insertImage", ...), optional for commands that don't require one ("bold", "underline", ...)
   * @example
   *    commands.exec("insertImage", "http://a1.twimg.com/profile_images/113868655/schrei_twitter_reasonably_small.jpg");
   */
  exec: function(command, value) {
    var obj     = wysihtml5.commands[command],
        args    = wysihtml5.lang.array(arguments).get(),
        method  = obj && obj.exec,
        result  = null;

    // If composer ahs placeholder unset it before command
    // Do not apply on commands that are behavioral 
    if (this.composer.hasPlaceholderSet() && !wysihtml5.lang.array(['styleWithCSS', 'enableObjectResizing', 'enableInlineTableEditing']).contains(command)) {
      this.composer.element.innerHTML = "";
      this.composer.selection.selectNode(this.composer.element);
    }

    this.editor.fire("beforecommand:composer");

    if (method) {
      args.unshift(this.composer);
      result = method.apply(obj, args);
    } else {
      try {
        // try/catch for buggy firefox
        result = this.doc.execCommand(command, false, value);
      } catch(e) {}
    }

    this.editor.fire("aftercommand:composer");
    return result;
  },

  /**
   * Check whether the current command is active
   * If the caret is within a bold text, then calling this with command "bold" should return true
   *
   * @param {String} command The command string which to check (eg. "bold", "italic", "insertUnorderedList")
   * @param {String} [commandValue] The command value parameter (eg. for "insertImage" the image src)
   * @return {Boolean} Whether the command is active
   * @example
   *    var isCurrentSelectionBold = commands.state("bold");
   */
  state: function(command, commandValue) {
    var obj     = wysihtml5.commands[command],
        args    = wysihtml5.lang.array(arguments).get(),
        method  = obj && obj.state;
    if (method) {
      args.unshift(this.composer);
      return method.apply(obj, args);
    } else {
      try {
        // try/catch for buggy firefox
        return this.doc.queryCommandState(command);
      } catch(e) {
        return false;
      }
    }
  },

  /* Get command state parsed value if command has stateValue parsing function */
  stateValue: function(command) {
    var obj     = wysihtml5.commands[command],
        args    = wysihtml5.lang.array(arguments).get(),
        method  = obj && obj.stateValue;
    if (method) {
      args.unshift(this.composer);
      return method.apply(obj, args);
    } else {
      return false;
    }
  }
});
;wysihtml5.commands.bold = {
  exec: function(composer, command) {
    wysihtml5.commands.formatInline.execWithToggle(composer, command, "b");
  },

  state: function(composer, command) {
    // element.ownerDocument.queryCommandState("bold") results:
    // firefox: only <b>
    // chrome:  <b>, <strong>, <h1>, <h2>, ...
    // ie:      <b>, <strong>
    // opera:   <b>, <strong>
    return wysihtml5.commands.formatInline.state(composer, command, "b");
  }
};

;(function(wysihtml5) {
  var undef,
      NODE_NAME = "A",
      dom       = wysihtml5.dom;

  function _format(composer, attributes) {
    var doc             = composer.doc,
        tempClass       = "_wysihtml5-temp-" + (+new Date()),
        tempClassRegExp = /non-matching-class/g,
        i               = 0,
        length,
        anchors,
        anchor,
        hasElementChild,
        isEmpty,
        elementToSetCaretAfter,
        textContent,
        whiteSpace,
        j;
    wysihtml5.commands.formatInline.exec(composer, undef, NODE_NAME, tempClass, tempClassRegExp, undef, undef, true, true);
    anchors = doc.querySelectorAll(NODE_NAME + "." + tempClass);
    length  = anchors.length;
    for (; i<length; i++) {
      anchor = anchors[i];
      anchor.removeAttribute("class");
      for (j in attributes) {
        // Do not set attribute "text" as it is meant for setting string value if created link has no textual data
        if (j !== "text") {
          anchor.setAttribute(j, attributes[j]);
        }
      }
    }

    elementToSetCaretAfter = anchor;
    if (length === 1) {
      textContent = dom.getTextContent(anchor);
      hasElementChild = !!anchor.querySelector("*");
      isEmpty = textContent === "" || textContent === wysihtml5.INVISIBLE_SPACE;
      if (!hasElementChild && isEmpty) {
        dom.setTextContent(anchor, attributes.text || anchor.href);
        whiteSpace = doc.createTextNode(" ");
        composer.selection.setAfter(anchor);
        dom.insert(whiteSpace).after(anchor);
        elementToSetCaretAfter = whiteSpace;
      }
    }
    composer.selection.setAfter(elementToSetCaretAfter);
  }

  // Changes attributes of links
  function _changeLinks(composer, anchors, attributes) {
    var oldAttrs;
    for (var a = anchors.length; a--;) {

      // Remove all old attributes
      oldAttrs = anchors[a].attributes;
      for (var oa = oldAttrs.length; oa--;) {
        anchors[a].removeAttribute(oldAttrs.item(oa).name);
      }

      // Set new attributes
      for (var j in attributes) {
        if (attributes.hasOwnProperty(j)) {
          anchors[a].setAttribute(j, attributes[j]);
        }
      }

    }
  }

  wysihtml5.commands.createLink = {
    /**
     * TODO: Use HTMLApplier or formatInline here
     *
     * Turns selection into a link
     * If selection is already a link, it just changes the attributes
     *
     * @example
     *    // either ...
     *    wysihtml5.commands.createLink.exec(composer, "createLink", "http://www.google.de");
     *    // ... or ...
     *    wysihtml5.commands.createLink.exec(composer, "createLink", { href: "http://www.google.de", target: "_blank" });
     */
    exec: function(composer, command, value) {
      var anchors = this.state(composer, command);
      if (anchors) {
        // Selection contains links then change attributes of these links
        composer.selection.executeAndRestore(function() {
          _changeLinks(composer, anchors, value);
        });
      } else {
        // Create links
        value = typeof(value) === "object" ? value : { href: value };
        _format(composer, value);
      }
    },

    state: function(composer, command) {
      return wysihtml5.commands.formatInline.state(composer, command, "A");
    }
  };
})(wysihtml5);
;(function(wysihtml5) {
  var dom = wysihtml5.dom;

  function _removeFormat(composer, anchors) {
    var length  = anchors.length,
        i       = 0,
        anchor,
        codeElement,
        textContent;
    for (; i<length; i++) {
      anchor      = anchors[i];
      codeElement = dom.getParentElement(anchor, { nodeName: "code" });
      textContent = dom.getTextContent(anchor);

      // if <a> contains url-like text content, rename it to <code> to prevent re-autolinking
      // else replace <a> with its childNodes
      if (textContent.match(dom.autoLink.URL_REG_EXP) && !codeElement) {
        // <code> element is used to prevent later auto-linking of the content
        codeElement = dom.renameElement(anchor, "code");
      } else {
        dom.replaceWithChildNodes(anchor);
      }
    }
  }

  wysihtml5.commands.removeLink = {
    /*
     * If selection is a link, it removes the link and wraps it with a <code> element
     * The <code> element is needed to avoid auto linking
     *
     * @example
     *    wysihtml5.commands.createLink.exec(composer, "removeLink");
     */

    exec: function(composer, command) {
      var anchors = this.state(composer, command);
      if (anchors) {
        composer.selection.executeAndRestore(function() {
          _removeFormat(composer, anchors);
        });
      }
    },

    state: function(composer, command) {
      return wysihtml5.commands.formatInline.state(composer, command, "A");
    }
  };
})(wysihtml5);
;/**
 * document.execCommand("fontSize") will create either inline styles (firefox, chrome) or use font tags
 * which we don't want
 * Instead we set a css class
 */
(function(wysihtml5) {
  var REG_EXP = /wysiwyg-font-size-[0-9a-z\-]+/g;

  wysihtml5.commands.fontSize = {
    exec: function(composer, command, size) {
        wysihtml5.commands.formatInline.execWithToggle(composer, command, "span", "wysiwyg-font-size-" + size, REG_EXP);
    },

    state: function(composer, command, size) {
      return wysihtml5.commands.formatInline.state(composer, command, "span", "wysiwyg-font-size-" + size, REG_EXP);
    }
  };
})(wysihtml5);
;/* In case font size adjustment to any number defined by user is preferred, we cannot use classes and must use inline styles. */
(function(wysihtml5) {
  var REG_EXP = /(\s|^)font-size\s*:\s*[^;\s]+;?/gi;

  wysihtml5.commands.fontSizeStyle = {
    exec: function(composer, command, size) {
      size = (typeof(size) == "object") ? size.size : size;
      if (!(/^\s*$/).test(size)) {
        wysihtml5.commands.formatInline.execWithToggle(composer, command, "span", false, false, "font-size:" + size, REG_EXP);
      }
    },

    state: function(composer, command, size) {
      return wysihtml5.commands.formatInline.state(composer, command, "span", false, false, "font-size", REG_EXP);
    },

    stateValue: function(composer, command) {
      var st = this.state(composer, command),
          styleStr, fontsizeMatches,
          val = false;

      if (st && wysihtml5.lang.object(st).isArray()) {
          st = st[0];
      }
      if (st) {
        styleStr = st.getAttribute('style');
        if (styleStr) {
          return wysihtml5.quirks.styleParser.parseFontSize(styleStr);
        }
      }
      return false;
    }
  };
})(wysihtml5);
;/**
 * document.execCommand("foreColor") will create either inline styles (firefox, chrome) or use font tags
 * which we don't want
 * Instead we set a css class
 */
(function(wysihtml5) {
  var REG_EXP = /wysiwyg-color-[0-9a-z]+/g;

  wysihtml5.commands.foreColor = {
    exec: function(composer, command, color) {
        wysihtml5.commands.formatInline.execWithToggle(composer, command, "span", "wysiwyg-color-" + color, REG_EXP);
    },

    state: function(composer, command, color) {
      return wysihtml5.commands.formatInline.state(composer, command, "span", "wysiwyg-color-" + color, REG_EXP);
    }
  };
})(wysihtml5);
;/**
 * document.execCommand("foreColor") will create either inline styles (firefox, chrome) or use font tags
 * which we don't want
 * Instead we set a css class
 */
(function(wysihtml5) {
  var REG_EXP = /(\s|^)color\s*:\s*[^;\s]+;?/gi;

  wysihtml5.commands.foreColorStyle = {
    exec: function(composer, command, color) {
      var colorVals  = wysihtml5.quirks.styleParser.parseColor((typeof(color) == "object") ? "color:" + color.color : "color:" + color, "color"),
          colString;

      if (colorVals) {
        colString = "color: rgb(" + colorVals[0] + ',' + colorVals[1] + ',' + colorVals[2] + ');';
        if (colorVals[3] !== 1) {
          colString += "color: rgba(" + colorVals[0] + ',' + colorVals[1] + ',' + colorVals[2] + ',' + colorVals[3] + ');';
        }
        wysihtml5.commands.formatInline.execWithToggle(composer, command, "span", false, false, colString, REG_EXP);
      }
    },

    state: function(composer, command) {
      return wysihtml5.commands.formatInline.state(composer, command, "span", false, false, "color", REG_EXP);
    },

    stateValue: function(composer, command, props) {
      var st = this.state(composer, command),
          colorStr;

      if (st && wysihtml5.lang.object(st).isArray()) {
        st = st[0];
      }

      if (st) {
        colorStr = st.getAttribute('style');
        if (colorStr) {
          if (colorStr) {
            val = wysihtml5.quirks.styleParser.parseColor(colorStr, "color");
            return wysihtml5.quirks.styleParser.unparseColor(val, props);
          }
        }
      }
      return false;
    }

  };
})(wysihtml5);
;/* In case background adjustment to any color defined by user is preferred, we cannot use classes and must use inline styles. */
(function(wysihtml5) {
  var REG_EXP = /(\s|^)background-color\s*:\s*[^;\s]+;?/gi;

  wysihtml5.commands.bgColorStyle = {
    exec: function(composer, command, color) {
      var colorVals  = wysihtml5.quirks.styleParser.parseColor((typeof(color) == "object") ? "background-color:" + color.color : "background-color:" + color, "background-color"),
          colString;

      if (colorVals) {
        colString = "background-color: rgb(" + colorVals[0] + ',' + colorVals[1] + ',' + colorVals[2] + ');';
        if (colorVals[3] !== 1) {
          colString += "background-color: rgba(" + colorVals[0] + ',' + colorVals[1] + ',' + colorVals[2] + ',' + colorVals[3] + ');';
        }
        wysihtml5.commands.formatInline.execWithToggle(composer, command, "span", false, false, colString, REG_EXP);
      }
    },

    state: function(composer, command) {
      return wysihtml5.commands.formatInline.state(composer, command, "span", false, false, "background-color", REG_EXP);
    },

    stateValue: function(composer, command, props) {
      var st = this.state(composer, command),
          colorStr,
          val = false;

      if (st && wysihtml5.lang.object(st).isArray()) {
        st = st[0];
      }

      if (st) {
        colorStr = st.getAttribute('style');
        if (colorStr) {
          val = wysihtml5.quirks.styleParser.parseColor(colorStr, "background-color");
          return wysihtml5.quirks.styleParser.unparseColor(val, props);
        }
      }
      return false;
    }

  };
})(wysihtml5);
;(function(wysihtml5) {
  var dom                     = wysihtml5.dom,
      // Following elements are grouped
      // when the caret is within a H1 and the H4 is invoked, the H1 should turn into H4
      // instead of creating a H4 within a H1 which would result in semantically invalid html
      BLOCK_ELEMENTS_GROUP    = ["H1", "H2", "H3", "H4", "H5", "H6", "P", "PRE", "DIV"];

  /**
   * Remove similiar classes (based on classRegExp)
   * and add the desired class name
   */
  function _addClass(element, className, classRegExp) {
    if (element.className) {
      _removeClass(element, classRegExp);
      element.className = wysihtml5.lang.string(element.className + " " + className).trim();
    } else {
      element.className = className;
    }
  }

  function _addStyle(element, cssStyle, styleRegExp) {
    _removeStyle(element, styleRegExp);
    if (element.getAttribute('style')) {
      element.setAttribute('style', wysihtml5.lang.string(element.getAttribute('style') + " " + cssStyle).trim());
    } else {
      element.setAttribute('style', cssStyle);
    }
  }

  function _removeClass(element, classRegExp) {
    var ret = classRegExp.test(element.className);
    element.className = element.className.replace(classRegExp, "");
    if (wysihtml5.lang.string(element.className).trim() == '') {
        element.removeAttribute('class');
    }
    return ret;
  }

  function _removeStyle(element, styleRegExp) {
    var ret = styleRegExp.test(element.getAttribute('style'));
    element.setAttribute('style', (element.getAttribute('style') || "").replace(styleRegExp, ""));
    if (wysihtml5.lang.string(element.getAttribute('style') || "").trim() == '') {
      element.removeAttribute('style');
    }
    return ret;
  }

  function _removeLastChildIfLineBreak(node) {
    var lastChild = node.lastChild;
    if (lastChild && _isLineBreak(lastChild)) {
      lastChild.parentNode.removeChild(lastChild);
    }
  }

  function _isLineBreak(node) {
    return node.nodeName === "BR";
  }

  /**
   * Execute native query command
   * and if necessary modify the inserted node's className
   */
  function _execCommand(doc, composer, command, nodeName, className) {
    var ranges = composer.selection.getOwnRanges();
    for (var i = ranges.length; i--;){
      composer.selection.getSelection().removeAllRanges();
      composer.selection.setSelection(ranges[i]);
      if (className) {
        var eventListener = dom.observe(doc, "DOMNodeInserted", function(event) {
          var target = event.target,
              displayStyle;
          if (target.nodeType !== wysihtml5.ELEMENT_NODE) {
            return;
          }
          displayStyle = dom.getStyle("display").from(target);
          if (displayStyle.substr(0, 6) !== "inline") {
            // Make sure that only block elements receive the given class
            target.className += " " + className;
          }
        });
      }
      doc.execCommand(command, false, nodeName);

      if (eventListener) {
        eventListener.stop();
      }
    }
  }

  function _selectionWrap(composer, options) {
    if (composer.selection.isCollapsed()) {
        composer.selection.selectLine();
    }

    var surroundedNodes = composer.selection.surround(options);
    for (var i = 0, imax = surroundedNodes.length; i < imax; i++) {
      wysihtml5.dom.lineBreaks(surroundedNodes[i]).remove();
      _removeLastChildIfLineBreak(surroundedNodes[i]);
    }

    // rethink restoring selection
    // composer.selection.selectNode(element, wysihtml5.browser.displaysCaretInEmptyContentEditableCorrectly());
  }

  function _hasClasses(element) {
    return !!wysihtml5.lang.string(element.className).trim();
  }

  function _hasStyles(element) {
    return !!wysihtml5.lang.string(element.getAttribute('style') || '').trim();
  }

  wysihtml5.commands.formatBlock = {
    exec: function(composer, command, nodeName, className, classRegExp, cssStyle, styleRegExp) {
      var doc             = composer.doc,
          blockElements    = this.state(composer, command, nodeName, className, classRegExp, cssStyle, styleRegExp),
          useLineBreaks   = composer.config.useLineBreaks,
          defaultNodeName = useLineBreaks ? "DIV" : "P",
          selectedNodes, classRemoveAction, blockRenameFound, styleRemoveAction, blockElement;
      nodeName = typeof(nodeName) === "string" ? nodeName.toUpperCase() : nodeName;

      if (blockElements.length) {
        composer.selection.executeAndRestoreRangy(function() {
          for (var b = blockElements.length; b--;) {
            if (classRegExp) {
              classRemoveAction = _removeClass(blockElements[b], classRegExp);
            }
            if (styleRegExp) {
              styleRemoveAction = _removeStyle(blockElements[b], styleRegExp);
            }

            if ((styleRemoveAction || classRemoveAction) && nodeName === null && blockElements[b].nodeName != defaultNodeName) {
              // dont rename or remove element when just setting block formating class or style
              return;
            }

            var hasClasses = _hasClasses(blockElements[b]),
                hasStyles = _hasStyles(blockElements[b]);

            if (!hasClasses && !hasStyles && (useLineBreaks || nodeName === "P")) {
              // Insert a line break afterwards and beforewards when there are siblings
              // that are not of type line break or block element
              wysihtml5.dom.lineBreaks(blockElements[b]).add();
              dom.replaceWithChildNodes(blockElements[b]);
            } else {
              // Make sure that styling is kept by renaming the element to a <div> or <p> and copying over the class name
              dom.renameElement(blockElements[b], nodeName === "P" ? "DIV" : defaultNodeName);
            }
          }
        });

        return;
      }

      // Find similiar block element and rename it (<h2 class="foo"></h2>  =>  <h1 class="foo"></h1>)
      if (nodeName === null || wysihtml5.lang.array(BLOCK_ELEMENTS_GROUP).contains(nodeName)) {
        selectedNodes = composer.selection.findNodesInSelection(BLOCK_ELEMENTS_GROUP).concat(composer.selection.getSelectedOwnNodes());
        composer.selection.executeAndRestoreRangy(function() {
          for (var n = selectedNodes.length; n--;) {
            blockElement = dom.getParentElement(selectedNodes[n], {
              nodeName: BLOCK_ELEMENTS_GROUP
            });
            if (blockElement == composer.element) {
              blockElement = null;
            }
            if (blockElement) {
                // Rename current block element to new block element and add class
                if (nodeName) {
                  blockElement = dom.renameElement(blockElement, nodeName);
                }
                if (className) {
                  _addClass(blockElement, className, classRegExp);
                }
                if (cssStyle) {
                  _addStyle(blockElement, cssStyle, styleRegExp);
                }
              blockRenameFound = true;
            }
          }

        });

        if (blockRenameFound) {
          return;
        }
      }

      _selectionWrap(composer, {
        "nodeName": (nodeName || defaultNodeName),
        "className": className || null,
        "cssStyle": cssStyle || null
      });
    },

    state: function(composer, command, nodeName, className, classRegExp, cssStyle, styleRegExp) {
      var nodes = composer.selection.getSelectedOwnNodes(),
          parents = [],
          parent;

      nodeName = typeof(nodeName) === "string" ? nodeName.toUpperCase() : nodeName;

      //var selectedNode = composer.selection.getSelectedNode();
      for (var i = 0, maxi = nodes.length; i < maxi; i++) {
        parent = dom.getParentElement(nodes[i], {
          nodeName:     nodeName,
          className:    className,
          classRegExp:  classRegExp,
          cssStyle:     cssStyle,
          styleRegExp:  styleRegExp
        });
        if (parent && wysihtml5.lang.array(parents).indexOf(parent) == -1) {
          parents.push(parent);
        }
      }
      if (parents.length == 0) {
        return false;
      }
      return parents;
    }


  };
})(wysihtml5);
;/* Formats block for as a <pre><code class="classname"></code></pre> block
 * Useful in conjuction for sytax highlight utility: highlight.js
 *
 * Usage:
 *
 * editorInstance.composer.commands.exec("formatCode", "language-html");
*/

wysihtml5.commands.formatCode = {

  exec: function(composer, command, classname) {
    var pre = this.state(composer),
        code, range, selectedNodes;
    if (pre) {
      // caret is already within a <pre><code>...</code></pre>
      composer.selection.executeAndRestore(function() {
        code = pre.querySelector("code");
        wysihtml5.dom.replaceWithChildNodes(pre);
        if (code) {
          wysihtml5.dom.replaceWithChildNodes(code);
        }
      });
    } else {
      // Wrap in <pre><code>...</code></pre>
      range = composer.selection.getRange();
      selectedNodes = range.extractContents();
      pre = composer.doc.createElement("pre");
      code = composer.doc.createElement("code");

      if (classname) {
        code.className = classname;
      }

      pre.appendChild(code);
      code.appendChild(selectedNodes);
      range.insertNode(pre);
      composer.selection.selectNode(pre);
    }
  },

  state: function(composer) {
    var selectedNode = composer.selection.getSelectedNode();
    if (selectedNode && selectedNode.nodeName && selectedNode.nodeName == "PRE"&&
        selectedNode.firstChild && selectedNode.firstChild.nodeName && selectedNode.firstChild.nodeName == "CODE") {
      return selectedNode;
    } else {
      return wysihtml5.dom.getParentElement(selectedNode, { nodeName: "CODE" }) && wysihtml5.dom.getParentElement(selectedNode, { nodeName: "PRE" });
    }
  }
};;/**
 * formatInline scenarios for tag "B" (| = caret, |foo| = selected text)
 *
 *   #1 caret in unformatted text:
 *      abcdefg|
 *   output:
 *      abcdefg<b>|</b>
 *
 *   #2 unformatted text selected:
 *      abc|deg|h
 *   output:
 *      abc<b>|deg|</b>h
 *
 *   #3 unformatted text selected across boundaries:
 *      ab|c <span>defg|h</span>
 *   output:
 *      ab<b>|c </b><span><b>defg</b>|h</span>
 *
 *   #4 formatted text entirely selected
 *      <b>|abc|</b>
 *   output:
 *      |abc|
 *
 *   #5 formatted text partially selected
 *      <b>ab|c|</b>
 *   output:
 *      <b>ab</b>|c|
 *
 *   #6 formatted text selected across boundaries
 *      <span>ab|c</span> <b>de|fgh</b>
 *   output:
 *      <span>ab|c</span> de|<b>fgh</b>
 */
(function(wysihtml5) {
  var // Treat <b> as <strong> and vice versa
      ALIAS_MAPPING = {
        "strong": "b",
        "em":     "i",
        "b":      "strong",
        "i":      "em"
      },
      htmlApplier = {};

  function _getTagNames(tagName) {
    var alias = ALIAS_MAPPING[tagName];
    return alias ? [tagName.toLowerCase(), alias.toLowerCase()] : [tagName.toLowerCase()];
  }

  function _getApplier(tagName, className, classRegExp, cssStyle, styleRegExp, container) {
    var identifier = tagName;
    
    if (className) {
      identifier += ":" + className;
    }
    if (cssStyle) {
      identifier += ":" + cssStyle;
    }

    if (!htmlApplier[identifier]) {
      htmlApplier[identifier] = new wysihtml5.selection.HTMLApplier(_getTagNames(tagName), className, classRegExp, true, cssStyle, styleRegExp, container);
    }

    return htmlApplier[identifier];
  }

  wysihtml5.commands.formatInline = {
    exec: function(composer, command, tagName, className, classRegExp, cssStyle, styleRegExp, dontRestoreSelect, noCleanup) {
      var range = composer.selection.createRange(),
          ownRanges = composer.selection.getOwnRanges();

      if (!ownRanges || ownRanges.length == 0) {
        return false;
      }
      composer.selection.getSelection().removeAllRanges();

      _getApplier(tagName, className, classRegExp, cssStyle, styleRegExp, composer.element).toggleRange(ownRanges);

      if (!dontRestoreSelect) {
        range.setStart(ownRanges[0].startContainer,  ownRanges[0].startOffset);
        range.setEnd(
          ownRanges[ownRanges.length - 1].endContainer,
          ownRanges[ownRanges.length - 1].endOffset
        );
        composer.selection.setSelection(range);
        composer.selection.executeAndRestore(function() {
          if (!noCleanup) {
            composer.cleanUp();
          }
        }, true, true);
      } else if (!noCleanup) {
        composer.cleanUp();
      }
    },

    // Executes so that if collapsed caret is in a state and executing that state it should unformat that state
    // It is achieved by selecting the entire state element before executing.
    // This works on built in contenteditable inline format commands
    execWithToggle: function(composer, command, tagName, className, classRegExp, cssStyle, styleRegExp) {
      var that = this;

      if (this.state(composer, command, tagName, className, classRegExp, cssStyle, styleRegExp) &&
        composer.selection.isCollapsed() &&
        !composer.selection.caretIsLastInSelection() &&
        !composer.selection.caretIsFirstInSelection()
      ) {
        var state_element = that.state(composer, command, tagName, className, classRegExp)[0];
        composer.selection.executeAndRestoreRangy(function() {
          var parent = state_element.parentNode;
          composer.selection.selectNode(state_element, true);
          wysihtml5.commands.formatInline.exec(composer, command, tagName, className, classRegExp, cssStyle, styleRegExp, true, true);
        });
      } else {
        if (this.state(composer, command, tagName, className, classRegExp, cssStyle, styleRegExp) && !composer.selection.isCollapsed()) {
          composer.selection.executeAndRestoreRangy(function() {
            wysihtml5.commands.formatInline.exec(composer, command, tagName, className, classRegExp, cssStyle, styleRegExp, true, true);
          });
        } else {
          wysihtml5.commands.formatInline.exec(composer, command, tagName, className, classRegExp, cssStyle, styleRegExp);
        }
      }
    },

    state: function(composer, command, tagName, className, classRegExp, cssStyle, styleRegExp) {
      var doc           = composer.doc,
          aliasTagName  = ALIAS_MAPPING[tagName] || tagName,
          ownRanges, isApplied;

      // Check whether the document contains a node with the desired tagName
      if (!wysihtml5.dom.hasElementWithTagName(doc, tagName) &&
          !wysihtml5.dom.hasElementWithTagName(doc, aliasTagName)) {
        return false;
      }

       // Check whether the document contains a node with the desired className
      if (className && !wysihtml5.dom.hasElementWithClassName(doc, className)) {
         return false;
      }

      ownRanges = composer.selection.getOwnRanges();

      if (!ownRanges || ownRanges.length === 0) {
        return false;
      }

      isApplied = _getApplier(tagName, className, classRegExp, cssStyle, styleRegExp, composer.element).isAppliedToRange(ownRanges);

      return (isApplied && isApplied.elements) ? isApplied.elements : false;
    }
  };
})(wysihtml5);
;(function(wysihtml5) {

  wysihtml5.commands.insertBlockQuote = {
    exec: function(composer, command) {
      var state = this.state(composer, command),
          endToEndParent = composer.selection.isEndToEndInNode(['H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'P']),
          prevNode, nextNode;

      composer.selection.executeAndRestore(function() {
        if (state) {
          if (composer.config.useLineBreaks) {
             wysihtml5.dom.lineBreaks(state).add();
          }
          wysihtml5.dom.unwrap(state);
        } else {
          if (composer.selection.isCollapsed()) {
            composer.selection.selectLine();
          }
          
          if (endToEndParent) {
            var qouteEl = endToEndParent.ownerDocument.createElement('blockquote');
            wysihtml5.dom.insert(qouteEl).after(endToEndParent);
            qouteEl.appendChild(endToEndParent);
          } else {
            composer.selection.surround({nodeName: "blockquote"});
          }
        }
      });
    },
    state: function(composer, command) {
      var selectedNode  = composer.selection.getSelectedNode(),
          node = wysihtml5.dom.getParentElement(selectedNode, { nodeName: "BLOCKQUOTE" }, false, composer.element);

      return (node) ? node : false;
    }
  };

})(wysihtml5);;wysihtml5.commands.insertHTML = {
  exec: function(composer, command, html) {
    if (composer.commands.support(command)) {
      composer.doc.execCommand(command, false, html);
    } else {
      composer.selection.insertHTML(html);
    }
  },

  state: function() {
    return false;
  }
};
;(function(wysihtml5) {
  var NODE_NAME = "IMG";

  wysihtml5.commands.insertImage = {
    /**
     * Inserts an <img>
     * If selection is already an image link, it removes it
     *
     * @example
     *    // either ...
     *    wysihtml5.commands.insertImage.exec(composer, "insertImage", "http://www.google.de/logo.jpg");
     *    // ... or ...
     *    wysihtml5.commands.insertImage.exec(composer, "insertImage", { src: "http://www.google.de/logo.jpg", title: "foo" });
     */
    exec: function(composer, command, value) {
      value = typeof(value) === "object" ? value : { src: value };

      var doc     = composer.doc,
          image   = this.state(composer),
          textNode,
          parent;

      if (image) {
        // Image already selected, set the caret before it and delete it
        composer.selection.setBefore(image);
        parent = image.parentNode;
        parent.removeChild(image);

        // and it's parent <a> too if it hasn't got any other relevant child nodes
        wysihtml5.dom.removeEmptyTextNodes(parent);
        if (parent.nodeName === "A" && !parent.firstChild) {
          composer.selection.setAfter(parent);
          parent.parentNode.removeChild(parent);
        }

        // firefox and ie sometimes don't remove the image handles, even though the image got removed
        wysihtml5.quirks.redraw(composer.element);
        return;
      }

      image = doc.createElement(NODE_NAME);

      for (var i in value) {
        image.setAttribute(i === "className" ? "class" : i, value[i]);
      }

      composer.selection.insertNode(image);
      if (wysihtml5.browser.hasProblemsSettingCaretAfterImg()) {
        textNode = doc.createTextNode(wysihtml5.INVISIBLE_SPACE);
        composer.selection.insertNode(textNode);
        composer.selection.setAfter(textNode);
      } else {
        composer.selection.setAfter(image);
      }
    },

    state: function(composer) {
      var doc = composer.doc,
          selectedNode,
          text,
          imagesInSelection;

      if (!wysihtml5.dom.hasElementWithTagName(doc, NODE_NAME)) {
        return false;
      }

      selectedNode = composer.selection.getSelectedNode();
      if (!selectedNode) {
        return false;
      }

      if (selectedNode.nodeName === NODE_NAME) {
        // This works perfectly in IE
        return selectedNode;
      }

      if (selectedNode.nodeType !== wysihtml5.ELEMENT_NODE) {
        return false;
      }

      text = composer.selection.getText();
      text = wysihtml5.lang.string(text).trim();
      if (text) {
        return false;
      }

      imagesInSelection = composer.selection.getNodes(wysihtml5.ELEMENT_NODE, function(node) {
        return node.nodeName === "IMG";
      });

      if (imagesInSelection.length !== 1) {
        return false;
      }

      return imagesInSelection[0];
    }
  };
})(wysihtml5);
;(function(wysihtml5) {
  var LINE_BREAK = "<br>" + (wysihtml5.browser.needsSpaceAfterLineBreak() ? " " : "");

  wysihtml5.commands.insertLineBreak = {
    exec: function(composer, command) {
      if (composer.commands.support(command)) {
        composer.doc.execCommand(command, false, null);
        if (!wysihtml5.browser.autoScrollsToCaret()) {
          composer.selection.scrollIntoView();
        }
      } else {
        composer.commands.exec("insertHTML", LINE_BREAK);
      }
    },

    state: function() {
      return false;
    }
  };
})(wysihtml5);
;wysihtml5.commands.insertOrderedList = {
  exec: function(composer, command) {
    wysihtml5.commands.insertList.exec(composer, command, "OL");
  },

  state: function(composer, command) {
    return wysihtml5.commands.insertList.state(composer, command, "OL");
  }
};
;wysihtml5.commands.insertUnorderedList = {
  exec: function(composer, command) {
    wysihtml5.commands.insertList.exec(composer, command, "UL");
  },

  state: function(composer, command) {
    return wysihtml5.commands.insertList.state(composer, command, "UL");
  }
};
;wysihtml5.commands.insertList = (function(wysihtml5) {

  var isNode = function(node, name) {
    if (node && node.nodeName) {
      if (typeof name === 'string') {
        name = [name];
      }
      for (var n = name.length; n--;) {
        if (node.nodeName === name[n]) {
          return true;
        }
      }
    }
    return false;
  };

  var findListEl = function(node, nodeName, composer) {
    var ret = {
          el: null,
          other: false
        };

    if (node) {
      var parentLi = wysihtml5.dom.getParentElement(node, { nodeName: "LI" }),
          otherNodeName = (nodeName === "UL") ? "OL" : "UL";

      if (isNode(node, nodeName)) {
        ret.el = node;
      } else if (isNode(node, otherNodeName)) {
        ret = {
          el: node,
          other: true
        };
      } else if (parentLi) {
        if (isNode(parentLi.parentNode, nodeName)) {
          ret.el = parentLi.parentNode;
        } else if (isNode(parentLi.parentNode, otherNodeName)) {
          ret = {
            el : parentLi.parentNode,
            other: true
          };
        }
      }
    }

    // do not count list elements outside of composer
    if (ret.el && !composer.element.contains(ret.el)) {
      ret.el = null;
    }

    return ret;
  };

  var handleSameTypeList = function(el, nodeName, composer) {
    var otherNodeName = (nodeName === "UL") ? "OL" : "UL",
        otherLists, innerLists;
    // Unwrap list
    // <ul><li>foo</li><li>bar</li></ul>
    // becomes:
    // foo<br>bar<br>
    composer.selection.executeAndRestore(function() {
      var otherLists = getListsInSelection(otherNodeName, composer);
      if (otherLists.length) {
        for (var l = otherLists.length; l--;) {
          wysihtml5.dom.renameElement(otherLists[l], nodeName.toLowerCase());
        }
      } else {
        innerLists = getListsInSelection(['OL', 'UL'], composer);
        for (var i = innerLists.length; i--;) {
          wysihtml5.dom.resolveList(innerLists[i], composer.config.useLineBreaks);
        }
        wysihtml5.dom.resolveList(el, composer.config.useLineBreaks);
      }
    });
  };

  var handleOtherTypeList =  function(el, nodeName, composer) {
    var otherNodeName = (nodeName === "UL") ? "OL" : "UL";
    // Turn an ordered list into an unordered list
    // <ol><li>foo</li><li>bar</li></ol>
    // becomes:
    // <ul><li>foo</li><li>bar</li></ul>
    // Also rename other lists in selection
    composer.selection.executeAndRestore(function() {
      var renameLists = [el].concat(getListsInSelection(otherNodeName, composer));

      // All selection inner lists get renamed too
      for (var l = renameLists.length; l--;) {
        wysihtml5.dom.renameElement(renameLists[l], nodeName.toLowerCase());
      }
    });
  };

  var getListsInSelection = function(nodeName, composer) {
      var ranges = composer.selection.getOwnRanges(),
          renameLists = [];

      for (var r = ranges.length; r--;) {
        renameLists = renameLists.concat(ranges[r].getNodes([1], function(node) {
          return isNode(node, nodeName);
        }));
      }

      return renameLists;
  };

  var createListFallback = function(nodeName, composer) {
    // Fallback for Create list
    composer.selection.executeAndRestoreRangy(function() {
      var tempClassName =  "_wysihtml5-temp-" + new Date().getTime(),
          tempElement = composer.selection.deblockAndSurround({
            "nodeName": "div",
            "className": tempClassName
          }),
          isEmpty, list;

      // This space causes new lists to never break on enter 
      var INVISIBLE_SPACE_REG_EXP = /\uFEFF/g;
      tempElement.innerHTML = tempElement.innerHTML.replace(wysihtml5.INVISIBLE_SPACE_REG_EXP, "");
      
      if (tempElement) {
        isEmpty = wysihtml5.lang.array(["", "<br>", wysihtml5.INVISIBLE_SPACE]).contains(tempElement.innerHTML);
        list = wysihtml5.dom.convertToList(tempElement, nodeName.toLowerCase(), composer.parent.config.uneditableContainerClassname);
        if (isEmpty) {
          composer.selection.selectNode(list.querySelector("li"), true);
        }
      }
    });
  };

  return {
    exec: function(composer, command, nodeName) {
      var doc           = composer.doc,
          cmd           = (nodeName === "OL") ? "insertOrderedList" : "insertUnorderedList",
          selectedNode  = composer.selection.getSelectedNode(),
          list          = findListEl(selectedNode, nodeName, composer);

      if (!list.el) {
        if (composer.commands.support(cmd)) {
          doc.execCommand(cmd, false, null);
        } else {
          createListFallback(nodeName, composer);
        }
      } else if (list.other) {
        handleOtherTypeList(list.el, nodeName, composer);
      } else {
        handleSameTypeList(list.el, nodeName, composer);
      }
    },

    state: function(composer, command, nodeName) {
      var selectedNode = composer.selection.getSelectedNode(),
          list         = findListEl(selectedNode, nodeName, composer);

      return (list.el && !list.other) ? list.el : false;
    }
  };

})(wysihtml5);;wysihtml5.commands.italic = {
  exec: function(composer, command) {
    wysihtml5.commands.formatInline.execWithToggle(composer, command, "i");
  },

  state: function(composer, command) {
    // element.ownerDocument.queryCommandState("italic") results:
    // firefox: only <i>
    // chrome:  <i>, <em>, <blockquote>, ...
    // ie:      <i>, <em>
    // opera:   only <i>
    return wysihtml5.commands.formatInline.state(composer, command, "i");
  }
};
;(function(wysihtml5) {
  var CLASS_NAME  = "wysiwyg-text-align-center",
      REG_EXP     = /wysiwyg-text-align-[0-9a-z]+/g;

  wysihtml5.commands.justifyCenter = {
    exec: function(composer, command) {
      return wysihtml5.commands.formatBlock.exec(composer, "formatBlock", null, CLASS_NAME, REG_EXP);
    },

    state: function(composer, command) {
      return wysihtml5.commands.formatBlock.state(composer, "formatBlock", null, CLASS_NAME, REG_EXP);
    }
  };
})(wysihtml5);
;(function(wysihtml5) {
  var CLASS_NAME  = "wysiwyg-text-align-left",
      REG_EXP     = /wysiwyg-text-align-[0-9a-z]+/g;

  wysihtml5.commands.justifyLeft = {
    exec: function(composer, command) {
      return wysihtml5.commands.formatBlock.exec(composer, "formatBlock", null, CLASS_NAME, REG_EXP);
    },

    state: function(composer, command) {
      return wysihtml5.commands.formatBlock.state(composer, "formatBlock", null, CLASS_NAME, REG_EXP);
    }
  };
})(wysihtml5);
;(function(wysihtml5) {
  var CLASS_NAME  = "wysiwyg-text-align-right",
      REG_EXP     = /wysiwyg-text-align-[0-9a-z]+/g;

  wysihtml5.commands.justifyRight = {
    exec: function(composer, command) {
      return wysihtml5.commands.formatBlock.exec(composer, "formatBlock", null, CLASS_NAME, REG_EXP);
    },

    state: function(composer, command) {
      return wysihtml5.commands.formatBlock.state(composer, "formatBlock", null, CLASS_NAME, REG_EXP);
    }
  };
})(wysihtml5);
;(function(wysihtml5) {
  var CLASS_NAME  = "wysiwyg-text-align-justify",
      REG_EXP     = /wysiwyg-text-align-[0-9a-z]+/g;

  wysihtml5.commands.justifyFull = {
    exec: function(composer, command) {
      return wysihtml5.commands.formatBlock.exec(composer, "formatBlock", null, CLASS_NAME, REG_EXP);
    },

    state: function(composer, command) {
      return wysihtml5.commands.formatBlock.state(composer, "formatBlock", null, CLASS_NAME, REG_EXP);
    }
  };
})(wysihtml5);
;(function(wysihtml5) {
  var STYLE_STR  = "text-align: right;",
      REG_EXP = /(\s|^)text-align\s*:\s*[^;\s]+;?/gi;

  wysihtml5.commands.alignRightStyle = {
    exec: function(composer, command) {
      return wysihtml5.commands.formatBlock.exec(composer, "formatBlock", null, null, null, STYLE_STR, REG_EXP);
    },

    state: function(composer, command) {
      return wysihtml5.commands.formatBlock.state(composer, "formatBlock", null, null, null, STYLE_STR, REG_EXP);
    }
  };
})(wysihtml5);
;(function(wysihtml5) {
  var STYLE_STR  = "text-align: left;",
      REG_EXP = /(\s|^)text-align\s*:\s*[^;\s]+;?/gi;

  wysihtml5.commands.alignLeftStyle = {
    exec: function(composer, command) {
      return wysihtml5.commands.formatBlock.exec(composer, "formatBlock", null, null, null, STYLE_STR, REG_EXP);
    },

    state: function(composer, command) {
      return wysihtml5.commands.formatBlock.state(composer, "formatBlock", null, null, null, STYLE_STR, REG_EXP);
    }
  };
})(wysihtml5);
;(function(wysihtml5) {
  var STYLE_STR  = "text-align: center;",
      REG_EXP = /(\s|^)text-align\s*:\s*[^;\s]+;?/gi;

  wysihtml5.commands.alignCenterStyle = {
    exec: function(composer, command) {
      return wysihtml5.commands.formatBlock.exec(composer, "formatBlock", null, null, null, STYLE_STR, REG_EXP);
    },

    state: function(composer, command) {
      return wysihtml5.commands.formatBlock.state(composer, "formatBlock", null, null, null, STYLE_STR, REG_EXP);
    }
  };
})(wysihtml5);
;wysihtml5.commands.redo = {
  exec: function(composer) {
    return composer.undoManager.redo();
  },

  state: function(composer) {
    return false;
  }
};
;wysihtml5.commands.underline = {
  exec: function(composer, command) {
    wysihtml5.commands.formatInline.execWithToggle(composer, command, "u");
  },

  state: function(composer, command) {
    return wysihtml5.commands.formatInline.state(composer, command, "u");
  }
};
;wysihtml5.commands.undo = {
  exec: function(composer) {
    return composer.undoManager.undo();
  },

  state: function(composer) {
    return false;
  }
};
;wysihtml5.commands.createTable = {
  exec: function(composer, command, value) {
      var col, row, html;
      if (value && value.cols && value.rows && parseInt(value.cols, 10) > 0 && parseInt(value.rows, 10) > 0) {
          if (value.tableStyle) {
            html = "<table style=\"" + value.tableStyle + "\">";
          } else {
            html = "<table>";
          }
          html += "<tbody>";
          for (row = 0; row < value.rows; row ++) {
              html += '<tr>';
              for (col = 0; col < value.cols; col ++) {
                  html += "<td>&nbsp;</td>";
              }
              html += '</tr>';
          }
          html += "</tbody></table>";
          composer.commands.exec("insertHTML", html);
          //composer.selection.insertHTML(html);
      }


  },

  state: function(composer, command) {
      return false;
  }
};
;wysihtml5.commands.mergeTableCells = {
  exec: function(composer, command) {
      if (composer.tableSelection && composer.tableSelection.start && composer.tableSelection.end) {
          if (this.state(composer, command)) {
              wysihtml5.dom.table.unmergeCell(composer.tableSelection.start);
          } else {
              wysihtml5.dom.table.mergeCellsBetween(composer.tableSelection.start, composer.tableSelection.end);
          }
      }
  },

  state: function(composer, command) {
      if (composer.tableSelection) {
          var start = composer.tableSelection.start,
              end = composer.tableSelection.end;
          if (start && end && start == end &&
              ((
                  wysihtml5.dom.getAttribute(start, "colspan") &&
                  parseInt(wysihtml5.dom.getAttribute(start, "colspan"), 10) > 1
              ) || (
                  wysihtml5.dom.getAttribute(start, "rowspan") &&
                  parseInt(wysihtml5.dom.getAttribute(start, "rowspan"), 10) > 1
              ))
          ) {
              return [start];
          }
      }
      return false;
  }
};
;wysihtml5.commands.addTableCells = {
  exec: function(composer, command, value) {
      if (composer.tableSelection && composer.tableSelection.start && composer.tableSelection.end) {

          // switches start and end if start is bigger than end (reverse selection)
          var tableSelect = wysihtml5.dom.table.orderSelectionEnds(composer.tableSelection.start, composer.tableSelection.end);
          if (value == "before" || value == "above") {
              wysihtml5.dom.table.addCells(tableSelect.start, value);
          } else if (value == "after" || value == "below") {
              wysihtml5.dom.table.addCells(tableSelect.end, value);
          }
          setTimeout(function() {
              composer.tableSelection.select(tableSelect.start, tableSelect.end);
          },0);
      }
  },

  state: function(composer, command) {
      return false;
  }
};
;wysihtml5.commands.deleteTableCells = {
  exec: function(composer, command, value) {
      if (composer.tableSelection && composer.tableSelection.start && composer.tableSelection.end) {
          var tableSelect = wysihtml5.dom.table.orderSelectionEnds(composer.tableSelection.start, composer.tableSelection.end),
              idx = wysihtml5.dom.table.indexOf(tableSelect.start),
              selCell,
              table = composer.tableSelection.table;

          wysihtml5.dom.table.removeCells(tableSelect.start, value);
          setTimeout(function() {
              // move selection to next or previous if not present
              selCell = wysihtml5.dom.table.findCell(table, idx);

              if (!selCell){
                  if (value == "row") {
                      selCell = wysihtml5.dom.table.findCell(table, {
                          "row": idx.row - 1,
                          "col": idx.col
                      });
                  }

                  if (value == "column") {
                      selCell = wysihtml5.dom.table.findCell(table, {
                          "row": idx.row,
                          "col": idx.col - 1
                      });
                  }
              }
              if (selCell) {
                  composer.tableSelection.select(selCell, selCell);
              }
          }, 0);

      }
  },

  state: function(composer, command) {
      return false;
  }
};
;wysihtml5.commands.indentList = {
  exec: function(composer, command, value) {
    var listEls = composer.selection.getSelectionParentsByTag('LI');
    if (listEls) {
      return this.tryToPushLiLevel(listEls, composer.selection);
    }
    return false;
  },

  state: function(composer, command) {
      return false;
  },

  tryToPushLiLevel: function(liNodes, selection) {
    var listTag, list, prevLi, liNode, prevLiList,
        found = false;

    selection.executeAndRestoreRangy(function() {

      for (var i = liNodes.length; i--;) {
        liNode = liNodes[i];
        listTag = (liNode.parentNode.nodeName === 'OL') ? 'OL' : 'UL';
        list = liNode.ownerDocument.createElement(listTag);
        prevLi = wysihtml5.dom.domNode(liNode).prev({nodeTypes: [wysihtml5.ELEMENT_NODE]});
        prevLiList = (prevLi) ? prevLi.querySelector('ul, ol') : null;

        if (prevLi) {
          if (prevLiList) {
            prevLiList.appendChild(liNode);
          } else {
            list.appendChild(liNode);
            prevLi.appendChild(list);
          }
          found = true;
        }
      }

    });
    return found;
  }
};
;wysihtml5.commands.outdentList = {
  exec: function(composer, command, value) {
    var listEls = composer.selection.getSelectionParentsByTag('LI');
    if (listEls) {
      return this.tryToPullLiLevel(listEls, composer);
    }
    return false;
  },

  state: function(composer, command) {
      return false;
  },

  tryToPullLiLevel: function(liNodes, composer) {
    var listNode, outerListNode, outerLiNode, list, prevLi, liNode, afterList,
        found = false,
        that = this;

    composer.selection.executeAndRestoreRangy(function() {

      for (var i = liNodes.length; i--;) {
        liNode = liNodes[i];
        if (liNode.parentNode) {
          listNode = liNode.parentNode;

          if (listNode.tagName === 'OL' || listNode.tagName === 'UL') {
            found = true;

            outerListNode = wysihtml5.dom.getParentElement(listNode.parentNode, { nodeName: ['OL', 'UL']}, false, composer.element);
            outerLiNode = wysihtml5.dom.getParentElement(listNode.parentNode, { nodeName: ['LI']}, false, composer.element);

            if (outerListNode && outerLiNode) {

              if (liNode.nextSibling) {
                afterList = that.getAfterList(listNode, liNode);
                liNode.appendChild(afterList);
              }
              outerListNode.insertBefore(liNode, outerLiNode.nextSibling);

            } else {

              if (liNode.nextSibling) {
                afterList = that.getAfterList(listNode, liNode);
                liNode.appendChild(afterList);
              }

              for (var j = liNode.childNodes.length; j--;) {
                listNode.parentNode.insertBefore(liNode.childNodes[j], listNode.nextSibling);
              }

              listNode.parentNode.insertBefore(document.createElement('br'), listNode.nextSibling);
              liNode.parentNode.removeChild(liNode);

            }

            // cleanup
            if (listNode.childNodes.length === 0) {
                listNode.parentNode.removeChild(listNode);
            }
          }
        }
      }

    });
    return found;
  },

  getAfterList: function(listNode, liNode) {
    var nodeName = listNode.nodeName,
        newList = document.createElement(nodeName);

    while (liNode.nextSibling) {
      newList.appendChild(liNode.nextSibling);
    }
    return newList;
  }

};;/**
 * Undo Manager for wysihtml5
 * slightly inspired by http://rniwa.com/editing/undomanager.html#the-undomanager-interface
 */
(function(wysihtml5) {
  var Z_KEY               = 90,
      Y_KEY               = 89,
      BACKSPACE_KEY       = 8,
      DELETE_KEY          = 46,
      MAX_HISTORY_ENTRIES = 25,
      DATA_ATTR_NODE      = "data-wysihtml5-selection-node",
      DATA_ATTR_OFFSET    = "data-wysihtml5-selection-offset",
      UNDO_HTML           = '<span id="_wysihtml5-undo" class="_wysihtml5-temp">' + wysihtml5.INVISIBLE_SPACE + '</span>',
      REDO_HTML           = '<span id="_wysihtml5-redo" class="_wysihtml5-temp">' + wysihtml5.INVISIBLE_SPACE + '</span>',
      dom                 = wysihtml5.dom;

  function cleanTempElements(doc) {
    var tempElement;
    while (tempElement = doc.querySelector("._wysihtml5-temp")) {
      tempElement.parentNode.removeChild(tempElement);
    }
  }

  wysihtml5.UndoManager = wysihtml5.lang.Dispatcher.extend(
    /** @scope wysihtml5.UndoManager.prototype */ {
    constructor: function(editor) {
      this.editor = editor;
      this.composer = editor.composer;
      this.element = this.composer.element;

      this.position = 0;
      this.historyStr = [];
      this.historyDom = [];

      this.transact();

      this._observe();
    },

    _observe: function() {
      var that      = this,
          doc       = this.composer.sandbox.getDocument(),
          lastKey;

      // Catch CTRL+Z and CTRL+Y
      dom.observe(this.element, "keydown", function(event) {
        if (event.altKey || (!event.ctrlKey && !event.metaKey)) {
          return;
        }

        var keyCode = event.keyCode,
            isUndo = keyCode === Z_KEY && !event.shiftKey,
            isRedo = (keyCode === Z_KEY && event.shiftKey) || (keyCode === Y_KEY);

        if (isUndo) {
          that.undo();
          event.preventDefault();
        } else if (isRedo) {
          that.redo();
          event.preventDefault();
        }
      });

      // Catch delete and backspace
      dom.observe(this.element, "keydown", function(event) {
        var keyCode = event.keyCode;
        if (keyCode === lastKey) {
          return;
        }

        lastKey = keyCode;

        if (keyCode === BACKSPACE_KEY || keyCode === DELETE_KEY) {
          that.transact();
        }
      });

      this.editor
        .on("newword:composer", function() {
          that.transact();
        })

        .on("beforecommand:composer", function() {
          that.transact();
        });
    },

    transact: function() {
      var previousHtml      = this.historyStr[this.position - 1],
          currentHtml       = this.composer.getValue(false, false),
          composerIsVisible   = this.element.offsetWidth > 0 && this.element.offsetHeight > 0,
          range, node, offset, element, position;

      if (currentHtml === previousHtml) {
        return;
      }

      var length = this.historyStr.length = this.historyDom.length = this.position;
      if (length > MAX_HISTORY_ENTRIES) {
        this.historyStr.shift();
        this.historyDom.shift();
        this.position--;
      }

      this.position++;

      if (composerIsVisible) {
        // Do not start saving selection if composer is not visible
        range   = this.composer.selection.getRange();
        node    = (range && range.startContainer) ? range.startContainer : this.element;
        offset  = (range && range.startOffset) ? range.startOffset : 0;

        if (node.nodeType === wysihtml5.ELEMENT_NODE) {
          element = node;
        } else {
          element  = node.parentNode;
          position = this.getChildNodeIndex(element, node);
        }

        element.setAttribute(DATA_ATTR_OFFSET, offset);
        if (typeof(position) !== "undefined") {
          element.setAttribute(DATA_ATTR_NODE, position);
        }
      }

      var clone = this.element.cloneNode(!!currentHtml);
      this.historyDom.push(clone);
      this.historyStr.push(currentHtml);

      if (element) {
        element.removeAttribute(DATA_ATTR_OFFSET);
        element.removeAttribute(DATA_ATTR_NODE);
      }

    },

    undo: function() {
      this.transact();

      if (!this.undoPossible()) {
        return;
      }

      this.set(this.historyDom[--this.position - 1]);
      this.editor.fire("undo:composer");
    },

    redo: function() {
      if (!this.redoPossible()) {
        return;
      }

      this.set(this.historyDom[++this.position - 1]);
      this.editor.fire("redo:composer");
    },

    undoPossible: function() {
      return this.position > 1;
    },

    redoPossible: function() {
      return this.position < this.historyStr.length;
    },

    set: function(historyEntry) {
      this.element.innerHTML = "";

      var i = 0,
          childNodes = historyEntry.childNodes,
          length = historyEntry.childNodes.length;

      for (; i<length; i++) {
        this.element.appendChild(childNodes[i].cloneNode(true));
      }

      // Restore selection
      var offset,
          node,
          position;

      if (historyEntry.hasAttribute(DATA_ATTR_OFFSET)) {
        offset    = historyEntry.getAttribute(DATA_ATTR_OFFSET);
        position  = historyEntry.getAttribute(DATA_ATTR_NODE);
        node      = this.element;
      } else {
        node      = this.element.querySelector("[" + DATA_ATTR_OFFSET + "]") || this.element;
        offset    = node.getAttribute(DATA_ATTR_OFFSET);
        position  = node.getAttribute(DATA_ATTR_NODE);
        node.removeAttribute(DATA_ATTR_OFFSET);
        node.removeAttribute(DATA_ATTR_NODE);
      }

      if (position !== null) {
        node = this.getChildNodeByIndex(node, +position);
      }

      this.composer.selection.set(node, offset);
    },

    getChildNodeIndex: function(parent, child) {
      var i           = 0,
          childNodes  = parent.childNodes,
          length      = childNodes.length;
      for (; i<length; i++) {
        if (childNodes[i] === child) {
          return i;
        }
      }
    },

    getChildNodeByIndex: function(parent, index) {
      return parent.childNodes[index];
    }
  });
})(wysihtml5);
;/**
 * TODO: the following methods still need unit test coverage
 */
wysihtml5.views.View = Base.extend(
  /** @scope wysihtml5.views.View.prototype */ {
  constructor: function(parent, textareaElement, config) {
    this.parent   = parent;
    this.element  = textareaElement;
    this.config   = config;
    if (!this.config.noTextarea) {
        this._observeViewChange();
    }
  },

  _observeViewChange: function() {
    var that = this;
    this.parent.on("beforeload", function() {
      that.parent.on("change_view", function(view) {
        if (view === that.name) {
          that.parent.currentView = that;
          that.show();
          // Using tiny delay here to make sure that the placeholder is set before focusing
          setTimeout(function() { that.focus(); }, 0);
        } else {
          that.hide();
        }
      });
    });
  },

  focus: function() {
    if (this.element && this.element.ownerDocument && this.element.ownerDocument.querySelector(":focus") === this.element) {
      return;
    }

    try { if(this.element) { this.element.focus(); } } catch(e) {}
  },

  hide: function() {
    this.element.style.display = "none";
  },

  show: function() {
    this.element.style.display = "";
  },

  disable: function() {
    this.element.setAttribute("disabled", "disabled");
  },

  enable: function() {
    this.element.removeAttribute("disabled");
  }
});
;(function(wysihtml5) {
  var dom       = wysihtml5.dom,
      browser   = wysihtml5.browser;

  wysihtml5.views.Composer = wysihtml5.views.View.extend(
    /** @scope wysihtml5.views.Composer.prototype */ {
    name: "composer",

    // Needed for firefox in order to display a proper caret in an empty contentEditable
    CARET_HACK: "<br>",

    constructor: function(parent, editableElement, config) {
      this.base(parent, editableElement, config);
      if (!this.config.noTextarea) {
          this.textarea = this.parent.textarea;
      } else {
          this.editableArea = editableElement;
      }
      if (this.config.contentEditableMode) {
          this._initContentEditableArea();
      } else {
          this._initSandbox();
      }
    },

    clear: function() {
      this.element.innerHTML = browser.displaysCaretInEmptyContentEditableCorrectly() ? "" : this.CARET_HACK;
    },

    getValue: function(parse, clearInternals) {
      var value = this.isEmpty() ? "" : wysihtml5.quirks.getCorrectInnerHTML(this.element);
      if (parse !== false) {
        value = this.parent.parse(value, (clearInternals === false) ? false : true);
      }

      return value;
    },

    setValue: function(html, parse) {
      if (parse) {
        html = this.parent.parse(html);
      }

      try {
        this.element.innerHTML = html;
      } catch (e) {
        this.element.innerText = html;
      }
    },

    cleanUp: function() {
        this.parent.parse(this.element);
    },

    show: function() {
      this.editableArea.style.display = this._displayStyle || "";

      if (!this.config.noTextarea && !this.textarea.element.disabled) {
        // Firefox needs this, otherwise contentEditable becomes uneditable
        this.disable();
        this.enable();
      }
    },

    hide: function() {
      this._displayStyle = dom.getStyle("display").from(this.editableArea);
      if (this._displayStyle === "none") {
        this._displayStyle = null;
      }
      this.editableArea.style.display = "none";
    },

    disable: function() {
      this.parent.fire("disable:composer");
      this.element.removeAttribute("contentEditable");
    },

    enable: function() {
      this.parent.fire("enable:composer");
      this.element.setAttribute("contentEditable", "true");
    },

    focus: function(setToEnd) {
      // IE 8 fires the focus event after .focus()
      // This is needed by our simulate_placeholder.js to work
      // therefore we clear it ourselves this time
      if (wysihtml5.browser.doesAsyncFocus() && this.hasPlaceholderSet()) {
        this.clear();
      }

      this.base();

      var lastChild = this.element.lastChild;
      if (setToEnd && lastChild && this.selection) {
        if (lastChild.nodeName === "BR") {
          this.selection.setBefore(this.element.lastChild);
        } else {
          this.selection.setAfter(this.element.lastChild);
        }
      }
    },

    getTextContent: function() {
      return dom.getTextContent(this.element);
    },

    hasPlaceholderSet: function() {
      return this.getTextContent() == ((this.config.noTextarea) ? this.editableArea.getAttribute("data-placeholder") : this.textarea.element.getAttribute("placeholder")) && this.placeholderSet;
    },

    isEmpty: function() {
      var innerHTML = this.element.innerHTML.toLowerCase();
      return (/^(\s|<br>|<\/br>|<p>|<\/p>)*$/i).test(innerHTML)  ||
             innerHTML === ""            ||
             innerHTML === "<br>"        ||
             innerHTML === "<p></p>"     ||
             innerHTML === "<p><br></p>" ||
             this.hasPlaceholderSet();
    },

    _initContentEditableArea: function() {
        var that = this;

        if (this.config.noTextarea) {
            this.sandbox = new dom.ContentEditableArea(function() {
                that._create();
            }, {}, this.editableArea);
        } else {
            this.sandbox = new dom.ContentEditableArea(function() {
                that._create();
            });
            this.editableArea = this.sandbox.getContentEditable();
            dom.insert(this.editableArea).after(this.textarea.element);
            this._createWysiwygFormField();
        }
    },

    _initSandbox: function() {
      var that = this;

      this.sandbox = new dom.Sandbox(function() {
        that._create();
      }, {
        stylesheets:  this.config.stylesheets
      });
      this.editableArea  = this.sandbox.getIframe();

      var textareaElement = this.textarea.element;
      dom.insert(this.editableArea).after(textareaElement);

      this._createWysiwygFormField();
    },

    // Creates hidden field which tells the server after submit, that the user used an wysiwyg editor
    _createWysiwygFormField: function() {
        if (this.textarea.element.form) {
          var hiddenField = document.createElement("input");
          hiddenField.type   = "hidden";
          hiddenField.name   = "_wysihtml5_mode";
          hiddenField.value  = 1;
          dom.insert(hiddenField).after(this.textarea.element);
        }
    },

    _create: function() {
      var that = this;
      this.doc                = this.sandbox.getDocument();
      this.element            = (this.config.contentEditableMode) ? this.sandbox.getContentEditable() : this.doc.body;
      if (!this.config.noTextarea) {
          this.textarea           = this.parent.textarea;
          this.element.innerHTML  = this.textarea.getValue(true, false);
      } else {
          this.cleanUp(); // cleans contenteditable on initiation as it may contain html
      }

      // Make sure our selection handler is ready
      this.selection = new wysihtml5.Selection(this.parent, this.element, this.config.uneditableContainerClassname);

      // Make sure commands dispatcher is ready
      this.commands  = new wysihtml5.Commands(this.parent);

      if (!this.config.noTextarea) {
          dom.copyAttributes([
              "className", "spellcheck", "title", "lang", "dir", "accessKey"
          ]).from(this.textarea.element).to(this.element);
      }

      dom.addClass(this.element, this.config.composerClassName);
      //
      // Make the editor look like the original textarea, by syncing styles
      if (this.config.style && !this.config.contentEditableMode) {
        this.style();
      }

      this.observe();

      var name = this.config.name;
      if (name) {
        dom.addClass(this.element, name);
        if (!this.config.contentEditableMode) { dom.addClass(this.editableArea, name); }
      }

      this.enable();

      if (!this.config.noTextarea && this.textarea.element.disabled) {
        this.disable();
      }

      // Simulate html5 placeholder attribute on contentEditable element
      var placeholderText = typeof(this.config.placeholder) === "string"
        ? this.config.placeholder
        : ((this.config.noTextarea) ? this.editableArea.getAttribute("data-placeholder") : this.textarea.element.getAttribute("placeholder"));
      if (placeholderText) {
        dom.simulatePlaceholder(this.parent, this, placeholderText);
      }

      // Make sure that the browser avoids using inline styles whenever possible
      this.commands.exec("styleWithCSS", false);

      this._initAutoLinking();
      this._initObjectResizing();
      this._initUndoManager();
      this._initLineBreaking();

      // Simulate html5 autofocus on contentEditable element
      // This doesn't work on IOS (5.1.1)
      if (!this.config.noTextarea && (this.textarea.element.hasAttribute("autofocus") || document.querySelector(":focus") == this.textarea.element) && !browser.isIos()) {
        setTimeout(function() { that.focus(true); }, 100);
      }

      // IE sometimes leaves a single paragraph, which can't be removed by the user
      if (!browser.clearsContentEditableCorrectly()) {
        wysihtml5.quirks.ensureProperClearing(this);
      }

      // Set up a sync that makes sure that textarea and editor have the same content
      if (this.initSync && this.config.sync) {
        this.initSync();
      }

      // Okay hide the textarea, we are ready to go
      if (!this.config.noTextarea) { this.textarea.hide(); }

      // Fire global (before-)load event
      this.parent.fire("beforeload").fire("load");
    },

    _initAutoLinking: function() {
      var that                           = this,
          supportsDisablingOfAutoLinking = browser.canDisableAutoLinking(),
          supportsAutoLinking            = browser.doesAutoLinkingInContentEditable();
      if (supportsDisablingOfAutoLinking) {
        this.commands.exec("autoUrlDetect", false);
      }

      if (!this.config.autoLink) {
        return;
      }

      // Only do the auto linking by ourselves when the browser doesn't support auto linking
      // OR when he supports auto linking but we were able to turn it off (IE9+)
      if (!supportsAutoLinking || (supportsAutoLinking && supportsDisablingOfAutoLinking)) {
        this.parent.on("newword:composer", function() {
          if (dom.getTextContent(that.element).match(dom.autoLink.URL_REG_EXP)) {
            var nodeWithSelection = that.selection.getSelectedNode(),
                uneditables = that.element.querySelectorAll("." + that.config.uneditableContainerClassname),
                isInUneditable = false;

            for (var i = uneditables.length; i--;) {
              if (wysihtml5.dom.contains(uneditables[i], nodeWithSelection)) {
                isInUneditable = true;
              }
            }

            if (!isInUneditable) dom.autoLink(nodeWithSelection, [that.config.uneditableContainerClassname]);
          }
        });

        dom.observe(this.element, "blur", function() {
          dom.autoLink(that.element, [that.config.uneditableContainerClassname]);
        });
      }

      // Assuming we have the following:
      //  <a href="http://www.google.de">http://www.google.de</a>
      // If a user now changes the url in the innerHTML we want to make sure that
      // it's synchronized with the href attribute (as long as the innerHTML is still a url)
      var // Use a live NodeList to check whether there are any links in the document
          links           = this.sandbox.getDocument().getElementsByTagName("a"),
          // The autoLink helper method reveals a reg exp to detect correct urls
          urlRegExp       = dom.autoLink.URL_REG_EXP,
          getTextContent  = function(element) {
            var textContent = wysihtml5.lang.string(dom.getTextContent(element)).trim();
            if (textContent.substr(0, 4) === "www.") {
              textContent = "http://" + textContent;
            }
            return textContent;
          };

      dom.observe(this.element, "keydown", function(event) {
        if (!links.length) {
          return;
        }

        var selectedNode = that.selection.getSelectedNode(event.target.ownerDocument),
            link         = dom.getParentElement(selectedNode, { nodeName: "A" }, 4),
            textContent;

        if (!link) {
          return;
        }

        textContent = getTextContent(link);
        // keydown is fired before the actual content is changed
        // therefore we set a timeout to change the href
        setTimeout(function() {
          var newTextContent = getTextContent(link);
          if (newTextContent === textContent) {
            return;
          }

          // Only set href when new href looks like a valid url
          if (newTextContent.match(urlRegExp)) {
            link.setAttribute("href", newTextContent);
          }
        }, 0);
      });
    },

    _initObjectResizing: function() {
      this.commands.exec("enableObjectResizing", true);

      // IE sets inline styles after resizing objects
      // The following lines make sure that the width/height css properties
      // are copied over to the width/height attributes
      if (browser.supportsEvent("resizeend")) {
        var properties        = ["width", "height"],
            propertiesLength  = properties.length,
            element           = this.element;

        dom.observe(element, "resizeend", function(event) {
          var target = event.target || event.srcElement,
              style  = target.style,
              i      = 0,
              property;

          if (target.nodeName !== "IMG") {
            return;
          }

          for (; i<propertiesLength; i++) {
            property = properties[i];
            if (style[property]) {
              target.setAttribute(property, parseInt(style[property], 10));
              style[property] = "";
            }
          }

          // After resizing IE sometimes forgets to remove the old resize handles
          wysihtml5.quirks.redraw(element);
        });
      }
    },

    _initUndoManager: function() {
      this.undoManager = new wysihtml5.UndoManager(this.parent);
    },

    _initLineBreaking: function() {
      var that                              = this,
          USE_NATIVE_LINE_BREAK_INSIDE_TAGS = ["LI", "P", "H1", "H2", "H3", "H4", "H5", "H6"],
          LIST_TAGS                         = ["UL", "OL", "MENU"];

      function adjust(selectedNode) {
        var parentElement = dom.getParentElement(selectedNode, { nodeName: ["P", "DIV"] }, 2);
        if (parentElement && dom.contains(that.element, parentElement)) {
          that.selection.executeAndRestore(function() {
            if (that.config.useLineBreaks) {
              dom.replaceWithChildNodes(parentElement);
            } else if (parentElement.nodeName !== "P") {
              dom.renameElement(parentElement, "p");
            }
          });
        }
      }

      if (!this.config.useLineBreaks) {
        dom.observe(this.element, ["focus", "keydown"], function() {
          if (that.isEmpty()) {
            var paragraph = that.doc.createElement("P");
            that.element.innerHTML = "";
            that.element.appendChild(paragraph);
            if (!browser.displaysCaretInEmptyContentEditableCorrectly()) {
              paragraph.innerHTML = "<br>";
              that.selection.setBefore(paragraph.firstChild);
            } else {
              that.selection.selectNode(paragraph, true);
            }
          }
        });
      }

      // Under certain circumstances Chrome + Safari create nested <p> or <hX> tags after paste
      // Inserting an invisible white space in front of it fixes the issue
      // This is too hacky and causes selection not to replace content on paste in chrome
     /* if (browser.createsNestedInvalidMarkupAfterPaste()) {
        dom.observe(this.element, "paste", function(event) {
          var invisibleSpace = that.doc.createTextNode(wysihtml5.INVISIBLE_SPACE);
          that.selection.insertNode(invisibleSpace);
        });
      }*/


      dom.observe(this.element, "keydown", function(event) {
        var keyCode = event.keyCode;

        if (event.shiftKey) {
          return;
        }

        if (keyCode !== wysihtml5.ENTER_KEY && keyCode !== wysihtml5.BACKSPACE_KEY) {
          return;
        }
        var blockElement = dom.getParentElement(that.selection.getSelectedNode(), { nodeName: USE_NATIVE_LINE_BREAK_INSIDE_TAGS }, 4);
        if (blockElement) {
          setTimeout(function() {
            // Unwrap paragraph after leaving a list or a H1-6
            var selectedNode = that.selection.getSelectedNode(),
                list;

            if (blockElement.nodeName === "LI") {
              if (!selectedNode) {
                return;
              }

              list = dom.getParentElement(selectedNode, { nodeName: LIST_TAGS }, 2);

              if (!list) {
                adjust(selectedNode);
              }
            }

            if (keyCode === wysihtml5.ENTER_KEY && blockElement.nodeName.match(/^H[1-6]$/)) {
              adjust(selectedNode);
            }
          }, 0);
          return;
        }

        if (that.config.useLineBreaks && keyCode === wysihtml5.ENTER_KEY && !wysihtml5.browser.insertsLineBreaksOnReturn()) {
          event.preventDefault();
          that.commands.exec("insertLineBreak");

        }
      });
    }
  });
})(wysihtml5);
;(function(wysihtml5) {
  var dom             = wysihtml5.dom,
      doc             = document,
      win             = window,
      HOST_TEMPLATE   = doc.createElement("div"),
      /**
       * Styles to copy from textarea to the composer element
       */
      TEXT_FORMATTING = [
        "background-color",
        "color", "cursor",
        "font-family", "font-size", "font-style", "font-variant", "font-weight",
        "line-height", "letter-spacing",
        "text-align", "text-decoration", "text-indent", "text-rendering",
        "word-break", "word-wrap", "word-spacing"
      ],
      /**
       * Styles to copy from textarea to the iframe
       */
      BOX_FORMATTING = [
        "background-color",
        "border-collapse",
        "border-bottom-color", "border-bottom-style", "border-bottom-width",
        "border-left-color", "border-left-style", "border-left-width",
        "border-right-color", "border-right-style", "border-right-width",
        "border-top-color", "border-top-style", "border-top-width",
        "clear", "display", "float",
        "margin-bottom", "margin-left", "margin-right", "margin-top",
        "outline-color", "outline-offset", "outline-width", "outline-style",
        "padding-left", "padding-right", "padding-top", "padding-bottom",
        "position", "top", "left", "right", "bottom", "z-index",
        "vertical-align", "text-align",
        "-webkit-box-sizing", "-moz-box-sizing", "-ms-box-sizing", "box-sizing",
        "-webkit-box-shadow", "-moz-box-shadow", "-ms-box-shadow","box-shadow",
        "-webkit-border-top-right-radius", "-moz-border-radius-topright", "border-top-right-radius",
        "-webkit-border-bottom-right-radius", "-moz-border-radius-bottomright", "border-bottom-right-radius",
        "-webkit-border-bottom-left-radius", "-moz-border-radius-bottomleft", "border-bottom-left-radius",
        "-webkit-border-top-left-radius", "-moz-border-radius-topleft", "border-top-left-radius",
        "width", "height"
      ],
      ADDITIONAL_CSS_RULES = [
        "html                 { height: 100%; }",
        "body                 { height: 100%; padding: 1px 0 0 0; margin: -1px 0 0 0; }",
        "body > p:first-child { margin-top: 0; }",
        "._wysihtml5-temp     { display: none; }",
        wysihtml5.browser.isGecko ?
          "body.placeholder { color: graytext !important; }" :
          "body.placeholder { color: #a9a9a9 !important; }",
        // Ensure that user see's broken images and can delete them
        "img:-moz-broken      { -moz-force-broken-image-icon: 1; height: 24px; width: 24px; }"
      ];

  /**
   * With "setActive" IE offers a smart way of focusing elements without scrolling them into view:
   * http://msdn.microsoft.com/en-us/library/ms536738(v=vs.85).aspx
   *
   * Other browsers need a more hacky way: (pssst don't tell my mama)
   * In order to prevent the element being scrolled into view when focusing it, we simply
   * move it out of the scrollable area, focus it, and reset it's position
   */
  var focusWithoutScrolling = function(element) {
    if (element.setActive) {
      // Following line could cause a js error when the textarea is invisible
      // See https://github.com/xing/wysihtml5/issues/9
      try { element.setActive(); } catch(e) {}
    } else {
      var elementStyle = element.style,
          originalScrollTop = doc.documentElement.scrollTop || doc.body.scrollTop,
          originalScrollLeft = doc.documentElement.scrollLeft || doc.body.scrollLeft,
          originalStyles = {
            position:         elementStyle.position,
            top:              elementStyle.top,
            left:             elementStyle.left,
            WebkitUserSelect: elementStyle.WebkitUserSelect
          };

      dom.setStyles({
        position:         "absolute",
        top:              "-99999px",
        left:             "-99999px",
        // Don't ask why but temporarily setting -webkit-user-select to none makes the whole thing performing smoother
        WebkitUserSelect: "none"
      }).on(element);

      element.focus();

      dom.setStyles(originalStyles).on(element);

      if (win.scrollTo) {
        // Some browser extensions unset this method to prevent annoyances
        // "Better PopUp Blocker" for Chrome http://code.google.com/p/betterpopupblocker/source/browse/trunk/blockStart.js#100
        // Issue: http://code.google.com/p/betterpopupblocker/issues/detail?id=1
        win.scrollTo(originalScrollLeft, originalScrollTop);
      }
    }
  };


  wysihtml5.views.Composer.prototype.style = function() {
    var that                  = this,
        originalActiveElement = doc.querySelector(":focus"),
        textareaElement       = this.textarea.element,
        hasPlaceholder        = textareaElement.hasAttribute("placeholder"),
        originalPlaceholder   = hasPlaceholder && textareaElement.getAttribute("placeholder"),
        originalDisplayValue  = textareaElement.style.display,
        originalDisabled      = textareaElement.disabled,
        displayValueForCopying;

    this.focusStylesHost      = HOST_TEMPLATE.cloneNode(false);
    this.blurStylesHost       = HOST_TEMPLATE.cloneNode(false);
    this.disabledStylesHost   = HOST_TEMPLATE.cloneNode(false);

    // Remove placeholder before copying (as the placeholder has an affect on the computed style)
    if (hasPlaceholder) {
      textareaElement.removeAttribute("placeholder");
    }

    if (textareaElement === originalActiveElement) {
      textareaElement.blur();
    }

    // enable for copying styles
    textareaElement.disabled = false;

    // set textarea to display="none" to get cascaded styles via getComputedStyle
    textareaElement.style.display = displayValueForCopying = "none";

    if ((textareaElement.getAttribute("rows") && dom.getStyle("height").from(textareaElement) === "auto") ||
        (textareaElement.getAttribute("cols") && dom.getStyle("width").from(textareaElement) === "auto")) {
      textareaElement.style.display = displayValueForCopying = originalDisplayValue;
    }

    // --------- iframe styles (has to be set before editor styles, otherwise IE9 sets wrong fontFamily on blurStylesHost) ---------
    dom.copyStyles(BOX_FORMATTING).from(textareaElement).to(this.editableArea).andTo(this.blurStylesHost);

    // --------- editor styles ---------
    dom.copyStyles(TEXT_FORMATTING).from(textareaElement).to(this.element).andTo(this.blurStylesHost);

    // --------- apply standard rules ---------
    dom.insertCSS(ADDITIONAL_CSS_RULES).into(this.element.ownerDocument);

    // --------- :disabled styles ---------
    textareaElement.disabled = true;
    dom.copyStyles(BOX_FORMATTING).from(textareaElement).to(this.disabledStylesHost);
    dom.copyStyles(TEXT_FORMATTING).from(textareaElement).to(this.disabledStylesHost);
    textareaElement.disabled = originalDisabled;

    // --------- :focus styles ---------
    textareaElement.style.display = originalDisplayValue;
    focusWithoutScrolling(textareaElement);
    textareaElement.style.display = displayValueForCopying;

    dom.copyStyles(BOX_FORMATTING).from(textareaElement).to(this.focusStylesHost);
    dom.copyStyles(TEXT_FORMATTING).from(textareaElement).to(this.focusStylesHost);

    // reset textarea
    textareaElement.style.display = originalDisplayValue;

    dom.copyStyles(["display"]).from(textareaElement).to(this.editableArea);

    // Make sure that we don't change the display style of the iframe when copying styles oblur/onfocus
    // this is needed for when the change_view event is fired where the iframe is hidden and then
    // the blur event fires and re-displays it
    var boxFormattingStyles = wysihtml5.lang.array(BOX_FORMATTING).without(["display"]);

    // --------- restore focus ---------
    if (originalActiveElement) {
      originalActiveElement.focus();
    } else {
      textareaElement.blur();
    }

    // --------- restore placeholder ---------
    if (hasPlaceholder) {
      textareaElement.setAttribute("placeholder", originalPlaceholder);
    }

    // --------- Sync focus/blur styles ---------
    this.parent.on("focus:composer", function() {
      dom.copyStyles(boxFormattingStyles) .from(that.focusStylesHost).to(that.editableArea);
      dom.copyStyles(TEXT_FORMATTING)     .from(that.focusStylesHost).to(that.element);
    });

    this.parent.on("blur:composer", function() {
      dom.copyStyles(boxFormattingStyles) .from(that.blurStylesHost).to(that.editableArea);
      dom.copyStyles(TEXT_FORMATTING)     .from(that.blurStylesHost).to(that.element);
    });

    this.parent.observe("disable:composer", function() {
      dom.copyStyles(boxFormattingStyles) .from(that.disabledStylesHost).to(that.editableArea);
      dom.copyStyles(TEXT_FORMATTING)     .from(that.disabledStylesHost).to(that.element);
    });

    this.parent.observe("enable:composer", function() {
      dom.copyStyles(boxFormattingStyles) .from(that.blurStylesHost).to(that.editableArea);
      dom.copyStyles(TEXT_FORMATTING)     .from(that.blurStylesHost).to(that.element);
    });

    return this;
  };
})(wysihtml5);
;/**
 * Taking care of events
 *  - Simulating 'change' event on contentEditable element
 *  - Handling drag & drop logic
 *  - Catch paste events
 *  - Dispatch proprietary newword:composer event
 *  - Keyboard shortcuts
 */
(function(wysihtml5) {
  var dom       = wysihtml5.dom,
      browser   = wysihtml5.browser,
      /**
       * Map keyCodes to query commands
       */
      shortcuts = {
        "66": "bold",     // B
        "73": "italic",   // I
        "85": "underline" // U
      };

  // Adds multiple eventlisteners to target, bound to one callback
  // TODO: If needed elsewhere make it part of wysihtml5.dom or sth
  var addListeners = function (target, events, callback) {
    for(var i = 0, max = events.length; i < max; i++) {
      target.addEventListener(events[i], callback, false);
    }
  };

  // Removes multiple eventlisteners from target, bound to one callback
  // TODO: If needed elsewhere make it part of wysihtml5.dom or sth
  var removeListeners = function (target, events, callback) {
    for(var i = 0, max = events.length; i < max; i++) {
      target.removeEventListener(events[i], callback, false);
    }
  };

  var deleteAroundEditable = function(selection, uneditable, element) {
    // merge node with previous node from uneditable
    var prevNode = selection.getPreviousNode(uneditable, true),
        curNode = selection.getSelectedNode();

    if (curNode.nodeType !== 1 && curNode.parentNode !== element) { curNode = curNode.parentNode; }
    if (prevNode) {
      if (curNode.nodeType == 1) {
        var first = curNode.firstChild;

        if (prevNode.nodeType == 1) {
          while (curNode.firstChild) {
            prevNode.appendChild(curNode.firstChild);
          }
        } else {
          while (curNode.firstChild) {
            uneditable.parentNode.insertBefore(curNode.firstChild, uneditable);
          }
        }
        if (curNode.parentNode) {
          curNode.parentNode.removeChild(curNode);
        }
        selection.setBefore(first);
      } else {
        if (prevNode.nodeType == 1) {
          prevNode.appendChild(curNode);
        } else {
          uneditable.parentNode.insertBefore(curNode, uneditable);
        }
        selection.setBefore(curNode);
      }
    }
  };

  var handleDeleteKeyPress = function(event, composer) {
    var selection = composer.selection,
        element = composer.element;

    if (selection.isCollapsed()) {
      if (selection.caretIsInTheBeginnig('LI')) {
        event.preventDefault();
        composer.commands.exec('outdentList');
      } else if (selection.caretIsInTheBeginnig()) {
        event.preventDefault();
      } else {

        if (selection.caretIsFirstInSelection() &&
            selection.getPreviousNode() &&
            selection.getPreviousNode().nodeName &&
            (/^H\d$/gi).test(selection.getPreviousNode().nodeName)
        ) {
          var prevNode = selection.getPreviousNode();
          event.preventDefault();
          if ((/^\s*$/).test(prevNode.textContent || prevNode.innerText)) {
            // heading is empty
            prevNode.parentNode.removeChild(prevNode);
          } else {
            var range = prevNode.ownerDocument.createRange();
            range.selectNodeContents(prevNode);
            range.collapse(false);
            selection.setSelection(range);
          }
        }

        var beforeUneditable = selection.caretIsBeforeUneditable();
        // Do a special delete if caret would delete uneditable
        if (beforeUneditable) {
          event.preventDefault();
          // If customevents present notify element of being deleted
          // TODO: Investigate if browser support can be extended
          try {
            var ev = new CustomEvent("wysihtml5:uneditable:delete");
            beforeUneditable.dispatchEvent(ev);
          } catch (err) {}
          beforeUneditable.parentNode.removeChild(beforeUneditable);
        }
      }
    } else {
      if (selection.containsUneditable()) {
        event.preventDefault();
        selection.deleteContents();
      }
    }
  };

  var handleTabKeyDown = function(composer, element) {
    if (!composer.selection.isCollapsed()) {
      composer.selection.deleteContents();
    } else if (composer.selection.caretIsInTheBeginnig('LI')) {
      if (composer.commands.exec('indentList')) return;
    }

    // Is &emsp; close enough to tab. Could not find enough counter arguments for now.
    composer.commands.exec("insertHTML", "&emsp;");
  };

  var handleDomNodeRemoved = function(event) {
      if (this.domNodeRemovedInterval) {
        clearInterval(domNodeRemovedInterval);
      }
      this.parent.fire("destroy:composer");
  };

  // Listens to "drop", "paste", "mouseup", "focus", "keyup" events and fires
  var handleUserInteraction = function (event) {
    this.parent.fire("beforeinteraction").fire("beforeinteraction:composer");
    setTimeout((function() {
      this.parent.fire("interaction").fire("interaction:composer");
    }).bind(this), 0);
  };

  var handleFocus = function(event) {
    this.parent.fire("focus", event).fire("focus:composer", event);

    // Delay storing of state until all focus handler are fired
    // especially the one which resets the placeholder
    setTimeout((function() {
      this.focusState = this.getValue(false, false);
    }).bind(this), 0);
  };

  var handleBlur = function(event) {
    if (this.focusState !== this.getValue(false, false)) {
      //create change event if supported (all except IE8)
      var changeevent = event;
      if(typeof Object.create == 'function') {
        changeevent = Object.create(event, { type: { value: 'change' } });
      }
      this.parent.fire("change", changeevent).fire("change:composer", changeevent);
    }
    this.parent.fire("blur", event).fire("blur:composer", event);
  };

  var handlePaste = function(event) {
    this.parent.fire(event.type, event).fire(event.type + ":composer", event);
    if (event.type === "paste") {
      setTimeout((function() {
        this.parent.fire("newword:composer");
      }).bind(this), 0);
    }
  };

  var handleCopy = function(event) {
    if (this.config.copyedFromMarking) {
      // If supported the copied source can be based directly on selection
      // Very useful for webkit based browsers where copy will otherwise contain a lot of code and styles based on whatever and not actually in selection.
      if (event.clipboardData) {
        event.clipboardData.setData("text/html", this.config.copyedFromMarking + this.selection.getHtml());
        event.clipboardData.setData("text/plain", this.selection.getPlainText());
        event.preventDefault();
      }
      this.parent.fire(event.type, event).fire(event.type + ":composer", event);
    }
  };

  var handleKeyUp = function(event) {
    var keyCode = event.keyCode;
    if (keyCode === wysihtml5.SPACE_KEY || keyCode === wysihtml5.ENTER_KEY) {
      this.parent.fire("newword:composer");
    }
  };

  var handleMouseDown = function(event) {
    if (!browser.canSelectImagesInContentEditable()) {
      // Make sure that images are selected when clicking on them
      var target = event.target,
          allImages = this.element.querySelectorAll('img'),
          notMyImages = this.element.querySelectorAll('.' + this.config.uneditableContainerClassname + ' img'),
          myImages = wysihtml5.lang.array(allImages).without(notMyImages);

      if (target.nodeName === "IMG" && wysihtml5.lang.array(myImages).contains(target)) {
        this.selection.selectNode(target);
      }
    }
  };

  // TODO: mouseover is not actually a foolproof and obvious place for this, must be changed as it modifies dom on random basis
  // Shows url in tooltip when hovering links or images
  var handleMouseOver = function(event) {
    var titlePrefixes = {
          IMG: "Image: ",
          A:   "Link: "
        },
        target   = event.target,
        nodeName = target.nodeName,
        title;

    if (nodeName !== "A" && nodeName !== "IMG") {
      return;
    }
    if(!target.hasAttribute("title")){
      title = titlePrefixes[nodeName] + (target.getAttribute("href") || target.getAttribute("src"));
      target.setAttribute("title", title);
    }
  };

  var handleClick = function(event) {
    if (this.config.uneditableContainerClassname) {
      // If uneditables is configured, makes clicking on uneditable move caret after clicked element (so it can be deleted like text)
      // If uneditable needs text selection itself event.stopPropagation can be used to prevent this behaviour
      var uneditable = wysihtml5.dom.getParentElement(event.target, { className: this.config.uneditableContainerClassname }, false, this.element);
      if (uneditable) {
        this.selection.setAfter(uneditable);
      }
    }
  };

  var handleDrop = function(event) {
    if (!browser.canSelectImagesInContentEditable()) {
      // TODO: if I knew how to get dropped elements list from event I could limit it to only IMG element case
      setTimeout((function() {
        this.selection.getSelection().removeAllRanges();
      }).bind(this), 0);
    }
  };

  var handleKeyDown = function(event) {
    var keyCode = event.keyCode,
        command = shortcuts[keyCode],
        target, parent;

    // Shortcut logic
    if ((event.ctrlKey || event.metaKey) && !event.altKey && command) {
      this.commands.exec(command);
      event.preventDefault();
    }

    if (keyCode === wysihtml5.BACKSPACE_KEY) {
      // Delete key override for special cases
      handleDeleteKeyPress(event, this);
    }

    // Make sure that when pressing backspace/delete on selected images deletes the image and it's anchor
    if (keyCode === wysihtml5.BACKSPACE_KEY || keyCode === wysihtml5.DELETE_KEY) {
      target = this.selection.getSelectedNode(true);
      if (target && target.nodeName === "IMG") {
        event.preventDefault();
        parent = target.parentNode;
        parent.removeChild(target);// delete the <img>
        // And it's parent <a> too if it hasn't got any other child nodes
        if (parent.nodeName === "A" && !parent.firstChild) {
          parent.parentNode.removeChild(parent);
        }
        setTimeout(function() {
          wysihtml5.quirks.redraw(element);
        }, 0);
      }
    }

    if (this.config.handleTabKey && keyCode === wysihtml5.TAB_KEY) {
      // TAB key handling
      event.preventDefault();
      handleTabKeyDown(this, element);
    }

  };

  var handleIframeFocus = function(event) {
    setTimeout((function() {
      if (this.doc.querySelector(":focus") !== this.element) {
        this.focus();
      }
    }).bind(this), 0);
  };

  var handleIframeBlur = function(event) {
    setTimeout((function() {
      this.selection.getSelection().removeAllRanges();
    }).bind(this), 0);
  };

  // Table management
  // If present enableObjectResizing and enableInlineTableEditing command should be called with false to prevent native table handlers
  var initTableHandling = function () {
    var hideHandlers = function () {
          this.doc.execCommand("enableObjectResizing", false, "false");
          this.doc.execCommand("enableInlineTableEditing", false, "false");
        },
        iframeInitiator = (function() {
          hideHandlers.call(this);
          removeListeners(this.sandbox.getIframe(), ["focus", "mouseup", "mouseover"], iframeInitiator);
        }).bind(this);

    if( this.doc.execCommand &&
        wysihtml5.browser.supportsCommand(this.doc, "enableObjectResizing") &&
        wysihtml5.browser.supportsCommand(this.doc, "enableInlineTableEditing"))
    {
      if (this.sandbox.getIframe) {
        addListeners(this.sandbox.getIframe(), ["focus", "mouseup", "mouseover"], iframeInitiator);
      } else {
        setTimeout((function() {
          hideHandlers.call(this);
        }).bind(this), 0);
      }
    }
    this.tableSelection = wysihtml5.quirks.tableCellsSelection(this.element, this.parent);
  };

  wysihtml5.views.Composer.prototype.observe = function() {
    var that                = this,
        container           = (this.sandbox.getIframe) ? this.sandbox.getIframe() : this.sandbox.getContentEditable(),
        element             = this.element,
        focusBlurElement    = (browser.supportsEventsInIframeCorrectly() || this.sandbox.getContentEditable) ? this.element : this.sandbox.getWindow();

    this.focusState = this.getValue(false, false);

    // --------- destroy:composer event ---------
    container.addEventListener(["DOMNodeRemoved"], handleDomNodeRemoved.bind(this), false);

    // DOMNodeRemoved event is not supported in IE 8
    // TODO: try to figure out a polyfill style fix, so it could be transferred to polyfills and removed if ie8 is not needed
    if (!browser.supportsMutationEvents()) {
      this.domNodeRemovedInterval = setInterval(function() {
        if (!dom.contains(document.documentElement, container)) {
          handleDomNodeRemoved.call(this);
        }
      }, 250);
    }

    // --------- User interactions --
    if (this.config.handleTables) {
      // If handleTables option is true, table handling functions are bound
      initTableHandling.call(this);
    }

    addListeners(focusBlurElement, ["drop", "paste", "mouseup", "focus", "keyup"], handleUserInteraction.bind(this));
    focusBlurElement.addEventListener("focus", handleFocus.bind(this), false);
    focusBlurElement.addEventListener("blur",  handleBlur.bind(this), false);
    
    addListeners(this.element, ["drop", "paste", "beforepaste"], handlePaste.bind(this), false);
    this.element.addEventListener("copy",       handleCopy.bind(this), false);
    this.element.addEventListener("mousedown",  handleMouseDown.bind(this), false);
    this.element.addEventListener("mouseover",  handleMouseOver.bind(this), false);
    this.element.addEventListener("click",      handleClick.bind(this), false);
    this.element.addEventListener("drop",       handleDrop.bind(this), false);
    this.element.addEventListener("keyup",      handleKeyUp.bind(this), false);
    this.element.addEventListener("keydown",    handleKeyDown.bind(this), false);

    this.element.addEventListener("dragenter", (function() {
      this.parent.fire("unset_placeholder");
    }).bind(this), false);

    // --------- IE 8+9 focus the editor when the iframe is clicked (without actually firing the 'focus' event on the <body>) ---------
    if (!this.config.contentEditableMode && browser.hasIframeFocusIssue()) {
      container.addEventListener("focus", handleIframeFocus.bind(this), false);
      container.addEventListener("blur", handleIframeBlur.bind(this), false);
    }

  };
})(wysihtml5);
;/**
 * Class that takes care that the value of the composer and the textarea is always in sync
 */
(function(wysihtml5) {
  var INTERVAL = 400;

  wysihtml5.views.Synchronizer = Base.extend(
    /** @scope wysihtml5.views.Synchronizer.prototype */ {

    constructor: function(editor, textarea, composer) {
      this.editor   = editor;
      this.textarea = textarea;
      this.composer = composer;

      this._observe();
    },

    /**
     * Sync html from composer to textarea
     * Takes care of placeholders
     * @param {Boolean} shouldParseHtml Whether the html should be sanitized before inserting it into the textarea
     */
    fromComposerToTextarea: function(shouldParseHtml) {
      this.textarea.setValue(wysihtml5.lang.string(this.composer.getValue(false, false)).trim(), shouldParseHtml);
    },

    /**
     * Sync value of textarea to composer
     * Takes care of placeholders
     * @param {Boolean} shouldParseHtml Whether the html should be sanitized before inserting it into the composer
     */
    fromTextareaToComposer: function(shouldParseHtml) {
      var textareaValue = this.textarea.getValue(false, false);
      if (textareaValue) {
        this.composer.setValue(textareaValue, shouldParseHtml);
      } else {
        this.composer.clear();
        this.editor.fire("set_placeholder");
      }
    },

    /**
     * Invoke syncing based on view state
     * @param {Boolean} shouldParseHtml Whether the html should be sanitized before inserting it into the composer/textarea
     */
    sync: function(shouldParseHtml) {
      if (this.editor.currentView.name === "textarea") {
        this.fromTextareaToComposer(shouldParseHtml);
      } else {
        this.fromComposerToTextarea(shouldParseHtml);
      }
    },

    /**
     * Initializes interval-based syncing
     * also makes sure that on-submit the composer's content is synced with the textarea
     * immediately when the form gets submitted
     */
    _observe: function() {
      var interval,
          that          = this,
          form          = this.textarea.element.form,
          startInterval = function() {
            interval = setInterval(function() { that.fromComposerToTextarea(); }, INTERVAL);
          },
          stopInterval  = function() {
            clearInterval(interval);
            interval = null;
          };

      startInterval();

      if (form) {
        // If the textarea is in a form make sure that after onreset and onsubmit the composer
        // has the correct state
        wysihtml5.dom.observe(form, "submit", function() {
          that.sync(true);
        });
        wysihtml5.dom.observe(form, "reset", function() {
          setTimeout(function() { that.fromTextareaToComposer(); }, 0);
        });
      }

      this.editor.on("change_view", function(view) {
        if (view === "composer" && !interval) {
          that.fromTextareaToComposer(true);
          startInterval();
        } else if (view === "textarea") {
          that.fromComposerToTextarea(true);
          stopInterval();
        }
      });

      this.editor.on("destroy:composer", stopInterval);
    }
  });
})(wysihtml5);
;wysihtml5.views.Textarea = wysihtml5.views.View.extend(
  /** @scope wysihtml5.views.Textarea.prototype */ {
  name: "textarea",

  constructor: function(parent, textareaElement, config) {
    this.base(parent, textareaElement, config);

    this._observe();
  },

  clear: function() {
    this.element.value = "";
  },

  getValue: function(parse) {
    var value = this.isEmpty() ? "" : this.element.value;
    if (parse !== false) {
      value = this.parent.parse(value);
    }
    return value;
  },

  setValue: function(html, parse) {
    if (parse) {
      html = this.parent.parse(html);
    }
    this.element.value = html;
  },

  cleanUp: function() {
      var html = this.parent.parse(this.element.value);
      this.element.value = html;
  },

  hasPlaceholderSet: function() {
    var supportsPlaceholder = wysihtml5.browser.supportsPlaceholderAttributeOn(this.element),
        placeholderText     = this.element.getAttribute("placeholder") || null,
        value               = this.element.value,
        isEmpty             = !value;
    return (supportsPlaceholder && isEmpty) || (value === placeholderText);
  },

  isEmpty: function() {
    return !wysihtml5.lang.string(this.element.value).trim() || this.hasPlaceholderSet();
  },

  _observe: function() {
    var element = this.element,
        parent  = this.parent,
        eventMapping = {
          focusin:  "focus",
          focusout: "blur"
        },
        /**
         * Calling focus() or blur() on an element doesn't synchronously trigger the attached focus/blur events
         * This is the case for focusin and focusout, so let's use them whenever possible, kkthxbai
         */
        events = wysihtml5.browser.supportsEvent("focusin") ? ["focusin", "focusout", "change"] : ["focus", "blur", "change"];

    parent.on("beforeload", function() {
      wysihtml5.dom.observe(element, events, function(event) {
        var eventName = eventMapping[event.type] || event.type;
        parent.fire(eventName).fire(eventName + ":textarea");
      });

      wysihtml5.dom.observe(element, ["paste", "drop"], function() {
        setTimeout(function() { parent.fire("paste").fire("paste:textarea"); }, 0);
      });
    });
  }
});
;/**
 * WYSIHTML5 Editor
 *
 * @param {Element} editableElement Reference to the textarea which should be turned into a rich text interface
 * @param {Object} [config] See defaultConfig object below for explanation of each individual config option
 *
 * @events
 *    load
 *    beforeload (for internal use only)
 *    focus
 *    focus:composer
 *    focus:textarea
 *    blur
 *    blur:composer
 *    blur:textarea
 *    change
 *    change:composer
 *    change:textarea
 *    paste
 *    paste:composer
 *    paste:textarea
 *    newword:composer
 *    destroy:composer
 *    undo:composer
 *    redo:composer
 *    beforecommand:composer
 *    aftercommand:composer
 *    enable:composer
 *    disable:composer
 *    change_view
 */
(function(wysihtml5) {
  var undef;

  var defaultConfig = {
    // Give the editor a name, the name will also be set as class name on the iframe and on the iframe's body
    name:                 undef,
    // Whether the editor should look like the textarea (by adopting styles)
    style:                true,
    // Id of the toolbar element, pass falsey value if you don't want any toolbar logic
    toolbar:              undef,
    // Whether toolbar is displayed after init by script automatically.
    // Can be set to false if toolobar is set to display only on editable area focus
    showToolbarAfterInit: true,
    // Whether urls, entered by the user should automatically become clickable-links
    autoLink:             true,
    // Includes table editing events and cell selection tracking
    handleTables:         true,
    // Tab key inserts tab into text as default behaviour. It can be disabled to regain keyboard navigation
    handleTabKey:         true,
    // Object which includes parser rules to apply when html gets cleaned
    // See parser_rules/*.js for examples
    parserRules:          { tags: { br: {}, span: {}, div: {}, p: {} }, classes: {} },
    // Object which includes parser when the user inserts content via copy & paste. If null parserRules will be used instead
    pasteParserRulesets: null,
    // Parser method to use when the user inserts content
    parser:               wysihtml5.dom.parse,
    // Class name which should be set on the contentEditable element in the created sandbox iframe, can be styled via the 'stylesheets' option
    composerClassName:    "wysihtml5-editor",
    // Class name to add to the body when the wysihtml5 editor is supported
    bodyClassName:        "wysihtml5-supported",
    // By default wysihtml5 will insert a <br> for line breaks, set this to false to use <p>
    useLineBreaks:        true,
    // Array (or single string) of stylesheet urls to be loaded in the editor's iframe
    stylesheets:          [],
    // Placeholder text to use, defaults to the placeholder attribute on the textarea element
    placeholderText:      undef,
    // Whether the rich text editor should be rendered on touch devices (wysihtml5 >= 0.3.0 comes with basic support for iOS 5)
    supportTouchDevices:  true,
    // Whether senseless <span> elements (empty or without attributes) should be removed/replaced with their content
    cleanUp:              true,
    // Whether to use div instead of secure iframe
    contentEditableMode: false,
    // Classname of container that editor should not touch and pass through
    // Pass false to disable
    uneditableContainerClassname: "wysihtml5-uneditable-container",
    // Browsers that support copied source handling will get a marking of the origin of the copied source (for determinig code cleanup rules on paste)
    // Also copied source is based directly on selection - 
    // (very useful for webkit based browsers where copy will otherwise contain a lot of code and styles based on whatever and not actually in selection).
    // If falsy value is passed source override is also disabled
    copyedFromMarking: '<meta name="copied-from" content="wysihtml5">'
  };

  wysihtml5.Editor = wysihtml5.lang.Dispatcher.extend(
    /** @scope wysihtml5.Editor.prototype */ {
    constructor: function(editableElement, config) {
      this.editableElement  = typeof(editableElement) === "string" ? document.getElementById(editableElement) : editableElement;
      this.config           = wysihtml5.lang.object({}).merge(defaultConfig).merge(config).get();
      this._isCompatible    = wysihtml5.browser.supported();

      if (this.editableElement.nodeName.toLowerCase() != "textarea") {
          this.config.contentEditableMode = true;
          this.config.noTextarea = true;
      }
      if (!this.config.noTextarea) {
          this.textarea         = new wysihtml5.views.Textarea(this, this.editableElement, this.config);
          this.currentView      = this.textarea;
      }

      // Sort out unsupported/unwanted browsers here
      if (!this._isCompatible || (!this.config.supportTouchDevices && wysihtml5.browser.isTouchDevice())) {
        var that = this;
        setTimeout(function() { that.fire("beforeload").fire("load"); }, 0);
        return;
      }

      // Add class name to body, to indicate that the editor is supported
      wysihtml5.dom.addClass(document.body, this.config.bodyClassName);

      this.composer = new wysihtml5.views.Composer(this, this.editableElement, this.config);
      this.currentView = this.composer;

      if (typeof(this.config.parser) === "function") {
        this._initParser();
      }

      this.on("beforeload", this.handleBeforeLoad);
    },

    handleBeforeLoad: function() {
        if (!this.config.noTextarea) {
            this.synchronizer = new wysihtml5.views.Synchronizer(this, this.textarea, this.composer);
        }
        if (this.config.toolbar) {
          this.toolbar = new wysihtml5.toolbar.Toolbar(this, this.config.toolbar, this.config.showToolbarAfterInit);
        }
    },

    isCompatible: function() {
      return this._isCompatible;
    },

    clear: function() {
      this.currentView.clear();
      return this;
    },

    getValue: function(parse, clearInternals) {
      return this.currentView.getValue(parse, clearInternals);
    },

    setValue: function(html, parse) {
      this.fire("unset_placeholder");

      if (!html) {
        return this.clear();
      }

      this.currentView.setValue(html, parse);
      return this;
    },

    cleanUp: function() {
        this.currentView.cleanUp();
    },

    focus: function(setToEnd) {
      this.currentView.focus(setToEnd);
      return this;
    },

    /**
     * Deactivate editor (make it readonly)
     */
    disable: function() {
      this.currentView.disable();
      return this;
    },

    /**
     * Activate editor
     */
    enable: function() {
      this.currentView.enable();
      return this;
    },

    isEmpty: function() {
      return this.currentView.isEmpty();
    },

    hasPlaceholderSet: function() {
      return this.currentView.hasPlaceholderSet();
    },

    parse: function(htmlOrElement, clearInternals) {
      var parseContext = (this.config.contentEditableMode) ? document : ((this.composer) ? this.composer.sandbox.getDocument() : null);
      var returnValue = this.config.parser(htmlOrElement, {
        "rules": this.config.parserRules,
        "cleanUp": this.config.cleanUp,
        "context": parseContext,
        "uneditableClass": this.config.uneditableContainerClassname,
        "clearInternals" : clearInternals
      });
      if (typeof(htmlOrElement) === "object") {
        wysihtml5.quirks.redraw(htmlOrElement);
      }
      return returnValue;
    },

    /**
     * Prepare html parser logic
     *  - Observes for paste and drop
     */
    _initParser: function() {
      var that = this,
          oldHtml,
          cleanHtml;

      if (wysihtml5.browser.supportsModenPaste()) {
        this.on("paste:composer", function(event) {
          event.preventDefault();
          oldHtml = wysihtml5.dom.getPastedHtml(event);
          if (oldHtml) {
            that._cleanAndPaste(oldHtml);
          }
        });

      } else {
        this.on("beforepaste:composer", function(event) {
          event.preventDefault();
          wysihtml5.dom.getPastedHtmlWithDiv(that.composer, function(pastedHTML) {
            if (pastedHTML) {
              that._cleanAndPaste(pastedHTML);
            }
          });
        });

      }
    },

    _cleanAndPaste: function (oldHtml) {
      var cleanHtml = wysihtml5.quirks.cleanPastedHTML(oldHtml, {
        "referenceNode": this.composer.element,
        "rules": this.config.pasteParserRulesets || [{"set": this.config.parserRules}],
        "uneditableClass": this.config.uneditableContainerClassname
      });
      this.composer.selection.deleteContents();
      this.composer.selection.insertHTML(cleanHtml);
    }
  });
})(wysihtml5);
;/**
 * Toolbar Dialog
 *
 * @param {Element} link The toolbar link which causes the dialog to show up
 * @param {Element} container The dialog container
 *
 * @example
 *    <!-- Toolbar link -->
 *    <a data-wysihtml5-command="insertImage">insert an image</a>
 *
 *    <!-- Dialog -->
 *    <div data-wysihtml5-dialog="insertImage" style="display: none;">
 *      <label>
 *        URL: <input data-wysihtml5-dialog-field="src" value="http://">
 *      </label>
 *      <label>
 *        Alternative text: <input data-wysihtml5-dialog-field="alt" value="">
 *      </label>
 *    </div>
 *
 *    <script>
 *      var dialog = new wysihtml5.toolbar.Dialog(
 *        document.querySelector("[data-wysihtml5-command='insertImage']"),
 *        document.querySelector("[data-wysihtml5-dialog='insertImage']")
 *      );
 *      dialog.observe("save", function(attributes) {
 *        // do something
 *      });
 *    </script>
 */
(function(wysihtml5) {
  var dom                     = wysihtml5.dom,
      CLASS_NAME_OPENED       = "wysihtml5-command-dialog-opened",
      SELECTOR_FORM_ELEMENTS  = "input, select, textarea",
      SELECTOR_FIELDS         = "[data-wysihtml5-dialog-field]",
      ATTRIBUTE_FIELDS        = "data-wysihtml5-dialog-field";


  wysihtml5.toolbar.Dialog = wysihtml5.lang.Dispatcher.extend(
    /** @scope wysihtml5.toolbar.Dialog.prototype */ {
    constructor: function(link, container) {
      this.link       = link;
      this.container  = container;
    },

    _observe: function() {
      if (this._observed) {
        return;
      }

      var that = this,
          callbackWrapper = function(event) {
            var attributes = that._serialize();
            if (attributes == that.elementToChange) {
              that.fire("edit", attributes);
            } else {
              that.fire("save", attributes);
            }
            that.hide();
            event.preventDefault();
            event.stopPropagation();
          };

      dom.observe(that.link, "click", function() {
        if (dom.hasClass(that.link, CLASS_NAME_OPENED)) {
          setTimeout(function() { that.hide(); }, 0);
        }
      });

      dom.observe(this.container, "keydown", function(event) {
        var keyCode = event.keyCode;
        if (keyCode === wysihtml5.ENTER_KEY) {
          callbackWrapper(event);
        }
        if (keyCode === wysihtml5.ESCAPE_KEY) {
          that.fire("cancel");
          that.hide();
        }
      });

      dom.delegate(this.container, "[data-wysihtml5-dialog-action=save]", "click", callbackWrapper);

      dom.delegate(this.container, "[data-wysihtml5-dialog-action=cancel]", "click", function(event) {
        that.fire("cancel");
        that.hide();
        event.preventDefault();
        event.stopPropagation();
      });

      var formElements  = this.container.querySelectorAll(SELECTOR_FORM_ELEMENTS),
          i             = 0,
          length        = formElements.length,
          _clearInterval = function() { clearInterval(that.interval); };
      for (; i<length; i++) {
        dom.observe(formElements[i], "change", _clearInterval);
      }

      this._observed = true;
    },

    /**
     * Grabs all fields in the dialog and puts them in key=>value style in an object which
     * then gets returned
     */
    _serialize: function() {
      var data    = this.elementToChange || {},
          fields  = this.container.querySelectorAll(SELECTOR_FIELDS),
          length  = fields.length,
          i       = 0;

      for (; i<length; i++) {
        data[fields[i].getAttribute(ATTRIBUTE_FIELDS)] = fields[i].value;
      }
      return data;
    },

    /**
     * Takes the attributes of the "elementToChange"
     * and inserts them in their corresponding dialog input fields
     *
     * Assume the "elementToChange" looks like this:
     *    <a href="http://www.google.com" target="_blank">foo</a>
     *
     * and we have the following dialog:
     *    <input type="text" data-wysihtml5-dialog-field="href" value="">
     *    <input type="text" data-wysihtml5-dialog-field="target" value="">
     *
     * after calling _interpolate() the dialog will look like this
     *    <input type="text" data-wysihtml5-dialog-field="href" value="http://www.google.com">
     *    <input type="text" data-wysihtml5-dialog-field="target" value="_blank">
     *
     * Basically it adopted the attribute values into the corresponding input fields
     *
     */
    _interpolate: function(avoidHiddenFields) {
      var field,
          fieldName,
          newValue,
          focusedElement = document.querySelector(":focus"),
          fields         = this.container.querySelectorAll(SELECTOR_FIELDS),
          length         = fields.length,
          i              = 0;
      for (; i<length; i++) {
        field = fields[i];

        // Never change elements where the user is currently typing in
        if (field === focusedElement) {
          continue;
        }

        // Don't update hidden fields
        // See https://github.com/xing/wysihtml5/pull/14
        if (avoidHiddenFields && field.type === "hidden") {
          continue;
        }

        fieldName = field.getAttribute(ATTRIBUTE_FIELDS);
        newValue  = (this.elementToChange && typeof(this.elementToChange) !== 'boolean') ? (this.elementToChange.getAttribute(fieldName) || "") : field.defaultValue;
        field.value = newValue;
      }
    },

    /**
     * Show the dialog element
     */
    show: function(elementToChange) {
      if (dom.hasClass(this.link, CLASS_NAME_OPENED)) {
        return;
      }

      var that        = this,
          firstField  = this.container.querySelector(SELECTOR_FORM_ELEMENTS);
      this.elementToChange = elementToChange;
      this._observe();
      this._interpolate();
      if (elementToChange) {
        this.interval = setInterval(function() { that._interpolate(true); }, 500);
      }
      dom.addClass(this.link, CLASS_NAME_OPENED);
      this.container.style.display = "";
      this.fire("show");
      if (firstField && !elementToChange) {
        try {
          firstField.focus();
        } catch(e) {}
      }
    },

    /**
     * Hide the dialog element
     */
    hide: function() {
      clearInterval(this.interval);
      this.elementToChange = null;
      dom.removeClass(this.link, CLASS_NAME_OPENED);
      this.container.style.display = "none";
      this.fire("hide");
    }
  });
})(wysihtml5);
;/**
 * Converts speech-to-text and inserts this into the editor
 * As of now (2011/03/25) this only is supported in Chrome >= 11
 *
 * Note that it sends the recorded audio to the google speech recognition api:
 * http://stackoverflow.com/questions/4361826/does-chrome-have-buil-in-speech-recognition-for-input-type-text-x-webkit-speec
 *
 * Current HTML5 draft can be found here
 * http://lists.w3.org/Archives/Public/public-xg-htmlspeech/2011Feb/att-0020/api-draft.html
 *
 * "Accessing Google Speech API Chrome 11"
 * http://mikepultz.com/2011/03/accessing-google-speech-api-chrome-11/
 */
(function(wysihtml5) {
  var dom = wysihtml5.dom;

  var linkStyles = {
    position: "relative"
  };

  var wrapperStyles = {
    left:     0,
    margin:   0,
    opacity:  0,
    overflow: "hidden",
    padding:  0,
    position: "absolute",
    top:      0,
    zIndex:   1
  };

  var inputStyles = {
    cursor:     "inherit",
    fontSize:   "50px",
    height:     "50px",
    marginTop:  "-25px",
    outline:    0,
    padding:    0,
    position:   "absolute",
    right:      "-4px",
    top:        "50%"
  };

  var inputAttributes = {
    "x-webkit-speech": "",
    "speech":          ""
  };

  wysihtml5.toolbar.Speech = function(parent, link) {
    var input = document.createElement("input");
    if (!wysihtml5.browser.supportsSpeechApiOn(input)) {
      link.style.display = "none";
      return;
    }
    var lang = parent.editor.textarea.element.getAttribute("lang");
    if (lang) {
      inputAttributes.lang = lang;
    }

    var wrapper = document.createElement("div");

    wysihtml5.lang.object(wrapperStyles).merge({
      width:  link.offsetWidth  + "px",
      height: link.offsetHeight + "px"
    });

    dom.insert(input).into(wrapper);
    dom.insert(wrapper).into(link);

    dom.setStyles(inputStyles).on(input);
    dom.setAttributes(inputAttributes).on(input);

    dom.setStyles(wrapperStyles).on(wrapper);
    dom.setStyles(linkStyles).on(link);

    var eventName = "onwebkitspeechchange" in input ? "webkitspeechchange" : "speechchange";
    dom.observe(input, eventName, function() {
      parent.execCommand("insertText", input.value);
      input.value = "";
    });

    dom.observe(input, "click", function(event) {
      if (dom.hasClass(link, "wysihtml5-command-disabled")) {
        event.preventDefault();
      }

      event.stopPropagation();
    });
  };
})(wysihtml5);
;/**
 * Toolbar
 *
 * @param {Object} parent Reference to instance of Editor instance
 * @param {Element} container Reference to the toolbar container element
 *
 * @example
 *    <div id="toolbar">
 *      <a data-wysihtml5-command="createLink">insert link</a>
 *      <a data-wysihtml5-command="formatBlock" data-wysihtml5-command-value="h1">insert h1</a>
 *    </div>
 *
 *    <script>
 *      var toolbar = new wysihtml5.toolbar.Toolbar(editor, document.getElementById("toolbar"));
 *    </script>
 */
(function(wysihtml5) {
  var CLASS_NAME_COMMAND_DISABLED   = "wysihtml5-command-disabled",
      CLASS_NAME_COMMANDS_DISABLED  = "wysihtml5-commands-disabled",
      CLASS_NAME_COMMAND_ACTIVE     = "wysihtml5-command-active",
      CLASS_NAME_ACTION_ACTIVE      = "wysihtml5-action-active",
      dom                           = wysihtml5.dom;

  wysihtml5.toolbar.Toolbar = Base.extend(
    /** @scope wysihtml5.toolbar.Toolbar.prototype */ {
    constructor: function(editor, container, showOnInit) {
      this.editor     = editor;
      this.container  = typeof(container) === "string" ? document.getElementById(container) : container;
      this.composer   = editor.composer;

      this._getLinks("command");
      this._getLinks("action");

      this._observe();
      if (showOnInit) { this.show(); }

      if (editor.config.classNameCommandDisabled != null) {
        CLASS_NAME_COMMAND_DISABLED = editor.config.classNameCommandDisabled;
      }
      if (editor.config.classNameCommandsDisabled != null) {
        CLASS_NAME_COMMANDS_DISABLED = editor.config.classNameCommandsDisabled;
      }
      if (editor.config.classNameCommandActive != null) {
        CLASS_NAME_COMMAND_ACTIVE = editor.config.classNameCommandActive;
      }
      if (editor.config.classNameActionActive != null) {
        CLASS_NAME_ACTION_ACTIVE = editor.config.classNameActionActive;
      }

      var speechInputLinks  = this.container.querySelectorAll("[data-wysihtml5-command=insertSpeech]"),
          length            = speechInputLinks.length,
          i                 = 0;
      for (; i<length; i++) {
        new wysihtml5.toolbar.Speech(this, speechInputLinks[i]);
      }
    },

    _getLinks: function(type) {
      var links   = this[type + "Links"] = wysihtml5.lang.array(this.container.querySelectorAll("[data-wysihtml5-" + type + "]")).get(),
          length  = links.length,
          i       = 0,
          mapping = this[type + "Mapping"] = {},
          link,
          group,
          name,
          value,
          dialog;
      for (; i<length; i++) {
        link    = links[i];
        name    = link.getAttribute("data-wysihtml5-" + type);
        value   = link.getAttribute("data-wysihtml5-" + type + "-value");
        group   = this.container.querySelector("[data-wysihtml5-" + type + "-group='" + name + "']");
        dialog  = this._getDialog(link, name);

        mapping[name + ":" + value] = {
          link:   link,
          group:  group,
          name:   name,
          value:  value,
          dialog: dialog,
          state:  false
        };
      }
    },

    _getDialog: function(link, command) {
      var that          = this,
          dialogElement = this.container.querySelector("[data-wysihtml5-dialog='" + command + "']"),
          dialog,
          caretBookmark;

      if (dialogElement) {
        if (wysihtml5.toolbar["Dialog_" + command]) {
            dialog = new wysihtml5.toolbar["Dialog_" + command](link, dialogElement);
        } else {
            dialog = new wysihtml5.toolbar.Dialog(link, dialogElement);
        }

        dialog.on("show", function() {
          caretBookmark = that.composer.selection.getBookmark();

          that.editor.fire("show:dialog", { command: command, dialogContainer: dialogElement, commandLink: link });
        });

        dialog.on("save", function(attributes) {
          if (caretBookmark) {
            that.composer.selection.setBookmark(caretBookmark);
          }
          that._execCommand(command, attributes);

          that.editor.fire("save:dialog", { command: command, dialogContainer: dialogElement, commandLink: link });
        });

        dialog.on("cancel", function() {
          that.editor.focus(false);
          that.editor.fire("cancel:dialog", { command: command, dialogContainer: dialogElement, commandLink: link });
        });
      }
      return dialog;
    },

    /**
     * @example
     *    var toolbar = new wysihtml5.Toolbar();
     *    // Insert a <blockquote> element or wrap current selection in <blockquote>
     *    toolbar.execCommand("formatBlock", "blockquote");
     */
    execCommand: function(command, commandValue) {
      if (this.commandsDisabled) {
        return;
      }

      var commandObj = this.commandMapping[command + ":" + commandValue];

      // Show dialog when available
      if (commandObj && commandObj.dialog && !commandObj.state) {
        commandObj.dialog.show();
      } else {
        this._execCommand(command, commandValue);
      }
    },

    _execCommand: function(command, commandValue) {
      // Make sure that composer is focussed (false => don't move caret to the end)
      this.editor.focus(false);

      this.composer.commands.exec(command, commandValue);
      this._updateLinkStates();
    },

    execAction: function(action) {
      var editor = this.editor;
      if (action === "change_view") {
        if (editor.textarea) {
            if (editor.currentView === editor.textarea) {
              editor.fire("change_view", "composer");
            } else {
              editor.fire("change_view", "textarea");
            }
        }
      }
      if (action == "showSource") {
          editor.fire("showSource");
      }
    },

    _observe: function() {
      var that      = this,
          editor    = this.editor,
          container = this.container,
          links     = this.commandLinks.concat(this.actionLinks),
          length    = links.length,
          i         = 0;

      for (; i<length; i++) {
        // 'javascript:;' and unselectable=on Needed for IE, but done in all browsers to make sure that all get the same css applied
        // (you know, a:link { ... } doesn't match anchors with missing href attribute)
        if (links[i].nodeName === "A") {
          dom.setAttributes({
            href:         "javascript:;",
            unselectable: "on"
          }).on(links[i]);
        } else {
          dom.setAttributes({ unselectable: "on" }).on(links[i]);
        }
      }

      // Needed for opera and chrome
      dom.delegate(container, "[data-wysihtml5-command], [data-wysihtml5-action]", "mousedown", function(event) { event.preventDefault(); });

      dom.delegate(container, "[data-wysihtml5-command]", "click", function(event) {
        var link          = this,
            command       = link.getAttribute("data-wysihtml5-command"),
            commandValue  = link.getAttribute("data-wysihtml5-command-value");
        that.execCommand(command, commandValue);
        event.preventDefault();
      });

      dom.delegate(container, "[data-wysihtml5-action]", "click", function(event) {
        var action = this.getAttribute("data-wysihtml5-action");
        that.execAction(action);
        event.preventDefault();
      });

      editor.on("interaction:composer", function() {
          that._updateLinkStates();
      });

      editor.on("focus:composer", function() {
        that.bookmark = null;
      });

      if (this.editor.config.handleTables) {
          editor.on("tableselect:composer", function() {
              that.container.querySelectorAll('[data-wysihtml5-hiddentools="table"]')[0].style.display = "";
          });
          editor.on("tableunselect:composer", function() {
              that.container.querySelectorAll('[data-wysihtml5-hiddentools="table"]')[0].style.display = "none";
          });
      }

      editor.on("change_view", function(currentView) {
        // Set timeout needed in order to let the blur event fire first
        if (editor.textarea) {
            setTimeout(function() {
              that.commandsDisabled = (currentView !== "composer");
              that._updateLinkStates();
              if (that.commandsDisabled) {
                dom.addClass(container, CLASS_NAME_COMMANDS_DISABLED);
              } else {
                dom.removeClass(container, CLASS_NAME_COMMANDS_DISABLED);
              }
            }, 0);
        }
      });
    },

    _updateLinkStates: function() {

      var commandMapping    = this.commandMapping,
          actionMapping     = this.actionMapping,
          i,
          state,
          action,
          command;
      // every millisecond counts... this is executed quite often
      for (i in commandMapping) {
        command = commandMapping[i];
        if (this.commandsDisabled) {
          state = false;
          dom.removeClass(command.link, CLASS_NAME_COMMAND_ACTIVE);
          if (command.group) {
            dom.removeClass(command.group, CLASS_NAME_COMMAND_ACTIVE);
          }
          if (command.dialog) {
            command.dialog.hide();
          }
        } else {
          state = this.composer.commands.state(command.name, command.value);
          dom.removeClass(command.link, CLASS_NAME_COMMAND_DISABLED);
          if (command.group) {
            dom.removeClass(command.group, CLASS_NAME_COMMAND_DISABLED);
          }
        }
        if (command.state === state) {
          continue;
        }

        command.state = state;
        if (state) {
          dom.addClass(command.link, CLASS_NAME_COMMAND_ACTIVE);
          if (command.group) {
            dom.addClass(command.group, CLASS_NAME_COMMAND_ACTIVE);
          }
          if (command.dialog) {
            if (typeof(state) === "object" || wysihtml5.lang.object(state).isArray()) {

              if (!command.dialog.multiselect && wysihtml5.lang.object(state).isArray()) {
                // Grab first and only object/element in state array, otherwise convert state into boolean
                // to avoid showing a dialog for multiple selected elements which may have different attributes
                // eg. when two links with different href are selected, the state will be an array consisting of both link elements
                // but the dialog interface can only update one
                state = state.length === 1 ? state[0] : true;
                command.state = state;
              }
              command.dialog.show(state);
            } else {
              command.dialog.hide();
            }
          }
        } else {
          dom.removeClass(command.link, CLASS_NAME_COMMAND_ACTIVE);
          if (command.group) {
            dom.removeClass(command.group, CLASS_NAME_COMMAND_ACTIVE);
          }
          if (command.dialog) {
            command.dialog.hide();
          }
        }
      }

      for (i in actionMapping) {
        action = actionMapping[i];

        if (action.name === "change_view") {
          action.state = this.editor.currentView === this.editor.textarea;
          if (action.state) {
            dom.addClass(action.link, CLASS_NAME_ACTION_ACTIVE);
          } else {
            dom.removeClass(action.link, CLASS_NAME_ACTION_ACTIVE);
          }
        }
      }
    },

    show: function() {
      this.container.style.display = "";
    },

    hide: function() {
      this.container.style.display = "none";
    }
  });

})(wysihtml5);
;(function(wysihtml5) {
    wysihtml5.toolbar.Dialog_createTable = wysihtml5.toolbar.Dialog.extend({
        show: function(elementToChange) {
            this.base(elementToChange);

        }

    });
})(wysihtml5);
;(function(wysihtml5) {
  var dom                     = wysihtml5.dom,
      SELECTOR_FIELDS         = "[data-wysihtml5-dialog-field]",
      ATTRIBUTE_FIELDS        = "data-wysihtml5-dialog-field";

  wysihtml5.toolbar.Dialog_foreColorStyle = wysihtml5.toolbar.Dialog.extend({
    multiselect: true,

    _serialize: function() {
      var data    = {},
          fields  = this.container.querySelectorAll(SELECTOR_FIELDS),
          length  = fields.length,
          i       = 0;

      for (; i<length; i++) {
        data[fields[i].getAttribute(ATTRIBUTE_FIELDS)] = fields[i].value;
      }
      return data;
    },

    _interpolate: function(avoidHiddenFields) {
      var field,
          fieldName,
          newValue,
          focusedElement = document.querySelector(":focus"),
          fields         = this.container.querySelectorAll(SELECTOR_FIELDS),
          length         = fields.length,
          i              = 0,
          firstElement   = (this.elementToChange) ? ((wysihtml5.lang.object(this.elementToChange).isArray()) ? this.elementToChange[0] : this.elementToChange) : null,
          colorStr       = (firstElement) ? firstElement.getAttribute('style') : null,
          color          = (colorStr) ? wysihtml5.quirks.styleParser.parseColor(colorStr, "color") : null;

      for (; i<length; i++) {
        field = fields[i];
        // Never change elements where the user is currently typing in
        if (field === focusedElement) {
          continue;
        }
        // Don't update hidden fields3
        if (avoidHiddenFields && field.type === "hidden") {
          continue;
        }
        if (field.getAttribute(ATTRIBUTE_FIELDS) === "color") {
          if (color) {
            if (color[3] && color[3] != 1) {
              field.value = "rgba(" + color[0] + "," + color[1] + "," + color[2] + "," + color[3] + ");";
            } else {
              field.value = "rgb(" + color[0] + "," + color[1] + "," + color[2] + ");";
            }
          } else {
            field.value = "rgb(0,0,0);";
          }
        }
      }
    }

  });
})(wysihtml5);
;(function(wysihtml5) {
  var dom                     = wysihtml5.dom,
      SELECTOR_FIELDS         = "[data-wysihtml5-dialog-field]",
      ATTRIBUTE_FIELDS        = "data-wysihtml5-dialog-field";

  wysihtml5.toolbar.Dialog_fontSizeStyle = wysihtml5.toolbar.Dialog.extend({
    multiselect: true,

    _serialize: function() {
      return {"size" : this.container.querySelector('[data-wysihtml5-dialog-field="size"]').value};
    },

    _interpolate: function(avoidHiddenFields) {
      var focusedElement = document.querySelector(":focus"),
          field          = this.container.querySelector("[data-wysihtml5-dialog-field='size']"),
          firstElement   = (this.elementToChange) ? ((wysihtml5.lang.object(this.elementToChange).isArray()) ? this.elementToChange[0] : this.elementToChange) : null,
          styleStr       = (firstElement) ? firstElement.getAttribute('style') : null,
          size           = (styleStr) ? wysihtml5.quirks.styleParser.parseFontSize(styleStr) : null;

      if (field && field !== focusedElement && size && !(/^\s*$/).test(size)) {
        field.value = size;
      }
    }

  });
})(wysihtml5);
/*global JST*/


Backbone.Marionette.Renderer.render = function(template, data) {
  if (_.isFunction(template)) {
    return template(data);
  }
  if (template.indexOf('templates/') === 0) {
    template = 'pageflow/editor/' + template;
  }
  if (!JST[template]) {
    throw "Template '" + template + "' not found!";
  }
  return JST[template](data);
};
(function() {
  // Class-y constructor by github.com/opensas
  // https://github.com/jashkenas/backbone/issues/2601

  pageflow.Object = function(options) {
      this.initialize.apply(this, arguments);
  };
  _.extend(pageflow.Object.prototype, Backbone.Events, {
      initialize: function(options) {}
  });

  // The self-propagating extend function that Backbone classes use.
  pageflow.Object.extend = Backbone.Model.extend;
}());
// pageflow.Object is now part of pageflow/base.js and no longer needs
// to be required by Pageflow extensions. Keep this file for backwards
// compatibility.


;
pageflow.i18nUtils = {
  findTranslation: function(keys, options) {
    options = options || {};

    return _.chain(keys).reverse().reduce(function(result, key) {
      return I18n.t(key, {defaultValue: result});
    }, options.defaultValue).value();
  },

  findKeyWithTranslation: function(keys) {
    var missing = '_not_translated';

    return _(keys).detect(function(key) {
      return I18n.t(key, {defaultValue: missing}) !== missing;
    }) || _.first(keys);
  },

  translationKeysWithSuffix: function(keys, suffix) {
    return _.chain(keys).map(function(key) {
      return [key + '_' + suffix, key];
    }).flatten().value();
  }
};
/**
 * Mixin for input views handling common concerns like labels,
 * inline help, visiblity and disabling.
 *
 * ## Label and Inline Help Translations
 *
 * By default `#labelText` and `#inlineHelpText` are defined through
 * translations. If no `attributeTranslationKeyPrefixes` are given,
 * translation keys for labels and inline help are constructed from
 * the `i18nKey` of the model and the given `propertyName`
 * option. Suppose the model's `i18nKey` is "page" and the
 * `propertyName` option is "title". Then the key
 *
 *     activerecord.attributes.page.title
 *
 * will be used for the label. And the key
 *
 *     pageflow.ui.inline_help.page.title
 *
 * will be used for the inline help.
 *
 * ### Attribute Translation Key Prefixes
 *
 * The `attributeTranslationKeyPrefixes` option can be used to supply
 * an array of scopes in which label and inline help translations
 * shall be looked up based on the `propertyName` option.
 *
 * Suppose the array `['some.attributes', 'fallback.attributes']` is
 * given as `attributeTranslationKeyPrefixes` option. Then, in the
 * example above, the first existing translation key is used as label:
 *
 *     some.attributes.title.label
 *     fallback.attributes.title.label
 *     activerecord.attributes.post.title
 *
 * Accordingly, for the inline help:
 *
 *     some.attributes.title.inline_help
 *     fallback.attributes.title.inline_help
 *     pageflow.ui.inline_help.post.title
 *
 * This setup allows to keep all translation keys for an attribute
 * to share a common prefix:
 *
 *    some:
 *      attributes:
 *        title:
 *          label: "Label"
 *          inline_help: "..."
 *          inline_help_disabled: "..."
 *
 * ### Inline Help for Disabled Inputs
 *
 * For each inline help translation key, a separate key with an
 * `"_disbaled"` suffix can be supplied, which provides a help string
 * that shall be displayed when the input is disabled. More specific
 * attribute translation key prefixes take precedence over suffixed
 * keys:
 *
 *     some.attributes.title.inline_help
 *     some.attributes.title.inline_help_disabled
 *     fallback.attributes.title.inline_help
 *     fallback.attributes.title.inline_help_disabled
 *     pageflow.ui.inline_help.post.title
 *     pageflow.ui.inline_help.post.title_disabled
 *
 * @option propertyName [String]
 *   Name of the attribute on the model to display and edit.
 *
 * @option label [String]
 *   Label text for the input.
 *
 * @option attributeTranslationKeyPrefixes [Array<String>]
 *   An array of prefixes to lookup translations for labels and
 *   inline help texts based on attribute names.
 *
 * @option disabled [Boolean]
 *   Render input as disabled.
 *
 * @option visibleBinding [String]
 *   Name of an attribute to control whether the input is visible. If
 *   the `visible` and `visibleBindingValue` options are not set,
 *   input will be visible whenever this attribute as a truthy value.
 *
 * @option visible [Function|Boolean]
 *   A Function taking the value of the `visibleBinding` attribute as
 *   parameter. Input will be visible only if function returns `true`.
 *
 * @option visibleBindingValue [Any]
 *   Input will be visible whenever the value of the `visibleBinding`
 *   attribute equals the value of this option.
 */

pageflow.inputView = {
  ui: {
    labelText: 'label .name',
    inlineHelp: 'label .inline_help'
  },

  /**
   * Returns an array of translation keys based on the propertyName
   * options and the given prefixes.
   *
   * @param keyName [String]
   *   Suffix to append to prefixes.
   *
   * @option attributeTranslationKeyPrefixes [Array<String>]
   *   An array of strings to use as prefixes to constructs
   *   translation keys.
   *
   * @option fallbackPrefix [String]
   *   Optional additional prefix to form a model based translation
   *   key of the form `prefix.modelI18nKey.propertyName.keyName
   *
   * @api edge
   */
  attributeTranslationKeys: function(keyName, options) {
    var result = [];

    if (this.options.attributeTranslationKeyPrefixes) {
      result = result.concat(_(this.options.attributeTranslationKeyPrefixes).map(function(prefix) {
        return prefix + '.' + this.options.propertyName + '.' + keyName;
      }, this));
    }

    if (options && options.fallbackPrefix) {
      result.push(options.fallbackPrefix + '.' + this.model.i18nKey + '.' + this.options.propertyName);
    }

    return result;
  },

  /** @private */
  onRender: function() {
    this.$el.addClass(this.model.modelName + '_' + this.options.propertyName);
    this.ui.labelText.text(this.labelText());

    this.ui.inlineHelp.text(this.inlineHelpText());

    if (!this.inlineHelpText()) {
      this.ui.inlineHelp.hide();
    }

    this.updateDisabled();
    this.setupVisibleBinding();
  },

  labelText: function() {
    return this.options.label || this.localizedAttributeName();
  },

  localizedAttributeName: function() {
    return pageflow.i18nUtils.findTranslation(this.attributeTranslationKeys('label', {fallbackPrefix: 'activerecord.attributes'}));
  },

  inlineHelpText: function() {
    var keys = this.attributeTranslationKeys('inline_help', {fallbackPrefix: 'pageflow.ui.inline_help'});

    if (this.options.disabled) {
      keys = pageflow.i18nUtils.translationKeysWithSuffix(keys, 'disabled');
    }

    return pageflow.i18nUtils.findTranslation(keys, {defaultValue: ''});
  },

  /** @private */
  updateDisabled: function() {
    if (this.ui.input) {
      this.updateDisabledAttribute(this.ui.input);
    }
  },

  /** @private */
  updateDisabledAttribute: function(element) {
    if (this.options.disabled) {
      element.attr('disabled', true);
    }
    else {
      element.removeAttr('disabled');
    }
  },

  /** @private */
  setupVisibleBinding: function() {
    var view = this;

    if (this.options.visibleBinding) {
      this.listenTo(this.model, 'change:' + this.options.visibleBinding, updateVisible);
      updateVisible(this.model, this.model.get(this.options.visibleBinding));
    }

    function updateVisible(model, value) {
      view.$el.toggle(isVisible(value));
    }

    function isVisible(value) {
      if (view.options.visibleBindingValue) {
        return value === view.options.visibleBindingValue;
      }
      else if (typeof view.options.visible === 'function') {
        return !!view.options.visible(value);
      }
      else if ('visible' in view.options) {
        return !!view.options.visible;
      }
      else {
        return !!value;
      }
    }
  }
};
pageflow.subviewContainer = {
  subview: function(view) {
    this.subviews = this.subviews || new Backbone.ChildViewContainer();
    this.subviews.add(view.render());
    return view;
  },

  appendSubview: function(view) {
    return this.$el.append(this.subview(view).el);
  },

  onClose: function() {
    if (this.subviews) {
      this.subviews.call('close');
    }
  }
};

Cocktail.mixin(Backbone.Marionette.View, pageflow.subviewContainer);
pageflow.tooltipContainer = {
  events: {
    'mouseover [data-tooltip]': function(event) {
      if (!this.tooltip.visible) {
        var target = $(event.target);
        var key = target.data('tooltip');
        var position;

        if (target.data('tooltipAlign') === 'bottom left') {
          position = {
            left: target.position().left,
            top: target.position().top + target.outerHeight()
          };
        }
        else if (target.data('tooltipAlign') === 'bottom right') {
          position = {
            left: target.position().left + target.outerWidth(),
            top: target.position().top + target.outerHeight()
          };
        }
        else {
          position = {
            left: target.position().left + target.outerWidth(),
            top: target.position().top + target.outerHeight() / 2
          };
        }

        this.tooltip.show(I18n.t(key), position, {
          align: target.data('tooltipAlign')
        })
      }
    },

    'mouseout [data-tooltip]': function() {
      this.tooltip.hide();
    }
  },

  onRender: function() {
    this.appendSubview(this.tooltip = new pageflow.TooltipView());
  }
};
pageflow.SelectInputView = Backbone.Marionette.ItemView.extend({
  mixins: [pageflow.inputView],

  template: 'pageflow/ui/templates/inputs/select_input',

  events: {
    'change': 'save'
  },

  ui: {
    select: 'select',
    input: 'select'
  },

  initialize: function() {
    if (this.options.collection) {
      this.options.values = _.pluck(this.options.collection, this.options.valueProperty);

      if (this.options.textProperty) {
        this.options.texts = _.pluck(this.options.collection, this.options.textProperty);
      }
      else if (this.options.translationKeyProperty) {
        this.options.translationKeys = _.pluck(this.options.collection, this.options.translationKeyProperty);
      }

      if (this.options.groupProperty) {
        this.options.groups = _.pluck(this.options.collection, this.options.groupProperty);
      }
      else if (this.options.groupTranslationKeyProperty) {
        this.options.groupTanslationKeys = _.pluck(this.options.collection, this.options.groupTranslationKeyProperty);
      }
    }

    if (!this.options.texts) {
      if (!this.options.translationKeys) {
        var translationKeyPrefix = this.options.translationKeyPrefix ||
          pageflow.i18nUtils.findKeyWithTranslation(this.attributeTranslationKeys('values', {
            fallbackPrefix: 'activerecord.values'
          }));

        this.options.translationKeys = _.map(this.options.values, function(value) {
          return translationKeyPrefix + '.' + value;
        }, this);
      }

      this.options.texts = _.map(this.options.translationKeys, function(key) {
        return I18n.t(key);
      });
    }

    if (!this.options.groups) {
      this.options.groups = _.map(this.options.groupTanslationKeys, function(key) {
        return I18n.t(key);
      });
    }

    this.optGroups = {};
  },

  onRender: function() {
    this.appendBlank();
    this.appendPlaceholder();
    this.appendOptions();

    this.load();
    this.listenTo(this.model, 'change:' + this.options.propertyName, this.load);

    if (this.options.ensureValueDefined && !this.ui.select.val()) {
      this.ui.select.val(this.options.values[0]);
      this.save();
    }
  },

  appendBlank: function() {
    if (!this.options.includeBlank) {
      return;
    }

    if (this.options.blankTranslationKey) {
      this.options.blankText = I18n.t(this.options.blankTranslationKey);
    }

    var option = document.createElement('option');

    option.value = '';
    option.text = this.options.blankText || I18n.t('pageflow.ui.views.inputs.select_input_view.none');

    this.ui.select.append(option);
  },

  appendPlaceholder: function() {
    if (!this.options.placeholderModel && !this.options.placeholderValue) {
      return;
    }

    var placeholderValue = this.options.placeholderValue || this.options.placeholderModel.get(this.options.propertyName);
    var placeholderIndex = this.options.values.indexOf(placeholderValue);

    if (placeholderIndex >= 0) {
      var option = document.createElement('option');

      option.value = '';
      option.text = I18n.t('pageflow.ui.views.inputs.select_input_view.placeholder', {text: this.options.texts[placeholderIndex]});

      this.ui.select.append(option);
    }
  },

  appendOptions: function() {
    _.each(this.options.values, function(value, index) {
      var option = document.createElement('option');
      var group = this.options.groups[index];

      option.value = value;
      option.text = this.options.texts[index];

      if (group) {
        option.setAttribute('data-group', group);
        this.findOrCreateOptGroup(group).append(option);
      }
      else {
        this.ui.select.append(option);
      }
    }, this);
  },

  findOrCreateOptGroup: function(label) {
    if (!this.optGroups[label]) {
      this.optGroups[label] = $('<optgroup />', {label: label})
        .appendTo(this.ui.select);
    }

    return this.optGroups[label];
  },

  save: function() {
    this.model.set(this.options.propertyName, this.ui.select.val());
  },

  load: function() {
    if (!this.isClosed) {
      this.ui.select.val(this.model.get(this.options.propertyName));
    }
  }
});
pageflow.CollectionView = Backbone.Marionette.View.extend({
  initialize: function() {
    this.rendered = false;
    this.itemViews = new Backbone.ChildViewContainer();

    this.collection.map(this.addItem, this);

    this.listenTo(this.collection, 'add', this.addItem);
    this.listenTo(this.collection, 'remove', this.removeItem);
    this.listenTo(this.collection, 'sort', this.sort);

    if (this.options.loadingViewConstructor) {
      this.listenTo(this.collection, 'request', function() {
        this.loading = true;
        this.togglePlaceHolder();
      });
      this.listenTo(this.collection, 'sync', function() {
        this.loading = false;
        this.togglePlaceHolder();
      });
    }
  },

  render: function() {
    if (!this.rendered) {
      this.$el.append(this.itemViews.map(function(itemView) {
        itemView.$el.data('view', itemView);
        return itemView.render().el;
      }));

      this.togglePlaceHolder();
      this.rendered = true;
    }

    return this;
  },

  onClose: function() {
    this.itemViews.call('close');

    this.closePlaceHolderView();
  },

  addItem: function(item) {
    var view = new this.options.itemViewConstructor(_.extend({
      model: item
    }, this.getItemViewOptions(item)));

    this.itemViews.add(view);

    if (this.rendered) {
      var index = this.collection.indexOf(item);

      view.render();
      view.$el.data('view', view);

      if (index > 0) {
        this.$el.children().eq(index - 1).after(view.el);
      }
      else {
        this.$el.prepend(view.el);
      }

      this.togglePlaceHolder();
    }
  },

  removeItem: function(item) {
    var view = this.itemViews.findByModel(item);

    if (view) {
      this.itemViews.remove(view);
      view.close();

      this.togglePlaceHolder();
    }
  },

  sort: function() {
    var last = null;

    this.collection.each(function(item) {
      var element = this.itemViews.findByModel(item).$el;

      if (last) {
        last.after(element);
      }
      else {
        this.$el.prepend(element);
      }

      last = element;
    }, this);
  },

  getItemViewOptions: function(item) {
    if (typeof this.options.itemViewOptions === 'function') {
      return this.options.itemViewOptions(item);
    }
    else {
      return this.options.itemViewOptions || {};
    }
  },

  closePlaceHolderView: function() {
    if (this.placeHolderView) {
      this.placeHolderView.close();
      this.placeHolderView = null;
    }
  },

  togglePlaceHolder: function() {
    var lastPlaceholderConstructor = this.placeHolderConstructor;
    this.placeHolderConstructor = this.getPlaceHolderConstructor();

    if (this.itemViews.length || !this.placeHolderConstructor) {
      this.closePlaceHolderView();
    }
    else if(!this.placeHolderView || lastPlaceholderConstructor !== this.placeHolderConstructor) {
      this.closePlaceHolderView();

      this.placeHolderView = new this.placeHolderConstructor();
      this.$el.append(this.placeHolderView.render().el);
    }
  },

  getPlaceHolderConstructor: function() {
    if(this.loading && this.options.loadingViewConstructor) {
      return this.options.loadingViewConstructor;
    }
    else if (this.options.blankSlateViewConstructor) {
      return this.options.blankSlateViewConstructor;
    }
  }
});
pageflow.ConfigurationEditorTabView = Backbone.Marionette.View.extend({
  className: 'configuration_editor',

  initialize: function() {
    this.groups = this.options.groups || pageflow.ConfigurationEditorTabView.groups;
  },

  input: function(propertyName, view, options) {
    this.view(view, _.extend({
      placeholderModel: this.options.placeholderModel,
      propertyName: propertyName,
      attributeTranslationKeyPrefixes: this.options.attributeTranslationKeyPrefixes
    }, options || {}));
  },

  view: function(view, options) {
    this.inputs = this.inputs || new Backbone.ChildViewContainer();
    this.inputs.add(new view(_.extend({
      model: this.model,
      parentTab: this.options.tab
    }, options || {})));
  },

  group: function(name, options) {
    this.groups.apply(name, this, options);
  },

  render: function() {
    this.inputs.each(function(input) {
      this.$el.append(input.render().el);
    }, this);

    return this;
  },

  onClose: function() {
    if (this.inputs) {
      this.inputs.call('close');
    }
  }
});

pageflow.ConfigurationEditorTabView.Groups = function() {
  var groups = {};

  this.define = function(name, fn) {
    if (typeof fn !== 'function') {
      throw 'Group has to be function.';
    }

    groups[name] = fn;
  };

  this.apply = function(name, context, options) {
    if (!(name in groups)) {
      throw 'Undefined group named "' + name + '".';
    }

    groups[name].call(context, options || {});
  };
};

pageflow.ConfigurationEditorTabView.groups = new pageflow.ConfigurationEditorTabView.Groups();
pageflow.ConfigurationEditorView = Backbone.Marionette.View.extend({
  className: 'configuration_editor',

  initialize: function() {
    this.tabsView = new pageflow.TabsView({
      i18n: 'pageflow.ui.configuration_editor.tabs',
      defaultTab: this.options.tab
    });
    this.configure();
  },

  configure: function() {},

  tab: function(name, callback) {
    this.tabsView.tab(name, _.bind(function() {
      var tabView = new pageflow.ConfigurationEditorTabView({
        model: this.model,
        placeholderModel: this.options.placeholderModel,
        tab: name,
        attributeTranslationKeyPrefixes: this.options.attributeTranslationKeyPrefixes
      });

      callback.call(tabView);
      return tabView;
    }, this));
  },

  render: function() {
    this.$el.append(this.subview(this.tabsView).el);
    return this;
  }
});

_.extend(pageflow.ConfigurationEditorView, {
  repository: {},
  register: function(pageTypeName, prototype) {
    this.repository[pageTypeName] = pageflow.ConfigurationEditorView.extend(prototype);
  }
});
pageflow.CheckBoxInputView = Backbone.Marionette.ItemView.extend({
  mixins: [pageflow.inputView],

  template: 'pageflow/ui/templates/inputs/check_box',
  className: 'check_box_input',

  events: {
    'change': 'save'
  },

  ui: {
    input: 'input',
    label: 'label'
  },

  onRender: function() {
    this.ui.label.attr('for', this.cid);
    this.ui.input.attr('id', this.cid);

    this.load();
    this.listenTo(this.model, 'change:' + this.options.propertyName, this.load);
  },

  save: function() {
    if (!this.options.disabled) {
      this.model.set(this.options.propertyName, this.ui.input.is(':checked'));
    }
  },

  load: function() {
    if (!this.isClosed) {
      this.ui.input.prop('checked', this.displayValue());
    }
  },

  displayValue: function() {
    if (this.options.disabled && this.options.displayUncheckedIfDisabled) {
      return false;
    }
    else {
      return this.model.get(this.options.propertyName);
    }
  }
});
pageflow.ExtendedSelectInputView = pageflow.SelectInputView.extend({
  className: 'extended_select_input',

  initialize: function() {
    pageflow.SelectInputView.prototype.initialize.apply(this, arguments);

    if (this.options.collection) {
      if (this.options.descriptionProperty) {
        this.options.descriptions = _.pluck(this.options.collection, this.options.descriptionProperty);
      }
      else if (this.options.descriptionTranslationKeyProperty) {
        this.options.descriptionTanslationKeys = _.pluck(this.options.collection, this.options.descriptionTranslationKeyProperty);
      }
    }

    if (!this.options.descriptions) {
      this.options.descriptions = _.map(this.options.descriptionTanslationKeys, function(key) {
        return I18n.t(key);
      });
    }
  },

  onRender: function() {
    var view = this,
        options = this.options;

    pageflow.SelectInputView.prototype.onRender.apply(this, arguments);

    $.widget("custom.extendedselectmenu", $.ui.selectmenu, {
      _renderItem: function(ul, item) {
        var widget = this;
        var li = $('<li>', { class: item.value });
        var container = $('<div>', { class: 'text-container' }).appendTo(li);
        var index = options.values.indexOf(item.value);

        if (item.disabled) {
          li.addClass('ui-state-disabled');
        }

        if (options.pictogramClass) {
          $('<span>', {
            class: options.pictogramClass
          }).prependTo(li);
        }

        $('<p>', {
          text: item.label,
          class: 'item-text'
        }).appendTo(container);

        $('<p>', {
          text: options.descriptions[index],
          class: 'item-description'
        }).appendTo(container);

        if (options.helpLinkClicked) {
          $('<a>', {
            href: '#',
            title: I18n.t('pageflow.ui.views.extended_select_input_view.display_help'),
          })
            .on('click', function() {
              widget.close();
              options.helpLinkClicked(item.value);
              return false;
            })
            .appendTo(li);
        }

        return li.appendTo(ul);
      },

      _resizeMenu: function() {
        this.menuWrap.addClass('extended_select_input_menu');

        var menuHeight = this.menu.height(),
            menuOffset = this.button.offset().top + this.button.outerHeight(),
            bodyHeight = $('body').height();

        if (menuHeight + menuOffset > bodyHeight) {
          this.menuWrap.outerHeight(bodyHeight - menuOffset - 5).css({ 'overflow-y': 'scroll' });
        }
        else {
          this.menuWrap.css({
            height: 'initial',
            'overflow-y': 'initial'
          });
        }
      }
    });

    this.ui.select.extendedselectmenu({
      select: view.select.bind(view),
      width: '100%',
      position: {
        my: 'right top',
        at: 'right bottom'
      }
    });
  },

  select: function(event, ui) {
    this.ui.select.val(ui.item.value);
    this.save();
  }

});
/*global editor*/


pageflow.FileInputView = Backbone.Marionette.ItemView.extend({
  mixins: [pageflow.inputView],

  template: 'pageflow/ui/templates/inputs/file_input',
  className: 'file_input',

  ui: {
    fileName: '.file_name',
    thumbnail: '.file_thumbnail',
    editPositioningButton: '.edit_positioning',
    unsetButton: '.unset'
  },

  events: {
    'click .choose': function() {
      pageflow.editor.selectFile(
        this.options.collection.name,
        this.options.fileSelectionHandler || 'pageConfiguration',
        _.extend({
          id: this.model.getRoutableId ? this.model.getRoutableId() : this.model.id,
          attributeName: this.options.propertyName,
          returnToTab: this.options.parentTab
        }, this.options.fileSelectionHandlerOptions || {})
      );

      return false;
    },

    'click .unset': function() {
      this.model.unsetReference(this.options.propertyName);
      return false;
    },

    'click. .edit_positioning': function() {
      pageflow.BackgroundPositioningView.open({
        model: this.model,
        propertyName: this.options.propertyName,
        filesCollection: this.options.collection
      });
      return false;
    }
  },

  initialize: function() {
    this.options = _.extend({
      positioning: true
    }, this.options);

    if (typeof this.options.collection === 'string') {
      this.options.collection = pageflow.entry.getFileCollection(
        pageflow.editor.fileTypes.findByCollectionName(this.options.collection)
      );
    }
  },

  onRender: function() {
    this.update();
    this.listenTo(this.model, 'change:' + this.options.propertyName, this.update);
  },

  update: function() {
    var file = this._getFile();

    this.ui.fileName.text(file ? file.get('file_name') : I18n.t('pageflow.ui.views.inputs.file_input_view.none'));
    this.ui.unsetButton.toggle(!!file);
    this.ui.editPositioningButton.toggle(this.options.positioning && !!file && file.isPositionable());

    this.subview(new pageflow.FileThumbnailView({
      el: this.ui.thumbnail,
      model: file
    }));
  },

  _getFile: function() {
    return this.model.getReference(this.options.propertyName, this.options.collection);
  }
});
pageflow.UrlInputView = Backbone.Marionette.Layout.extend({
  mixins: [pageflow.inputView],

  template: 'pageflow/ui/templates/inputs/url_input',

  ui: {
    input: 'input',
    validation: '.validation'
  },

  events: {
    'change': 'onChange'
  },

  onRender: function() {
    this.ui.validation.hide();
    this.load();
    this.validate();
  },

  onChange: function() {
    var view = this;

    this.saveDisplayProperty();

    this.validate().done(function() {
      view.save();
    });
  },

  saveDisplayProperty: function() {
    this.model.set(this.options.displayPropertyName, this.ui.input.val());
    this.model.unset(this.options.propertyName);
  },

  save: function() {
    var view = this;

    $.when(this.transformPropertyValue(this.ui.input.val())).then(function(value) {
      view.model.set(view.options.propertyName, value);
    });
  },

  load: function() {
    this.ui.input.val(this.model.get(this.options.displayPropertyName));
    this.onLoad();
  },

  /**
   * Override to be notified when the input has been loaded.
   */
  onLoad: function() {},

  /**
   * Override to validate the untransformed url. Validation error
   * message can be passed as rejected promise. Progress notifications
   * are displayed. Only valid urls are stored in the configuration.
   *
   * @return Promise
   */
  validateUrl: function(url) {
    return $.Deferred().resolve().promise();
  },

  /**
   * Override to transform the property value before it is stored.
   *
   * @return Promise | String
   */
  transformPropertyValue: function(value) {
    return value;
  },

  /**
   * Override to change the list of supported host names.
   */
  supportedHosts: function() {
    return this.options.supportedHosts;
  },

  validate: function(success) {
    var view = this;
    var options = this.options;
    var value = this.ui.input.val();

    if (options.required && !value) {
      displayValidationError(I18n.t('pageflow.ui.views.inputs.url_input_view.required_field'));
    }
    else if (value && !isValidUrl(value)) {
      var errorMessage = I18n.t('pageflow.ui.views.inputs.url_input_view.url_hint');

      if (options.permitHttps) {
        errorMessage = I18n.t('pageflow.ui.views.inputs.url_input_view.url_hint_https');
      }

      displayValidationError(errorMessage);
    }
    else if (value && !hasSupportedHost(value)) {
      displayValidationError(I18n.t('pageflow.ui.views.inputs.url_input_view.supported_vendors') +
                             _.map(view.supportedHosts(), function(url) {
                               return '<li>' + url +'</li>';
                             }).join(''));
    }
    else {
      return view.validateUrl(value)
        .progress(function(message) {
          displayValidationPending(message);
        })
        .done(function() {
          resetValidationError();
        })
        .fail(function(error) {
          displayValidationError(error);
        });
    }

    return $.Deferred().reject().promise();

    function isValidUrl(url) {
      return options.permitHttps ? url.match(/^https?:\/\//i) : url.match(/^http:\/\//i);
    }

    function hasSupportedHost(url) {
      return _.any(view.supportedHosts(), function(host) {
        return url.match(new RegExp('^' + host));
      });
    }

    function displayValidationError(message) {
      view.$el.addClass('invalid');
      view.ui.validation
        .removeClass('pending')
        .addClass('failed')
        .html(message)
        .show();
    }

    function displayValidationPending(message) {
      view.$el.removeClass('invalid');
      view.ui.validation
        .removeClass('failed')
        .addClass('pending')
        .html(message)
        .show();
    }

    function resetValidationError(message) {
      view.$el.removeClass('invalid');
      view.ui.validation.hide();
    }
  }
});

pageflow.ProxyUrlInputView = pageflow.UrlInputView.extend({
  /** @override */
  validateUrl: function(url) {
    var view = this;

    return $.Deferred(function(deferred) {
      deferred.notify(I18n.t('pageflow.ui.views.inputs.proxy_url_input_view.url_validation'));

      $.ajax({
        url: view.rewriteUrl(url),
        dataType: 'html'
      })
        .done(deferred.resolve)
        .fail(function(xhr) {
          deferred.reject(I18n.t('pageflow.ui.views.inputs.proxy_url_input_view.http_error', { status: xhr.status}));
        });
    }).promise();
  },

  /** @override */
  transformPropertyValue: function(url) {
    return this.rewriteUrl(url);
  },

  /** @override */
  supportedHosts: function() {
    return _.pluck(this.options.proxies, 'url');
  },

  rewriteUrl: function(url) {
    _.each(this.options.proxies, function(proxy) {
      url = url.replace(new RegExp('^' + proxy.url + '/?'), proxy.base_path + '/');
    });

    return url;
  }
});
pageflow.SliderInputView = Backbone.Marionette.ItemView.extend({
  mixins: [pageflow.inputView],

  className: 'slider_input',
  template: 'pageflow/ui/templates/inputs/slider_input',

  ui: {
    widget: '.slider',
    value: '.value'
  },

  events: {
    'slidechange': 'save'
  },

  onRender: function() {
    this.ui.widget.slider({
      animate: 'fast',
      min: 'minValue' in this.options ? this.options.minValue : 0,
      max: 'maxValue' in this.options ? this.options.maxValue : 100,
    });

    this.load();
  },

  save: function() {
    var value = this.ui.widget.slider('option', 'value');
    var unit = 'unit' in this.options ? this.options.unit : '%';

    this.ui.value.text(value + unit);

    this.model.set(this.options.propertyName, value);
  },

  load: function() {
    var value;

    if (this.model.has(this.options.propertyName)) {
      value = this.model.get(this.options.propertyName)
    }
    else {
      value = 'defaultValue' in this.options ? this.options.defaultValue : 0
    }

    this.ui.widget.slider('option', 'value', value);
  }
});
/*global wysihtml5, wysihtml5ParserRules*/


pageflow.TextAreaInputView = Backbone.Marionette.ItemView.extend({
  mixins: [pageflow.inputView],

  template: 'pageflow/ui/templates/inputs/text_area_input',

  ui: {
    textarea: 'textarea',
    toolbar: '.toolbar'
  },

  events: {
    'change': 'save'
  },

  onRender: function() {
    this.ui.textarea.addClass(this.options.size);
    this.load();

    this.editor = new wysihtml5.Editor(this.ui.textarea[0], {
      toolbar: this.ui.toolbar[0],
      autoLink: this.options.disableLinks ? 0 : 1,
      parserRules: {
        tags: {
          em: {unwrap: this.options.disableRichtext ? 1 : 0, rename_tag: "i"},
          strong: {unwrap: this.options.disableRichtext ? 1 : 0, rename_tag: "b"},
          u: {unwrap: this.options.disableRichtext ? 1 : 0},
          b: {unwrap: this.options.disableRichtext ? 1 : 0},
          i: {unwrap: this.options.disableRichtext ? 1 : 0},
          br: {},
          a: {
            unwrap: this.options.disableLinks ? 1 : 0,
            check_attributes: {
              href: "href"
            },
            set_attributes: {
              rel: "nofollow",
              target: "_blank"
            }
          }
        }
      }
    });

    if (this.options.disableRichtext) {
      this.ui.toolbar.find('a[data-wysihtml5-command="bold"]').hide();
      this.ui.toolbar.find('a[data-wysihtml5-command="italic"]').hide();
      this.ui.toolbar.find('a[data-wysihtml5-command="underline"]').hide();
    }
    if (this.options.disableLinks) {
      this.ui.toolbar.find('a[data-wysihtml5-command="createLink"]').hide();
    }

    this.editor.on('change', _.bind(this.save, this));
    this.editor.on('aftercommand:composer', _.bind(this.save, this));
  },

  save: function() {
    this.model.set(this.options.propertyName, this.editor.getValue());
  },

  load: function() {
    this.ui.textarea.val(this.model.get(this.options.propertyName));
  }
});

(function() {
  var isIE11 = navigator.userAgent.indexOf("Trident") !== -1;
  // This browser detections is copied from wysihtml5.
  var isGecko = navigator.userAgent.indexOf("Gecko") !== -1 && navigator.userAgent.indexOf("KHTML") === -1;

  wysihtml5.browser.insertsLineBreaksOnReturn = function() {
    // Used to be only isGecko. Unfortunately IE 11 is detected as
    // Gecko since it says "like Gecko" in its user agent. Make sure
    // we really are not IE 11.
    return isGecko && !isIE11;
  };
}());
pageflow.TextInputView = Backbone.Marionette.ItemView.extend({
  mixins: [pageflow.inputView],

  template: 'pageflow/ui/templates/inputs/text_input',

  ui: {
    input: 'input'
  },

  events: {
    'change': 'onChange'
  },

  onRender: function() {
    this.updatePlaceholder();
    this.load();
    this.validate();

    this.listenTo(this.model, 'change:' + this.options.propertyName, this.load);
  },

  onChange: function() {
    this.validate();
    this.save();
  },

  onClose: function() {
    this.save();
  },

  save: function() {
    this.model.set(this.options.propertyName, this.ui.input.val());
  },

  load: function() {
    this.ui.input.val(this.model.get(this.options.propertyName));
  },

  validate: function() {
    if (this.options.required && !this.ui.input.val()) {
      this.displayValidationError(I18n.t('pageflow.ui.views.inputs.text_input_view.required_field'));
    }
    else {
      this.resetValidationError();
    }
  },

  displayValidationError: function(message) {
    this.$el.addClass('invalid');
    this.ui.input.attr('title', message);
  },

  resetValidationError: function(message) {
    this.$el.removeClass('invalid');
    this.ui.input.attr('title', '');
  },

  updatePlaceholder: function() {
    this.ui.input.attr('placeholder', this.placeholderText());
  },

  placeholderText: function() {
    if (!this.options.disabled || !this.options.hidePlaceholderIfDisabled) {
      return this.options.placeholder || this.placholderModelValue();
    }
  },

  placholderModelValue: function() {
    return this.options.placeholderModel && this.options.placeholderModel.get(this.options.propertyName);
  }
});
pageflow.SortableCollectionView = pageflow.CollectionView.extend({
  render: function() {
    pageflow.CollectionView.prototype.render.call(this);

    this.$el.sortable({
      connectWith: this.options.connectWith,
      placeholder: 'sortable-placeholder',
      forcePlaceholderSize: true,
      delay: 200,

      update: _.bind(function(event, ui) {
        if (ui.item.parent().is(this.el)) {
          this.updateOrder();
        }
      }, this),

      receive: _.bind(function(event, ui) {
        var view = ui.item.data('view');

        this.reindexPositions();

        this.itemViews.add(view);
        this.collection.add(view.model);
      }, this),

      remove: _.bind(function(event, ui) {
        var view = ui.item.data('view');

        this.itemViews.remove(view);
        this.collection.remove(view.model);
      }, this)
    });

    return this;
  },

  addItem: function(item) {
    if (!this.itemViews.findByModel(item)) {
      pageflow.CollectionView.prototype.addItem.call(this, item);
    }
  },

  removeItem: function(item) {
    if (this.itemViews.findByModel(item)) {
      pageflow.CollectionView.prototype.removeItem.call(this, item);
    }
  },

  updateOrder: function() {
    this.reindexPositions();

    this.collection.sort();
    this.collection.saveOrder();
  },

  reindexPositions: function() {
    this.$el.children().each(function(index) {
      $(this).data('view').model.set('position', index);
    });
  }
});
pageflow.TabsView = Backbone.Marionette.Layout.extend({
  template: 'pageflow/ui/templates/tabs_view',
  className: 'tabs_view',

  ui: {
    headers: '> ul',
  },

  regions: {
    container: '> div'
  },

  events: {
    'click > ul > li': function(event) {
      this.changeTab($(event.target).data('tab-name'));
    }
  },

  initialize: function() {
    this.tabFactoryFns = {};
    this.tabNames = [];
    this.currentTabName = null;
  },

  tab: function(name, factoryFn) {
    this.tabFactoryFns[name] = factoryFn;
    this.tabNames.push(name);
  },

  onRender: function() {
    _.each(this.tabNames, function(name) {
      this.ui.headers.append(
        $('<li />')
          .attr('data-tab-name', name)
          .text(I18n.t(this.options.i18n + '.' + name))
      );
    }, this);

    this.changeTab(this.defaultTab());
  },

  changeTab: function(name) {
    this.container.show(this.tabFactoryFns[name]());
    this._updateActiveHeader(name);
    this.currentTabName = name;
  },

  defaultTab: function() {
    if (_.include(this.tabNames, this.options.defaultTab)) {
      return this.options.defaultTab;
    }
    else {
      return _.first(this.tabNames);
    }
  },

  refresh: function() {
    this.changeTab(this.currentTabName);
  },

  toggleSpinnerOnTab: function(name, visible) {
    this.$('[data-tab-name=' + name + ']').toggleClass('spinner', visible);
  },

  _updateActiveHeader: function(activeTabName) {
    this.ui.headers.children().each(function() {
      $(this).toggleClass('active', $(this).data('tab-name') === activeTabName);
    });
  }
});
pageflow.TooltipView = Backbone.Marionette.ItemView.extend({
  template: 'pageflow/ui/templates/tooltip',
  className: 'tooltip',

  ui: {
    label: '.label'
  },

  hide: function() {
    this.visible = false;
    clearTimeout(this.timeout);
    this.$el.removeClass('visible');
  },

  show: function(text, position, options) {
    options = options || {};
    this.visible = true;

    clearTimeout(this.timeout);

    this.timeout = setTimeout(_.bind(function() {
      var offsetTop;
      var offsetLeft;

      this.ui.label.text(text);

      this.$el.toggleClass('align_bottom_right', options.align === 'bottom right');
      this.$el.toggleClass('align_bottom_left', options.align === 'bottom left');

      if (options.align === 'bottom right' ||
          options.align === 'bottom left' ) {

        offsetTop = 10;
        offsetLeft = 0;
      }
      else {
        offsetTop = -17;
        offsetLeft = 10;
      }

      this.$el.css({
        top: (position.top + offsetTop) + 'px',
        left: (position.left + offsetLeft) + 'px'
      });

      this.$el.addClass('visible');
    }, this), 200);
  }
});
(function() { this.JST || (this.JST = {}); this.JST["pageflow/ui/templates/inputs/check_box"] = function(obj){var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('<input type="checkbox" />\n<label>\n  <span class="name"></span>\n  <span class="inline_help"></span>\n</label>\n');}return __p.join('');};
}).call(this);
(function() { this.JST || (this.JST = {}); this.JST["pageflow/ui/templates/inputs/file_input"] = function(obj){var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('<label>\n  <span class="name"></span>\n  <span class="inline_help"></span>\n</label>\n<div class="file_thumbnail"></div>\n<div class="file_name"></div>\n<a href="" class="edit_positioning" title="',  I18n.t('pageflow.ui.templates.inputs.file_input.adjust_positioning') ,'"></a>\n<a href="" class="unset" title="',  I18n.t('pageflow.ui.templates.inputs.file_input.reset') ,'"></a>\n<a href="" class="choose" title="',  I18n.t('pageflow.ui.templates.inputs.file_input.edit') ,'"></a>\n');}return __p.join('');};
}).call(this);
(function() { this.JST || (this.JST = {}); this.JST["pageflow/ui/templates/inputs/select_input"] = function(obj){var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('<label>\n  <span class="name"></span>\n  <span class="inline_help"></span>\n</label>\n<select></select>\n');}return __p.join('');};
}).call(this);
(function() { this.JST || (this.JST = {}); this.JST["pageflow/ui/templates/inputs/slider_input"] = function(obj){var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('<label>\n  <span class="name"></span>\n  <span class="inline_help"></span>\n</label>\n<div class="value"></div>\n<div class="slider"></div>\n');}return __p.join('');};
}).call(this);
(function() { this.JST || (this.JST = {}); this.JST["pageflow/ui/templates/inputs/text_area_input"] = function(obj){var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('<label>\n  <span class="name"></span>\n  <span class="inline_help"></span>\n</label>\n\n<!-- inline style for wysihtml5 to pick up -->\n<textarea style="width: 100%;"></textarea>\n\n<div class="toolbar">\n  <a data-wysihtml5-command="bold" title="',  I18n.t('pageflow.ui.templates.inputs.text_area_input.bold') ,'"></a>\n  <a data-wysihtml5-command="italic" title="',  I18n.t('pageflow.ui.templates.inputs.text_area_input.italic') ,'"></a>\n  <a data-wysihtml5-command="underline" title="',  I18n.t('pageflow.ui.templates.inputs.text_area_input.underline') ,'"></a>\n  <a data-wysihtml5-command="createLink" title="',  I18n.t('pageflow.ui.templates.inputs.text_area_input.create_link') ,'"></a>\n\n  <div data-wysihtml5-dialog="createLink" class="dialog" style="display: none;">\n    <label>\n        ',  I18n.t('pageflow.ui.templates.inputs.text_area_input.url') ,':\n      <input data-wysihtml5-dialog-field="href" value="http://">\n    </label>\n    <a data-wysihtml5-dialog-action="save">',  I18n.t('pageflow.ui.templates.inputs.text_area_input.ok') ,'</a>\n    <a data-wysihtml5-dialog-action="cancel">',  I18n.t('pageflow.ui.templates.inputs.text_area_input.cancel') ,'</a>\n  </div>\n</div>\n');}return __p.join('');};
}).call(this);
(function() { this.JST || (this.JST = {}); this.JST["pageflow/ui/templates/inputs/text_input"] = function(obj){var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('<label>\n  <span class="name"></span>\n  <span class="inline_help"></span>\n</label>\n<input type="text" />\n');}return __p.join('');};
}).call(this);
(function() { this.JST || (this.JST = {}); this.JST["pageflow/ui/templates/inputs/url_input"] = function(obj){var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('<label>\n  <span class="name"></span>\n  <span class="inline_help"></span>\n</label>\n<input type="text" />\n<div class="validation"></div>\n');}return __p.join('');};
}).call(this);
(function() { this.JST || (this.JST = {}); this.JST["pageflow/ui/templates/tabs_view"] = function(obj){var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('<ul></ul>\n<div></div>\n');}return __p.join('');};
}).call(this);
(function() { this.JST || (this.JST = {}); this.JST["pageflow/ui/templates/tooltip"] = function(obj){var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('<span class="label">\n</span>\n');}return __p.join('');};
}).call(this);
(function() {
  var sync = Backbone.sync;

  Backbone.sync = function(method, model, options) {
    if (model.paramRoot && !options.attrs) {
      options.attrs = {};
      options.attrs[model.paramRoot] = model.toJSON(options);
    }

    return sync(method, model, options);
  };
}());
/*!
 * jQuery UI Core 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/category/ui-core/
 */

(function( factory ) {
	if ( typeof define === "function" && define.amd ) {

		// AMD. Register as an anonymous module.
		define( [ "jquery" ], factory );
	} else {

		// Browser globals
		factory( jQuery );
	}
}(function( $ ) {

// $.ui might exist from components with no dependencies, e.g., $.ui.position
$.ui = $.ui || {};

$.extend( $.ui, {
	version: "1.11.4",

	keyCode: {
		BACKSPACE: 8,
		COMMA: 188,
		DELETE: 46,
		DOWN: 40,
		END: 35,
		ENTER: 13,
		ESCAPE: 27,
		HOME: 36,
		LEFT: 37,
		PAGE_DOWN: 34,
		PAGE_UP: 33,
		PERIOD: 190,
		RIGHT: 39,
		SPACE: 32,
		TAB: 9,
		UP: 38
	}
});

// plugins
$.fn.extend({
	scrollParent: function( includeHidden ) {
		var position = this.css( "position" ),
			excludeStaticParent = position === "absolute",
			overflowRegex = includeHidden ? /(auto|scroll|hidden)/ : /(auto|scroll)/,
			scrollParent = this.parents().filter( function() {
				var parent = $( this );
				if ( excludeStaticParent && parent.css( "position" ) === "static" ) {
					return false;
				}
				return overflowRegex.test( parent.css( "overflow" ) + parent.css( "overflow-y" ) + parent.css( "overflow-x" ) );
			}).eq( 0 );

		return position === "fixed" || !scrollParent.length ? $( this[ 0 ].ownerDocument || document ) : scrollParent;
	},

	uniqueId: (function() {
		var uuid = 0;

		return function() {
			return this.each(function() {
				if ( !this.id ) {
					this.id = "ui-id-" + ( ++uuid );
				}
			});
		};
	})(),

	removeUniqueId: function() {
		return this.each(function() {
			if ( /^ui-id-\d+$/.test( this.id ) ) {
				$( this ).removeAttr( "id" );
			}
		});
	}
});

// selectors
function focusable( element, isTabIndexNotNaN ) {
	var map, mapName, img,
		nodeName = element.nodeName.toLowerCase();
	if ( "area" === nodeName ) {
		map = element.parentNode;
		mapName = map.name;
		if ( !element.href || !mapName || map.nodeName.toLowerCase() !== "map" ) {
			return false;
		}
		img = $( "img[usemap='#" + mapName + "']" )[ 0 ];
		return !!img && visible( img );
	}
	return ( /^(input|select|textarea|button|object)$/.test( nodeName ) ?
		!element.disabled :
		"a" === nodeName ?
			element.href || isTabIndexNotNaN :
			isTabIndexNotNaN) &&
		// the element and all of its ancestors must be visible
		visible( element );
}

function visible( element ) {
	return $.expr.filters.visible( element ) &&
		!$( element ).parents().addBack().filter(function() {
			return $.css( this, "visibility" ) === "hidden";
		}).length;
}

$.extend( $.expr[ ":" ], {
	data: $.expr.createPseudo ?
		$.expr.createPseudo(function( dataName ) {
			return function( elem ) {
				return !!$.data( elem, dataName );
			};
		}) :
		// support: jQuery <1.8
		function( elem, i, match ) {
			return !!$.data( elem, match[ 3 ] );
		},

	focusable: function( element ) {
		return focusable( element, !isNaN( $.attr( element, "tabindex" ) ) );
	},

	tabbable: function( element ) {
		var tabIndex = $.attr( element, "tabindex" ),
			isTabIndexNaN = isNaN( tabIndex );
		return ( isTabIndexNaN || tabIndex >= 0 ) && focusable( element, !isTabIndexNaN );
	}
});

// support: jQuery <1.8
if ( !$( "<a>" ).outerWidth( 1 ).jquery ) {
	$.each( [ "Width", "Height" ], function( i, name ) {
		var side = name === "Width" ? [ "Left", "Right" ] : [ "Top", "Bottom" ],
			type = name.toLowerCase(),
			orig = {
				innerWidth: $.fn.innerWidth,
				innerHeight: $.fn.innerHeight,
				outerWidth: $.fn.outerWidth,
				outerHeight: $.fn.outerHeight
			};

		function reduce( elem, size, border, margin ) {
			$.each( side, function() {
				size -= parseFloat( $.css( elem, "padding" + this ) ) || 0;
				if ( border ) {
					size -= parseFloat( $.css( elem, "border" + this + "Width" ) ) || 0;
				}
				if ( margin ) {
					size -= parseFloat( $.css( elem, "margin" + this ) ) || 0;
				}
			});
			return size;
		}

		$.fn[ "inner" + name ] = function( size ) {
			if ( size === undefined ) {
				return orig[ "inner" + name ].call( this );
			}

			return this.each(function() {
				$( this ).css( type, reduce( this, size ) + "px" );
			});
		};

		$.fn[ "outer" + name] = function( size, margin ) {
			if ( typeof size !== "number" ) {
				return orig[ "outer" + name ].call( this, size );
			}

			return this.each(function() {
				$( this).css( type, reduce( this, size, true, margin ) + "px" );
			});
		};
	});
}

// support: jQuery <1.8
if ( !$.fn.addBack ) {
	$.fn.addBack = function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	};
}

// support: jQuery 1.6.1, 1.6.2 (http://bugs.jquery.com/ticket/9413)
if ( $( "<a>" ).data( "a-b", "a" ).removeData( "a-b" ).data( "a-b" ) ) {
	$.fn.removeData = (function( removeData ) {
		return function( key ) {
			if ( arguments.length ) {
				return removeData.call( this, $.camelCase( key ) );
			} else {
				return removeData.call( this );
			}
		};
	})( $.fn.removeData );
}

// deprecated
$.ui.ie = !!/msie [\w.]+/.exec( navigator.userAgent.toLowerCase() );

$.fn.extend({
	focus: (function( orig ) {
		return function( delay, fn ) {
			return typeof delay === "number" ?
				this.each(function() {
					var elem = this;
					setTimeout(function() {
						$( elem ).focus();
						if ( fn ) {
							fn.call( elem );
						}
					}, delay );
				}) :
				orig.apply( this, arguments );
		};
	})( $.fn.focus ),

	disableSelection: (function() {
		var eventType = "onselectstart" in document.createElement( "div" ) ?
			"selectstart" :
			"mousedown";

		return function() {
			return this.bind( eventType + ".ui-disableSelection", function( event ) {
				event.preventDefault();
			});
		};
	})(),

	enableSelection: function() {
		return this.unbind( ".ui-disableSelection" );
	},

	zIndex: function( zIndex ) {
		if ( zIndex !== undefined ) {
			return this.css( "zIndex", zIndex );
		}

		if ( this.length ) {
			var elem = $( this[ 0 ] ), position, value;
			while ( elem.length && elem[ 0 ] !== document ) {
				// Ignore z-index if position is set to a value where z-index is ignored by the browser
				// This makes behavior of this function consistent across browsers
				// WebKit always returns auto if the element is positioned
				position = elem.css( "position" );
				if ( position === "absolute" || position === "relative" || position === "fixed" ) {
					// IE returns 0 when zIndex is not specified
					// other browsers return a string
					// we ignore the case of nested elements with an explicit value of 0
					// <div style="z-index: -10;"><div style="z-index: 0;"></div></div>
					value = parseInt( elem.css( "zIndex" ), 10 );
					if ( !isNaN( value ) && value !== 0 ) {
						return value;
					}
				}
				elem = elem.parent();
			}
		}

		return 0;
	}
});

// $.ui.plugin is deprecated. Use $.widget() extensions instead.
$.ui.plugin = {
	add: function( module, option, set ) {
		var i,
			proto = $.ui[ module ].prototype;
		for ( i in set ) {
			proto.plugins[ i ] = proto.plugins[ i ] || [];
			proto.plugins[ i ].push( [ option, set[ i ] ] );
		}
	},
	call: function( instance, name, args, allowDisconnected ) {
		var i,
			set = instance.plugins[ name ];

		if ( !set ) {
			return;
		}

		if ( !allowDisconnected && ( !instance.element[ 0 ].parentNode || instance.element[ 0 ].parentNode.nodeType === 11 ) ) {
			return;
		}

		for ( i = 0; i < set.length; i++ ) {
			if ( instance.options[ set[ i ][ 0 ] ] ) {
				set[ i ][ 1 ].apply( instance.element, args );
			}
		}
	}
};

}));
/*!
 * jQuery UI Widget 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/jQuery.widget/
 */

(function( factory ) {
	if ( typeof define === "function" && define.amd ) {

		// AMD. Register as an anonymous module.
		define( [ "jquery" ], factory );
	} else {

		// Browser globals
		factory( jQuery );
	}
}(function( $ ) {

var widget_uuid = 0,
	widget_slice = Array.prototype.slice;

$.cleanData = (function( orig ) {
	return function( elems ) {
		var events, elem, i;
		for ( i = 0; (elem = elems[i]) != null; i++ ) {
			try {

				// Only trigger remove when necessary to save time
				events = $._data( elem, "events" );
				if ( events && events.remove ) {
					$( elem ).triggerHandler( "remove" );
				}

			// http://bugs.jquery.com/ticket/8235
			} catch ( e ) {}
		}
		orig( elems );
	};
})( $.cleanData );

$.widget = function( name, base, prototype ) {
	var fullName, existingConstructor, constructor, basePrototype,
		// proxiedPrototype allows the provided prototype to remain unmodified
		// so that it can be used as a mixin for multiple widgets (#8876)
		proxiedPrototype = {},
		namespace = name.split( "." )[ 0 ];

	name = name.split( "." )[ 1 ];
	fullName = namespace + "-" + name;

	if ( !prototype ) {
		prototype = base;
		base = $.Widget;
	}

	// create selector for plugin
	$.expr[ ":" ][ fullName.toLowerCase() ] = function( elem ) {
		return !!$.data( elem, fullName );
	};

	$[ namespace ] = $[ namespace ] || {};
	existingConstructor = $[ namespace ][ name ];
	constructor = $[ namespace ][ name ] = function( options, element ) {
		// allow instantiation without "new" keyword
		if ( !this._createWidget ) {
			return new constructor( options, element );
		}

		// allow instantiation without initializing for simple inheritance
		// must use "new" keyword (the code above always passes args)
		if ( arguments.length ) {
			this._createWidget( options, element );
		}
	};
	// extend with the existing constructor to carry over any static properties
	$.extend( constructor, existingConstructor, {
		version: prototype.version,
		// copy the object used to create the prototype in case we need to
		// redefine the widget later
		_proto: $.extend( {}, prototype ),
		// track widgets that inherit from this widget in case this widget is
		// redefined after a widget inherits from it
		_childConstructors: []
	});

	basePrototype = new base();
	// we need to make the options hash a property directly on the new instance
	// otherwise we'll modify the options hash on the prototype that we're
	// inheriting from
	basePrototype.options = $.widget.extend( {}, basePrototype.options );
	$.each( prototype, function( prop, value ) {
		if ( !$.isFunction( value ) ) {
			proxiedPrototype[ prop ] = value;
			return;
		}
		proxiedPrototype[ prop ] = (function() {
			var _super = function() {
					return base.prototype[ prop ].apply( this, arguments );
				},
				_superApply = function( args ) {
					return base.prototype[ prop ].apply( this, args );
				};
			return function() {
				var __super = this._super,
					__superApply = this._superApply,
					returnValue;

				this._super = _super;
				this._superApply = _superApply;

				returnValue = value.apply( this, arguments );

				this._super = __super;
				this._superApply = __superApply;

				return returnValue;
			};
		})();
	});
	constructor.prototype = $.widget.extend( basePrototype, {
		// TODO: remove support for widgetEventPrefix
		// always use the name + a colon as the prefix, e.g., draggable:start
		// don't prefix for widgets that aren't DOM-based
		widgetEventPrefix: existingConstructor ? (basePrototype.widgetEventPrefix || name) : name
	}, proxiedPrototype, {
		constructor: constructor,
		namespace: namespace,
		widgetName: name,
		widgetFullName: fullName
	});

	// If this widget is being redefined then we need to find all widgets that
	// are inheriting from it and redefine all of them so that they inherit from
	// the new version of this widget. We're essentially trying to replace one
	// level in the prototype chain.
	if ( existingConstructor ) {
		$.each( existingConstructor._childConstructors, function( i, child ) {
			var childPrototype = child.prototype;

			// redefine the child widget using the same prototype that was
			// originally used, but inherit from the new version of the base
			$.widget( childPrototype.namespace + "." + childPrototype.widgetName, constructor, child._proto );
		});
		// remove the list of existing child constructors from the old constructor
		// so the old child constructors can be garbage collected
		delete existingConstructor._childConstructors;
	} else {
		base._childConstructors.push( constructor );
	}

	$.widget.bridge( name, constructor );

	return constructor;
};

$.widget.extend = function( target ) {
	var input = widget_slice.call( arguments, 1 ),
		inputIndex = 0,
		inputLength = input.length,
		key,
		value;
	for ( ; inputIndex < inputLength; inputIndex++ ) {
		for ( key in input[ inputIndex ] ) {
			value = input[ inputIndex ][ key ];
			if ( input[ inputIndex ].hasOwnProperty( key ) && value !== undefined ) {
				// Clone objects
				if ( $.isPlainObject( value ) ) {
					target[ key ] = $.isPlainObject( target[ key ] ) ?
						$.widget.extend( {}, target[ key ], value ) :
						// Don't extend strings, arrays, etc. with objects
						$.widget.extend( {}, value );
				// Copy everything else by reference
				} else {
					target[ key ] = value;
				}
			}
		}
	}
	return target;
};

$.widget.bridge = function( name, object ) {
	var fullName = object.prototype.widgetFullName || name;
	$.fn[ name ] = function( options ) {
		var isMethodCall = typeof options === "string",
			args = widget_slice.call( arguments, 1 ),
			returnValue = this;

		if ( isMethodCall ) {
			this.each(function() {
				var methodValue,
					instance = $.data( this, fullName );
				if ( options === "instance" ) {
					returnValue = instance;
					return false;
				}
				if ( !instance ) {
					return $.error( "cannot call methods on " + name + " prior to initialization; " +
						"attempted to call method '" + options + "'" );
				}
				if ( !$.isFunction( instance[options] ) || options.charAt( 0 ) === "_" ) {
					return $.error( "no such method '" + options + "' for " + name + " widget instance" );
				}
				methodValue = instance[ options ].apply( instance, args );
				if ( methodValue !== instance && methodValue !== undefined ) {
					returnValue = methodValue && methodValue.jquery ?
						returnValue.pushStack( methodValue.get() ) :
						methodValue;
					return false;
				}
			});
		} else {

			// Allow multiple hashes to be passed on init
			if ( args.length ) {
				options = $.widget.extend.apply( null, [ options ].concat(args) );
			}

			this.each(function() {
				var instance = $.data( this, fullName );
				if ( instance ) {
					instance.option( options || {} );
					if ( instance._init ) {
						instance._init();
					}
				} else {
					$.data( this, fullName, new object( options, this ) );
				}
			});
		}

		return returnValue;
	};
};

$.Widget = function( /* options, element */ ) {};
$.Widget._childConstructors = [];

$.Widget.prototype = {
	widgetName: "widget",
	widgetEventPrefix: "",
	defaultElement: "<div>",
	options: {
		disabled: false,

		// callbacks
		create: null
	},
	_createWidget: function( options, element ) {
		element = $( element || this.defaultElement || this )[ 0 ];
		this.element = $( element );
		this.uuid = widget_uuid++;
		this.eventNamespace = "." + this.widgetName + this.uuid;

		this.bindings = $();
		this.hoverable = $();
		this.focusable = $();

		if ( element !== this ) {
			$.data( element, this.widgetFullName, this );
			this._on( true, this.element, {
				remove: function( event ) {
					if ( event.target === element ) {
						this.destroy();
					}
				}
			});
			this.document = $( element.style ?
				// element within the document
				element.ownerDocument :
				// element is window or document
				element.document || element );
			this.window = $( this.document[0].defaultView || this.document[0].parentWindow );
		}

		this.options = $.widget.extend( {},
			this.options,
			this._getCreateOptions(),
			options );

		this._create();
		this._trigger( "create", null, this._getCreateEventData() );
		this._init();
	},
	_getCreateOptions: $.noop,
	_getCreateEventData: $.noop,
	_create: $.noop,
	_init: $.noop,

	destroy: function() {
		this._destroy();
		// we can probably remove the unbind calls in 2.0
		// all event bindings should go through this._on()
		this.element
			.unbind( this.eventNamespace )
			.removeData( this.widgetFullName )
			// support: jquery <1.6.3
			// http://bugs.jquery.com/ticket/9413
			.removeData( $.camelCase( this.widgetFullName ) );
		this.widget()
			.unbind( this.eventNamespace )
			.removeAttr( "aria-disabled" )
			.removeClass(
				this.widgetFullName + "-disabled " +
				"ui-state-disabled" );

		// clean up events and states
		this.bindings.unbind( this.eventNamespace );
		this.hoverable.removeClass( "ui-state-hover" );
		this.focusable.removeClass( "ui-state-focus" );
	},
	_destroy: $.noop,

	widget: function() {
		return this.element;
	},

	option: function( key, value ) {
		var options = key,
			parts,
			curOption,
			i;

		if ( arguments.length === 0 ) {
			// don't return a reference to the internal hash
			return $.widget.extend( {}, this.options );
		}

		if ( typeof key === "string" ) {
			// handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
			options = {};
			parts = key.split( "." );
			key = parts.shift();
			if ( parts.length ) {
				curOption = options[ key ] = $.widget.extend( {}, this.options[ key ] );
				for ( i = 0; i < parts.length - 1; i++ ) {
					curOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};
					curOption = curOption[ parts[ i ] ];
				}
				key = parts.pop();
				if ( arguments.length === 1 ) {
					return curOption[ key ] === undefined ? null : curOption[ key ];
				}
				curOption[ key ] = value;
			} else {
				if ( arguments.length === 1 ) {
					return this.options[ key ] === undefined ? null : this.options[ key ];
				}
				options[ key ] = value;
			}
		}

		this._setOptions( options );

		return this;
	},
	_setOptions: function( options ) {
		var key;

		for ( key in options ) {
			this._setOption( key, options[ key ] );
		}

		return this;
	},
	_setOption: function( key, value ) {
		this.options[ key ] = value;

		if ( key === "disabled" ) {
			this.widget()
				.toggleClass( this.widgetFullName + "-disabled", !!value );

			// If the widget is becoming disabled, then nothing is interactive
			if ( value ) {
				this.hoverable.removeClass( "ui-state-hover" );
				this.focusable.removeClass( "ui-state-focus" );
			}
		}

		return this;
	},

	enable: function() {
		return this._setOptions({ disabled: false });
	},
	disable: function() {
		return this._setOptions({ disabled: true });
	},

	_on: function( suppressDisabledCheck, element, handlers ) {
		var delegateElement,
			instance = this;

		// no suppressDisabledCheck flag, shuffle arguments
		if ( typeof suppressDisabledCheck !== "boolean" ) {
			handlers = element;
			element = suppressDisabledCheck;
			suppressDisabledCheck = false;
		}

		// no element argument, shuffle and use this.element
		if ( !handlers ) {
			handlers = element;
			element = this.element;
			delegateElement = this.widget();
		} else {
			element = delegateElement = $( element );
			this.bindings = this.bindings.add( element );
		}

		$.each( handlers, function( event, handler ) {
			function handlerProxy() {
				// allow widgets to customize the disabled handling
				// - disabled as an array instead of boolean
				// - disabled class as method for disabling individual parts
				if ( !suppressDisabledCheck &&
						( instance.options.disabled === true ||
							$( this ).hasClass( "ui-state-disabled" ) ) ) {
					return;
				}
				return ( typeof handler === "string" ? instance[ handler ] : handler )
					.apply( instance, arguments );
			}

			// copy the guid so direct unbinding works
			if ( typeof handler !== "string" ) {
				handlerProxy.guid = handler.guid =
					handler.guid || handlerProxy.guid || $.guid++;
			}

			var match = event.match( /^([\w:-]*)\s*(.*)$/ ),
				eventName = match[1] + instance.eventNamespace,
				selector = match[2];
			if ( selector ) {
				delegateElement.delegate( selector, eventName, handlerProxy );
			} else {
				element.bind( eventName, handlerProxy );
			}
		});
	},

	_off: function( element, eventName ) {
		eventName = (eventName || "").split( " " ).join( this.eventNamespace + " " ) +
			this.eventNamespace;
		element.unbind( eventName ).undelegate( eventName );

		// Clear the stack to avoid memory leaks (#10056)
		this.bindings = $( this.bindings.not( element ).get() );
		this.focusable = $( this.focusable.not( element ).get() );
		this.hoverable = $( this.hoverable.not( element ).get() );
	},

	_delay: function( handler, delay ) {
		function handlerProxy() {
			return ( typeof handler === "string" ? instance[ handler ] : handler )
				.apply( instance, arguments );
		}
		var instance = this;
		return setTimeout( handlerProxy, delay || 0 );
	},

	_hoverable: function( element ) {
		this.hoverable = this.hoverable.add( element );
		this._on( element, {
			mouseenter: function( event ) {
				$( event.currentTarget ).addClass( "ui-state-hover" );
			},
			mouseleave: function( event ) {
				$( event.currentTarget ).removeClass( "ui-state-hover" );
			}
		});
	},

	_focusable: function( element ) {
		this.focusable = this.focusable.add( element );
		this._on( element, {
			focusin: function( event ) {
				$( event.currentTarget ).addClass( "ui-state-focus" );
			},
			focusout: function( event ) {
				$( event.currentTarget ).removeClass( "ui-state-focus" );
			}
		});
	},

	_trigger: function( type, event, data ) {
		var prop, orig,
			callback = this.options[ type ];

		data = data || {};
		event = $.Event( event );
		event.type = ( type === this.widgetEventPrefix ?
			type :
			this.widgetEventPrefix + type ).toLowerCase();
		// the original event may come from any element
		// so we need to reset the target on the new event
		event.target = this.element[ 0 ];

		// copy original event properties over to the new event
		orig = event.originalEvent;
		if ( orig ) {
			for ( prop in orig ) {
				if ( !( prop in event ) ) {
					event[ prop ] = orig[ prop ];
				}
			}
		}

		this.element.trigger( event, data );
		return !( $.isFunction( callback ) &&
			callback.apply( this.element[0], [ event ].concat( data ) ) === false ||
			event.isDefaultPrevented() );
	}
};

$.each( { show: "fadeIn", hide: "fadeOut" }, function( method, defaultEffect ) {
	$.Widget.prototype[ "_" + method ] = function( element, options, callback ) {
		if ( typeof options === "string" ) {
			options = { effect: options };
		}
		var hasOptions,
			effectName = !options ?
				method :
				options === true || typeof options === "number" ?
					defaultEffect :
					options.effect || defaultEffect;
		options = options || {};
		if ( typeof options === "number" ) {
			options = { duration: options };
		}
		hasOptions = !$.isEmptyObject( options );
		options.complete = callback;
		if ( options.delay ) {
			element.delay( options.delay );
		}
		if ( hasOptions && $.effects && $.effects.effect[ effectName ] ) {
			element[ method ]( options );
		} else if ( effectName !== method && element[ effectName ] ) {
			element[ effectName ]( options.duration, options.easing, callback );
		} else {
			element.queue(function( next ) {
				$( this )[ method ]();
				if ( callback ) {
					callback.call( element[ 0 ] );
				}
				next();
			});
		}
	};
});

return $.widget;

}));



/*!
 * jQuery UI Accordion 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/accordion/
 */

(function( factory ) {
	if ( typeof define === "function" && define.amd ) {

		// AMD. Register as an anonymous module.
		define([
			"jquery",
			"./core",
			"./widget"
		], factory );
	} else {

		// Browser globals
		factory( jQuery );
	}
}(function( $ ) {

return $.widget( "ui.accordion", {
	version: "1.11.4",
	options: {
		active: 0,
		animate: {},
		collapsible: false,
		event: "click",
		header: "> li > :first-child,> :not(li):even",
		heightStyle: "auto",
		icons: {
			activeHeader: "ui-icon-triangle-1-s",
			header: "ui-icon-triangle-1-e"
		},

		// callbacks
		activate: null,
		beforeActivate: null
	},

	hideProps: {
		borderTopWidth: "hide",
		borderBottomWidth: "hide",
		paddingTop: "hide",
		paddingBottom: "hide",
		height: "hide"
	},

	showProps: {
		borderTopWidth: "show",
		borderBottomWidth: "show",
		paddingTop: "show",
		paddingBottom: "show",
		height: "show"
	},

	_create: function() {
		var options = this.options;
		this.prevShow = this.prevHide = $();
		this.element.addClass( "ui-accordion ui-widget ui-helper-reset" )
			// ARIA
			.attr( "role", "tablist" );

		// don't allow collapsible: false and active: false / null
		if ( !options.collapsible && (options.active === false || options.active == null) ) {
			options.active = 0;
		}

		this._processPanels();
		// handle negative values
		if ( options.active < 0 ) {
			options.active += this.headers.length;
		}
		this._refresh();
	},

	_getCreateEventData: function() {
		return {
			header: this.active,
			panel: !this.active.length ? $() : this.active.next()
		};
	},

	_createIcons: function() {
		var icons = this.options.icons;
		if ( icons ) {
			$( "<span>" )
				.addClass( "ui-accordion-header-icon ui-icon " + icons.header )
				.prependTo( this.headers );
			this.active.children( ".ui-accordion-header-icon" )
				.removeClass( icons.header )
				.addClass( icons.activeHeader );
			this.headers.addClass( "ui-accordion-icons" );
		}
	},

	_destroyIcons: function() {
		this.headers
			.removeClass( "ui-accordion-icons" )
			.children( ".ui-accordion-header-icon" )
				.remove();
	},

	_destroy: function() {
		var contents;

		// clean up main element
		this.element
			.removeClass( "ui-accordion ui-widget ui-helper-reset" )
			.removeAttr( "role" );

		// clean up headers
		this.headers
			.removeClass( "ui-accordion-header ui-accordion-header-active ui-state-default " +
				"ui-corner-all ui-state-active ui-state-disabled ui-corner-top" )
			.removeAttr( "role" )
			.removeAttr( "aria-expanded" )
			.removeAttr( "aria-selected" )
			.removeAttr( "aria-controls" )
			.removeAttr( "tabIndex" )
			.removeUniqueId();

		this._destroyIcons();

		// clean up content panels
		contents = this.headers.next()
			.removeClass( "ui-helper-reset ui-widget-content ui-corner-bottom " +
				"ui-accordion-content ui-accordion-content-active ui-state-disabled" )
			.css( "display", "" )
			.removeAttr( "role" )
			.removeAttr( "aria-hidden" )
			.removeAttr( "aria-labelledby" )
			.removeUniqueId();

		if ( this.options.heightStyle !== "content" ) {
			contents.css( "height", "" );
		}
	},

	_setOption: function( key, value ) {
		if ( key === "active" ) {
			// _activate() will handle invalid values and update this.options
			this._activate( value );
			return;
		}

		if ( key === "event" ) {
			if ( this.options.event ) {
				this._off( this.headers, this.options.event );
			}
			this._setupEvents( value );
		}

		this._super( key, value );

		// setting collapsible: false while collapsed; open first panel
		if ( key === "collapsible" && !value && this.options.active === false ) {
			this._activate( 0 );
		}

		if ( key === "icons" ) {
			this._destroyIcons();
			if ( value ) {
				this._createIcons();
			}
		}

		// #5332 - opacity doesn't cascade to positioned elements in IE
		// so we need to add the disabled class to the headers and panels
		if ( key === "disabled" ) {
			this.element
				.toggleClass( "ui-state-disabled", !!value )
				.attr( "aria-disabled", value );
			this.headers.add( this.headers.next() )
				.toggleClass( "ui-state-disabled", !!value );
		}
	},

	_keydown: function( event ) {
		if ( event.altKey || event.ctrlKey ) {
			return;
		}

		var keyCode = $.ui.keyCode,
			length = this.headers.length,
			currentIndex = this.headers.index( event.target ),
			toFocus = false;

		switch ( event.keyCode ) {
			case keyCode.RIGHT:
			case keyCode.DOWN:
				toFocus = this.headers[ ( currentIndex + 1 ) % length ];
				break;
			case keyCode.LEFT:
			case keyCode.UP:
				toFocus = this.headers[ ( currentIndex - 1 + length ) % length ];
				break;
			case keyCode.SPACE:
			case keyCode.ENTER:
				this._eventHandler( event );
				break;
			case keyCode.HOME:
				toFocus = this.headers[ 0 ];
				break;
			case keyCode.END:
				toFocus = this.headers[ length - 1 ];
				break;
		}

		if ( toFocus ) {
			$( event.target ).attr( "tabIndex", -1 );
			$( toFocus ).attr( "tabIndex", 0 );
			toFocus.focus();
			event.preventDefault();
		}
	},

	_panelKeyDown: function( event ) {
		if ( event.keyCode === $.ui.keyCode.UP && event.ctrlKey ) {
			$( event.currentTarget ).prev().focus();
		}
	},

	refresh: function() {
		var options = this.options;
		this._processPanels();

		// was collapsed or no panel
		if ( ( options.active === false && options.collapsible === true ) || !this.headers.length ) {
			options.active = false;
			this.active = $();
		// active false only when collapsible is true
		} else if ( options.active === false ) {
			this._activate( 0 );
		// was active, but active panel is gone
		} else if ( this.active.length && !$.contains( this.element[ 0 ], this.active[ 0 ] ) ) {
			// all remaining panel are disabled
			if ( this.headers.length === this.headers.find(".ui-state-disabled").length ) {
				options.active = false;
				this.active = $();
			// activate previous panel
			} else {
				this._activate( Math.max( 0, options.active - 1 ) );
			}
		// was active, active panel still exists
		} else {
			// make sure active index is correct
			options.active = this.headers.index( this.active );
		}

		this._destroyIcons();

		this._refresh();
	},

	_processPanels: function() {
		var prevHeaders = this.headers,
			prevPanels = this.panels;

		this.headers = this.element.find( this.options.header )
			.addClass( "ui-accordion-header ui-state-default ui-corner-all" );

		this.panels = this.headers.next()
			.addClass( "ui-accordion-content ui-helper-reset ui-widget-content ui-corner-bottom" )
			.filter( ":not(.ui-accordion-content-active)" )
			.hide();

		// Avoid memory leaks (#10056)
		if ( prevPanels ) {
			this._off( prevHeaders.not( this.headers ) );
			this._off( prevPanels.not( this.panels ) );
		}
	},

	_refresh: function() {
		var maxHeight,
			options = this.options,
			heightStyle = options.heightStyle,
			parent = this.element.parent();

		this.active = this._findActive( options.active )
			.addClass( "ui-accordion-header-active ui-state-active ui-corner-top" )
			.removeClass( "ui-corner-all" );
		this.active.next()
			.addClass( "ui-accordion-content-active" )
			.show();

		this.headers
			.attr( "role", "tab" )
			.each(function() {
				var header = $( this ),
					headerId = header.uniqueId().attr( "id" ),
					panel = header.next(),
					panelId = panel.uniqueId().attr( "id" );
				header.attr( "aria-controls", panelId );
				panel.attr( "aria-labelledby", headerId );
			})
			.next()
				.attr( "role", "tabpanel" );

		this.headers
			.not( this.active )
			.attr({
				"aria-selected": "false",
				"aria-expanded": "false",
				tabIndex: -1
			})
			.next()
				.attr({
					"aria-hidden": "true"
				})
				.hide();

		// make sure at least one header is in the tab order
		if ( !this.active.length ) {
			this.headers.eq( 0 ).attr( "tabIndex", 0 );
		} else {
			this.active.attr({
				"aria-selected": "true",
				"aria-expanded": "true",
				tabIndex: 0
			})
			.next()
				.attr({
					"aria-hidden": "false"
				});
		}

		this._createIcons();

		this._setupEvents( options.event );

		if ( heightStyle === "fill" ) {
			maxHeight = parent.height();
			this.element.siblings( ":visible" ).each(function() {
				var elem = $( this ),
					position = elem.css( "position" );

				if ( position === "absolute" || position === "fixed" ) {
					return;
				}
				maxHeight -= elem.outerHeight( true );
			});

			this.headers.each(function() {
				maxHeight -= $( this ).outerHeight( true );
			});

			this.headers.next()
				.each(function() {
					$( this ).height( Math.max( 0, maxHeight -
						$( this ).innerHeight() + $( this ).height() ) );
				})
				.css( "overflow", "auto" );
		} else if ( heightStyle === "auto" ) {
			maxHeight = 0;
			this.headers.next()
				.each(function() {
					maxHeight = Math.max( maxHeight, $( this ).css( "height", "" ).height() );
				})
				.height( maxHeight );
		}
	},

	_activate: function( index ) {
		var active = this._findActive( index )[ 0 ];

		// trying to activate the already active panel
		if ( active === this.active[ 0 ] ) {
			return;
		}

		// trying to collapse, simulate a click on the currently active header
		active = active || this.active[ 0 ];

		this._eventHandler({
			target: active,
			currentTarget: active,
			preventDefault: $.noop
		});
	},

	_findActive: function( selector ) {
		return typeof selector === "number" ? this.headers.eq( selector ) : $();
	},

	_setupEvents: function( event ) {
		var events = {
			keydown: "_keydown"
		};
		if ( event ) {
			$.each( event.split( " " ), function( index, eventName ) {
				events[ eventName ] = "_eventHandler";
			});
		}

		this._off( this.headers.add( this.headers.next() ) );
		this._on( this.headers, events );
		this._on( this.headers.next(), { keydown: "_panelKeyDown" });
		this._hoverable( this.headers );
		this._focusable( this.headers );
	},

	_eventHandler: function( event ) {
		var options = this.options,
			active = this.active,
			clicked = $( event.currentTarget ),
			clickedIsActive = clicked[ 0 ] === active[ 0 ],
			collapsing = clickedIsActive && options.collapsible,
			toShow = collapsing ? $() : clicked.next(),
			toHide = active.next(),
			eventData = {
				oldHeader: active,
				oldPanel: toHide,
				newHeader: collapsing ? $() : clicked,
				newPanel: toShow
			};

		event.preventDefault();

		if (
				// click on active header, but not collapsible
				( clickedIsActive && !options.collapsible ) ||
				// allow canceling activation
				( this._trigger( "beforeActivate", event, eventData ) === false ) ) {
			return;
		}

		options.active = collapsing ? false : this.headers.index( clicked );

		// when the call to ._toggle() comes after the class changes
		// it causes a very odd bug in IE 8 (see #6720)
		this.active = clickedIsActive ? $() : clicked;
		this._toggle( eventData );

		// switch classes
		// corner classes on the previously active header stay after the animation
		active.removeClass( "ui-accordion-header-active ui-state-active" );
		if ( options.icons ) {
			active.children( ".ui-accordion-header-icon" )
				.removeClass( options.icons.activeHeader )
				.addClass( options.icons.header );
		}

		if ( !clickedIsActive ) {
			clicked
				.removeClass( "ui-corner-all" )
				.addClass( "ui-accordion-header-active ui-state-active ui-corner-top" );
			if ( options.icons ) {
				clicked.children( ".ui-accordion-header-icon" )
					.removeClass( options.icons.header )
					.addClass( options.icons.activeHeader );
			}

			clicked
				.next()
				.addClass( "ui-accordion-content-active" );
		}
	},

	_toggle: function( data ) {
		var toShow = data.newPanel,
			toHide = this.prevShow.length ? this.prevShow : data.oldPanel;

		// handle activating a panel during the animation for another activation
		this.prevShow.add( this.prevHide ).stop( true, true );
		this.prevShow = toShow;
		this.prevHide = toHide;

		if ( this.options.animate ) {
			this._animate( toShow, toHide, data );
		} else {
			toHide.hide();
			toShow.show();
			this._toggleComplete( data );
		}

		toHide.attr({
			"aria-hidden": "true"
		});
		toHide.prev().attr({
			"aria-selected": "false",
			"aria-expanded": "false"
		});
		// if we're switching panels, remove the old header from the tab order
		// if we're opening from collapsed state, remove the previous header from the tab order
		// if we're collapsing, then keep the collapsing header in the tab order
		if ( toShow.length && toHide.length ) {
			toHide.prev().attr({
				"tabIndex": -1,
				"aria-expanded": "false"
			});
		} else if ( toShow.length ) {
			this.headers.filter(function() {
				return parseInt( $( this ).attr( "tabIndex" ), 10 ) === 0;
			})
			.attr( "tabIndex", -1 );
		}

		toShow
			.attr( "aria-hidden", "false" )
			.prev()
				.attr({
					"aria-selected": "true",
					"aria-expanded": "true",
					tabIndex: 0
				});
	},

	_animate: function( toShow, toHide, data ) {
		var total, easing, duration,
			that = this,
			adjust = 0,
			boxSizing = toShow.css( "box-sizing" ),
			down = toShow.length &&
				( !toHide.length || ( toShow.index() < toHide.index() ) ),
			animate = this.options.animate || {},
			options = down && animate.down || animate,
			complete = function() {
				that._toggleComplete( data );
			};

		if ( typeof options === "number" ) {
			duration = options;
		}
		if ( typeof options === "string" ) {
			easing = options;
		}
		// fall back from options to animation in case of partial down settings
		easing = easing || options.easing || animate.easing;
		duration = duration || options.duration || animate.duration;

		if ( !toHide.length ) {
			return toShow.animate( this.showProps, duration, easing, complete );
		}
		if ( !toShow.length ) {
			return toHide.animate( this.hideProps, duration, easing, complete );
		}

		total = toShow.show().outerHeight();
		toHide.animate( this.hideProps, {
			duration: duration,
			easing: easing,
			step: function( now, fx ) {
				fx.now = Math.round( now );
			}
		});
		toShow
			.hide()
			.animate( this.showProps, {
				duration: duration,
				easing: easing,
				complete: complete,
				step: function( now, fx ) {
					fx.now = Math.round( now );
					if ( fx.prop !== "height" ) {
						if ( boxSizing === "content-box" ) {
							adjust += fx.now;
						}
					} else if ( that.options.heightStyle !== "content" ) {
						fx.now = Math.round( total - toHide.outerHeight() - adjust );
						adjust = 0;
					}
				}
			});
	},

	_toggleComplete: function( data ) {
		var toHide = data.oldPanel;

		toHide
			.removeClass( "ui-accordion-content-active" )
			.prev()
				.removeClass( "ui-corner-top" )
				.addClass( "ui-corner-all" );

		// Work around for rendering bug in IE (#5421)
		if ( toHide.length ) {
			toHide.parent()[ 0 ].className = toHide.parent()[ 0 ].className;
		}
		this._trigger( "activate", null, data );
	}
});

}));
/*!
 * jQuery UI Position 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/position/
 */

(function( factory ) {
	if ( typeof define === "function" && define.amd ) {

		// AMD. Register as an anonymous module.
		define( [ "jquery" ], factory );
	} else {

		// Browser globals
		factory( jQuery );
	}
}(function( $ ) {
(function() {

$.ui = $.ui || {};

var cachedScrollbarWidth, supportsOffsetFractions,
	max = Math.max,
	abs = Math.abs,
	round = Math.round,
	rhorizontal = /left|center|right/,
	rvertical = /top|center|bottom/,
	roffset = /[\+\-]\d+(\.[\d]+)?%?/,
	rposition = /^\w+/,
	rpercent = /%$/,
	_position = $.fn.position;

function getOffsets( offsets, width, height ) {
	return [
		parseFloat( offsets[ 0 ] ) * ( rpercent.test( offsets[ 0 ] ) ? width / 100 : 1 ),
		parseFloat( offsets[ 1 ] ) * ( rpercent.test( offsets[ 1 ] ) ? height / 100 : 1 )
	];
}

function parseCss( element, property ) {
	return parseInt( $.css( element, property ), 10 ) || 0;
}

function getDimensions( elem ) {
	var raw = elem[0];
	if ( raw.nodeType === 9 ) {
		return {
			width: elem.width(),
			height: elem.height(),
			offset: { top: 0, left: 0 }
		};
	}
	if ( $.isWindow( raw ) ) {
		return {
			width: elem.width(),
			height: elem.height(),
			offset: { top: elem.scrollTop(), left: elem.scrollLeft() }
		};
	}
	if ( raw.preventDefault ) {
		return {
			width: 0,
			height: 0,
			offset: { top: raw.pageY, left: raw.pageX }
		};
	}
	return {
		width: elem.outerWidth(),
		height: elem.outerHeight(),
		offset: elem.offset()
	};
}

$.position = {
	scrollbarWidth: function() {
		if ( cachedScrollbarWidth !== undefined ) {
			return cachedScrollbarWidth;
		}
		var w1, w2,
			div = $( "<div style='display:block;position:absolute;width:50px;height:50px;overflow:hidden;'><div style='height:100px;width:auto;'></div></div>" ),
			innerDiv = div.children()[0];

		$( "body" ).append( div );
		w1 = innerDiv.offsetWidth;
		div.css( "overflow", "scroll" );

		w2 = innerDiv.offsetWidth;

		if ( w1 === w2 ) {
			w2 = div[0].clientWidth;
		}

		div.remove();

		return (cachedScrollbarWidth = w1 - w2);
	},
	getScrollInfo: function( within ) {
		var overflowX = within.isWindow || within.isDocument ? "" :
				within.element.css( "overflow-x" ),
			overflowY = within.isWindow || within.isDocument ? "" :
				within.element.css( "overflow-y" ),
			hasOverflowX = overflowX === "scroll" ||
				( overflowX === "auto" && within.width < within.element[0].scrollWidth ),
			hasOverflowY = overflowY === "scroll" ||
				( overflowY === "auto" && within.height < within.element[0].scrollHeight );
		return {
			width: hasOverflowY ? $.position.scrollbarWidth() : 0,
			height: hasOverflowX ? $.position.scrollbarWidth() : 0
		};
	},
	getWithinInfo: function( element ) {
		var withinElement = $( element || window ),
			isWindow = $.isWindow( withinElement[0] ),
			isDocument = !!withinElement[ 0 ] && withinElement[ 0 ].nodeType === 9;
		return {
			element: withinElement,
			isWindow: isWindow,
			isDocument: isDocument,
			offset: withinElement.offset() || { left: 0, top: 0 },
			scrollLeft: withinElement.scrollLeft(),
			scrollTop: withinElement.scrollTop(),

			// support: jQuery 1.6.x
			// jQuery 1.6 doesn't support .outerWidth/Height() on documents or windows
			width: isWindow || isDocument ? withinElement.width() : withinElement.outerWidth(),
			height: isWindow || isDocument ? withinElement.height() : withinElement.outerHeight()
		};
	}
};

$.fn.position = function( options ) {
	if ( !options || !options.of ) {
		return _position.apply( this, arguments );
	}

	// make a copy, we don't want to modify arguments
	options = $.extend( {}, options );

	var atOffset, targetWidth, targetHeight, targetOffset, basePosition, dimensions,
		target = $( options.of ),
		within = $.position.getWithinInfo( options.within ),
		scrollInfo = $.position.getScrollInfo( within ),
		collision = ( options.collision || "flip" ).split( " " ),
		offsets = {};

	dimensions = getDimensions( target );
	if ( target[0].preventDefault ) {
		// force left top to allow flipping
		options.at = "left top";
	}
	targetWidth = dimensions.width;
	targetHeight = dimensions.height;
	targetOffset = dimensions.offset;
	// clone to reuse original targetOffset later
	basePosition = $.extend( {}, targetOffset );

	// force my and at to have valid horizontal and vertical positions
	// if a value is missing or invalid, it will be converted to center
	$.each( [ "my", "at" ], function() {
		var pos = ( options[ this ] || "" ).split( " " ),
			horizontalOffset,
			verticalOffset;

		if ( pos.length === 1) {
			pos = rhorizontal.test( pos[ 0 ] ) ?
				pos.concat( [ "center" ] ) :
				rvertical.test( pos[ 0 ] ) ?
					[ "center" ].concat( pos ) :
					[ "center", "center" ];
		}
		pos[ 0 ] = rhorizontal.test( pos[ 0 ] ) ? pos[ 0 ] : "center";
		pos[ 1 ] = rvertical.test( pos[ 1 ] ) ? pos[ 1 ] : "center";

		// calculate offsets
		horizontalOffset = roffset.exec( pos[ 0 ] );
		verticalOffset = roffset.exec( pos[ 1 ] );
		offsets[ this ] = [
			horizontalOffset ? horizontalOffset[ 0 ] : 0,
			verticalOffset ? verticalOffset[ 0 ] : 0
		];

		// reduce to just the positions without the offsets
		options[ this ] = [
			rposition.exec( pos[ 0 ] )[ 0 ],
			rposition.exec( pos[ 1 ] )[ 0 ]
		];
	});

	// normalize collision option
	if ( collision.length === 1 ) {
		collision[ 1 ] = collision[ 0 ];
	}

	if ( options.at[ 0 ] === "right" ) {
		basePosition.left += targetWidth;
	} else if ( options.at[ 0 ] === "center" ) {
		basePosition.left += targetWidth / 2;
	}

	if ( options.at[ 1 ] === "bottom" ) {
		basePosition.top += targetHeight;
	} else if ( options.at[ 1 ] === "center" ) {
		basePosition.top += targetHeight / 2;
	}

	atOffset = getOffsets( offsets.at, targetWidth, targetHeight );
	basePosition.left += atOffset[ 0 ];
	basePosition.top += atOffset[ 1 ];

	return this.each(function() {
		var collisionPosition, using,
			elem = $( this ),
			elemWidth = elem.outerWidth(),
			elemHeight = elem.outerHeight(),
			marginLeft = parseCss( this, "marginLeft" ),
			marginTop = parseCss( this, "marginTop" ),
			collisionWidth = elemWidth + marginLeft + parseCss( this, "marginRight" ) + scrollInfo.width,
			collisionHeight = elemHeight + marginTop + parseCss( this, "marginBottom" ) + scrollInfo.height,
			position = $.extend( {}, basePosition ),
			myOffset = getOffsets( offsets.my, elem.outerWidth(), elem.outerHeight() );

		if ( options.my[ 0 ] === "right" ) {
			position.left -= elemWidth;
		} else if ( options.my[ 0 ] === "center" ) {
			position.left -= elemWidth / 2;
		}

		if ( options.my[ 1 ] === "bottom" ) {
			position.top -= elemHeight;
		} else if ( options.my[ 1 ] === "center" ) {
			position.top -= elemHeight / 2;
		}

		position.left += myOffset[ 0 ];
		position.top += myOffset[ 1 ];

		// if the browser doesn't support fractions, then round for consistent results
		if ( !supportsOffsetFractions ) {
			position.left = round( position.left );
			position.top = round( position.top );
		}

		collisionPosition = {
			marginLeft: marginLeft,
			marginTop: marginTop
		};

		$.each( [ "left", "top" ], function( i, dir ) {
			if ( $.ui.position[ collision[ i ] ] ) {
				$.ui.position[ collision[ i ] ][ dir ]( position, {
					targetWidth: targetWidth,
					targetHeight: targetHeight,
					elemWidth: elemWidth,
					elemHeight: elemHeight,
					collisionPosition: collisionPosition,
					collisionWidth: collisionWidth,
					collisionHeight: collisionHeight,
					offset: [ atOffset[ 0 ] + myOffset[ 0 ], atOffset [ 1 ] + myOffset[ 1 ] ],
					my: options.my,
					at: options.at,
					within: within,
					elem: elem
				});
			}
		});

		if ( options.using ) {
			// adds feedback as second argument to using callback, if present
			using = function( props ) {
				var left = targetOffset.left - position.left,
					right = left + targetWidth - elemWidth,
					top = targetOffset.top - position.top,
					bottom = top + targetHeight - elemHeight,
					feedback = {
						target: {
							element: target,
							left: targetOffset.left,
							top: targetOffset.top,
							width: targetWidth,
							height: targetHeight
						},
						element: {
							element: elem,
							left: position.left,
							top: position.top,
							width: elemWidth,
							height: elemHeight
						},
						horizontal: right < 0 ? "left" : left > 0 ? "right" : "center",
						vertical: bottom < 0 ? "top" : top > 0 ? "bottom" : "middle"
					};
				if ( targetWidth < elemWidth && abs( left + right ) < targetWidth ) {
					feedback.horizontal = "center";
				}
				if ( targetHeight < elemHeight && abs( top + bottom ) < targetHeight ) {
					feedback.vertical = "middle";
				}
				if ( max( abs( left ), abs( right ) ) > max( abs( top ), abs( bottom ) ) ) {
					feedback.important = "horizontal";
				} else {
					feedback.important = "vertical";
				}
				options.using.call( this, props, feedback );
			};
		}

		elem.offset( $.extend( position, { using: using } ) );
	});
};

$.ui.position = {
	fit: {
		left: function( position, data ) {
			var within = data.within,
				withinOffset = within.isWindow ? within.scrollLeft : within.offset.left,
				outerWidth = within.width,
				collisionPosLeft = position.left - data.collisionPosition.marginLeft,
				overLeft = withinOffset - collisionPosLeft,
				overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,
				newOverRight;

			// element is wider than within
			if ( data.collisionWidth > outerWidth ) {
				// element is initially over the left side of within
				if ( overLeft > 0 && overRight <= 0 ) {
					newOverRight = position.left + overLeft + data.collisionWidth - outerWidth - withinOffset;
					position.left += overLeft - newOverRight;
				// element is initially over right side of within
				} else if ( overRight > 0 && overLeft <= 0 ) {
					position.left = withinOffset;
				// element is initially over both left and right sides of within
				} else {
					if ( overLeft > overRight ) {
						position.left = withinOffset + outerWidth - data.collisionWidth;
					} else {
						position.left = withinOffset;
					}
				}
			// too far left -> align with left edge
			} else if ( overLeft > 0 ) {
				position.left += overLeft;
			// too far right -> align with right edge
			} else if ( overRight > 0 ) {
				position.left -= overRight;
			// adjust based on position and margin
			} else {
				position.left = max( position.left - collisionPosLeft, position.left );
			}
		},
		top: function( position, data ) {
			var within = data.within,
				withinOffset = within.isWindow ? within.scrollTop : within.offset.top,
				outerHeight = data.within.height,
				collisionPosTop = position.top - data.collisionPosition.marginTop,
				overTop = withinOffset - collisionPosTop,
				overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,
				newOverBottom;

			// element is taller than within
			if ( data.collisionHeight > outerHeight ) {
				// element is initially over the top of within
				if ( overTop > 0 && overBottom <= 0 ) {
					newOverBottom = position.top + overTop + data.collisionHeight - outerHeight - withinOffset;
					position.top += overTop - newOverBottom;
				// element is initially over bottom of within
				} else if ( overBottom > 0 && overTop <= 0 ) {
					position.top = withinOffset;
				// element is initially over both top and bottom of within
				} else {
					if ( overTop > overBottom ) {
						position.top = withinOffset + outerHeight - data.collisionHeight;
					} else {
						position.top = withinOffset;
					}
				}
			// too far up -> align with top
			} else if ( overTop > 0 ) {
				position.top += overTop;
			// too far down -> align with bottom edge
			} else if ( overBottom > 0 ) {
				position.top -= overBottom;
			// adjust based on position and margin
			} else {
				position.top = max( position.top - collisionPosTop, position.top );
			}
		}
	},
	flip: {
		left: function( position, data ) {
			var within = data.within,
				withinOffset = within.offset.left + within.scrollLeft,
				outerWidth = within.width,
				offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,
				collisionPosLeft = position.left - data.collisionPosition.marginLeft,
				overLeft = collisionPosLeft - offsetLeft,
				overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,
				myOffset = data.my[ 0 ] === "left" ?
					-data.elemWidth :
					data.my[ 0 ] === "right" ?
						data.elemWidth :
						0,
				atOffset = data.at[ 0 ] === "left" ?
					data.targetWidth :
					data.at[ 0 ] === "right" ?
						-data.targetWidth :
						0,
				offset = -2 * data.offset[ 0 ],
				newOverRight,
				newOverLeft;

			if ( overLeft < 0 ) {
				newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth - outerWidth - withinOffset;
				if ( newOverRight < 0 || newOverRight < abs( overLeft ) ) {
					position.left += myOffset + atOffset + offset;
				}
			} else if ( overRight > 0 ) {
				newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset + atOffset + offset - offsetLeft;
				if ( newOverLeft > 0 || abs( newOverLeft ) < overRight ) {
					position.left += myOffset + atOffset + offset;
				}
			}
		},
		top: function( position, data ) {
			var within = data.within,
				withinOffset = within.offset.top + within.scrollTop,
				outerHeight = within.height,
				offsetTop = within.isWindow ? within.scrollTop : within.offset.top,
				collisionPosTop = position.top - data.collisionPosition.marginTop,
				overTop = collisionPosTop - offsetTop,
				overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,
				top = data.my[ 1 ] === "top",
				myOffset = top ?
					-data.elemHeight :
					data.my[ 1 ] === "bottom" ?
						data.elemHeight :
						0,
				atOffset = data.at[ 1 ] === "top" ?
					data.targetHeight :
					data.at[ 1 ] === "bottom" ?
						-data.targetHeight :
						0,
				offset = -2 * data.offset[ 1 ],
				newOverTop,
				newOverBottom;
			if ( overTop < 0 ) {
				newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight - outerHeight - withinOffset;
				if ( newOverBottom < 0 || newOverBottom < abs( overTop ) ) {
					position.top += myOffset + atOffset + offset;
				}
			} else if ( overBottom > 0 ) {
				newOverTop = position.top - data.collisionPosition.marginTop + myOffset + atOffset + offset - offsetTop;
				if ( newOverTop > 0 || abs( newOverTop ) < overBottom ) {
					position.top += myOffset + atOffset + offset;
				}
			}
		}
	},
	flipfit: {
		left: function() {
			$.ui.position.flip.left.apply( this, arguments );
			$.ui.position.fit.left.apply( this, arguments );
		},
		top: function() {
			$.ui.position.flip.top.apply( this, arguments );
			$.ui.position.fit.top.apply( this, arguments );
		}
	}
};

// fraction support test
(function() {
	var testElement, testElementParent, testElementStyle, offsetLeft, i,
		body = document.getElementsByTagName( "body" )[ 0 ],
		div = document.createElement( "div" );

	//Create a "fake body" for testing based on method used in jQuery.support
	testElement = document.createElement( body ? "div" : "body" );
	testElementStyle = {
		visibility: "hidden",
		width: 0,
		height: 0,
		border: 0,
		margin: 0,
		background: "none"
	};
	if ( body ) {
		$.extend( testElementStyle, {
			position: "absolute",
			left: "-1000px",
			top: "-1000px"
		});
	}
	for ( i in testElementStyle ) {
		testElement.style[ i ] = testElementStyle[ i ];
	}
	testElement.appendChild( div );
	testElementParent = body || document.documentElement;
	testElementParent.insertBefore( testElement, testElementParent.firstChild );

	div.style.cssText = "position: absolute; left: 10.7432222px;";

	offsetLeft = $( div ).offset().left;
	supportsOffsetFractions = offsetLeft > 10 && offsetLeft < 11;

	testElement.innerHTML = "";
	testElementParent.removeChild( testElement );
})();

})();

return $.ui.position;

}));




/*!
 * jQuery UI Menu 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/menu/
 */

(function( factory ) {
	if ( typeof define === "function" && define.amd ) {

		// AMD. Register as an anonymous module.
		define([
			"jquery",
			"./core",
			"./widget",
			"./position"
		], factory );
	} else {

		// Browser globals
		factory( jQuery );
	}
}(function( $ ) {

return $.widget( "ui.menu", {
	version: "1.11.4",
	defaultElement: "<ul>",
	delay: 300,
	options: {
		icons: {
			submenu: "ui-icon-carat-1-e"
		},
		items: "> *",
		menus: "ul",
		position: {
			my: "left-1 top",
			at: "right top"
		},
		role: "menu",

		// callbacks
		blur: null,
		focus: null,
		select: null
	},

	_create: function() {
		this.activeMenu = this.element;

		// Flag used to prevent firing of the click handler
		// as the event bubbles up through nested menus
		this.mouseHandled = false;
		this.element
			.uniqueId()
			.addClass( "ui-menu ui-widget ui-widget-content" )
			.toggleClass( "ui-menu-icons", !!this.element.find( ".ui-icon" ).length )
			.attr({
				role: this.options.role,
				tabIndex: 0
			});

		if ( this.options.disabled ) {
			this.element
				.addClass( "ui-state-disabled" )
				.attr( "aria-disabled", "true" );
		}

		this._on({
			// Prevent focus from sticking to links inside menu after clicking
			// them (focus should always stay on UL during navigation).
			"mousedown .ui-menu-item": function( event ) {
				event.preventDefault();
			},
			"click .ui-menu-item": function( event ) {
				var target = $( event.target );
				if ( !this.mouseHandled && target.not( ".ui-state-disabled" ).length ) {
					this.select( event );

					// Only set the mouseHandled flag if the event will bubble, see #9469.
					if ( !event.isPropagationStopped() ) {
						this.mouseHandled = true;
					}

					// Open submenu on click
					if ( target.has( ".ui-menu" ).length ) {
						this.expand( event );
					} else if ( !this.element.is( ":focus" ) && $( this.document[ 0 ].activeElement ).closest( ".ui-menu" ).length ) {

						// Redirect focus to the menu
						this.element.trigger( "focus", [ true ] );

						// If the active item is on the top level, let it stay active.
						// Otherwise, blur the active item since it is no longer visible.
						if ( this.active && this.active.parents( ".ui-menu" ).length === 1 ) {
							clearTimeout( this.timer );
						}
					}
				}
			},
			"mouseenter .ui-menu-item": function( event ) {
				// Ignore mouse events while typeahead is active, see #10458.
				// Prevents focusing the wrong item when typeahead causes a scroll while the mouse
				// is over an item in the menu
				if ( this.previousFilter ) {
					return;
				}
				var target = $( event.currentTarget );
				// Remove ui-state-active class from siblings of the newly focused menu item
				// to avoid a jump caused by adjacent elements both having a class with a border
				target.siblings( ".ui-state-active" ).removeClass( "ui-state-active" );
				this.focus( event, target );
			},
			mouseleave: "collapseAll",
			"mouseleave .ui-menu": "collapseAll",
			focus: function( event, keepActiveItem ) {
				// If there's already an active item, keep it active
				// If not, activate the first item
				var item = this.active || this.element.find( this.options.items ).eq( 0 );

				if ( !keepActiveItem ) {
					this.focus( event, item );
				}
			},
			blur: function( event ) {
				this._delay(function() {
					if ( !$.contains( this.element[0], this.document[0].activeElement ) ) {
						this.collapseAll( event );
					}
				});
			},
			keydown: "_keydown"
		});

		this.refresh();

		// Clicks outside of a menu collapse any open menus
		this._on( this.document, {
			click: function( event ) {
				if ( this._closeOnDocumentClick( event ) ) {
					this.collapseAll( event );
				}

				// Reset the mouseHandled flag
				this.mouseHandled = false;
			}
		});
	},

	_destroy: function() {
		// Destroy (sub)menus
		this.element
			.removeAttr( "aria-activedescendant" )
			.find( ".ui-menu" ).addBack()
				.removeClass( "ui-menu ui-widget ui-widget-content ui-menu-icons ui-front" )
				.removeAttr( "role" )
				.removeAttr( "tabIndex" )
				.removeAttr( "aria-labelledby" )
				.removeAttr( "aria-expanded" )
				.removeAttr( "aria-hidden" )
				.removeAttr( "aria-disabled" )
				.removeUniqueId()
				.show();

		// Destroy menu items
		this.element.find( ".ui-menu-item" )
			.removeClass( "ui-menu-item" )
			.removeAttr( "role" )
			.removeAttr( "aria-disabled" )
			.removeUniqueId()
			.removeClass( "ui-state-hover" )
			.removeAttr( "tabIndex" )
			.removeAttr( "role" )
			.removeAttr( "aria-haspopup" )
			.children().each( function() {
				var elem = $( this );
				if ( elem.data( "ui-menu-submenu-carat" ) ) {
					elem.remove();
				}
			});

		// Destroy menu dividers
		this.element.find( ".ui-menu-divider" ).removeClass( "ui-menu-divider ui-widget-content" );
	},

	_keydown: function( event ) {
		var match, prev, character, skip,
			preventDefault = true;

		switch ( event.keyCode ) {
		case $.ui.keyCode.PAGE_UP:
			this.previousPage( event );
			break;
		case $.ui.keyCode.PAGE_DOWN:
			this.nextPage( event );
			break;
		case $.ui.keyCode.HOME:
			this._move( "first", "first", event );
			break;
		case $.ui.keyCode.END:
			this._move( "last", "last", event );
			break;
		case $.ui.keyCode.UP:
			this.previous( event );
			break;
		case $.ui.keyCode.DOWN:
			this.next( event );
			break;
		case $.ui.keyCode.LEFT:
			this.collapse( event );
			break;
		case $.ui.keyCode.RIGHT:
			if ( this.active && !this.active.is( ".ui-state-disabled" ) ) {
				this.expand( event );
			}
			break;
		case $.ui.keyCode.ENTER:
		case $.ui.keyCode.SPACE:
			this._activate( event );
			break;
		case $.ui.keyCode.ESCAPE:
			this.collapse( event );
			break;
		default:
			preventDefault = false;
			prev = this.previousFilter || "";
			character = String.fromCharCode( event.keyCode );
			skip = false;

			clearTimeout( this.filterTimer );

			if ( character === prev ) {
				skip = true;
			} else {
				character = prev + character;
			}

			match = this._filterMenuItems( character );
			match = skip && match.index( this.active.next() ) !== -1 ?
				this.active.nextAll( ".ui-menu-item" ) :
				match;

			// If no matches on the current filter, reset to the last character pressed
			// to move down the menu to the first item that starts with that character
			if ( !match.length ) {
				character = String.fromCharCode( event.keyCode );
				match = this._filterMenuItems( character );
			}

			if ( match.length ) {
				this.focus( event, match );
				this.previousFilter = character;
				this.filterTimer = this._delay(function() {
					delete this.previousFilter;
				}, 1000 );
			} else {
				delete this.previousFilter;
			}
		}

		if ( preventDefault ) {
			event.preventDefault();
		}
	},

	_activate: function( event ) {
		if ( !this.active.is( ".ui-state-disabled" ) ) {
			if ( this.active.is( "[aria-haspopup='true']" ) ) {
				this.expand( event );
			} else {
				this.select( event );
			}
		}
	},

	refresh: function() {
		var menus, items,
			that = this,
			icon = this.options.icons.submenu,
			submenus = this.element.find( this.options.menus );

		this.element.toggleClass( "ui-menu-icons", !!this.element.find( ".ui-icon" ).length );

		// Initialize nested menus
		submenus.filter( ":not(.ui-menu)" )
			.addClass( "ui-menu ui-widget ui-widget-content ui-front" )
			.hide()
			.attr({
				role: this.options.role,
				"aria-hidden": "true",
				"aria-expanded": "false"
			})
			.each(function() {
				var menu = $( this ),
					item = menu.parent(),
					submenuCarat = $( "<span>" )
						.addClass( "ui-menu-icon ui-icon " + icon )
						.data( "ui-menu-submenu-carat", true );

				item
					.attr( "aria-haspopup", "true" )
					.prepend( submenuCarat );
				menu.attr( "aria-labelledby", item.attr( "id" ) );
			});

		menus = submenus.add( this.element );
		items = menus.find( this.options.items );

		// Initialize menu-items containing spaces and/or dashes only as dividers
		items.not( ".ui-menu-item" ).each(function() {
			var item = $( this );
			if ( that._isDivider( item ) ) {
				item.addClass( "ui-widget-content ui-menu-divider" );
			}
		});

		// Don't refresh list items that are already adapted
		items.not( ".ui-menu-item, .ui-menu-divider" )
			.addClass( "ui-menu-item" )
			.uniqueId()
			.attr({
				tabIndex: -1,
				role: this._itemRole()
			});

		// Add aria-disabled attribute to any disabled menu item
		items.filter( ".ui-state-disabled" ).attr( "aria-disabled", "true" );

		// If the active item has been removed, blur the menu
		if ( this.active && !$.contains( this.element[ 0 ], this.active[ 0 ] ) ) {
			this.blur();
		}
	},

	_itemRole: function() {
		return {
			menu: "menuitem",
			listbox: "option"
		}[ this.options.role ];
	},

	_setOption: function( key, value ) {
		if ( key === "icons" ) {
			this.element.find( ".ui-menu-icon" )
				.removeClass( this.options.icons.submenu )
				.addClass( value.submenu );
		}
		if ( key === "disabled" ) {
			this.element
				.toggleClass( "ui-state-disabled", !!value )
				.attr( "aria-disabled", value );
		}
		this._super( key, value );
	},

	focus: function( event, item ) {
		var nested, focused;
		this.blur( event, event && event.type === "focus" );

		this._scrollIntoView( item );

		this.active = item.first();
		focused = this.active.addClass( "ui-state-focus" ).removeClass( "ui-state-active" );
		// Only update aria-activedescendant if there's a role
		// otherwise we assume focus is managed elsewhere
		if ( this.options.role ) {
			this.element.attr( "aria-activedescendant", focused.attr( "id" ) );
		}

		// Highlight active parent menu item, if any
		this.active
			.parent()
			.closest( ".ui-menu-item" )
			.addClass( "ui-state-active" );

		if ( event && event.type === "keydown" ) {
			this._close();
		} else {
			this.timer = this._delay(function() {
				this._close();
			}, this.delay );
		}

		nested = item.children( ".ui-menu" );
		if ( nested.length && event && ( /^mouse/.test( event.type ) ) ) {
			this._startOpening(nested);
		}
		this.activeMenu = item.parent();

		this._trigger( "focus", event, { item: item } );
	},

	_scrollIntoView: function( item ) {
		var borderTop, paddingTop, offset, scroll, elementHeight, itemHeight;
		if ( this._hasScroll() ) {
			borderTop = parseFloat( $.css( this.activeMenu[0], "borderTopWidth" ) ) || 0;
			paddingTop = parseFloat( $.css( this.activeMenu[0], "paddingTop" ) ) || 0;
			offset = item.offset().top - this.activeMenu.offset().top - borderTop - paddingTop;
			scroll = this.activeMenu.scrollTop();
			elementHeight = this.activeMenu.height();
			itemHeight = item.outerHeight();

			if ( offset < 0 ) {
				this.activeMenu.scrollTop( scroll + offset );
			} else if ( offset + itemHeight > elementHeight ) {
				this.activeMenu.scrollTop( scroll + offset - elementHeight + itemHeight );
			}
		}
	},

	blur: function( event, fromFocus ) {
		if ( !fromFocus ) {
			clearTimeout( this.timer );
		}

		if ( !this.active ) {
			return;
		}

		this.active.removeClass( "ui-state-focus" );
		this.active = null;

		this._trigger( "blur", event, { item: this.active } );
	},

	_startOpening: function( submenu ) {
		clearTimeout( this.timer );

		// Don't open if already open fixes a Firefox bug that caused a .5 pixel
		// shift in the submenu position when mousing over the carat icon
		if ( submenu.attr( "aria-hidden" ) !== "true" ) {
			return;
		}

		this.timer = this._delay(function() {
			this._close();
			this._open( submenu );
		}, this.delay );
	},

	_open: function( submenu ) {
		var position = $.extend({
			of: this.active
		}, this.options.position );

		clearTimeout( this.timer );
		this.element.find( ".ui-menu" ).not( submenu.parents( ".ui-menu" ) )
			.hide()
			.attr( "aria-hidden", "true" );

		submenu
			.show()
			.removeAttr( "aria-hidden" )
			.attr( "aria-expanded", "true" )
			.position( position );
	},

	collapseAll: function( event, all ) {
		clearTimeout( this.timer );
		this.timer = this._delay(function() {
			// If we were passed an event, look for the submenu that contains the event
			var currentMenu = all ? this.element :
				$( event && event.target ).closest( this.element.find( ".ui-menu" ) );

			// If we found no valid submenu ancestor, use the main menu to close all sub menus anyway
			if ( !currentMenu.length ) {
				currentMenu = this.element;
			}

			this._close( currentMenu );

			this.blur( event );
			this.activeMenu = currentMenu;
		}, this.delay );
	},

	// With no arguments, closes the currently active menu - if nothing is active
	// it closes all menus.  If passed an argument, it will search for menus BELOW
	_close: function( startMenu ) {
		if ( !startMenu ) {
			startMenu = this.active ? this.active.parent() : this.element;
		}

		startMenu
			.find( ".ui-menu" )
				.hide()
				.attr( "aria-hidden", "true" )
				.attr( "aria-expanded", "false" )
			.end()
			.find( ".ui-state-active" ).not( ".ui-state-focus" )
				.removeClass( "ui-state-active" );
	},

	_closeOnDocumentClick: function( event ) {
		return !$( event.target ).closest( ".ui-menu" ).length;
	},

	_isDivider: function( item ) {

		// Match hyphen, em dash, en dash
		return !/[^\-\u2014\u2013\s]/.test( item.text() );
	},

	collapse: function( event ) {
		var newItem = this.active &&
			this.active.parent().closest( ".ui-menu-item", this.element );
		if ( newItem && newItem.length ) {
			this._close();
			this.focus( event, newItem );
		}
	},

	expand: function( event ) {
		var newItem = this.active &&
			this.active
				.children( ".ui-menu " )
				.find( this.options.items )
				.first();

		if ( newItem && newItem.length ) {
			this._open( newItem.parent() );

			// Delay so Firefox will not hide activedescendant change in expanding submenu from AT
			this._delay(function() {
				this.focus( event, newItem );
			});
		}
	},

	next: function( event ) {
		this._move( "next", "first", event );
	},

	previous: function( event ) {
		this._move( "prev", "last", event );
	},

	isFirstItem: function() {
		return this.active && !this.active.prevAll( ".ui-menu-item" ).length;
	},

	isLastItem: function() {
		return this.active && !this.active.nextAll( ".ui-menu-item" ).length;
	},

	_move: function( direction, filter, event ) {
		var next;
		if ( this.active ) {
			if ( direction === "first" || direction === "last" ) {
				next = this.active
					[ direction === "first" ? "prevAll" : "nextAll" ]( ".ui-menu-item" )
					.eq( -1 );
			} else {
				next = this.active
					[ direction + "All" ]( ".ui-menu-item" )
					.eq( 0 );
			}
		}
		if ( !next || !next.length || !this.active ) {
			next = this.activeMenu.find( this.options.items )[ filter ]();
		}

		this.focus( event, next );
	},

	nextPage: function( event ) {
		var item, base, height;

		if ( !this.active ) {
			this.next( event );
			return;
		}
		if ( this.isLastItem() ) {
			return;
		}
		if ( this._hasScroll() ) {
			base = this.active.offset().top;
			height = this.element.height();
			this.active.nextAll( ".ui-menu-item" ).each(function() {
				item = $( this );
				return item.offset().top - base - height < 0;
			});

			this.focus( event, item );
		} else {
			this.focus( event, this.activeMenu.find( this.options.items )
				[ !this.active ? "first" : "last" ]() );
		}
	},

	previousPage: function( event ) {
		var item, base, height;
		if ( !this.active ) {
			this.next( event );
			return;
		}
		if ( this.isFirstItem() ) {
			return;
		}
		if ( this._hasScroll() ) {
			base = this.active.offset().top;
			height = this.element.height();
			this.active.prevAll( ".ui-menu-item" ).each(function() {
				item = $( this );
				return item.offset().top - base + height > 0;
			});

			this.focus( event, item );
		} else {
			this.focus( event, this.activeMenu.find( this.options.items ).first() );
		}
	},

	_hasScroll: function() {
		return this.element.outerHeight() < this.element.prop( "scrollHeight" );
	},

	select: function( event ) {
		// TODO: It should never be possible to not have an active item at this
		// point, but the tests don't trigger mouseenter before click.
		this.active = this.active || $( event.target ).closest( ".ui-menu-item" );
		var ui = { item: this.active };
		if ( !this.active.has( ".ui-menu" ).length ) {
			this.collapseAll( event, true );
		}
		this._trigger( "select", event, ui );
	},

	_filterMenuItems: function(character) {
		var escapedCharacter = character.replace( /[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&" ),
			regex = new RegExp( "^" + escapedCharacter, "i" );

		return this.activeMenu
			.find( this.options.items )

			// Only match on items, not dividers or other content (#10571)
			.filter( ".ui-menu-item" )
			.filter(function() {
				return regex.test( $.trim( $( this ).text() ) );
			});
	}
});

}));





/*!
 * jQuery UI Autocomplete 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/autocomplete/
 */

(function( factory ) {
	if ( typeof define === "function" && define.amd ) {

		// AMD. Register as an anonymous module.
		define([
			"jquery",
			"./core",
			"./widget",
			"./position",
			"./menu"
		], factory );
	} else {

		// Browser globals
		factory( jQuery );
	}
}(function( $ ) {

$.widget( "ui.autocomplete", {
	version: "1.11.4",
	defaultElement: "<input>",
	options: {
		appendTo: null,
		autoFocus: false,
		delay: 300,
		minLength: 1,
		position: {
			my: "left top",
			at: "left bottom",
			collision: "none"
		},
		source: null,

		// callbacks
		change: null,
		close: null,
		focus: null,
		open: null,
		response: null,
		search: null,
		select: null
	},

	requestIndex: 0,
	pending: 0,

	_create: function() {
		// Some browsers only repeat keydown events, not keypress events,
		// so we use the suppressKeyPress flag to determine if we've already
		// handled the keydown event. #7269
		// Unfortunately the code for & in keypress is the same as the up arrow,
		// so we use the suppressKeyPressRepeat flag to avoid handling keypress
		// events when we know the keydown event was used to modify the
		// search term. #7799
		var suppressKeyPress, suppressKeyPressRepeat, suppressInput,
			nodeName = this.element[ 0 ].nodeName.toLowerCase(),
			isTextarea = nodeName === "textarea",
			isInput = nodeName === "input";

		this.isMultiLine =
			// Textareas are always multi-line
			isTextarea ? true :
			// Inputs are always single-line, even if inside a contentEditable element
			// IE also treats inputs as contentEditable
			isInput ? false :
			// All other element types are determined by whether or not they're contentEditable
			this.element.prop( "isContentEditable" );

		this.valueMethod = this.element[ isTextarea || isInput ? "val" : "text" ];
		this.isNewMenu = true;

		this.element
			.addClass( "ui-autocomplete-input" )
			.attr( "autocomplete", "off" );

		this._on( this.element, {
			keydown: function( event ) {
				if ( this.element.prop( "readOnly" ) ) {
					suppressKeyPress = true;
					suppressInput = true;
					suppressKeyPressRepeat = true;
					return;
				}

				suppressKeyPress = false;
				suppressInput = false;
				suppressKeyPressRepeat = false;
				var keyCode = $.ui.keyCode;
				switch ( event.keyCode ) {
				case keyCode.PAGE_UP:
					suppressKeyPress = true;
					this._move( "previousPage", event );
					break;
				case keyCode.PAGE_DOWN:
					suppressKeyPress = true;
					this._move( "nextPage", event );
					break;
				case keyCode.UP:
					suppressKeyPress = true;
					this._keyEvent( "previous", event );
					break;
				case keyCode.DOWN:
					suppressKeyPress = true;
					this._keyEvent( "next", event );
					break;
				case keyCode.ENTER:
					// when menu is open and has focus
					if ( this.menu.active ) {
						// #6055 - Opera still allows the keypress to occur
						// which causes forms to submit
						suppressKeyPress = true;
						event.preventDefault();
						this.menu.select( event );
					}
					break;
				case keyCode.TAB:
					if ( this.menu.active ) {
						this.menu.select( event );
					}
					break;
				case keyCode.ESCAPE:
					if ( this.menu.element.is( ":visible" ) ) {
						if ( !this.isMultiLine ) {
							this._value( this.term );
						}
						this.close( event );
						// Different browsers have different default behavior for escape
						// Single press can mean undo or clear
						// Double press in IE means clear the whole form
						event.preventDefault();
					}
					break;
				default:
					suppressKeyPressRepeat = true;
					// search timeout should be triggered before the input value is changed
					this._searchTimeout( event );
					break;
				}
			},
			keypress: function( event ) {
				if ( suppressKeyPress ) {
					suppressKeyPress = false;
					if ( !this.isMultiLine || this.menu.element.is( ":visible" ) ) {
						event.preventDefault();
					}
					return;
				}
				if ( suppressKeyPressRepeat ) {
					return;
				}

				// replicate some key handlers to allow them to repeat in Firefox and Opera
				var keyCode = $.ui.keyCode;
				switch ( event.keyCode ) {
				case keyCode.PAGE_UP:
					this._move( "previousPage", event );
					break;
				case keyCode.PAGE_DOWN:
					this._move( "nextPage", event );
					break;
				case keyCode.UP:
					this._keyEvent( "previous", event );
					break;
				case keyCode.DOWN:
					this._keyEvent( "next", event );
					break;
				}
			},
			input: function( event ) {
				if ( suppressInput ) {
					suppressInput = false;
					event.preventDefault();
					return;
				}
				this._searchTimeout( event );
			},
			focus: function() {
				this.selectedItem = null;
				this.previous = this._value();
			},
			blur: function( event ) {
				if ( this.cancelBlur ) {
					delete this.cancelBlur;
					return;
				}

				clearTimeout( this.searching );
				this.close( event );
				this._change( event );
			}
		});

		this._initSource();
		this.menu = $( "<ul>" )
			.addClass( "ui-autocomplete ui-front" )
			.appendTo( this._appendTo() )
			.menu({
				// disable ARIA support, the live region takes care of that
				role: null
			})
			.hide()
			.menu( "instance" );

		this._on( this.menu.element, {
			mousedown: function( event ) {
				// prevent moving focus out of the text field
				event.preventDefault();

				// IE doesn't prevent moving focus even with event.preventDefault()
				// so we set a flag to know when we should ignore the blur event
				this.cancelBlur = true;
				this._delay(function() {
					delete this.cancelBlur;
				});

				// clicking on the scrollbar causes focus to shift to the body
				// but we can't detect a mouseup or a click immediately afterward
				// so we have to track the next mousedown and close the menu if
				// the user clicks somewhere outside of the autocomplete
				var menuElement = this.menu.element[ 0 ];
				if ( !$( event.target ).closest( ".ui-menu-item" ).length ) {
					this._delay(function() {
						var that = this;
						this.document.one( "mousedown", function( event ) {
							if ( event.target !== that.element[ 0 ] &&
									event.target !== menuElement &&
									!$.contains( menuElement, event.target ) ) {
								that.close();
							}
						});
					});
				}
			},
			menufocus: function( event, ui ) {
				var label, item;
				// support: Firefox
				// Prevent accidental activation of menu items in Firefox (#7024 #9118)
				if ( this.isNewMenu ) {
					this.isNewMenu = false;
					if ( event.originalEvent && /^mouse/.test( event.originalEvent.type ) ) {
						this.menu.blur();

						this.document.one( "mousemove", function() {
							$( event.target ).trigger( event.originalEvent );
						});

						return;
					}
				}

				item = ui.item.data( "ui-autocomplete-item" );
				if ( false !== this._trigger( "focus", event, { item: item } ) ) {
					// use value to match what will end up in the input, if it was a key event
					if ( event.originalEvent && /^key/.test( event.originalEvent.type ) ) {
						this._value( item.value );
					}
				}

				// Announce the value in the liveRegion
				label = ui.item.attr( "aria-label" ) || item.value;
				if ( label && $.trim( label ).length ) {
					this.liveRegion.children().hide();
					$( "<div>" ).text( label ).appendTo( this.liveRegion );
				}
			},
			menuselect: function( event, ui ) {
				var item = ui.item.data( "ui-autocomplete-item" ),
					previous = this.previous;

				// only trigger when focus was lost (click on menu)
				if ( this.element[ 0 ] !== this.document[ 0 ].activeElement ) {
					this.element.focus();
					this.previous = previous;
					// #6109 - IE triggers two focus events and the second
					// is asynchronous, so we need to reset the previous
					// term synchronously and asynchronously :-(
					this._delay(function() {
						this.previous = previous;
						this.selectedItem = item;
					});
				}

				if ( false !== this._trigger( "select", event, { item: item } ) ) {
					this._value( item.value );
				}
				// reset the term after the select event
				// this allows custom select handling to work properly
				this.term = this._value();

				this.close( event );
				this.selectedItem = item;
			}
		});

		this.liveRegion = $( "<span>", {
				role: "status",
				"aria-live": "assertive",
				"aria-relevant": "additions"
			})
			.addClass( "ui-helper-hidden-accessible" )
			.appendTo( this.document[ 0 ].body );

		// turning off autocomplete prevents the browser from remembering the
		// value when navigating through history, so we re-enable autocomplete
		// if the page is unloaded before the widget is destroyed. #7790
		this._on( this.window, {
			beforeunload: function() {
				this.element.removeAttr( "autocomplete" );
			}
		});
	},

	_destroy: function() {
		clearTimeout( this.searching );
		this.element
			.removeClass( "ui-autocomplete-input" )
			.removeAttr( "autocomplete" );
		this.menu.element.remove();
		this.liveRegion.remove();
	},

	_setOption: function( key, value ) {
		this._super( key, value );
		if ( key === "source" ) {
			this._initSource();
		}
		if ( key === "appendTo" ) {
			this.menu.element.appendTo( this._appendTo() );
		}
		if ( key === "disabled" && value && this.xhr ) {
			this.xhr.abort();
		}
	},

	_appendTo: function() {
		var element = this.options.appendTo;

		if ( element ) {
			element = element.jquery || element.nodeType ?
				$( element ) :
				this.document.find( element ).eq( 0 );
		}

		if ( !element || !element[ 0 ] ) {
			element = this.element.closest( ".ui-front" );
		}

		if ( !element.length ) {
			element = this.document[ 0 ].body;
		}

		return element;
	},

	_initSource: function() {
		var array, url,
			that = this;
		if ( $.isArray( this.options.source ) ) {
			array = this.options.source;
			this.source = function( request, response ) {
				response( $.ui.autocomplete.filter( array, request.term ) );
			};
		} else if ( typeof this.options.source === "string" ) {
			url = this.options.source;
			this.source = function( request, response ) {
				if ( that.xhr ) {
					that.xhr.abort();
				}
				that.xhr = $.ajax({
					url: url,
					data: request,
					dataType: "json",
					success: function( data ) {
						response( data );
					},
					error: function() {
						response([]);
					}
				});
			};
		} else {
			this.source = this.options.source;
		}
	},

	_searchTimeout: function( event ) {
		clearTimeout( this.searching );
		this.searching = this._delay(function() {

			// Search if the value has changed, or if the user retypes the same value (see #7434)
			var equalValues = this.term === this._value(),
				menuVisible = this.menu.element.is( ":visible" ),
				modifierKey = event.altKey || event.ctrlKey || event.metaKey || event.shiftKey;

			if ( !equalValues || ( equalValues && !menuVisible && !modifierKey ) ) {
				this.selectedItem = null;
				this.search( null, event );
			}
		}, this.options.delay );
	},

	search: function( value, event ) {
		value = value != null ? value : this._value();

		// always save the actual value, not the one passed as an argument
		this.term = this._value();

		if ( value.length < this.options.minLength ) {
			return this.close( event );
		}

		if ( this._trigger( "search", event ) === false ) {
			return;
		}

		return this._search( value );
	},

	_search: function( value ) {
		this.pending++;
		this.element.addClass( "ui-autocomplete-loading" );
		this.cancelSearch = false;

		this.source( { term: value }, this._response() );
	},

	_response: function() {
		var index = ++this.requestIndex;

		return $.proxy(function( content ) {
			if ( index === this.requestIndex ) {
				this.__response( content );
			}

			this.pending--;
			if ( !this.pending ) {
				this.element.removeClass( "ui-autocomplete-loading" );
			}
		}, this );
	},

	__response: function( content ) {
		if ( content ) {
			content = this._normalize( content );
		}
		this._trigger( "response", null, { content: content } );
		if ( !this.options.disabled && content && content.length && !this.cancelSearch ) {
			this._suggest( content );
			this._trigger( "open" );
		} else {
			// use ._close() instead of .close() so we don't cancel future searches
			this._close();
		}
	},

	close: function( event ) {
		this.cancelSearch = true;
		this._close( event );
	},

	_close: function( event ) {
		if ( this.menu.element.is( ":visible" ) ) {
			this.menu.element.hide();
			this.menu.blur();
			this.isNewMenu = true;
			this._trigger( "close", event );
		}
	},

	_change: function( event ) {
		if ( this.previous !== this._value() ) {
			this._trigger( "change", event, { item: this.selectedItem } );
		}
	},

	_normalize: function( items ) {
		// assume all items have the right format when the first item is complete
		if ( items.length && items[ 0 ].label && items[ 0 ].value ) {
			return items;
		}
		return $.map( items, function( item ) {
			if ( typeof item === "string" ) {
				return {
					label: item,
					value: item
				};
			}
			return $.extend( {}, item, {
				label: item.label || item.value,
				value: item.value || item.label
			});
		});
	},

	_suggest: function( items ) {
		var ul = this.menu.element.empty();
		this._renderMenu( ul, items );
		this.isNewMenu = true;
		this.menu.refresh();

		// size and position menu
		ul.show();
		this._resizeMenu();
		ul.position( $.extend({
			of: this.element
		}, this.options.position ) );

		if ( this.options.autoFocus ) {
			this.menu.next();
		}
	},

	_resizeMenu: function() {
		var ul = this.menu.element;
		ul.outerWidth( Math.max(
			// Firefox wraps long text (possibly a rounding bug)
			// so we add 1px to avoid the wrapping (#7513)
			ul.width( "" ).outerWidth() + 1,
			this.element.outerWidth()
		) );
	},

	_renderMenu: function( ul, items ) {
		var that = this;
		$.each( items, function( index, item ) {
			that._renderItemData( ul, item );
		});
	},

	_renderItemData: function( ul, item ) {
		return this._renderItem( ul, item ).data( "ui-autocomplete-item", item );
	},

	_renderItem: function( ul, item ) {
		return $( "<li>" ).text( item.label ).appendTo( ul );
	},

	_move: function( direction, event ) {
		if ( !this.menu.element.is( ":visible" ) ) {
			this.search( null, event );
			return;
		}
		if ( this.menu.isFirstItem() && /^previous/.test( direction ) ||
				this.menu.isLastItem() && /^next/.test( direction ) ) {

			if ( !this.isMultiLine ) {
				this._value( this.term );
			}

			this.menu.blur();
			return;
		}
		this.menu[ direction ]( event );
	},

	widget: function() {
		return this.menu.element;
	},

	_value: function() {
		return this.valueMethod.apply( this.element, arguments );
	},

	_keyEvent: function( keyEvent, event ) {
		if ( !this.isMultiLine || this.menu.element.is( ":visible" ) ) {
			this._move( keyEvent, event );

			// prevents moving cursor to beginning/end of the text field in some browsers
			event.preventDefault();
		}
	}
});

$.extend( $.ui.autocomplete, {
	escapeRegex: function( value ) {
		return value.replace( /[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&" );
	},
	filter: function( array, term ) {
		var matcher = new RegExp( $.ui.autocomplete.escapeRegex( term ), "i" );
		return $.grep( array, function( value ) {
			return matcher.test( value.label || value.value || value );
		});
	}
});

// live region extension, adding a `messages` option
// NOTE: This is an experimental API. We are still investigating
// a full solution for string manipulation and internationalization.
$.widget( "ui.autocomplete", $.ui.autocomplete, {
	options: {
		messages: {
			noResults: "No search results.",
			results: function( amount ) {
				return amount + ( amount > 1 ? " results are" : " result is" ) +
					" available, use up and down arrow keys to navigate.";
			}
		}
	},

	__response: function( content ) {
		var message;
		this._superApply( arguments );
		if ( this.options.disabled || this.cancelSearch ) {
			return;
		}
		if ( content && content.length ) {
			message = this.options.messages.results( content.length );
		} else {
			message = this.options.messages.noResults;
		}
		this.liveRegion.children().hide();
		$( "<div>" ).text( message ).appendTo( this.liveRegion );
	}
});

return $.ui.autocomplete;

}));



/*!
 * jQuery UI Button 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/button/
 */

(function( factory ) {
	if ( typeof define === "function" && define.amd ) {

		// AMD. Register as an anonymous module.
		define([
			"jquery",
			"./core",
			"./widget"
		], factory );
	} else {

		// Browser globals
		factory( jQuery );
	}
}(function( $ ) {

var lastActive,
	baseClasses = "ui-button ui-widget ui-state-default ui-corner-all",
	typeClasses = "ui-button-icons-only ui-button-icon-only ui-button-text-icons ui-button-text-icon-primary ui-button-text-icon-secondary ui-button-text-only",
	formResetHandler = function() {
		var form = $( this );
		setTimeout(function() {
			form.find( ":ui-button" ).button( "refresh" );
		}, 1 );
	},
	radioGroup = function( radio ) {
		var name = radio.name,
			form = radio.form,
			radios = $( [] );
		if ( name ) {
			name = name.replace( /'/g, "\\'" );
			if ( form ) {
				radios = $( form ).find( "[name='" + name + "'][type=radio]" );
			} else {
				radios = $( "[name='" + name + "'][type=radio]", radio.ownerDocument )
					.filter(function() {
						return !this.form;
					});
			}
		}
		return radios;
	};

$.widget( "ui.button", {
	version: "1.11.4",
	defaultElement: "<button>",
	options: {
		disabled: null,
		text: true,
		label: null,
		icons: {
			primary: null,
			secondary: null
		}
	},
	_create: function() {
		this.element.closest( "form" )
			.unbind( "reset" + this.eventNamespace )
			.bind( "reset" + this.eventNamespace, formResetHandler );

		if ( typeof this.options.disabled !== "boolean" ) {
			this.options.disabled = !!this.element.prop( "disabled" );
		} else {
			this.element.prop( "disabled", this.options.disabled );
		}

		this._determineButtonType();
		this.hasTitle = !!this.buttonElement.attr( "title" );

		var that = this,
			options = this.options,
			toggleButton = this.type === "checkbox" || this.type === "radio",
			activeClass = !toggleButton ? "ui-state-active" : "";

		if ( options.label === null ) {
			options.label = (this.type === "input" ? this.buttonElement.val() : this.buttonElement.html());
		}

		this._hoverable( this.buttonElement );

		this.buttonElement
			.addClass( baseClasses )
			.attr( "role", "button" )
			.bind( "mouseenter" + this.eventNamespace, function() {
				if ( options.disabled ) {
					return;
				}
				if ( this === lastActive ) {
					$( this ).addClass( "ui-state-active" );
				}
			})
			.bind( "mouseleave" + this.eventNamespace, function() {
				if ( options.disabled ) {
					return;
				}
				$( this ).removeClass( activeClass );
			})
			.bind( "click" + this.eventNamespace, function( event ) {
				if ( options.disabled ) {
					event.preventDefault();
					event.stopImmediatePropagation();
				}
			});

		// Can't use _focusable() because the element that receives focus
		// and the element that gets the ui-state-focus class are different
		this._on({
			focus: function() {
				this.buttonElement.addClass( "ui-state-focus" );
			},
			blur: function() {
				this.buttonElement.removeClass( "ui-state-focus" );
			}
		});

		if ( toggleButton ) {
			this.element.bind( "change" + this.eventNamespace, function() {
				that.refresh();
			});
		}

		if ( this.type === "checkbox" ) {
			this.buttonElement.bind( "click" + this.eventNamespace, function() {
				if ( options.disabled ) {
					return false;
				}
			});
		} else if ( this.type === "radio" ) {
			this.buttonElement.bind( "click" + this.eventNamespace, function() {
				if ( options.disabled ) {
					return false;
				}
				$( this ).addClass( "ui-state-active" );
				that.buttonElement.attr( "aria-pressed", "true" );

				var radio = that.element[ 0 ];
				radioGroup( radio )
					.not( radio )
					.map(function() {
						return $( this ).button( "widget" )[ 0 ];
					})
					.removeClass( "ui-state-active" )
					.attr( "aria-pressed", "false" );
			});
		} else {
			this.buttonElement
				.bind( "mousedown" + this.eventNamespace, function() {
					if ( options.disabled ) {
						return false;
					}
					$( this ).addClass( "ui-state-active" );
					lastActive = this;
					that.document.one( "mouseup", function() {
						lastActive = null;
					});
				})
				.bind( "mouseup" + this.eventNamespace, function() {
					if ( options.disabled ) {
						return false;
					}
					$( this ).removeClass( "ui-state-active" );
				})
				.bind( "keydown" + this.eventNamespace, function(event) {
					if ( options.disabled ) {
						return false;
					}
					if ( event.keyCode === $.ui.keyCode.SPACE || event.keyCode === $.ui.keyCode.ENTER ) {
						$( this ).addClass( "ui-state-active" );
					}
				})
				// see #8559, we bind to blur here in case the button element loses
				// focus between keydown and keyup, it would be left in an "active" state
				.bind( "keyup" + this.eventNamespace + " blur" + this.eventNamespace, function() {
					$( this ).removeClass( "ui-state-active" );
				});

			if ( this.buttonElement.is("a") ) {
				this.buttonElement.keyup(function(event) {
					if ( event.keyCode === $.ui.keyCode.SPACE ) {
						// TODO pass through original event correctly (just as 2nd argument doesn't work)
						$( this ).click();
					}
				});
			}
		}

		this._setOption( "disabled", options.disabled );
		this._resetButton();
	},

	_determineButtonType: function() {
		var ancestor, labelSelector, checked;

		if ( this.element.is("[type=checkbox]") ) {
			this.type = "checkbox";
		} else if ( this.element.is("[type=radio]") ) {
			this.type = "radio";
		} else if ( this.element.is("input") ) {
			this.type = "input";
		} else {
			this.type = "button";
		}

		if ( this.type === "checkbox" || this.type === "radio" ) {
			// we don't search against the document in case the element
			// is disconnected from the DOM
			ancestor = this.element.parents().last();
			labelSelector = "label[for='" + this.element.attr("id") + "']";
			this.buttonElement = ancestor.find( labelSelector );
			if ( !this.buttonElement.length ) {
				ancestor = ancestor.length ? ancestor.siblings() : this.element.siblings();
				this.buttonElement = ancestor.filter( labelSelector );
				if ( !this.buttonElement.length ) {
					this.buttonElement = ancestor.find( labelSelector );
				}
			}
			this.element.addClass( "ui-helper-hidden-accessible" );

			checked = this.element.is( ":checked" );
			if ( checked ) {
				this.buttonElement.addClass( "ui-state-active" );
			}
			this.buttonElement.prop( "aria-pressed", checked );
		} else {
			this.buttonElement = this.element;
		}
	},

	widget: function() {
		return this.buttonElement;
	},

	_destroy: function() {
		this.element
			.removeClass( "ui-helper-hidden-accessible" );
		this.buttonElement
			.removeClass( baseClasses + " ui-state-active " + typeClasses )
			.removeAttr( "role" )
			.removeAttr( "aria-pressed" )
			.html( this.buttonElement.find(".ui-button-text").html() );

		if ( !this.hasTitle ) {
			this.buttonElement.removeAttr( "title" );
		}
	},

	_setOption: function( key, value ) {
		this._super( key, value );
		if ( key === "disabled" ) {
			this.widget().toggleClass( "ui-state-disabled", !!value );
			this.element.prop( "disabled", !!value );
			if ( value ) {
				if ( this.type === "checkbox" || this.type === "radio" ) {
					this.buttonElement.removeClass( "ui-state-focus" );
				} else {
					this.buttonElement.removeClass( "ui-state-focus ui-state-active" );
				}
			}
			return;
		}
		this._resetButton();
	},

	refresh: function() {
		//See #8237 & #8828
		var isDisabled = this.element.is( "input, button" ) ? this.element.is( ":disabled" ) : this.element.hasClass( "ui-button-disabled" );

		if ( isDisabled !== this.options.disabled ) {
			this._setOption( "disabled", isDisabled );
		}
		if ( this.type === "radio" ) {
			radioGroup( this.element[0] ).each(function() {
				if ( $( this ).is( ":checked" ) ) {
					$( this ).button( "widget" )
						.addClass( "ui-state-active" )
						.attr( "aria-pressed", "true" );
				} else {
					$( this ).button( "widget" )
						.removeClass( "ui-state-active" )
						.attr( "aria-pressed", "false" );
				}
			});
		} else if ( this.type === "checkbox" ) {
			if ( this.element.is( ":checked" ) ) {
				this.buttonElement
					.addClass( "ui-state-active" )
					.attr( "aria-pressed", "true" );
			} else {
				this.buttonElement
					.removeClass( "ui-state-active" )
					.attr( "aria-pressed", "false" );
			}
		}
	},

	_resetButton: function() {
		if ( this.type === "input" ) {
			if ( this.options.label ) {
				this.element.val( this.options.label );
			}
			return;
		}
		var buttonElement = this.buttonElement.removeClass( typeClasses ),
			buttonText = $( "<span></span>", this.document[0] )
				.addClass( "ui-button-text" )
				.html( this.options.label )
				.appendTo( buttonElement.empty() )
				.text(),
			icons = this.options.icons,
			multipleIcons = icons.primary && icons.secondary,
			buttonClasses = [];

		if ( icons.primary || icons.secondary ) {
			if ( this.options.text ) {
				buttonClasses.push( "ui-button-text-icon" + ( multipleIcons ? "s" : ( icons.primary ? "-primary" : "-secondary" ) ) );
			}

			if ( icons.primary ) {
				buttonElement.prepend( "<span class='ui-button-icon-primary ui-icon " + icons.primary + "'></span>" );
			}

			if ( icons.secondary ) {
				buttonElement.append( "<span class='ui-button-icon-secondary ui-icon " + icons.secondary + "'></span>" );
			}

			if ( !this.options.text ) {
				buttonClasses.push( multipleIcons ? "ui-button-icons-only" : "ui-button-icon-only" );

				if ( !this.hasTitle ) {
					buttonElement.attr( "title", $.trim( buttonText ) );
				}
			}
		} else {
			buttonClasses.push( "ui-button-text-only" );
		}
		buttonElement.addClass( buttonClasses.join( " " ) );
	}
});

$.widget( "ui.buttonset", {
	version: "1.11.4",
	options: {
		items: "button, input[type=button], input[type=submit], input[type=reset], input[type=checkbox], input[type=radio], a, :data(ui-button)"
	},

	_create: function() {
		this.element.addClass( "ui-buttonset" );
	},

	_init: function() {
		this.refresh();
	},

	_setOption: function( key, value ) {
		if ( key === "disabled" ) {
			this.buttons.button( "option", key, value );
		}

		this._super( key, value );
	},

	refresh: function() {
		var rtl = this.element.css( "direction" ) === "rtl",
			allButtons = this.element.find( this.options.items ),
			existingButtons = allButtons.filter( ":ui-button" );

		// Initialize new buttons
		allButtons.not( ":ui-button" ).button();

		// Refresh existing buttons
		existingButtons.button( "refresh" );

		this.buttons = allButtons
			.map(function() {
				return $( this ).button( "widget" )[ 0 ];
			})
				.removeClass( "ui-corner-all ui-corner-left ui-corner-right" )
				.filter( ":first" )
					.addClass( rtl ? "ui-corner-right" : "ui-corner-left" )
				.end()
				.filter( ":last" )
					.addClass( rtl ? "ui-corner-left" : "ui-corner-right" )
				.end()
			.end();
	},

	_destroy: function() {
		this.element.removeClass( "ui-buttonset" );
		this.buttons
			.map(function() {
				return $( this ).button( "widget" )[ 0 ];
			})
				.removeClass( "ui-corner-left ui-corner-right" )
			.end()
			.button( "destroy" );
	}
});

return $.ui.button;

}));


/*!
 * jQuery UI Datepicker 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/datepicker/
 */

(function( factory ) {
	if ( typeof define === "function" && define.amd ) {

		// AMD. Register as an anonymous module.
		define([
			"jquery",
			"./core"
		], factory );
	} else {

		// Browser globals
		factory( jQuery );
	}
}(function( $ ) {

$.extend($.ui, { datepicker: { version: "1.11.4" } });

var datepicker_instActive;

function datepicker_getZindex( elem ) {
	var position, value;
	while ( elem.length && elem[ 0 ] !== document ) {
		// Ignore z-index if position is set to a value where z-index is ignored by the browser
		// This makes behavior of this function consistent across browsers
		// WebKit always returns auto if the element is positioned
		position = elem.css( "position" );
		if ( position === "absolute" || position === "relative" || position === "fixed" ) {
			// IE returns 0 when zIndex is not specified
			// other browsers return a string
			// we ignore the case of nested elements with an explicit value of 0
			// <div style="z-index: -10;"><div style="z-index: 0;"></div></div>
			value = parseInt( elem.css( "zIndex" ), 10 );
			if ( !isNaN( value ) && value !== 0 ) {
				return value;
			}
		}
		elem = elem.parent();
	}

	return 0;
}
/* Date picker manager.
   Use the singleton instance of this class, $.datepicker, to interact with the date picker.
   Settings for (groups of) date pickers are maintained in an instance object,
   allowing multiple different settings on the same page. */

function Datepicker() {
	this._curInst = null; // The current instance in use
	this._keyEvent = false; // If the last event was a key event
	this._disabledInputs = []; // List of date picker inputs that have been disabled
	this._datepickerShowing = false; // True if the popup picker is showing , false if not
	this._inDialog = false; // True if showing within a "dialog", false if not
	this._mainDivId = "ui-datepicker-div"; // The ID of the main datepicker division
	this._inlineClass = "ui-datepicker-inline"; // The name of the inline marker class
	this._appendClass = "ui-datepicker-append"; // The name of the append marker class
	this._triggerClass = "ui-datepicker-trigger"; // The name of the trigger marker class
	this._dialogClass = "ui-datepicker-dialog"; // The name of the dialog marker class
	this._disableClass = "ui-datepicker-disabled"; // The name of the disabled covering marker class
	this._unselectableClass = "ui-datepicker-unselectable"; // The name of the unselectable cell marker class
	this._currentClass = "ui-datepicker-current-day"; // The name of the current day marker class
	this._dayOverClass = "ui-datepicker-days-cell-over"; // The name of the day hover marker class
	this.regional = []; // Available regional settings, indexed by language code
	this.regional[""] = { // Default regional settings
		closeText: "Done", // Display text for close link
		prevText: "Prev", // Display text for previous month link
		nextText: "Next", // Display text for next month link
		currentText: "Today", // Display text for current month link
		monthNames: ["January","February","March","April","May","June",
			"July","August","September","October","November","December"], // Names of months for drop-down and formatting
		monthNamesShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], // For formatting
		dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], // For formatting
		dayNamesShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], // For formatting
		dayNamesMin: ["Su","Mo","Tu","We","Th","Fr","Sa"], // Column headings for days starting at Sunday
		weekHeader: "Wk", // Column header for week of the year
		dateFormat: "mm/dd/yy", // See format options on parseDate
		firstDay: 0, // The first day of the week, Sun = 0, Mon = 1, ...
		isRTL: false, // True if right-to-left language, false if left-to-right
		showMonthAfterYear: false, // True if the year select precedes month, false for month then year
		yearSuffix: "" // Additional text to append to the year in the month headers
	};
	this._defaults = { // Global defaults for all the date picker instances
		showOn: "focus", // "focus" for popup on focus,
			// "button" for trigger button, or "both" for either
		showAnim: "fadeIn", // Name of jQuery animation for popup
		showOptions: {}, // Options for enhanced animations
		defaultDate: null, // Used when field is blank: actual date,
			// +/-number for offset from today, null for today
		appendText: "", // Display text following the input box, e.g. showing the format
		buttonText: "...", // Text for trigger button
		buttonImage: "", // URL for trigger button image
		buttonImageOnly: false, // True if the image appears alone, false if it appears on a button
		hideIfNoPrevNext: false, // True to hide next/previous month links
			// if not applicable, false to just disable them
		navigationAsDateFormat: false, // True if date formatting applied to prev/today/next links
		gotoCurrent: false, // True if today link goes back to current selection instead
		changeMonth: false, // True if month can be selected directly, false if only prev/next
		changeYear: false, // True if year can be selected directly, false if only prev/next
		yearRange: "c-10:c+10", // Range of years to display in drop-down,
			// either relative to today's year (-nn:+nn), relative to currently displayed year
			// (c-nn:c+nn), absolute (nnnn:nnnn), or a combination of the above (nnnn:-n)
		showOtherMonths: false, // True to show dates in other months, false to leave blank
		selectOtherMonths: false, // True to allow selection of dates in other months, false for unselectable
		showWeek: false, // True to show week of the year, false to not show it
		calculateWeek: this.iso8601Week, // How to calculate the week of the year,
			// takes a Date and returns the number of the week for it
		shortYearCutoff: "+10", // Short year values < this are in the current century,
			// > this are in the previous century,
			// string value starting with "+" for current year + value
		minDate: null, // The earliest selectable date, or null for no limit
		maxDate: null, // The latest selectable date, or null for no limit
		duration: "fast", // Duration of display/closure
		beforeShowDay: null, // Function that takes a date and returns an array with
			// [0] = true if selectable, false if not, [1] = custom CSS class name(s) or "",
			// [2] = cell title (optional), e.g. $.datepicker.noWeekends
		beforeShow: null, // Function that takes an input field and
			// returns a set of custom settings for the date picker
		onSelect: null, // Define a callback function when a date is selected
		onChangeMonthYear: null, // Define a callback function when the month or year is changed
		onClose: null, // Define a callback function when the datepicker is closed
		numberOfMonths: 1, // Number of months to show at a time
		showCurrentAtPos: 0, // The position in multipe months at which to show the current month (starting at 0)
		stepMonths: 1, // Number of months to step back/forward
		stepBigMonths: 12, // Number of months to step back/forward for the big links
		altField: "", // Selector for an alternate field to store selected dates into
		altFormat: "", // The date format to use for the alternate field
		constrainInput: true, // The input is constrained by the current date format
		showButtonPanel: false, // True to show button panel, false to not show it
		autoSize: false, // True to size the input for the date format, false to leave as is
		disabled: false // The initial disabled state
	};
	$.extend(this._defaults, this.regional[""]);
	this.regional.en = $.extend( true, {}, this.regional[ "" ]);
	this.regional[ "en-US" ] = $.extend( true, {}, this.regional.en );
	this.dpDiv = datepicker_bindHover($("<div id='" + this._mainDivId + "' class='ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>"));
}

$.extend(Datepicker.prototype, {
	/* Class name added to elements to indicate already configured with a date picker. */
	markerClassName: "hasDatepicker",

	//Keep track of the maximum number of rows displayed (see #7043)
	maxRows: 4,

	// TODO rename to "widget" when switching to widget factory
	_widgetDatepicker: function() {
		return this.dpDiv;
	},

	/* Override the default settings for all instances of the date picker.
	 * @param  settings  object - the new settings to use as defaults (anonymous object)
	 * @return the manager object
	 */
	setDefaults: function(settings) {
		datepicker_extendRemove(this._defaults, settings || {});
		return this;
	},

	/* Attach the date picker to a jQuery selection.
	 * @param  target	element - the target input field or division or span
	 * @param  settings  object - the new settings to use for this date picker instance (anonymous)
	 */
	_attachDatepicker: function(target, settings) {
		var nodeName, inline, inst;
		nodeName = target.nodeName.toLowerCase();
		inline = (nodeName === "div" || nodeName === "span");
		if (!target.id) {
			this.uuid += 1;
			target.id = "dp" + this.uuid;
		}
		inst = this._newInst($(target), inline);
		inst.settings = $.extend({}, settings || {});
		if (nodeName === "input") {
			this._connectDatepicker(target, inst);
		} else if (inline) {
			this._inlineDatepicker(target, inst);
		}
	},

	/* Create a new instance object. */
	_newInst: function(target, inline) {
		var id = target[0].id.replace(/([^A-Za-z0-9_\-])/g, "\\\\$1"); // escape jQuery meta chars
		return {id: id, input: target, // associated target
			selectedDay: 0, selectedMonth: 0, selectedYear: 0, // current selection
			drawMonth: 0, drawYear: 0, // month being drawn
			inline: inline, // is datepicker inline or not
			dpDiv: (!inline ? this.dpDiv : // presentation div
			datepicker_bindHover($("<div class='" + this._inlineClass + " ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>")))};
	},

	/* Attach the date picker to an input field. */
	_connectDatepicker: function(target, inst) {
		var input = $(target);
		inst.append = $([]);
		inst.trigger = $([]);
		if (input.hasClass(this.markerClassName)) {
			return;
		}
		this._attachments(input, inst);
		input.addClass(this.markerClassName).keydown(this._doKeyDown).
			keypress(this._doKeyPress).keyup(this._doKeyUp);
		this._autoSize(inst);
		$.data(target, "datepicker", inst);
		//If disabled option is true, disable the datepicker once it has been attached to the input (see ticket #5665)
		if( inst.settings.disabled ) {
			this._disableDatepicker( target );
		}
	},

	/* Make attachments based on settings. */
	_attachments: function(input, inst) {
		var showOn, buttonText, buttonImage,
			appendText = this._get(inst, "appendText"),
			isRTL = this._get(inst, "isRTL");

		if (inst.append) {
			inst.append.remove();
		}
		if (appendText) {
			inst.append = $("<span class='" + this._appendClass + "'>" + appendText + "</span>");
			input[isRTL ? "before" : "after"](inst.append);
		}

		input.unbind("focus", this._showDatepicker);

		if (inst.trigger) {
			inst.trigger.remove();
		}

		showOn = this._get(inst, "showOn");
		if (showOn === "focus" || showOn === "both") { // pop-up date picker when in the marked field
			input.focus(this._showDatepicker);
		}
		if (showOn === "button" || showOn === "both") { // pop-up date picker when button clicked
			buttonText = this._get(inst, "buttonText");
			buttonImage = this._get(inst, "buttonImage");
			inst.trigger = $(this._get(inst, "buttonImageOnly") ?
				$("<img/>").addClass(this._triggerClass).
					attr({ src: buttonImage, alt: buttonText, title: buttonText }) :
				$("<button type='button'></button>").addClass(this._triggerClass).
					html(!buttonImage ? buttonText : $("<img/>").attr(
					{ src:buttonImage, alt:buttonText, title:buttonText })));
			input[isRTL ? "before" : "after"](inst.trigger);
			inst.trigger.click(function() {
				if ($.datepicker._datepickerShowing && $.datepicker._lastInput === input[0]) {
					$.datepicker._hideDatepicker();
				} else if ($.datepicker._datepickerShowing && $.datepicker._lastInput !== input[0]) {
					$.datepicker._hideDatepicker();
					$.datepicker._showDatepicker(input[0]);
				} else {
					$.datepicker._showDatepicker(input[0]);
				}
				return false;
			});
		}
	},

	/* Apply the maximum length for the date format. */
	_autoSize: function(inst) {
		if (this._get(inst, "autoSize") && !inst.inline) {
			var findMax, max, maxI, i,
				date = new Date(2009, 12 - 1, 20), // Ensure double digits
				dateFormat = this._get(inst, "dateFormat");

			if (dateFormat.match(/[DM]/)) {
				findMax = function(names) {
					max = 0;
					maxI = 0;
					for (i = 0; i < names.length; i++) {
						if (names[i].length > max) {
							max = names[i].length;
							maxI = i;
						}
					}
					return maxI;
				};
				date.setMonth(findMax(this._get(inst, (dateFormat.match(/MM/) ?
					"monthNames" : "monthNamesShort"))));
				date.setDate(findMax(this._get(inst, (dateFormat.match(/DD/) ?
					"dayNames" : "dayNamesShort"))) + 20 - date.getDay());
			}
			inst.input.attr("size", this._formatDate(inst, date).length);
		}
	},

	/* Attach an inline date picker to a div. */
	_inlineDatepicker: function(target, inst) {
		var divSpan = $(target);
		if (divSpan.hasClass(this.markerClassName)) {
			return;
		}
		divSpan.addClass(this.markerClassName).append(inst.dpDiv);
		$.data(target, "datepicker", inst);
		this._setDate(inst, this._getDefaultDate(inst), true);
		this._updateDatepicker(inst);
		this._updateAlternate(inst);
		//If disabled option is true, disable the datepicker before showing it (see ticket #5665)
		if( inst.settings.disabled ) {
			this._disableDatepicker( target );
		}
		// Set display:block in place of inst.dpDiv.show() which won't work on disconnected elements
		// http://bugs.jqueryui.com/ticket/7552 - A Datepicker created on a detached div has zero height
		inst.dpDiv.css( "display", "block" );
	},

	/* Pop-up the date picker in a "dialog" box.
	 * @param  input element - ignored
	 * @param  date	string or Date - the initial date to display
	 * @param  onSelect  function - the function to call when a date is selected
	 * @param  settings  object - update the dialog date picker instance's settings (anonymous object)
	 * @param  pos int[2] - coordinates for the dialog's position within the screen or
	 *					event - with x/y coordinates or
	 *					leave empty for default (screen centre)
	 * @return the manager object
	 */
	_dialogDatepicker: function(input, date, onSelect, settings, pos) {
		var id, browserWidth, browserHeight, scrollX, scrollY,
			inst = this._dialogInst; // internal instance

		if (!inst) {
			this.uuid += 1;
			id = "dp" + this.uuid;
			this._dialogInput = $("<input type='text' id='" + id +
				"' style='position: absolute; top: -100px; width: 0px;'/>");
			this._dialogInput.keydown(this._doKeyDown);
			$("body").append(this._dialogInput);
			inst = this._dialogInst = this._newInst(this._dialogInput, false);
			inst.settings = {};
			$.data(this._dialogInput[0], "datepicker", inst);
		}
		datepicker_extendRemove(inst.settings, settings || {});
		date = (date && date.constructor === Date ? this._formatDate(inst, date) : date);
		this._dialogInput.val(date);

		this._pos = (pos ? (pos.length ? pos : [pos.pageX, pos.pageY]) : null);
		if (!this._pos) {
			browserWidth = document.documentElement.clientWidth;
			browserHeight = document.documentElement.clientHeight;
			scrollX = document.documentElement.scrollLeft || document.body.scrollLeft;
			scrollY = document.documentElement.scrollTop || document.body.scrollTop;
			this._pos = // should use actual width/height below
				[(browserWidth / 2) - 100 + scrollX, (browserHeight / 2) - 150 + scrollY];
		}

		// move input on screen for focus, but hidden behind dialog
		this._dialogInput.css("left", (this._pos[0] + 20) + "px").css("top", this._pos[1] + "px");
		inst.settings.onSelect = onSelect;
		this._inDialog = true;
		this.dpDiv.addClass(this._dialogClass);
		this._showDatepicker(this._dialogInput[0]);
		if ($.blockUI) {
			$.blockUI(this.dpDiv);
		}
		$.data(this._dialogInput[0], "datepicker", inst);
		return this;
	},

	/* Detach a datepicker from its control.
	 * @param  target	element - the target input field or division or span
	 */
	_destroyDatepicker: function(target) {
		var nodeName,
			$target = $(target),
			inst = $.data(target, "datepicker");

		if (!$target.hasClass(this.markerClassName)) {
			return;
		}

		nodeName = target.nodeName.toLowerCase();
		$.removeData(target, "datepicker");
		if (nodeName === "input") {
			inst.append.remove();
			inst.trigger.remove();
			$target.removeClass(this.markerClassName).
				unbind("focus", this._showDatepicker).
				unbind("keydown", this._doKeyDown).
				unbind("keypress", this._doKeyPress).
				unbind("keyup", this._doKeyUp);
		} else if (nodeName === "div" || nodeName === "span") {
			$target.removeClass(this.markerClassName).empty();
		}

		if ( datepicker_instActive === inst ) {
			datepicker_instActive = null;
		}
	},

	/* Enable the date picker to a jQuery selection.
	 * @param  target	element - the target input field or division or span
	 */
	_enableDatepicker: function(target) {
		var nodeName, inline,
			$target = $(target),
			inst = $.data(target, "datepicker");

		if (!$target.hasClass(this.markerClassName)) {
			return;
		}

		nodeName = target.nodeName.toLowerCase();
		if (nodeName === "input") {
			target.disabled = false;
			inst.trigger.filter("button").
				each(function() { this.disabled = false; }).end().
				filter("img").css({opacity: "1.0", cursor: ""});
		} else if (nodeName === "div" || nodeName === "span") {
			inline = $target.children("." + this._inlineClass);
			inline.children().removeClass("ui-state-disabled");
			inline.find("select.ui-datepicker-month, select.ui-datepicker-year").
				prop("disabled", false);
		}
		this._disabledInputs = $.map(this._disabledInputs,
			function(value) { return (value === target ? null : value); }); // delete entry
	},

	/* Disable the date picker to a jQuery selection.
	 * @param  target	element - the target input field or division or span
	 */
	_disableDatepicker: function(target) {
		var nodeName, inline,
			$target = $(target),
			inst = $.data(target, "datepicker");

		if (!$target.hasClass(this.markerClassName)) {
			return;
		}

		nodeName = target.nodeName.toLowerCase();
		if (nodeName === "input") {
			target.disabled = true;
			inst.trigger.filter("button").
				each(function() { this.disabled = true; }).end().
				filter("img").css({opacity: "0.5", cursor: "default"});
		} else if (nodeName === "div" || nodeName === "span") {
			inline = $target.children("." + this._inlineClass);
			inline.children().addClass("ui-state-disabled");
			inline.find("select.ui-datepicker-month, select.ui-datepicker-year").
				prop("disabled", true);
		}
		this._disabledInputs = $.map(this._disabledInputs,
			function(value) { return (value === target ? null : value); }); // delete entry
		this._disabledInputs[this._disabledInputs.length] = target;
	},

	/* Is the first field in a jQuery collection disabled as a datepicker?
	 * @param  target	element - the target input field or division or span
	 * @return boolean - true if disabled, false if enabled
	 */
	_isDisabledDatepicker: function(target) {
		if (!target) {
			return false;
		}
		for (var i = 0; i < this._disabledInputs.length; i++) {
			if (this._disabledInputs[i] === target) {
				return true;
			}
		}
		return false;
	},

	/* Retrieve the instance data for the target control.
	 * @param  target  element - the target input field or division or span
	 * @return  object - the associated instance data
	 * @throws  error if a jQuery problem getting data
	 */
	_getInst: function(target) {
		try {
			return $.data(target, "datepicker");
		}
		catch (err) {
			throw "Missing instance data for this datepicker";
		}
	},

	/* Update or retrieve the settings for a date picker attached to an input field or division.
	 * @param  target  element - the target input field or division or span
	 * @param  name	object - the new settings to update or
	 *				string - the name of the setting to change or retrieve,
	 *				when retrieving also "all" for all instance settings or
	 *				"defaults" for all global defaults
	 * @param  value   any - the new value for the setting
	 *				(omit if above is an object or to retrieve a value)
	 */
	_optionDatepicker: function(target, name, value) {
		var settings, date, minDate, maxDate,
			inst = this._getInst(target);

		if (arguments.length === 2 && typeof name === "string") {
			return (name === "defaults" ? $.extend({}, $.datepicker._defaults) :
				(inst ? (name === "all" ? $.extend({}, inst.settings) :
				this._get(inst, name)) : null));
		}

		settings = name || {};
		if (typeof name === "string") {
			settings = {};
			settings[name] = value;
		}

		if (inst) {
			if (this._curInst === inst) {
				this._hideDatepicker();
			}

			date = this._getDateDatepicker(target, true);
			minDate = this._getMinMaxDate(inst, "min");
			maxDate = this._getMinMaxDate(inst, "max");
			datepicker_extendRemove(inst.settings, settings);
			// reformat the old minDate/maxDate values if dateFormat changes and a new minDate/maxDate isn't provided
			if (minDate !== null && settings.dateFormat !== undefined && settings.minDate === undefined) {
				inst.settings.minDate = this._formatDate(inst, minDate);
			}
			if (maxDate !== null && settings.dateFormat !== undefined && settings.maxDate === undefined) {
				inst.settings.maxDate = this._formatDate(inst, maxDate);
			}
			if ( "disabled" in settings ) {
				if ( settings.disabled ) {
					this._disableDatepicker(target);
				} else {
					this._enableDatepicker(target);
				}
			}
			this._attachments($(target), inst);
			this._autoSize(inst);
			this._setDate(inst, date);
			this._updateAlternate(inst);
			this._updateDatepicker(inst);
		}
	},

	// change method deprecated
	_changeDatepicker: function(target, name, value) {
		this._optionDatepicker(target, name, value);
	},

	/* Redraw the date picker attached to an input field or division.
	 * @param  target  element - the target input field or division or span
	 */
	_refreshDatepicker: function(target) {
		var inst = this._getInst(target);
		if (inst) {
			this._updateDatepicker(inst);
		}
	},

	/* Set the dates for a jQuery selection.
	 * @param  target element - the target input field or division or span
	 * @param  date	Date - the new date
	 */
	_setDateDatepicker: function(target, date) {
		var inst = this._getInst(target);
		if (inst) {
			this._setDate(inst, date);
			this._updateDatepicker(inst);
			this._updateAlternate(inst);
		}
	},

	/* Get the date(s) for the first entry in a jQuery selection.
	 * @param  target element - the target input field or division or span
	 * @param  noDefault boolean - true if no default date is to be used
	 * @return Date - the current date
	 */
	_getDateDatepicker: function(target, noDefault) {
		var inst = this._getInst(target);
		if (inst && !inst.inline) {
			this._setDateFromField(inst, noDefault);
		}
		return (inst ? this._getDate(inst) : null);
	},

	/* Handle keystrokes. */
	_doKeyDown: function(event) {
		var onSelect, dateStr, sel,
			inst = $.datepicker._getInst(event.target),
			handled = true,
			isRTL = inst.dpDiv.is(".ui-datepicker-rtl");

		inst._keyEvent = true;
		if ($.datepicker._datepickerShowing) {
			switch (event.keyCode) {
				case 9: $.datepicker._hideDatepicker();
						handled = false;
						break; // hide on tab out
				case 13: sel = $("td." + $.datepicker._dayOverClass + ":not(." +
									$.datepicker._currentClass + ")", inst.dpDiv);
						if (sel[0]) {
							$.datepicker._selectDay(event.target, inst.selectedMonth, inst.selectedYear, sel[0]);
						}

						onSelect = $.datepicker._get(inst, "onSelect");
						if (onSelect) {
							dateStr = $.datepicker._formatDate(inst);

							// trigger custom callback
							onSelect.apply((inst.input ? inst.input[0] : null), [dateStr, inst]);
						} else {
							$.datepicker._hideDatepicker();
						}

						return false; // don't submit the form
				case 27: $.datepicker._hideDatepicker();
						break; // hide on escape
				case 33: $.datepicker._adjustDate(event.target, (event.ctrlKey ?
							-$.datepicker._get(inst, "stepBigMonths") :
							-$.datepicker._get(inst, "stepMonths")), "M");
						break; // previous month/year on page up/+ ctrl
				case 34: $.datepicker._adjustDate(event.target, (event.ctrlKey ?
							+$.datepicker._get(inst, "stepBigMonths") :
							+$.datepicker._get(inst, "stepMonths")), "M");
						break; // next month/year on page down/+ ctrl
				case 35: if (event.ctrlKey || event.metaKey) {
							$.datepicker._clearDate(event.target);
						}
						handled = event.ctrlKey || event.metaKey;
						break; // clear on ctrl or command +end
				case 36: if (event.ctrlKey || event.metaKey) {
							$.datepicker._gotoToday(event.target);
						}
						handled = event.ctrlKey || event.metaKey;
						break; // current on ctrl or command +home
				case 37: if (event.ctrlKey || event.metaKey) {
							$.datepicker._adjustDate(event.target, (isRTL ? +1 : -1), "D");
						}
						handled = event.ctrlKey || event.metaKey;
						// -1 day on ctrl or command +left
						if (event.originalEvent.altKey) {
							$.datepicker._adjustDate(event.target, (event.ctrlKey ?
								-$.datepicker._get(inst, "stepBigMonths") :
								-$.datepicker._get(inst, "stepMonths")), "M");
						}
						// next month/year on alt +left on Mac
						break;
				case 38: if (event.ctrlKey || event.metaKey) {
							$.datepicker._adjustDate(event.target, -7, "D");
						}
						handled = event.ctrlKey || event.metaKey;
						break; // -1 week on ctrl or command +up
				case 39: if (event.ctrlKey || event.metaKey) {
							$.datepicker._adjustDate(event.target, (isRTL ? -1 : +1), "D");
						}
						handled = event.ctrlKey || event.metaKey;
						// +1 day on ctrl or command +right
						if (event.originalEvent.altKey) {
							$.datepicker._adjustDate(event.target, (event.ctrlKey ?
								+$.datepicker._get(inst, "stepBigMonths") :
								+$.datepicker._get(inst, "stepMonths")), "M");
						}
						// next month/year on alt +right
						break;
				case 40: if (event.ctrlKey || event.metaKey) {
							$.datepicker._adjustDate(event.target, +7, "D");
						}
						handled = event.ctrlKey || event.metaKey;
						break; // +1 week on ctrl or command +down
				default: handled = false;
			}
		} else if (event.keyCode === 36 && event.ctrlKey) { // display the date picker on ctrl+home
			$.datepicker._showDatepicker(this);
		} else {
			handled = false;
		}

		if (handled) {
			event.preventDefault();
			event.stopPropagation();
		}
	},

	/* Filter entered characters - based on date format. */
	_doKeyPress: function(event) {
		var chars, chr,
			inst = $.datepicker._getInst(event.target);

		if ($.datepicker._get(inst, "constrainInput")) {
			chars = $.datepicker._possibleChars($.datepicker._get(inst, "dateFormat"));
			chr = String.fromCharCode(event.charCode == null ? event.keyCode : event.charCode);
			return event.ctrlKey || event.metaKey || (chr < " " || !chars || chars.indexOf(chr) > -1);
		}
	},

	/* Synchronise manual entry and field/alternate field. */
	_doKeyUp: function(event) {
		var date,
			inst = $.datepicker._getInst(event.target);

		if (inst.input.val() !== inst.lastVal) {
			try {
				date = $.datepicker.parseDate($.datepicker._get(inst, "dateFormat"),
					(inst.input ? inst.input.val() : null),
					$.datepicker._getFormatConfig(inst));

				if (date) { // only if valid
					$.datepicker._setDateFromField(inst);
					$.datepicker._updateAlternate(inst);
					$.datepicker._updateDatepicker(inst);
				}
			}
			catch (err) {
			}
		}
		return true;
	},

	/* Pop-up the date picker for a given input field.
	 * If false returned from beforeShow event handler do not show.
	 * @param  input  element - the input field attached to the date picker or
	 *					event - if triggered by focus
	 */
	_showDatepicker: function(input) {
		input = input.target || input;
		if (input.nodeName.toLowerCase() !== "input") { // find from button/image trigger
			input = $("input", input.parentNode)[0];
		}

		if ($.datepicker._isDisabledDatepicker(input) || $.datepicker._lastInput === input) { // already here
			return;
		}

		var inst, beforeShow, beforeShowSettings, isFixed,
			offset, showAnim, duration;

		inst = $.datepicker._getInst(input);
		if ($.datepicker._curInst && $.datepicker._curInst !== inst) {
			$.datepicker._curInst.dpDiv.stop(true, true);
			if ( inst && $.datepicker._datepickerShowing ) {
				$.datepicker._hideDatepicker( $.datepicker._curInst.input[0] );
			}
		}

		beforeShow = $.datepicker._get(inst, "beforeShow");
		beforeShowSettings = beforeShow ? beforeShow.apply(input, [input, inst]) : {};
		if(beforeShowSettings === false){
			return;
		}
		datepicker_extendRemove(inst.settings, beforeShowSettings);

		inst.lastVal = null;
		$.datepicker._lastInput = input;
		$.datepicker._setDateFromField(inst);

		if ($.datepicker._inDialog) { // hide cursor
			input.value = "";
		}
		if (!$.datepicker._pos) { // position below input
			$.datepicker._pos = $.datepicker._findPos(input);
			$.datepicker._pos[1] += input.offsetHeight; // add the height
		}

		isFixed = false;
		$(input).parents().each(function() {
			isFixed |= $(this).css("position") === "fixed";
			return !isFixed;
		});

		offset = {left: $.datepicker._pos[0], top: $.datepicker._pos[1]};
		$.datepicker._pos = null;
		//to avoid flashes on Firefox
		inst.dpDiv.empty();
		// determine sizing offscreen
		inst.dpDiv.css({position: "absolute", display: "block", top: "-1000px"});
		$.datepicker._updateDatepicker(inst);
		// fix width for dynamic number of date pickers
		// and adjust position before showing
		offset = $.datepicker._checkOffset(inst, offset, isFixed);
		inst.dpDiv.css({position: ($.datepicker._inDialog && $.blockUI ?
			"static" : (isFixed ? "fixed" : "absolute")), display: "none",
			left: offset.left + "px", top: offset.top + "px"});

		if (!inst.inline) {
			showAnim = $.datepicker._get(inst, "showAnim");
			duration = $.datepicker._get(inst, "duration");
			inst.dpDiv.css( "z-index", datepicker_getZindex( $( input ) ) + 1 );
			$.datepicker._datepickerShowing = true;

			if ( $.effects && $.effects.effect[ showAnim ] ) {
				inst.dpDiv.show(showAnim, $.datepicker._get(inst, "showOptions"), duration);
			} else {
				inst.dpDiv[showAnim || "show"](showAnim ? duration : null);
			}

			if ( $.datepicker._shouldFocusInput( inst ) ) {
				inst.input.focus();
			}

			$.datepicker._curInst = inst;
		}
	},

	/* Generate the date picker content. */
	_updateDatepicker: function(inst) {
		this.maxRows = 4; //Reset the max number of rows being displayed (see #7043)
		datepicker_instActive = inst; // for delegate hover events
		inst.dpDiv.empty().append(this._generateHTML(inst));
		this._attachHandlers(inst);

		var origyearshtml,
			numMonths = this._getNumberOfMonths(inst),
			cols = numMonths[1],
			width = 17,
			activeCell = inst.dpDiv.find( "." + this._dayOverClass + " a" );

		if ( activeCell.length > 0 ) {
			datepicker_handleMouseover.apply( activeCell.get( 0 ) );
		}

		inst.dpDiv.removeClass("ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4").width("");
		if (cols > 1) {
			inst.dpDiv.addClass("ui-datepicker-multi-" + cols).css("width", (width * cols) + "em");
		}
		inst.dpDiv[(numMonths[0] !== 1 || numMonths[1] !== 1 ? "add" : "remove") +
			"Class"]("ui-datepicker-multi");
		inst.dpDiv[(this._get(inst, "isRTL") ? "add" : "remove") +
			"Class"]("ui-datepicker-rtl");

		if (inst === $.datepicker._curInst && $.datepicker._datepickerShowing && $.datepicker._shouldFocusInput( inst ) ) {
			inst.input.focus();
		}

		// deffered render of the years select (to avoid flashes on Firefox)
		if( inst.yearshtml ){
			origyearshtml = inst.yearshtml;
			setTimeout(function(){
				//assure that inst.yearshtml didn't change.
				if( origyearshtml === inst.yearshtml && inst.yearshtml ){
					inst.dpDiv.find("select.ui-datepicker-year:first").replaceWith(inst.yearshtml);
				}
				origyearshtml = inst.yearshtml = null;
			}, 0);
		}
	},

	// #6694 - don't focus the input if it's already focused
	// this breaks the change event in IE
	// Support: IE and jQuery <1.9
	_shouldFocusInput: function( inst ) {
		return inst.input && inst.input.is( ":visible" ) && !inst.input.is( ":disabled" ) && !inst.input.is( ":focus" );
	},

	/* Check positioning to remain on screen. */
	_checkOffset: function(inst, offset, isFixed) {
		var dpWidth = inst.dpDiv.outerWidth(),
			dpHeight = inst.dpDiv.outerHeight(),
			inputWidth = inst.input ? inst.input.outerWidth() : 0,
			inputHeight = inst.input ? inst.input.outerHeight() : 0,
			viewWidth = document.documentElement.clientWidth + (isFixed ? 0 : $(document).scrollLeft()),
			viewHeight = document.documentElement.clientHeight + (isFixed ? 0 : $(document).scrollTop());

		offset.left -= (this._get(inst, "isRTL") ? (dpWidth - inputWidth) : 0);
		offset.left -= (isFixed && offset.left === inst.input.offset().left) ? $(document).scrollLeft() : 0;
		offset.top -= (isFixed && offset.top === (inst.input.offset().top + inputHeight)) ? $(document).scrollTop() : 0;

		// now check if datepicker is showing outside window viewport - move to a better place if so.
		offset.left -= Math.min(offset.left, (offset.left + dpWidth > viewWidth && viewWidth > dpWidth) ?
			Math.abs(offset.left + dpWidth - viewWidth) : 0);
		offset.top -= Math.min(offset.top, (offset.top + dpHeight > viewHeight && viewHeight > dpHeight) ?
			Math.abs(dpHeight + inputHeight) : 0);

		return offset;
	},

	/* Find an object's position on the screen. */
	_findPos: function(obj) {
		var position,
			inst = this._getInst(obj),
			isRTL = this._get(inst, "isRTL");

		while (obj && (obj.type === "hidden" || obj.nodeType !== 1 || $.expr.filters.hidden(obj))) {
			obj = obj[isRTL ? "previousSibling" : "nextSibling"];
		}

		position = $(obj).offset();
		return [position.left, position.top];
	},

	/* Hide the date picker from view.
	 * @param  input  element - the input field attached to the date picker
	 */
	_hideDatepicker: function(input) {
		var showAnim, duration, postProcess, onClose,
			inst = this._curInst;

		if (!inst || (input && inst !== $.data(input, "datepicker"))) {
			return;
		}

		if (this._datepickerShowing) {
			showAnim = this._get(inst, "showAnim");
			duration = this._get(inst, "duration");
			postProcess = function() {
				$.datepicker._tidyDialog(inst);
			};

			// DEPRECATED: after BC for 1.8.x $.effects[ showAnim ] is not needed
			if ( $.effects && ( $.effects.effect[ showAnim ] || $.effects[ showAnim ] ) ) {
				inst.dpDiv.hide(showAnim, $.datepicker._get(inst, "showOptions"), duration, postProcess);
			} else {
				inst.dpDiv[(showAnim === "slideDown" ? "slideUp" :
					(showAnim === "fadeIn" ? "fadeOut" : "hide"))]((showAnim ? duration : null), postProcess);
			}

			if (!showAnim) {
				postProcess();
			}
			this._datepickerShowing = false;

			onClose = this._get(inst, "onClose");
			if (onClose) {
				onClose.apply((inst.input ? inst.input[0] : null), [(inst.input ? inst.input.val() : ""), inst]);
			}

			this._lastInput = null;
			if (this._inDialog) {
				this._dialogInput.css({ position: "absolute", left: "0", top: "-100px" });
				if ($.blockUI) {
					$.unblockUI();
					$("body").append(this.dpDiv);
				}
			}
			this._inDialog = false;
		}
	},

	/* Tidy up after a dialog display. */
	_tidyDialog: function(inst) {
		inst.dpDiv.removeClass(this._dialogClass).unbind(".ui-datepicker-calendar");
	},

	/* Close date picker if clicked elsewhere. */
	_checkExternalClick: function(event) {
		if (!$.datepicker._curInst) {
			return;
		}

		var $target = $(event.target),
			inst = $.datepicker._getInst($target[0]);

		if ( ( ( $target[0].id !== $.datepicker._mainDivId &&
				$target.parents("#" + $.datepicker._mainDivId).length === 0 &&
				!$target.hasClass($.datepicker.markerClassName) &&
				!$target.closest("." + $.datepicker._triggerClass).length &&
				$.datepicker._datepickerShowing && !($.datepicker._inDialog && $.blockUI) ) ) ||
			( $target.hasClass($.datepicker.markerClassName) && $.datepicker._curInst !== inst ) ) {
				$.datepicker._hideDatepicker();
		}
	},

	/* Adjust one of the date sub-fields. */
	_adjustDate: function(id, offset, period) {
		var target = $(id),
			inst = this._getInst(target[0]);

		if (this._isDisabledDatepicker(target[0])) {
			return;
		}
		this._adjustInstDate(inst, offset +
			(period === "M" ? this._get(inst, "showCurrentAtPos") : 0), // undo positioning
			period);
		this._updateDatepicker(inst);
	},

	/* Action for current link. */
	_gotoToday: function(id) {
		var date,
			target = $(id),
			inst = this._getInst(target[0]);

		if (this._get(inst, "gotoCurrent") && inst.currentDay) {
			inst.selectedDay = inst.currentDay;
			inst.drawMonth = inst.selectedMonth = inst.currentMonth;
			inst.drawYear = inst.selectedYear = inst.currentYear;
		} else {
			date = new Date();
			inst.selectedDay = date.getDate();
			inst.drawMonth = inst.selectedMonth = date.getMonth();
			inst.drawYear = inst.selectedYear = date.getFullYear();
		}
		this._notifyChange(inst);
		this._adjustDate(target);
	},

	/* Action for selecting a new month/year. */
	_selectMonthYear: function(id, select, period) {
		var target = $(id),
			inst = this._getInst(target[0]);

		inst["selected" + (period === "M" ? "Month" : "Year")] =
		inst["draw" + (period === "M" ? "Month" : "Year")] =
			parseInt(select.options[select.selectedIndex].value,10);

		this._notifyChange(inst);
		this._adjustDate(target);
	},

	/* Action for selecting a day. */
	_selectDay: function(id, month, year, td) {
		var inst,
			target = $(id);

		if ($(td).hasClass(this._unselectableClass) || this._isDisabledDatepicker(target[0])) {
			return;
		}

		inst = this._getInst(target[0]);
		inst.selectedDay = inst.currentDay = $("a", td).html();
		inst.selectedMonth = inst.currentMonth = month;
		inst.selectedYear = inst.currentYear = year;
		this._selectDate(id, this._formatDate(inst,
			inst.currentDay, inst.currentMonth, inst.currentYear));
	},

	/* Erase the input field and hide the date picker. */
	_clearDate: function(id) {
		var target = $(id);
		this._selectDate(target, "");
	},

	/* Update the input field with the selected date. */
	_selectDate: function(id, dateStr) {
		var onSelect,
			target = $(id),
			inst = this._getInst(target[0]);

		dateStr = (dateStr != null ? dateStr : this._formatDate(inst));
		if (inst.input) {
			inst.input.val(dateStr);
		}
		this._updateAlternate(inst);

		onSelect = this._get(inst, "onSelect");
		if (onSelect) {
			onSelect.apply((inst.input ? inst.input[0] : null), [dateStr, inst]);  // trigger custom callback
		} else if (inst.input) {
			inst.input.trigger("change"); // fire the change event
		}

		if (inst.inline){
			this._updateDatepicker(inst);
		} else {
			this._hideDatepicker();
			this._lastInput = inst.input[0];
			if (typeof(inst.input[0]) !== "object") {
				inst.input.focus(); // restore focus
			}
			this._lastInput = null;
		}
	},

	/* Update any alternate field to synchronise with the main field. */
	_updateAlternate: function(inst) {
		var altFormat, date, dateStr,
			altField = this._get(inst, "altField");

		if (altField) { // update alternate field too
			altFormat = this._get(inst, "altFormat") || this._get(inst, "dateFormat");
			date = this._getDate(inst);
			dateStr = this.formatDate(altFormat, date, this._getFormatConfig(inst));
			$(altField).each(function() { $(this).val(dateStr); });
		}
	},

	/* Set as beforeShowDay function to prevent selection of weekends.
	 * @param  date  Date - the date to customise
	 * @return [boolean, string] - is this date selectable?, what is its CSS class?
	 */
	noWeekends: function(date) {
		var day = date.getDay();
		return [(day > 0 && day < 6), ""];
	},

	/* Set as calculateWeek to determine the week of the year based on the ISO 8601 definition.
	 * @param  date  Date - the date to get the week for
	 * @return  number - the number of the week within the year that contains this date
	 */
	iso8601Week: function(date) {
		var time,
			checkDate = new Date(date.getTime());

		// Find Thursday of this week starting on Monday
		checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7));

		time = checkDate.getTime();
		checkDate.setMonth(0); // Compare with Jan 1
		checkDate.setDate(1);
		return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;
	},

	/* Parse a string value into a date object.
	 * See formatDate below for the possible formats.
	 *
	 * @param  format string - the expected format of the date
	 * @param  value string - the date in the above format
	 * @param  settings Object - attributes include:
	 *					shortYearCutoff  number - the cutoff year for determining the century (optional)
	 *					dayNamesShort	string[7] - abbreviated names of the days from Sunday (optional)
	 *					dayNames		string[7] - names of the days from Sunday (optional)
	 *					monthNamesShort string[12] - abbreviated names of the months (optional)
	 *					monthNames		string[12] - names of the months (optional)
	 * @return  Date - the extracted date value or null if value is blank
	 */
	parseDate: function (format, value, settings) {
		if (format == null || value == null) {
			throw "Invalid arguments";
		}

		value = (typeof value === "object" ? value.toString() : value + "");
		if (value === "") {
			return null;
		}

		var iFormat, dim, extra,
			iValue = 0,
			shortYearCutoffTemp = (settings ? settings.shortYearCutoff : null) || this._defaults.shortYearCutoff,
			shortYearCutoff = (typeof shortYearCutoffTemp !== "string" ? shortYearCutoffTemp :
				new Date().getFullYear() % 100 + parseInt(shortYearCutoffTemp, 10)),
			dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort,
			dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames,
			monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort,
			monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames,
			year = -1,
			month = -1,
			day = -1,
			doy = -1,
			literal = false,
			date,
			// Check whether a format character is doubled
			lookAhead = function(match) {
				var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) === match);
				if (matches) {
					iFormat++;
				}
				return matches;
			},
			// Extract a number from the string value
			getNumber = function(match) {
				var isDoubled = lookAhead(match),
					size = (match === "@" ? 14 : (match === "!" ? 20 :
					(match === "y" && isDoubled ? 4 : (match === "o" ? 3 : 2)))),
					minSize = (match === "y" ? size : 1),
					digits = new RegExp("^\\d{" + minSize + "," + size + "}"),
					num = value.substring(iValue).match(digits);
				if (!num) {
					throw "Missing number at position " + iValue;
				}
				iValue += num[0].length;
				return parseInt(num[0], 10);
			},
			// Extract a name from the string value and convert to an index
			getName = function(match, shortNames, longNames) {
				var index = -1,
					names = $.map(lookAhead(match) ? longNames : shortNames, function (v, k) {
						return [ [k, v] ];
					}).sort(function (a, b) {
						return -(a[1].length - b[1].length);
					});

				$.each(names, function (i, pair) {
					var name = pair[1];
					if (value.substr(iValue, name.length).toLowerCase() === name.toLowerCase()) {
						index = pair[0];
						iValue += name.length;
						return false;
					}
				});
				if (index !== -1) {
					return index + 1;
				} else {
					throw "Unknown name at position " + iValue;
				}
			},
			// Confirm that a literal character matches the string value
			checkLiteral = function() {
				if (value.charAt(iValue) !== format.charAt(iFormat)) {
					throw "Unexpected literal at position " + iValue;
				}
				iValue++;
			};

		for (iFormat = 0; iFormat < format.length; iFormat++) {
			if (literal) {
				if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
					literal = false;
				} else {
					checkLiteral();
				}
			} else {
				switch (format.charAt(iFormat)) {
					case "d":
						day = getNumber("d");
						break;
					case "D":
						getName("D", dayNamesShort, dayNames);
						break;
					case "o":
						doy = getNumber("o");
						break;
					case "m":
						month = getNumber("m");
						break;
					case "M":
						month = getName("M", monthNamesShort, monthNames);
						break;
					case "y":
						year = getNumber("y");
						break;
					case "@":
						date = new Date(getNumber("@"));
						year = date.getFullYear();
						month = date.getMonth() + 1;
						day = date.getDate();
						break;
					case "!":
						date = new Date((getNumber("!") - this._ticksTo1970) / 10000);
						year = date.getFullYear();
						month = date.getMonth() + 1;
						day = date.getDate();
						break;
					case "'":
						if (lookAhead("'")){
							checkLiteral();
						} else {
							literal = true;
						}
						break;
					default:
						checkLiteral();
				}
			}
		}

		if (iValue < value.length){
			extra = value.substr(iValue);
			if (!/^\s+/.test(extra)) {
				throw "Extra/unparsed characters found in date: " + extra;
			}
		}

		if (year === -1) {
			year = new Date().getFullYear();
		} else if (year < 100) {
			year += new Date().getFullYear() - new Date().getFullYear() % 100 +
				(year <= shortYearCutoff ? 0 : -100);
		}

		if (doy > -1) {
			month = 1;
			day = doy;
			do {
				dim = this._getDaysInMonth(year, month - 1);
				if (day <= dim) {
					break;
				}
				month++;
				day -= dim;
			} while (true);
		}

		date = this._daylightSavingAdjust(new Date(year, month - 1, day));
		if (date.getFullYear() !== year || date.getMonth() + 1 !== month || date.getDate() !== day) {
			throw "Invalid date"; // E.g. 31/02/00
		}
		return date;
	},

	/* Standard date formats. */
	ATOM: "yy-mm-dd", // RFC 3339 (ISO 8601)
	COOKIE: "D, dd M yy",
	ISO_8601: "yy-mm-dd",
	RFC_822: "D, d M y",
	RFC_850: "DD, dd-M-y",
	RFC_1036: "D, d M y",
	RFC_1123: "D, d M yy",
	RFC_2822: "D, d M yy",
	RSS: "D, d M y", // RFC 822
	TICKS: "!",
	TIMESTAMP: "@",
	W3C: "yy-mm-dd", // ISO 8601

	_ticksTo1970: (((1970 - 1) * 365 + Math.floor(1970 / 4) - Math.floor(1970 / 100) +
		Math.floor(1970 / 400)) * 24 * 60 * 60 * 10000000),

	/* Format a date object into a string value.
	 * The format can be combinations of the following:
	 * d  - day of month (no leading zero)
	 * dd - day of month (two digit)
	 * o  - day of year (no leading zeros)
	 * oo - day of year (three digit)
	 * D  - day name short
	 * DD - day name long
	 * m  - month of year (no leading zero)
	 * mm - month of year (two digit)
	 * M  - month name short
	 * MM - month name long
	 * y  - year (two digit)
	 * yy - year (four digit)
	 * @ - Unix timestamp (ms since 01/01/1970)
	 * ! - Windows ticks (100ns since 01/01/0001)
	 * "..." - literal text
	 * '' - single quote
	 *
	 * @param  format string - the desired format of the date
	 * @param  date Date - the date value to format
	 * @param  settings Object - attributes include:
	 *					dayNamesShort	string[7] - abbreviated names of the days from Sunday (optional)
	 *					dayNames		string[7] - names of the days from Sunday (optional)
	 *					monthNamesShort string[12] - abbreviated names of the months (optional)
	 *					monthNames		string[12] - names of the months (optional)
	 * @return  string - the date in the above format
	 */
	formatDate: function (format, date, settings) {
		if (!date) {
			return "";
		}

		var iFormat,
			dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort,
			dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames,
			monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort,
			monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames,
			// Check whether a format character is doubled
			lookAhead = function(match) {
				var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) === match);
				if (matches) {
					iFormat++;
				}
				return matches;
			},
			// Format a number, with leading zero if necessary
			formatNumber = function(match, value, len) {
				var num = "" + value;
				if (lookAhead(match)) {
					while (num.length < len) {
						num = "0" + num;
					}
				}
				return num;
			},
			// Format a name, short or long as requested
			formatName = function(match, value, shortNames, longNames) {
				return (lookAhead(match) ? longNames[value] : shortNames[value]);
			},
			output = "",
			literal = false;

		if (date) {
			for (iFormat = 0; iFormat < format.length; iFormat++) {
				if (literal) {
					if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
						literal = false;
					} else {
						output += format.charAt(iFormat);
					}
				} else {
					switch (format.charAt(iFormat)) {
						case "d":
							output += formatNumber("d", date.getDate(), 2);
							break;
						case "D":
							output += formatName("D", date.getDay(), dayNamesShort, dayNames);
							break;
						case "o":
							output += formatNumber("o",
								Math.round((new Date(date.getFullYear(), date.getMonth(), date.getDate()).getTime() - new Date(date.getFullYear(), 0, 0).getTime()) / 86400000), 3);
							break;
						case "m":
							output += formatNumber("m", date.getMonth() + 1, 2);
							break;
						case "M":
							output += formatName("M", date.getMonth(), monthNamesShort, monthNames);
							break;
						case "y":
							output += (lookAhead("y") ? date.getFullYear() :
								(date.getYear() % 100 < 10 ? "0" : "") + date.getYear() % 100);
							break;
						case "@":
							output += date.getTime();
							break;
						case "!":
							output += date.getTime() * 10000 + this._ticksTo1970;
							break;
						case "'":
							if (lookAhead("'")) {
								output += "'";
							} else {
								literal = true;
							}
							break;
						default:
							output += format.charAt(iFormat);
					}
				}
			}
		}
		return output;
	},

	/* Extract all possible characters from the date format. */
	_possibleChars: function (format) {
		var iFormat,
			chars = "",
			literal = false,
			// Check whether a format character is doubled
			lookAhead = function(match) {
				var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) === match);
				if (matches) {
					iFormat++;
				}
				return matches;
			};

		for (iFormat = 0; iFormat < format.length; iFormat++) {
			if (literal) {
				if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
					literal = false;
				} else {
					chars += format.charAt(iFormat);
				}
			} else {
				switch (format.charAt(iFormat)) {
					case "d": case "m": case "y": case "@":
						chars += "0123456789";
						break;
					case "D": case "M":
						return null; // Accept anything
					case "'":
						if (lookAhead("'")) {
							chars += "'";
						} else {
							literal = true;
						}
						break;
					default:
						chars += format.charAt(iFormat);
				}
			}
		}
		return chars;
	},

	/* Get a setting value, defaulting if necessary. */
	_get: function(inst, name) {
		return inst.settings[name] !== undefined ?
			inst.settings[name] : this._defaults[name];
	},

	/* Parse existing date and initialise date picker. */
	_setDateFromField: function(inst, noDefault) {
		if (inst.input.val() === inst.lastVal) {
			return;
		}

		var dateFormat = this._get(inst, "dateFormat"),
			dates = inst.lastVal = inst.input ? inst.input.val() : null,
			defaultDate = this._getDefaultDate(inst),
			date = defaultDate,
			settings = this._getFormatConfig(inst);

		try {
			date = this.parseDate(dateFormat, dates, settings) || defaultDate;
		} catch (event) {
			dates = (noDefault ? "" : dates);
		}
		inst.selectedDay = date.getDate();
		inst.drawMonth = inst.selectedMonth = date.getMonth();
		inst.drawYear = inst.selectedYear = date.getFullYear();
		inst.currentDay = (dates ? date.getDate() : 0);
		inst.currentMonth = (dates ? date.getMonth() : 0);
		inst.currentYear = (dates ? date.getFullYear() : 0);
		this._adjustInstDate(inst);
	},

	/* Retrieve the default date shown on opening. */
	_getDefaultDate: function(inst) {
		return this._restrictMinMax(inst,
			this._determineDate(inst, this._get(inst, "defaultDate"), new Date()));
	},

	/* A date may be specified as an exact value or a relative one. */
	_determineDate: function(inst, date, defaultDate) {
		var offsetNumeric = function(offset) {
				var date = new Date();
				date.setDate(date.getDate() + offset);
				return date;
			},
			offsetString = function(offset) {
				try {
					return $.datepicker.parseDate($.datepicker._get(inst, "dateFormat"),
						offset, $.datepicker._getFormatConfig(inst));
				}
				catch (e) {
					// Ignore
				}

				var date = (offset.toLowerCase().match(/^c/) ?
					$.datepicker._getDate(inst) : null) || new Date(),
					year = date.getFullYear(),
					month = date.getMonth(),
					day = date.getDate(),
					pattern = /([+\-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g,
					matches = pattern.exec(offset);

				while (matches) {
					switch (matches[2] || "d") {
						case "d" : case "D" :
							day += parseInt(matches[1],10); break;
						case "w" : case "W" :
							day += parseInt(matches[1],10) * 7; break;
						case "m" : case "M" :
							month += parseInt(matches[1],10);
							day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
							break;
						case "y": case "Y" :
							year += parseInt(matches[1],10);
							day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
							break;
					}
					matches = pattern.exec(offset);
				}
				return new Date(year, month, day);
			},
			newDate = (date == null || date === "" ? defaultDate : (typeof date === "string" ? offsetString(date) :
				(typeof date === "number" ? (isNaN(date) ? defaultDate : offsetNumeric(date)) : new Date(date.getTime()))));

		newDate = (newDate && newDate.toString() === "Invalid Date" ? defaultDate : newDate);
		if (newDate) {
			newDate.setHours(0);
			newDate.setMinutes(0);
			newDate.setSeconds(0);
			newDate.setMilliseconds(0);
		}
		return this._daylightSavingAdjust(newDate);
	},

	/* Handle switch to/from daylight saving.
	 * Hours may be non-zero on daylight saving cut-over:
	 * > 12 when midnight changeover, but then cannot generate
	 * midnight datetime, so jump to 1AM, otherwise reset.
	 * @param  date  (Date) the date to check
	 * @return  (Date) the corrected date
	 */
	_daylightSavingAdjust: function(date) {
		if (!date) {
			return null;
		}
		date.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0);
		return date;
	},

	/* Set the date(s) directly. */
	_setDate: function(inst, date, noChange) {
		var clear = !date,
			origMonth = inst.selectedMonth,
			origYear = inst.selectedYear,
			newDate = this._restrictMinMax(inst, this._determineDate(inst, date, new Date()));

		inst.selectedDay = inst.currentDay = newDate.getDate();
		inst.drawMonth = inst.selectedMonth = inst.currentMonth = newDate.getMonth();
		inst.drawYear = inst.selectedYear = inst.currentYear = newDate.getFullYear();
		if ((origMonth !== inst.selectedMonth || origYear !== inst.selectedYear) && !noChange) {
			this._notifyChange(inst);
		}
		this._adjustInstDate(inst);
		if (inst.input) {
			inst.input.val(clear ? "" : this._formatDate(inst));
		}
	},

	/* Retrieve the date(s) directly. */
	_getDate: function(inst) {
		var startDate = (!inst.currentYear || (inst.input && inst.input.val() === "") ? null :
			this._daylightSavingAdjust(new Date(
			inst.currentYear, inst.currentMonth, inst.currentDay)));
			return startDate;
	},

	/* Attach the onxxx handlers.  These are declared statically so
	 * they work with static code transformers like Caja.
	 */
	_attachHandlers: function(inst) {
		var stepMonths = this._get(inst, "stepMonths"),
			id = "#" + inst.id.replace( /\\\\/g, "\\" );
		inst.dpDiv.find("[data-handler]").map(function () {
			var handler = {
				prev: function () {
					$.datepicker._adjustDate(id, -stepMonths, "M");
				},
				next: function () {
					$.datepicker._adjustDate(id, +stepMonths, "M");
				},
				hide: function () {
					$.datepicker._hideDatepicker();
				},
				today: function () {
					$.datepicker._gotoToday(id);
				},
				selectDay: function () {
					$.datepicker._selectDay(id, +this.getAttribute("data-month"), +this.getAttribute("data-year"), this);
					return false;
				},
				selectMonth: function () {
					$.datepicker._selectMonthYear(id, this, "M");
					return false;
				},
				selectYear: function () {
					$.datepicker._selectMonthYear(id, this, "Y");
					return false;
				}
			};
			$(this).bind(this.getAttribute("data-event"), handler[this.getAttribute("data-handler")]);
		});
	},

	/* Generate the HTML for the current state of the date picker. */
	_generateHTML: function(inst) {
		var maxDraw, prevText, prev, nextText, next, currentText, gotoDate,
			controls, buttonPanel, firstDay, showWeek, dayNames, dayNamesMin,
			monthNames, monthNamesShort, beforeShowDay, showOtherMonths,
			selectOtherMonths, defaultDate, html, dow, row, group, col, selectedDate,
			cornerClass, calender, thead, day, daysInMonth, leadDays, curRows, numRows,
			printDate, dRow, tbody, daySettings, otherMonth, unselectable,
			tempDate = new Date(),
			today = this._daylightSavingAdjust(
				new Date(tempDate.getFullYear(), tempDate.getMonth(), tempDate.getDate())), // clear time
			isRTL = this._get(inst, "isRTL"),
			showButtonPanel = this._get(inst, "showButtonPanel"),
			hideIfNoPrevNext = this._get(inst, "hideIfNoPrevNext"),
			navigationAsDateFormat = this._get(inst, "navigationAsDateFormat"),
			numMonths = this._getNumberOfMonths(inst),
			showCurrentAtPos = this._get(inst, "showCurrentAtPos"),
			stepMonths = this._get(inst, "stepMonths"),
			isMultiMonth = (numMonths[0] !== 1 || numMonths[1] !== 1),
			currentDate = this._daylightSavingAdjust((!inst.currentDay ? new Date(9999, 9, 9) :
				new Date(inst.currentYear, inst.currentMonth, inst.currentDay))),
			minDate = this._getMinMaxDate(inst, "min"),
			maxDate = this._getMinMaxDate(inst, "max"),
			drawMonth = inst.drawMonth - showCurrentAtPos,
			drawYear = inst.drawYear;

		if (drawMonth < 0) {
			drawMonth += 12;
			drawYear--;
		}
		if (maxDate) {
			maxDraw = this._daylightSavingAdjust(new Date(maxDate.getFullYear(),
				maxDate.getMonth() - (numMonths[0] * numMonths[1]) + 1, maxDate.getDate()));
			maxDraw = (minDate && maxDraw < minDate ? minDate : maxDraw);
			while (this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1)) > maxDraw) {
				drawMonth--;
				if (drawMonth < 0) {
					drawMonth = 11;
					drawYear--;
				}
			}
		}
		inst.drawMonth = drawMonth;
		inst.drawYear = drawYear;

		prevText = this._get(inst, "prevText");
		prevText = (!navigationAsDateFormat ? prevText : this.formatDate(prevText,
			this._daylightSavingAdjust(new Date(drawYear, drawMonth - stepMonths, 1)),
			this._getFormatConfig(inst)));

		prev = (this._canAdjustMonth(inst, -1, drawYear, drawMonth) ?
			"<a class='ui-datepicker-prev ui-corner-all' data-handler='prev' data-event='click'" +
			" title='" + prevText + "'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "e" : "w") + "'>" + prevText + "</span></a>" :
			(hideIfNoPrevNext ? "" : "<a class='ui-datepicker-prev ui-corner-all ui-state-disabled' title='"+ prevText +"'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "e" : "w") + "'>" + prevText + "</span></a>"));

		nextText = this._get(inst, "nextText");
		nextText = (!navigationAsDateFormat ? nextText : this.formatDate(nextText,
			this._daylightSavingAdjust(new Date(drawYear, drawMonth + stepMonths, 1)),
			this._getFormatConfig(inst)));

		next = (this._canAdjustMonth(inst, +1, drawYear, drawMonth) ?
			"<a class='ui-datepicker-next ui-corner-all' data-handler='next' data-event='click'" +
			" title='" + nextText + "'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "w" : "e") + "'>" + nextText + "</span></a>" :
			(hideIfNoPrevNext ? "" : "<a class='ui-datepicker-next ui-corner-all ui-state-disabled' title='"+ nextText + "'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "w" : "e") + "'>" + nextText + "</span></a>"));

		currentText = this._get(inst, "currentText");
		gotoDate = (this._get(inst, "gotoCurrent") && inst.currentDay ? currentDate : today);
		currentText = (!navigationAsDateFormat ? currentText :
			this.formatDate(currentText, gotoDate, this._getFormatConfig(inst)));

		controls = (!inst.inline ? "<button type='button' class='ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all' data-handler='hide' data-event='click'>" +
			this._get(inst, "closeText") + "</button>" : "");

		buttonPanel = (showButtonPanel) ? "<div class='ui-datepicker-buttonpane ui-widget-content'>" + (isRTL ? controls : "") +
			(this._isInRange(inst, gotoDate) ? "<button type='button' class='ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all' data-handler='today' data-event='click'" +
			">" + currentText + "</button>" : "") + (isRTL ? "" : controls) + "</div>" : "";

		firstDay = parseInt(this._get(inst, "firstDay"),10);
		firstDay = (isNaN(firstDay) ? 0 : firstDay);

		showWeek = this._get(inst, "showWeek");
		dayNames = this._get(inst, "dayNames");
		dayNamesMin = this._get(inst, "dayNamesMin");
		monthNames = this._get(inst, "monthNames");
		monthNamesShort = this._get(inst, "monthNamesShort");
		beforeShowDay = this._get(inst, "beforeShowDay");
		showOtherMonths = this._get(inst, "showOtherMonths");
		selectOtherMonths = this._get(inst, "selectOtherMonths");
		defaultDate = this._getDefaultDate(inst);
		html = "";
		dow;
		for (row = 0; row < numMonths[0]; row++) {
			group = "";
			this.maxRows = 4;
			for (col = 0; col < numMonths[1]; col++) {
				selectedDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, inst.selectedDay));
				cornerClass = " ui-corner-all";
				calender = "";
				if (isMultiMonth) {
					calender += "<div class='ui-datepicker-group";
					if (numMonths[1] > 1) {
						switch (col) {
							case 0: calender += " ui-datepicker-group-first";
								cornerClass = " ui-corner-" + (isRTL ? "right" : "left"); break;
							case numMonths[1]-1: calender += " ui-datepicker-group-last";
								cornerClass = " ui-corner-" + (isRTL ? "left" : "right"); break;
							default: calender += " ui-datepicker-group-middle"; cornerClass = ""; break;
						}
					}
					calender += "'>";
				}
				calender += "<div class='ui-datepicker-header ui-widget-header ui-helper-clearfix" + cornerClass + "'>" +
					(/all|left/.test(cornerClass) && row === 0 ? (isRTL ? next : prev) : "") +
					(/all|right/.test(cornerClass) && row === 0 ? (isRTL ? prev : next) : "") +
					this._generateMonthYearHeader(inst, drawMonth, drawYear, minDate, maxDate,
					row > 0 || col > 0, monthNames, monthNamesShort) + // draw month headers
					"</div><table class='ui-datepicker-calendar'><thead>" +
					"<tr>";
				thead = (showWeek ? "<th class='ui-datepicker-week-col'>" + this._get(inst, "weekHeader") + "</th>" : "");
				for (dow = 0; dow < 7; dow++) { // days of the week
					day = (dow + firstDay) % 7;
					thead += "<th scope='col'" + ((dow + firstDay + 6) % 7 >= 5 ? " class='ui-datepicker-week-end'" : "") + ">" +
						"<span title='" + dayNames[day] + "'>" + dayNamesMin[day] + "</span></th>";
				}
				calender += thead + "</tr></thead><tbody>";
				daysInMonth = this._getDaysInMonth(drawYear, drawMonth);
				if (drawYear === inst.selectedYear && drawMonth === inst.selectedMonth) {
					inst.selectedDay = Math.min(inst.selectedDay, daysInMonth);
				}
				leadDays = (this._getFirstDayOfMonth(drawYear, drawMonth) - firstDay + 7) % 7;
				curRows = Math.ceil((leadDays + daysInMonth) / 7); // calculate the number of rows to generate
				numRows = (isMultiMonth ? this.maxRows > curRows ? this.maxRows : curRows : curRows); //If multiple months, use the higher number of rows (see #7043)
				this.maxRows = numRows;
				printDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1 - leadDays));
				for (dRow = 0; dRow < numRows; dRow++) { // create date picker rows
					calender += "<tr>";
					tbody = (!showWeek ? "" : "<td class='ui-datepicker-week-col'>" +
						this._get(inst, "calculateWeek")(printDate) + "</td>");
					for (dow = 0; dow < 7; dow++) { // create date picker days
						daySettings = (beforeShowDay ?
							beforeShowDay.apply((inst.input ? inst.input[0] : null), [printDate]) : [true, ""]);
						otherMonth = (printDate.getMonth() !== drawMonth);
						unselectable = (otherMonth && !selectOtherMonths) || !daySettings[0] ||
							(minDate && printDate < minDate) || (maxDate && printDate > maxDate);
						tbody += "<td class='" +
							((dow + firstDay + 6) % 7 >= 5 ? " ui-datepicker-week-end" : "") + // highlight weekends
							(otherMonth ? " ui-datepicker-other-month" : "") + // highlight days from other months
							((printDate.getTime() === selectedDate.getTime() && drawMonth === inst.selectedMonth && inst._keyEvent) || // user pressed key
							(defaultDate.getTime() === printDate.getTime() && defaultDate.getTime() === selectedDate.getTime()) ?
							// or defaultDate is current printedDate and defaultDate is selectedDate
							" " + this._dayOverClass : "") + // highlight selected day
							(unselectable ? " " + this._unselectableClass + " ui-state-disabled": "") +  // highlight unselectable days
							(otherMonth && !showOtherMonths ? "" : " " + daySettings[1] + // highlight custom dates
							(printDate.getTime() === currentDate.getTime() ? " " + this._currentClass : "") + // highlight selected day
							(printDate.getTime() === today.getTime() ? " ui-datepicker-today" : "")) + "'" + // highlight today (if different)
							((!otherMonth || showOtherMonths) && daySettings[2] ? " title='" + daySettings[2].replace(/'/g, "&#39;") + "'" : "") + // cell title
							(unselectable ? "" : " data-handler='selectDay' data-event='click' data-month='" + printDate.getMonth() + "' data-year='" + printDate.getFullYear() + "'") + ">" + // actions
							(otherMonth && !showOtherMonths ? "&#xa0;" : // display for other months
							(unselectable ? "<span class='ui-state-default'>" + printDate.getDate() + "</span>" : "<a class='ui-state-default" +
							(printDate.getTime() === today.getTime() ? " ui-state-highlight" : "") +
							(printDate.getTime() === currentDate.getTime() ? " ui-state-active" : "") + // highlight selected day
							(otherMonth ? " ui-priority-secondary" : "") + // distinguish dates from other months
							"' href='#'>" + printDate.getDate() + "</a>")) + "</td>"; // display selectable date
						printDate.setDate(printDate.getDate() + 1);
						printDate = this._daylightSavingAdjust(printDate);
					}
					calender += tbody + "</tr>";
				}
				drawMonth++;
				if (drawMonth > 11) {
					drawMonth = 0;
					drawYear++;
				}
				calender += "</tbody></table>" + (isMultiMonth ? "</div>" +
							((numMonths[0] > 0 && col === numMonths[1]-1) ? "<div class='ui-datepicker-row-break'></div>" : "") : "");
				group += calender;
			}
			html += group;
		}
		html += buttonPanel;
		inst._keyEvent = false;
		return html;
	},

	/* Generate the month and year header. */
	_generateMonthYearHeader: function(inst, drawMonth, drawYear, minDate, maxDate,
			secondary, monthNames, monthNamesShort) {

		var inMinYear, inMaxYear, month, years, thisYear, determineYear, year, endYear,
			changeMonth = this._get(inst, "changeMonth"),
			changeYear = this._get(inst, "changeYear"),
			showMonthAfterYear = this._get(inst, "showMonthAfterYear"),
			html = "<div class='ui-datepicker-title'>",
			monthHtml = "";

		// month selection
		if (secondary || !changeMonth) {
			monthHtml += "<span class='ui-datepicker-month'>" + monthNames[drawMonth] + "</span>";
		} else {
			inMinYear = (minDate && minDate.getFullYear() === drawYear);
			inMaxYear = (maxDate && maxDate.getFullYear() === drawYear);
			monthHtml += "<select class='ui-datepicker-month' data-handler='selectMonth' data-event='change'>";
			for ( month = 0; month < 12; month++) {
				if ((!inMinYear || month >= minDate.getMonth()) && (!inMaxYear || month <= maxDate.getMonth())) {
					monthHtml += "<option value='" + month + "'" +
						(month === drawMonth ? " selected='selected'" : "") +
						">" + monthNamesShort[month] + "</option>";
				}
			}
			monthHtml += "</select>";
		}

		if (!showMonthAfterYear) {
			html += monthHtml + (secondary || !(changeMonth && changeYear) ? "&#xa0;" : "");
		}

		// year selection
		if ( !inst.yearshtml ) {
			inst.yearshtml = "";
			if (secondary || !changeYear) {
				html += "<span class='ui-datepicker-year'>" + drawYear + "</span>";
			} else {
				// determine range of years to display
				years = this._get(inst, "yearRange").split(":");
				thisYear = new Date().getFullYear();
				determineYear = function(value) {
					var year = (value.match(/c[+\-].*/) ? drawYear + parseInt(value.substring(1), 10) :
						(value.match(/[+\-].*/) ? thisYear + parseInt(value, 10) :
						parseInt(value, 10)));
					return (isNaN(year) ? thisYear : year);
				};
				year = determineYear(years[0]);
				endYear = Math.max(year, determineYear(years[1] || ""));
				year = (minDate ? Math.max(year, minDate.getFullYear()) : year);
				endYear = (maxDate ? Math.min(endYear, maxDate.getFullYear()) : endYear);
				inst.yearshtml += "<select class='ui-datepicker-year' data-handler='selectYear' data-event='change'>";
				for (; year <= endYear; year++) {
					inst.yearshtml += "<option value='" + year + "'" +
						(year === drawYear ? " selected='selected'" : "") +
						">" + year + "</option>";
				}
				inst.yearshtml += "</select>";

				html += inst.yearshtml;
				inst.yearshtml = null;
			}
		}

		html += this._get(inst, "yearSuffix");
		if (showMonthAfterYear) {
			html += (secondary || !(changeMonth && changeYear) ? "&#xa0;" : "") + monthHtml;
		}
		html += "</div>"; // Close datepicker_header
		return html;
	},

	/* Adjust one of the date sub-fields. */
	_adjustInstDate: function(inst, offset, period) {
		var year = inst.drawYear + (period === "Y" ? offset : 0),
			month = inst.drawMonth + (period === "M" ? offset : 0),
			day = Math.min(inst.selectedDay, this._getDaysInMonth(year, month)) + (period === "D" ? offset : 0),
			date = this._restrictMinMax(inst, this._daylightSavingAdjust(new Date(year, month, day)));

		inst.selectedDay = date.getDate();
		inst.drawMonth = inst.selectedMonth = date.getMonth();
		inst.drawYear = inst.selectedYear = date.getFullYear();
		if (period === "M" || period === "Y") {
			this._notifyChange(inst);
		}
	},

	/* Ensure a date is within any min/max bounds. */
	_restrictMinMax: function(inst, date) {
		var minDate = this._getMinMaxDate(inst, "min"),
			maxDate = this._getMinMaxDate(inst, "max"),
			newDate = (minDate && date < minDate ? minDate : date);
		return (maxDate && newDate > maxDate ? maxDate : newDate);
	},

	/* Notify change of month/year. */
	_notifyChange: function(inst) {
		var onChange = this._get(inst, "onChangeMonthYear");
		if (onChange) {
			onChange.apply((inst.input ? inst.input[0] : null),
				[inst.selectedYear, inst.selectedMonth + 1, inst]);
		}
	},

	/* Determine the number of months to show. */
	_getNumberOfMonths: function(inst) {
		var numMonths = this._get(inst, "numberOfMonths");
		return (numMonths == null ? [1, 1] : (typeof numMonths === "number" ? [1, numMonths] : numMonths));
	},

	/* Determine the current maximum date - ensure no time components are set. */
	_getMinMaxDate: function(inst, minMax) {
		return this._determineDate(inst, this._get(inst, minMax + "Date"), null);
	},

	/* Find the number of days in a given month. */
	_getDaysInMonth: function(year, month) {
		return 32 - this._daylightSavingAdjust(new Date(year, month, 32)).getDate();
	},

	/* Find the day of the week of the first of a month. */
	_getFirstDayOfMonth: function(year, month) {
		return new Date(year, month, 1).getDay();
	},

	/* Determines if we should allow a "next/prev" month display change. */
	_canAdjustMonth: function(inst, offset, curYear, curMonth) {
		var numMonths = this._getNumberOfMonths(inst),
			date = this._daylightSavingAdjust(new Date(curYear,
			curMonth + (offset < 0 ? offset : numMonths[0] * numMonths[1]), 1));

		if (offset < 0) {
			date.setDate(this._getDaysInMonth(date.getFullYear(), date.getMonth()));
		}
		return this._isInRange(inst, date);
	},

	/* Is the given date in the accepted range? */
	_isInRange: function(inst, date) {
		var yearSplit, currentYear,
			minDate = this._getMinMaxDate(inst, "min"),
			maxDate = this._getMinMaxDate(inst, "max"),
			minYear = null,
			maxYear = null,
			years = this._get(inst, "yearRange");
			if (years){
				yearSplit = years.split(":");
				currentYear = new Date().getFullYear();
				minYear = parseInt(yearSplit[0], 10);
				maxYear = parseInt(yearSplit[1], 10);
				if ( yearSplit[0].match(/[+\-].*/) ) {
					minYear += currentYear;
				}
				if ( yearSplit[1].match(/[+\-].*/) ) {
					maxYear += currentYear;
				}
			}

		return ((!minDate || date.getTime() >= minDate.getTime()) &&
			(!maxDate || date.getTime() <= maxDate.getTime()) &&
			(!minYear || date.getFullYear() >= minYear) &&
			(!maxYear || date.getFullYear() <= maxYear));
	},

	/* Provide the configuration settings for formatting/parsing. */
	_getFormatConfig: function(inst) {
		var shortYearCutoff = this._get(inst, "shortYearCutoff");
		shortYearCutoff = (typeof shortYearCutoff !== "string" ? shortYearCutoff :
			new Date().getFullYear() % 100 + parseInt(shortYearCutoff, 10));
		return {shortYearCutoff: shortYearCutoff,
			dayNamesShort: this._get(inst, "dayNamesShort"), dayNames: this._get(inst, "dayNames"),
			monthNamesShort: this._get(inst, "monthNamesShort"), monthNames: this._get(inst, "monthNames")};
	},

	/* Format the given date for display. */
	_formatDate: function(inst, day, month, year) {
		if (!day) {
			inst.currentDay = inst.selectedDay;
			inst.currentMonth = inst.selectedMonth;
			inst.currentYear = inst.selectedYear;
		}
		var date = (day ? (typeof day === "object" ? day :
			this._daylightSavingAdjust(new Date(year, month, day))) :
			this._daylightSavingAdjust(new Date(inst.currentYear, inst.currentMonth, inst.currentDay)));
		return this.formatDate(this._get(inst, "dateFormat"), date, this._getFormatConfig(inst));
	}
});

/*
 * Bind hover events for datepicker elements.
 * Done via delegate so the binding only occurs once in the lifetime of the parent div.
 * Global datepicker_instActive, set by _updateDatepicker allows the handlers to find their way back to the active picker.
 */
function datepicker_bindHover(dpDiv) {
	var selector = "button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a";
	return dpDiv.delegate(selector, "mouseout", function() {
			$(this).removeClass("ui-state-hover");
			if (this.className.indexOf("ui-datepicker-prev") !== -1) {
				$(this).removeClass("ui-datepicker-prev-hover");
			}
			if (this.className.indexOf("ui-datepicker-next") !== -1) {
				$(this).removeClass("ui-datepicker-next-hover");
			}
		})
		.delegate( selector, "mouseover", datepicker_handleMouseover );
}

function datepicker_handleMouseover() {
	if (!$.datepicker._isDisabledDatepicker( datepicker_instActive.inline? datepicker_instActive.dpDiv.parent()[0] : datepicker_instActive.input[0])) {
		$(this).parents(".ui-datepicker-calendar").find("a").removeClass("ui-state-hover");
		$(this).addClass("ui-state-hover");
		if (this.className.indexOf("ui-datepicker-prev") !== -1) {
			$(this).addClass("ui-datepicker-prev-hover");
		}
		if (this.className.indexOf("ui-datepicker-next") !== -1) {
			$(this).addClass("ui-datepicker-next-hover");
		}
	}
}

/* jQuery extend now ignores nulls! */
function datepicker_extendRemove(target, props) {
	$.extend(target, props);
	for (var name in props) {
		if (props[name] == null) {
			target[name] = props[name];
		}
	}
	return target;
}

/* Invoke the datepicker functionality.
   @param  options  string - a command, optionally followed by additional parameters or
					Object - settings for attaching new datepicker functionality
   @return  jQuery object */
$.fn.datepicker = function(options){

	/* Verify an empty collection wasn't passed - Fixes #6976 */
	if ( !this.length ) {
		return this;
	}

	/* Initialise the date picker. */
	if (!$.datepicker.initialized) {
		$(document).mousedown($.datepicker._checkExternalClick);
		$.datepicker.initialized = true;
	}

	/* Append datepicker main container to body if not exist. */
	if ($("#"+$.datepicker._mainDivId).length === 0) {
		$("body").append($.datepicker.dpDiv);
	}

	var otherArgs = Array.prototype.slice.call(arguments, 1);
	if (typeof options === "string" && (options === "isDisabled" || options === "getDate" || options === "widget")) {
		return $.datepicker["_" + options + "Datepicker"].
			apply($.datepicker, [this[0]].concat(otherArgs));
	}
	if (options === "option" && arguments.length === 2 && typeof arguments[1] === "string") {
		return $.datepicker["_" + options + "Datepicker"].
			apply($.datepicker, [this[0]].concat(otherArgs));
	}
	return this.each(function() {
		typeof options === "string" ?
			$.datepicker["_" + options + "Datepicker"].
				apply($.datepicker, [this].concat(otherArgs)) :
			$.datepicker._attachDatepicker(this, options);
	});
};

$.datepicker = new Datepicker(); // singleton instance
$.datepicker.initialized = false;
$.datepicker.uuid = new Date().getTime();
$.datepicker.version = "1.11.4";

return $.datepicker;

}));



/*!
 * jQuery UI Mouse 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/mouse/
 */

(function( factory ) {
	if ( typeof define === "function" && define.amd ) {

		// AMD. Register as an anonymous module.
		define([
			"jquery",
			"./widget"
		], factory );
	} else {

		// Browser globals
		factory( jQuery );
	}
}(function( $ ) {

var mouseHandled = false;
$( document ).mouseup( function() {
	mouseHandled = false;
});

return $.widget("ui.mouse", {
	version: "1.11.4",
	options: {
		cancel: "input,textarea,button,select,option",
		distance: 1,
		delay: 0
	},
	_mouseInit: function() {
		var that = this;

		this.element
			.bind("mousedown." + this.widgetName, function(event) {
				return that._mouseDown(event);
			})
			.bind("click." + this.widgetName, function(event) {
				if (true === $.data(event.target, that.widgetName + ".preventClickEvent")) {
					$.removeData(event.target, that.widgetName + ".preventClickEvent");
					event.stopImmediatePropagation();
					return false;
				}
			});

		this.started = false;
	},

	// TODO: make sure destroying one instance of mouse doesn't mess with
	// other instances of mouse
	_mouseDestroy: function() {
		this.element.unbind("." + this.widgetName);
		if ( this._mouseMoveDelegate ) {
			this.document
				.unbind("mousemove." + this.widgetName, this._mouseMoveDelegate)
				.unbind("mouseup." + this.widgetName, this._mouseUpDelegate);
		}
	},

	_mouseDown: function(event) {
		// don't let more than one widget handle mouseStart
		if ( mouseHandled ) {
			return;
		}

		this._mouseMoved = false;

		// we may have missed mouseup (out of window)
		(this._mouseStarted && this._mouseUp(event));

		this._mouseDownEvent = event;

		var that = this,
			btnIsLeft = (event.which === 1),
			// event.target.nodeName works around a bug in IE 8 with
			// disabled inputs (#7620)
			elIsCancel = (typeof this.options.cancel === "string" && event.target.nodeName ? $(event.target).closest(this.options.cancel).length : false);
		if (!btnIsLeft || elIsCancel || !this._mouseCapture(event)) {
			return true;
		}

		this.mouseDelayMet = !this.options.delay;
		if (!this.mouseDelayMet) {
			this._mouseDelayTimer = setTimeout(function() {
				that.mouseDelayMet = true;
			}, this.options.delay);
		}

		if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
			this._mouseStarted = (this._mouseStart(event) !== false);
			if (!this._mouseStarted) {
				event.preventDefault();
				return true;
			}
		}

		// Click event may never have fired (Gecko & Opera)
		if (true === $.data(event.target, this.widgetName + ".preventClickEvent")) {
			$.removeData(event.target, this.widgetName + ".preventClickEvent");
		}

		// these delegates are required to keep context
		this._mouseMoveDelegate = function(event) {
			return that._mouseMove(event);
		};
		this._mouseUpDelegate = function(event) {
			return that._mouseUp(event);
		};

		this.document
			.bind( "mousemove." + this.widgetName, this._mouseMoveDelegate )
			.bind( "mouseup." + this.widgetName, this._mouseUpDelegate );

		event.preventDefault();

		mouseHandled = true;
		return true;
	},

	_mouseMove: function(event) {
		// Only check for mouseups outside the document if you've moved inside the document
		// at least once. This prevents the firing of mouseup in the case of IE<9, which will
		// fire a mousemove event if content is placed under the cursor. See #7778
		// Support: IE <9
		if ( this._mouseMoved ) {
			// IE mouseup check - mouseup happened when mouse was out of window
			if ($.ui.ie && ( !document.documentMode || document.documentMode < 9 ) && !event.button) {
				return this._mouseUp(event);

			// Iframe mouseup check - mouseup occurred in another document
			} else if ( !event.which ) {
				return this._mouseUp( event );
			}
		}

		if ( event.which || event.button ) {
			this._mouseMoved = true;
		}

		if (this._mouseStarted) {
			this._mouseDrag(event);
			return event.preventDefault();
		}

		if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
			this._mouseStarted =
				(this._mouseStart(this._mouseDownEvent, event) !== false);
			(this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event));
		}

		return !this._mouseStarted;
	},

	_mouseUp: function(event) {
		this.document
			.unbind( "mousemove." + this.widgetName, this._mouseMoveDelegate )
			.unbind( "mouseup." + this.widgetName, this._mouseUpDelegate );

		if (this._mouseStarted) {
			this._mouseStarted = false;

			if (event.target === this._mouseDownEvent.target) {
				$.data(event.target, this.widgetName + ".preventClickEvent", true);
			}

			this._mouseStop(event);
		}

		mouseHandled = false;
		return false;
	},

	_mouseDistanceMet: function(event) {
		return (Math.max(
				Math.abs(this._mouseDownEvent.pageX - event.pageX),
				Math.abs(this._mouseDownEvent.pageY - event.pageY)
			) >= this.options.distance
		);
	},

	_mouseDelayMet: function(/* event */) {
		return this.mouseDelayMet;
	},

	// These are placeholder methods, to be overriden by extending plugin
	_mouseStart: function(/* event */) {},
	_mouseDrag: function(/* event */) {},
	_mouseStop: function(/* event */) {},
	_mouseCapture: function(/* event */) { return true; }
});

}));




/*!
 * jQuery UI Draggable 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/draggable/
 */

(function( factory ) {
	if ( typeof define === "function" && define.amd ) {

		// AMD. Register as an anonymous module.
		define([
			"jquery",
			"./core",
			"./mouse",
			"./widget"
		], factory );
	} else {

		// Browser globals
		factory( jQuery );
	}
}(function( $ ) {

$.widget("ui.draggable", $.ui.mouse, {
	version: "1.11.4",
	widgetEventPrefix: "drag",
	options: {
		addClasses: true,
		appendTo: "parent",
		axis: false,
		connectToSortable: false,
		containment: false,
		cursor: "auto",
		cursorAt: false,
		grid: false,
		handle: false,
		helper: "original",
		iframeFix: false,
		opacity: false,
		refreshPositions: false,
		revert: false,
		revertDuration: 500,
		scope: "default",
		scroll: true,
		scrollSensitivity: 20,
		scrollSpeed: 20,
		snap: false,
		snapMode: "both",
		snapTolerance: 20,
		stack: false,
		zIndex: false,

		// callbacks
		drag: null,
		start: null,
		stop: null
	},
	_create: function() {

		if ( this.options.helper === "original" ) {
			this._setPositionRelative();
		}
		if (this.options.addClasses){
			this.element.addClass("ui-draggable");
		}
		if (this.options.disabled){
			this.element.addClass("ui-draggable-disabled");
		}
		this._setHandleClassName();

		this._mouseInit();
	},

	_setOption: function( key, value ) {
		this._super( key, value );
		if ( key === "handle" ) {
			this._removeHandleClassName();
			this._setHandleClassName();
		}
	},

	_destroy: function() {
		if ( ( this.helper || this.element ).is( ".ui-draggable-dragging" ) ) {
			this.destroyOnClear = true;
			return;
		}
		this.element.removeClass( "ui-draggable ui-draggable-dragging ui-draggable-disabled" );
		this._removeHandleClassName();
		this._mouseDestroy();
	},

	_mouseCapture: function(event) {
		var o = this.options;

		this._blurActiveElement( event );

		// among others, prevent a drag on a resizable-handle
		if (this.helper || o.disabled || $(event.target).closest(".ui-resizable-handle").length > 0) {
			return false;
		}

		//Quit if we're not on a valid handle
		this.handle = this._getHandle(event);
		if (!this.handle) {
			return false;
		}

		this._blockFrames( o.iframeFix === true ? "iframe" : o.iframeFix );

		return true;

	},

	_blockFrames: function( selector ) {
		this.iframeBlocks = this.document.find( selector ).map(function() {
			var iframe = $( this );

			return $( "<div>" )
				.css( "position", "absolute" )
				.appendTo( iframe.parent() )
				.outerWidth( iframe.outerWidth() )
				.outerHeight( iframe.outerHeight() )
				.offset( iframe.offset() )[ 0 ];
		});
	},

	_unblockFrames: function() {
		if ( this.iframeBlocks ) {
			this.iframeBlocks.remove();
			delete this.iframeBlocks;
		}
	},

	_blurActiveElement: function( event ) {
		var document = this.document[ 0 ];

		// Only need to blur if the event occurred on the draggable itself, see #10527
		if ( !this.handleElement.is( event.target ) ) {
			return;
		}

		// support: IE9
		// IE9 throws an "Unspecified error" accessing document.activeElement from an <iframe>
		try {

			// Support: IE9, IE10
			// If the <body> is blurred, IE will switch windows, see #9520
			if ( document.activeElement && document.activeElement.nodeName.toLowerCase() !== "body" ) {

				// Blur any element that currently has focus, see #4261
				$( document.activeElement ).blur();
			}
		} catch ( error ) {}
	},

	_mouseStart: function(event) {

		var o = this.options;

		//Create and append the visible helper
		this.helper = this._createHelper(event);

		this.helper.addClass("ui-draggable-dragging");

		//Cache the helper size
		this._cacheHelperProportions();

		//If ddmanager is used for droppables, set the global draggable
		if ($.ui.ddmanager) {
			$.ui.ddmanager.current = this;
		}

		/*
		 * - Position generation -
		 * This block generates everything position related - it's the core of draggables.
		 */

		//Cache the margins of the original element
		this._cacheMargins();

		//Store the helper's css position
		this.cssPosition = this.helper.css( "position" );
		this.scrollParent = this.helper.scrollParent( true );
		this.offsetParent = this.helper.offsetParent();
		this.hasFixedAncestor = this.helper.parents().filter(function() {
				return $( this ).css( "position" ) === "fixed";
			}).length > 0;

		//The element's absolute position on the page minus margins
		this.positionAbs = this.element.offset();
		this._refreshOffsets( event );

		//Generate the original position
		this.originalPosition = this.position = this._generatePosition( event, false );
		this.originalPageX = event.pageX;
		this.originalPageY = event.pageY;

		//Adjust the mouse offset relative to the helper if "cursorAt" is supplied
		(o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt));

		//Set a containment if given in the options
		this._setContainment();

		//Trigger event + callbacks
		if (this._trigger("start", event) === false) {
			this._clear();
			return false;
		}

		//Recache the helper size
		this._cacheHelperProportions();

		//Prepare the droppable offsets
		if ($.ui.ddmanager && !o.dropBehaviour) {
			$.ui.ddmanager.prepareOffsets(this, event);
		}

		// Reset helper's right/bottom css if they're set and set explicit width/height instead
		// as this prevents resizing of elements with right/bottom set (see #7772)
		this._normalizeRightBottom();

		this._mouseDrag(event, true); //Execute the drag once - this causes the helper not to be visible before getting its correct position

		//If the ddmanager is used for droppables, inform the manager that dragging has started (see #5003)
		if ( $.ui.ddmanager ) {
			$.ui.ddmanager.dragStart(this, event);
		}

		return true;
	},

	_refreshOffsets: function( event ) {
		this.offset = {
			top: this.positionAbs.top - this.margins.top,
			left: this.positionAbs.left - this.margins.left,
			scroll: false,
			parent: this._getParentOffset(),
			relative: this._getRelativeOffset()
		};

		this.offset.click = {
			left: event.pageX - this.offset.left,
			top: event.pageY - this.offset.top
		};
	},

	_mouseDrag: function(event, noPropagation) {
		// reset any necessary cached properties (see #5009)
		if ( this.hasFixedAncestor ) {
			this.offset.parent = this._getParentOffset();
		}

		//Compute the helpers position
		this.position = this._generatePosition( event, true );
		this.positionAbs = this._convertPositionTo("absolute");

		//Call plugins and callbacks and use the resulting position if something is returned
		if (!noPropagation) {
			var ui = this._uiHash();
			if (this._trigger("drag", event, ui) === false) {
				this._mouseUp({});
				return false;
			}
			this.position = ui.position;
		}

		this.helper[ 0 ].style.left = this.position.left + "px";
		this.helper[ 0 ].style.top = this.position.top + "px";

		if ($.ui.ddmanager) {
			$.ui.ddmanager.drag(this, event);
		}

		return false;
	},

	_mouseStop: function(event) {

		//If we are using droppables, inform the manager about the drop
		var that = this,
			dropped = false;
		if ($.ui.ddmanager && !this.options.dropBehaviour) {
			dropped = $.ui.ddmanager.drop(this, event);
		}

		//if a drop comes from outside (a sortable)
		if (this.dropped) {
			dropped = this.dropped;
			this.dropped = false;
		}

		if ((this.options.revert === "invalid" && !dropped) || (this.options.revert === "valid" && dropped) || this.options.revert === true || ($.isFunction(this.options.revert) && this.options.revert.call(this.element, dropped))) {
			$(this.helper).animate(this.originalPosition, parseInt(this.options.revertDuration, 10), function() {
				if (that._trigger("stop", event) !== false) {
					that._clear();
				}
			});
		} else {
			if (this._trigger("stop", event) !== false) {
				this._clear();
			}
		}

		return false;
	},

	_mouseUp: function( event ) {
		this._unblockFrames();

		//If the ddmanager is used for droppables, inform the manager that dragging has stopped (see #5003)
		if ( $.ui.ddmanager ) {
			$.ui.ddmanager.dragStop(this, event);
		}

		// Only need to focus if the event occurred on the draggable itself, see #10527
		if ( this.handleElement.is( event.target ) ) {
			// The interaction is over; whether or not the click resulted in a drag, focus the element
			this.element.focus();
		}

		return $.ui.mouse.prototype._mouseUp.call(this, event);
	},

	cancel: function() {

		if (this.helper.is(".ui-draggable-dragging")) {
			this._mouseUp({});
		} else {
			this._clear();
		}

		return this;

	},

	_getHandle: function(event) {
		return this.options.handle ?
			!!$( event.target ).closest( this.element.find( this.options.handle ) ).length :
			true;
	},

	_setHandleClassName: function() {
		this.handleElement = this.options.handle ?
			this.element.find( this.options.handle ) : this.element;
		this.handleElement.addClass( "ui-draggable-handle" );
	},

	_removeHandleClassName: function() {
		this.handleElement.removeClass( "ui-draggable-handle" );
	},

	_createHelper: function(event) {

		var o = this.options,
			helperIsFunction = $.isFunction( o.helper ),
			helper = helperIsFunction ?
				$( o.helper.apply( this.element[ 0 ], [ event ] ) ) :
				( o.helper === "clone" ?
					this.element.clone().removeAttr( "id" ) :
					this.element );

		if (!helper.parents("body").length) {
			helper.appendTo((o.appendTo === "parent" ? this.element[0].parentNode : o.appendTo));
		}

		// http://bugs.jqueryui.com/ticket/9446
		// a helper function can return the original element
		// which wouldn't have been set to relative in _create
		if ( helperIsFunction && helper[ 0 ] === this.element[ 0 ] ) {
			this._setPositionRelative();
		}

		if (helper[0] !== this.element[0] && !(/(fixed|absolute)/).test(helper.css("position"))) {
			helper.css("position", "absolute");
		}

		return helper;

	},

	_setPositionRelative: function() {
		if ( !( /^(?:r|a|f)/ ).test( this.element.css( "position" ) ) ) {
			this.element[ 0 ].style.position = "relative";
		}
	},

	_adjustOffsetFromHelper: function(obj) {
		if (typeof obj === "string") {
			obj = obj.split(" ");
		}
		if ($.isArray(obj)) {
			obj = { left: +obj[0], top: +obj[1] || 0 };
		}
		if ("left" in obj) {
			this.offset.click.left = obj.left + this.margins.left;
		}
		if ("right" in obj) {
			this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
		}
		if ("top" in obj) {
			this.offset.click.top = obj.top + this.margins.top;
		}
		if ("bottom" in obj) {
			this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
		}
	},

	_isRootNode: function( element ) {
		return ( /(html|body)/i ).test( element.tagName ) || element === this.document[ 0 ];
	},

	_getParentOffset: function() {

		//Get the offsetParent and cache its position
		var po = this.offsetParent.offset(),
			document = this.document[ 0 ];

		// This is a special case where we need to modify a offset calculated on start, since the following happened:
		// 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent
		// 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that
		//    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag
		if (this.cssPosition === "absolute" && this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) {
			po.left += this.scrollParent.scrollLeft();
			po.top += this.scrollParent.scrollTop();
		}

		if ( this._isRootNode( this.offsetParent[ 0 ] ) ) {
			po = { top: 0, left: 0 };
		}

		return {
			top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"), 10) || 0),
			left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"), 10) || 0)
		};

	},

	_getRelativeOffset: function() {
		if ( this.cssPosition !== "relative" ) {
			return { top: 0, left: 0 };
		}

		var p = this.element.position(),
			scrollIsRootNode = this._isRootNode( this.scrollParent[ 0 ] );

		return {
			top: p.top - ( parseInt(this.helper.css( "top" ), 10) || 0 ) + ( !scrollIsRootNode ? this.scrollParent.scrollTop() : 0 ),
			left: p.left - ( parseInt(this.helper.css( "left" ), 10) || 0 ) + ( !scrollIsRootNode ? this.scrollParent.scrollLeft() : 0 )
		};

	},

	_cacheMargins: function() {
		this.margins = {
			left: (parseInt(this.element.css("marginLeft"), 10) || 0),
			top: (parseInt(this.element.css("marginTop"), 10) || 0),
			right: (parseInt(this.element.css("marginRight"), 10) || 0),
			bottom: (parseInt(this.element.css("marginBottom"), 10) || 0)
		};
	},

	_cacheHelperProportions: function() {
		this.helperProportions = {
			width: this.helper.outerWidth(),
			height: this.helper.outerHeight()
		};
	},

	_setContainment: function() {

		var isUserScrollable, c, ce,
			o = this.options,
			document = this.document[ 0 ];

		this.relativeContainer = null;

		if ( !o.containment ) {
			this.containment = null;
			return;
		}

		if ( o.containment === "window" ) {
			this.containment = [
				$( window ).scrollLeft() - this.offset.relative.left - this.offset.parent.left,
				$( window ).scrollTop() - this.offset.relative.top - this.offset.parent.top,
				$( window ).scrollLeft() + $( window ).width() - this.helperProportions.width - this.margins.left,
				$( window ).scrollTop() + ( $( window ).height() || document.body.parentNode.scrollHeight ) - this.helperProportions.height - this.margins.top
			];
			return;
		}

		if ( o.containment === "document") {
			this.containment = [
				0,
				0,
				$( document ).width() - this.helperProportions.width - this.margins.left,
				( $( document ).height() || document.body.parentNode.scrollHeight ) - this.helperProportions.height - this.margins.top
			];
			return;
		}

		if ( o.containment.constructor === Array ) {
			this.containment = o.containment;
			return;
		}

		if ( o.containment === "parent" ) {
			o.containment = this.helper[ 0 ].parentNode;
		}

		c = $( o.containment );
		ce = c[ 0 ];

		if ( !ce ) {
			return;
		}

		isUserScrollable = /(scroll|auto)/.test( c.css( "overflow" ) );

		this.containment = [
			( parseInt( c.css( "borderLeftWidth" ), 10 ) || 0 ) + ( parseInt( c.css( "paddingLeft" ), 10 ) || 0 ),
			( parseInt( c.css( "borderTopWidth" ), 10 ) || 0 ) + ( parseInt( c.css( "paddingTop" ), 10 ) || 0 ),
			( isUserScrollable ? Math.max( ce.scrollWidth, ce.offsetWidth ) : ce.offsetWidth ) -
				( parseInt( c.css( "borderRightWidth" ), 10 ) || 0 ) -
				( parseInt( c.css( "paddingRight" ), 10 ) || 0 ) -
				this.helperProportions.width -
				this.margins.left -
				this.margins.right,
			( isUserScrollable ? Math.max( ce.scrollHeight, ce.offsetHeight ) : ce.offsetHeight ) -
				( parseInt( c.css( "borderBottomWidth" ), 10 ) || 0 ) -
				( parseInt( c.css( "paddingBottom" ), 10 ) || 0 ) -
				this.helperProportions.height -
				this.margins.top -
				this.margins.bottom
		];
		this.relativeContainer = c;
	},

	_convertPositionTo: function(d, pos) {

		if (!pos) {
			pos = this.position;
		}

		var mod = d === "absolute" ? 1 : -1,
			scrollIsRootNode = this._isRootNode( this.scrollParent[ 0 ] );

		return {
			top: (
				pos.top	+																// The absolute mouse position
				this.offset.relative.top * mod +										// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.parent.top * mod -										// The offsetParent's offset without borders (offset + border)
				( ( this.cssPosition === "fixed" ? -this.offset.scroll.top : ( scrollIsRootNode ? 0 : this.offset.scroll.top ) ) * mod)
			),
			left: (
				pos.left +																// The absolute mouse position
				this.offset.relative.left * mod +										// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.parent.left * mod	-										// The offsetParent's offset without borders (offset + border)
				( ( this.cssPosition === "fixed" ? -this.offset.scroll.left : ( scrollIsRootNode ? 0 : this.offset.scroll.left ) ) * mod)
			)
		};

	},

	_generatePosition: function( event, constrainPosition ) {

		var containment, co, top, left,
			o = this.options,
			scrollIsRootNode = this._isRootNode( this.scrollParent[ 0 ] ),
			pageX = event.pageX,
			pageY = event.pageY;

		// Cache the scroll
		if ( !scrollIsRootNode || !this.offset.scroll ) {
			this.offset.scroll = {
				top: this.scrollParent.scrollTop(),
				left: this.scrollParent.scrollLeft()
			};
		}

		/*
		 * - Position constraining -
		 * Constrain the position to a mix of grid, containment.
		 */

		// If we are not dragging yet, we won't check for options
		if ( constrainPosition ) {
			if ( this.containment ) {
				if ( this.relativeContainer ){
					co = this.relativeContainer.offset();
					containment = [
						this.containment[ 0 ] + co.left,
						this.containment[ 1 ] + co.top,
						this.containment[ 2 ] + co.left,
						this.containment[ 3 ] + co.top
					];
				} else {
					containment = this.containment;
				}

				if (event.pageX - this.offset.click.left < containment[0]) {
					pageX = containment[0] + this.offset.click.left;
				}
				if (event.pageY - this.offset.click.top < containment[1]) {
					pageY = containment[1] + this.offset.click.top;
				}
				if (event.pageX - this.offset.click.left > containment[2]) {
					pageX = containment[2] + this.offset.click.left;
				}
				if (event.pageY - this.offset.click.top > containment[3]) {
					pageY = containment[3] + this.offset.click.top;
				}
			}

			if (o.grid) {
				//Check for grid elements set to 0 to prevent divide by 0 error causing invalid argument errors in IE (see ticket #6950)
				top = o.grid[1] ? this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1] : this.originalPageY;
				pageY = containment ? ((top - this.offset.click.top >= containment[1] || top - this.offset.click.top > containment[3]) ? top : ((top - this.offset.click.top >= containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;

				left = o.grid[0] ? this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0] : this.originalPageX;
				pageX = containment ? ((left - this.offset.click.left >= containment[0] || left - this.offset.click.left > containment[2]) ? left : ((left - this.offset.click.left >= containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;
			}

			if ( o.axis === "y" ) {
				pageX = this.originalPageX;
			}

			if ( o.axis === "x" ) {
				pageY = this.originalPageY;
			}
		}

		return {
			top: (
				pageY -																	// The absolute mouse position
				this.offset.click.top	-												// Click offset (relative to the element)
				this.offset.relative.top -												// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.parent.top +												// The offsetParent's offset without borders (offset + border)
				( this.cssPosition === "fixed" ? -this.offset.scroll.top : ( scrollIsRootNode ? 0 : this.offset.scroll.top ) )
			),
			left: (
				pageX -																	// The absolute mouse position
				this.offset.click.left -												// Click offset (relative to the element)
				this.offset.relative.left -												// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.parent.left +												// The offsetParent's offset without borders (offset + border)
				( this.cssPosition === "fixed" ? -this.offset.scroll.left : ( scrollIsRootNode ? 0 : this.offset.scroll.left ) )
			)
		};

	},

	_clear: function() {
		this.helper.removeClass("ui-draggable-dragging");
		if (this.helper[0] !== this.element[0] && !this.cancelHelperRemoval) {
			this.helper.remove();
		}
		this.helper = null;
		this.cancelHelperRemoval = false;
		if ( this.destroyOnClear ) {
			this.destroy();
		}
	},

	_normalizeRightBottom: function() {
		if ( this.options.axis !== "y" && this.helper.css( "right" ) !== "auto" ) {
			this.helper.width( this.helper.width() );
			this.helper.css( "right", "auto" );
		}
		if ( this.options.axis !== "x" && this.helper.css( "bottom" ) !== "auto" ) {
			this.helper.height( this.helper.height() );
			this.helper.css( "bottom", "auto" );
		}
	},

	// From now on bulk stuff - mainly helpers

	_trigger: function( type, event, ui ) {
		ui = ui || this._uiHash();
		$.ui.plugin.call( this, type, [ event, ui, this ], true );

		// Absolute position and offset (see #6884 ) have to be recalculated after plugins
		if ( /^(drag|start|stop)/.test( type ) ) {
			this.positionAbs = this._convertPositionTo( "absolute" );
			ui.offset = this.positionAbs;
		}
		return $.Widget.prototype._trigger.call( this, type, event, ui );
	},

	plugins: {},

	_uiHash: function() {
		return {
			helper: this.helper,
			position: this.position,
			originalPosition: this.originalPosition,
			offset: this.positionAbs
		};
	}

});

$.ui.plugin.add( "draggable", "connectToSortable", {
	start: function( event, ui, draggable ) {
		var uiSortable = $.extend( {}, ui, {
			item: draggable.element
		});

		draggable.sortables = [];
		$( draggable.options.connectToSortable ).each(function() {
			var sortable = $( this ).sortable( "instance" );

			if ( sortable && !sortable.options.disabled ) {
				draggable.sortables.push( sortable );

				// refreshPositions is called at drag start to refresh the containerCache
				// which is used in drag. This ensures it's initialized and synchronized
				// with any changes that might have happened on the page since initialization.
				sortable.refreshPositions();
				sortable._trigger("activate", event, uiSortable);
			}
		});
	},
	stop: function( event, ui, draggable ) {
		var uiSortable = $.extend( {}, ui, {
			item: draggable.element
		});

		draggable.cancelHelperRemoval = false;

		$.each( draggable.sortables, function() {
			var sortable = this;

			if ( sortable.isOver ) {
				sortable.isOver = 0;

				// Allow this sortable to handle removing the helper
				draggable.cancelHelperRemoval = true;
				sortable.cancelHelperRemoval = false;

				// Use _storedCSS To restore properties in the sortable,
				// as this also handles revert (#9675) since the draggable
				// may have modified them in unexpected ways (#8809)
				sortable._storedCSS = {
					position: sortable.placeholder.css( "position" ),
					top: sortable.placeholder.css( "top" ),
					left: sortable.placeholder.css( "left" )
				};

				sortable._mouseStop(event);

				// Once drag has ended, the sortable should return to using
				// its original helper, not the shared helper from draggable
				sortable.options.helper = sortable.options._helper;
			} else {
				// Prevent this Sortable from removing the helper.
				// However, don't set the draggable to remove the helper
				// either as another connected Sortable may yet handle the removal.
				sortable.cancelHelperRemoval = true;

				sortable._trigger( "deactivate", event, uiSortable );
			}
		});
	},
	drag: function( event, ui, draggable ) {
		$.each( draggable.sortables, function() {
			var innermostIntersecting = false,
				sortable = this;

			// Copy over variables that sortable's _intersectsWith uses
			sortable.positionAbs = draggable.positionAbs;
			sortable.helperProportions = draggable.helperProportions;
			sortable.offset.click = draggable.offset.click;

			if ( sortable._intersectsWith( sortable.containerCache ) ) {
				innermostIntersecting = true;

				$.each( draggable.sortables, function() {
					// Copy over variables that sortable's _intersectsWith uses
					this.positionAbs = draggable.positionAbs;
					this.helperProportions = draggable.helperProportions;
					this.offset.click = draggable.offset.click;

					if ( this !== sortable &&
							this._intersectsWith( this.containerCache ) &&
							$.contains( sortable.element[ 0 ], this.element[ 0 ] ) ) {
						innermostIntersecting = false;
					}

					return innermostIntersecting;
				});
			}

			if ( innermostIntersecting ) {
				// If it intersects, we use a little isOver variable and set it once,
				// so that the move-in stuff gets fired only once.
				if ( !sortable.isOver ) {
					sortable.isOver = 1;

					// Store draggable's parent in case we need to reappend to it later.
					draggable._parent = ui.helper.parent();

					sortable.currentItem = ui.helper
						.appendTo( sortable.element )
						.data( "ui-sortable-item", true );

					// Store helper option to later restore it
					sortable.options._helper = sortable.options.helper;

					sortable.options.helper = function() {
						return ui.helper[ 0 ];
					};

					// Fire the start events of the sortable with our passed browser event,
					// and our own helper (so it doesn't create a new one)
					event.target = sortable.currentItem[ 0 ];
					sortable._mouseCapture( event, true );
					sortable._mouseStart( event, true, true );

					// Because the browser event is way off the new appended portlet,
					// modify necessary variables to reflect the changes
					sortable.offset.click.top = draggable.offset.click.top;
					sortable.offset.click.left = draggable.offset.click.left;
					sortable.offset.parent.left -= draggable.offset.parent.left -
						sortable.offset.parent.left;
					sortable.offset.parent.top -= draggable.offset.parent.top -
						sortable.offset.parent.top;

					draggable._trigger( "toSortable", event );

					// Inform draggable that the helper is in a valid drop zone,
					// used solely in the revert option to handle "valid/invalid".
					draggable.dropped = sortable.element;

					// Need to refreshPositions of all sortables in the case that
					// adding to one sortable changes the location of the other sortables (#9675)
					$.each( draggable.sortables, function() {
						this.refreshPositions();
					});

					// hack so receive/update callbacks work (mostly)
					draggable.currentItem = draggable.element;
					sortable.fromOutside = draggable;
				}

				if ( sortable.currentItem ) {
					sortable._mouseDrag( event );
					// Copy the sortable's position because the draggable's can potentially reflect
					// a relative position, while sortable is always absolute, which the dragged
					// element has now become. (#8809)
					ui.position = sortable.position;
				}
			} else {
				// If it doesn't intersect with the sortable, and it intersected before,
				// we fake the drag stop of the sortable, but make sure it doesn't remove
				// the helper by using cancelHelperRemoval.
				if ( sortable.isOver ) {

					sortable.isOver = 0;
					sortable.cancelHelperRemoval = true;

					// Calling sortable's mouseStop would trigger a revert,
					// so revert must be temporarily false until after mouseStop is called.
					sortable.options._revert = sortable.options.revert;
					sortable.options.revert = false;

					sortable._trigger( "out", event, sortable._uiHash( sortable ) );
					sortable._mouseStop( event, true );

					// restore sortable behaviors that were modfied
					// when the draggable entered the sortable area (#9481)
					sortable.options.revert = sortable.options._revert;
					sortable.options.helper = sortable.options._helper;

					if ( sortable.placeholder ) {
						sortable.placeholder.remove();
					}

					// Restore and recalculate the draggable's offset considering the sortable
					// may have modified them in unexpected ways. (#8809, #10669)
					ui.helper.appendTo( draggable._parent );
					draggable._refreshOffsets( event );
					ui.position = draggable._generatePosition( event, true );

					draggable._trigger( "fromSortable", event );

					// Inform draggable that the helper is no longer in a valid drop zone
					draggable.dropped = false;

					// Need to refreshPositions of all sortables just in case removing
					// from one sortable changes the location of other sortables (#9675)
					$.each( draggable.sortables, function() {
						this.refreshPositions();
					});
				}
			}
		});
	}
});

$.ui.plugin.add("draggable", "cursor", {
	start: function( event, ui, instance ) {
		var t = $( "body" ),
			o = instance.options;

		if (t.css("cursor")) {
			o._cursor = t.css("cursor");
		}
		t.css("cursor", o.cursor);
	},
	stop: function( event, ui, instance ) {
		var o = instance.options;
		if (o._cursor) {
			$("body").css("cursor", o._cursor);
		}
	}
});

$.ui.plugin.add("draggable", "opacity", {
	start: function( event, ui, instance ) {
		var t = $( ui.helper ),
			o = instance.options;
		if (t.css("opacity")) {
			o._opacity = t.css("opacity");
		}
		t.css("opacity", o.opacity);
	},
	stop: function( event, ui, instance ) {
		var o = instance.options;
		if (o._opacity) {
			$(ui.helper).css("opacity", o._opacity);
		}
	}
});

$.ui.plugin.add("draggable", "scroll", {
	start: function( event, ui, i ) {
		if ( !i.scrollParentNotHidden ) {
			i.scrollParentNotHidden = i.helper.scrollParent( false );
		}

		if ( i.scrollParentNotHidden[ 0 ] !== i.document[ 0 ] && i.scrollParentNotHidden[ 0 ].tagName !== "HTML" ) {
			i.overflowOffset = i.scrollParentNotHidden.offset();
		}
	},
	drag: function( event, ui, i  ) {

		var o = i.options,
			scrolled = false,
			scrollParent = i.scrollParentNotHidden[ 0 ],
			document = i.document[ 0 ];

		if ( scrollParent !== document && scrollParent.tagName !== "HTML" ) {
			if ( !o.axis || o.axis !== "x" ) {
				if ( ( i.overflowOffset.top + scrollParent.offsetHeight ) - event.pageY < o.scrollSensitivity ) {
					scrollParent.scrollTop = scrolled = scrollParent.scrollTop + o.scrollSpeed;
				} else if ( event.pageY - i.overflowOffset.top < o.scrollSensitivity ) {
					scrollParent.scrollTop = scrolled = scrollParent.scrollTop - o.scrollSpeed;
				}
			}

			if ( !o.axis || o.axis !== "y" ) {
				if ( ( i.overflowOffset.left + scrollParent.offsetWidth ) - event.pageX < o.scrollSensitivity ) {
					scrollParent.scrollLeft = scrolled = scrollParent.scrollLeft + o.scrollSpeed;
				} else if ( event.pageX - i.overflowOffset.left < o.scrollSensitivity ) {
					scrollParent.scrollLeft = scrolled = scrollParent.scrollLeft - o.scrollSpeed;
				}
			}

		} else {

			if (!o.axis || o.axis !== "x") {
				if (event.pageY - $(document).scrollTop() < o.scrollSensitivity) {
					scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);
				} else if ($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity) {
					scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);
				}
			}

			if (!o.axis || o.axis !== "y") {
				if (event.pageX - $(document).scrollLeft() < o.scrollSensitivity) {
					scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);
				} else if ($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity) {
					scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);
				}
			}

		}

		if (scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {
			$.ui.ddmanager.prepareOffsets(i, event);
		}

	}
});

$.ui.plugin.add("draggable", "snap", {
	start: function( event, ui, i ) {

		var o = i.options;

		i.snapElements = [];

		$(o.snap.constructor !== String ? ( o.snap.items || ":data(ui-draggable)" ) : o.snap).each(function() {
			var $t = $(this),
				$o = $t.offset();
			if (this !== i.element[0]) {
				i.snapElements.push({
					item: this,
					width: $t.outerWidth(), height: $t.outerHeight(),
					top: $o.top, left: $o.left
				});
			}
		});

	},
	drag: function( event, ui, inst ) {

		var ts, bs, ls, rs, l, r, t, b, i, first,
			o = inst.options,
			d = o.snapTolerance,
			x1 = ui.offset.left, x2 = x1 + inst.helperProportions.width,
			y1 = ui.offset.top, y2 = y1 + inst.helperProportions.height;

		for (i = inst.snapElements.length - 1; i >= 0; i--){

			l = inst.snapElements[i].left - inst.margins.left;
			r = l + inst.snapElements[i].width;
			t = inst.snapElements[i].top - inst.margins.top;
			b = t + inst.snapElements[i].height;

			if ( x2 < l - d || x1 > r + d || y2 < t - d || y1 > b + d || !$.contains( inst.snapElements[ i ].item.ownerDocument, inst.snapElements[ i ].item ) ) {
				if (inst.snapElements[i].snapping) {
					(inst.options.snap.release && inst.options.snap.release.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));
				}
				inst.snapElements[i].snapping = false;
				continue;
			}

			if (o.snapMode !== "inner") {
				ts = Math.abs(t - y2) <= d;
				bs = Math.abs(b - y1) <= d;
				ls = Math.abs(l - x2) <= d;
				rs = Math.abs(r - x1) <= d;
				if (ts) {
					ui.position.top = inst._convertPositionTo("relative", { top: t - inst.helperProportions.height, left: 0 }).top;
				}
				if (bs) {
					ui.position.top = inst._convertPositionTo("relative", { top: b, left: 0 }).top;
				}
				if (ls) {
					ui.position.left = inst._convertPositionTo("relative", { top: 0, left: l - inst.helperProportions.width }).left;
				}
				if (rs) {
					ui.position.left = inst._convertPositionTo("relative", { top: 0, left: r }).left;
				}
			}

			first = (ts || bs || ls || rs);

			if (o.snapMode !== "outer") {
				ts = Math.abs(t - y1) <= d;
				bs = Math.abs(b - y2) <= d;
				ls = Math.abs(l - x1) <= d;
				rs = Math.abs(r - x2) <= d;
				if (ts) {
					ui.position.top = inst._convertPositionTo("relative", { top: t, left: 0 }).top;
				}
				if (bs) {
					ui.position.top = inst._convertPositionTo("relative", { top: b - inst.helperProportions.height, left: 0 }).top;
				}
				if (ls) {
					ui.position.left = inst._convertPositionTo("relative", { top: 0, left: l }).left;
				}
				if (rs) {
					ui.position.left = inst._convertPositionTo("relative", { top: 0, left: r - inst.helperProportions.width }).left;
				}
			}

			if (!inst.snapElements[i].snapping && (ts || bs || ls || rs || first)) {
				(inst.options.snap.snap && inst.options.snap.snap.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));
			}
			inst.snapElements[i].snapping = (ts || bs || ls || rs || first);

		}

	}
});

$.ui.plugin.add("draggable", "stack", {
	start: function( event, ui, instance ) {
		var min,
			o = instance.options,
			group = $.makeArray($(o.stack)).sort(function(a, b) {
				return (parseInt($(a).css("zIndex"), 10) || 0) - (parseInt($(b).css("zIndex"), 10) || 0);
			});

		if (!group.length) { return; }

		min = parseInt($(group[0]).css("zIndex"), 10) || 0;
		$(group).each(function(i) {
			$(this).css("zIndex", min + i);
		});
		this.css("zIndex", (min + group.length));
	}
});

$.ui.plugin.add("draggable", "zIndex", {
	start: function( event, ui, instance ) {
		var t = $( ui.helper ),
			o = instance.options;

		if (t.css("zIndex")) {
			o._zIndex = t.css("zIndex");
		}
		t.css("zIndex", o.zIndex);
	},
	stop: function( event, ui, instance ) {
		var o = instance.options;

		if (o._zIndex) {
			$(ui.helper).css("zIndex", o._zIndex);
		}
	}
});

return $.ui.draggable;

}));




/*!
 * jQuery UI Resizable 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/resizable/
 */

(function( factory ) {
	if ( typeof define === "function" && define.amd ) {

		// AMD. Register as an anonymous module.
		define([
			"jquery",
			"./core",
			"./mouse",
			"./widget"
		], factory );
	} else {

		// Browser globals
		factory( jQuery );
	}
}(function( $ ) {

$.widget("ui.resizable", $.ui.mouse, {
	version: "1.11.4",
	widgetEventPrefix: "resize",
	options: {
		alsoResize: false,
		animate: false,
		animateDuration: "slow",
		animateEasing: "swing",
		aspectRatio: false,
		autoHide: false,
		containment: false,
		ghost: false,
		grid: false,
		handles: "e,s,se",
		helper: false,
		maxHeight: null,
		maxWidth: null,
		minHeight: 10,
		minWidth: 10,
		// See #7960
		zIndex: 90,

		// callbacks
		resize: null,
		start: null,
		stop: null
	},

	_num: function( value ) {
		return parseInt( value, 10 ) || 0;
	},

	_isNumber: function( value ) {
		return !isNaN( parseInt( value, 10 ) );
	},

	_hasScroll: function( el, a ) {

		if ( $( el ).css( "overflow" ) === "hidden") {
			return false;
		}

		var scroll = ( a && a === "left" ) ? "scrollLeft" : "scrollTop",
			has = false;

		if ( el[ scroll ] > 0 ) {
			return true;
		}

		// TODO: determine which cases actually cause this to happen
		// if the element doesn't have the scroll set, see if it's possible to
		// set the scroll
		el[ scroll ] = 1;
		has = ( el[ scroll ] > 0 );
		el[ scroll ] = 0;
		return has;
	},

	_create: function() {

		var n, i, handle, axis, hname,
			that = this,
			o = this.options;
		this.element.addClass("ui-resizable");

		$.extend(this, {
			_aspectRatio: !!(o.aspectRatio),
			aspectRatio: o.aspectRatio,
			originalElement: this.element,
			_proportionallyResizeElements: [],
			_helper: o.helper || o.ghost || o.animate ? o.helper || "ui-resizable-helper" : null
		});

		// Wrap the element if it cannot hold child nodes
		if (this.element[0].nodeName.match(/^(canvas|textarea|input|select|button|img)$/i)) {

			this.element.wrap(
				$("<div class='ui-wrapper' style='overflow: hidden;'></div>").css({
					position: this.element.css("position"),
					width: this.element.outerWidth(),
					height: this.element.outerHeight(),
					top: this.element.css("top"),
					left: this.element.css("left")
				})
			);

			this.element = this.element.parent().data(
				"ui-resizable", this.element.resizable( "instance" )
			);

			this.elementIsWrapper = true;

			this.element.css({
				marginLeft: this.originalElement.css("marginLeft"),
				marginTop: this.originalElement.css("marginTop"),
				marginRight: this.originalElement.css("marginRight"),
				marginBottom: this.originalElement.css("marginBottom")
			});
			this.originalElement.css({
				marginLeft: 0,
				marginTop: 0,
				marginRight: 0,
				marginBottom: 0
			});
			// support: Safari
			// Prevent Safari textarea resize
			this.originalResizeStyle = this.originalElement.css("resize");
			this.originalElement.css("resize", "none");

			this._proportionallyResizeElements.push( this.originalElement.css({
				position: "static",
				zoom: 1,
				display: "block"
			}) );

			// support: IE9
			// avoid IE jump (hard set the margin)
			this.originalElement.css({ margin: this.originalElement.css("margin") });

			this._proportionallyResize();
		}

		this.handles = o.handles ||
			( !$(".ui-resizable-handle", this.element).length ?
				"e,s,se" : {
					n: ".ui-resizable-n",
					e: ".ui-resizable-e",
					s: ".ui-resizable-s",
					w: ".ui-resizable-w",
					se: ".ui-resizable-se",
					sw: ".ui-resizable-sw",
					ne: ".ui-resizable-ne",
					nw: ".ui-resizable-nw"
				} );

		this._handles = $();
		if ( this.handles.constructor === String ) {

			if ( this.handles === "all") {
				this.handles = "n,e,s,w,se,sw,ne,nw";
			}

			n = this.handles.split(",");
			this.handles = {};

			for (i = 0; i < n.length; i++) {

				handle = $.trim(n[i]);
				hname = "ui-resizable-" + handle;
				axis = $("<div class='ui-resizable-handle " + hname + "'></div>");

				axis.css({ zIndex: o.zIndex });

				// TODO : What's going on here?
				if ("se" === handle) {
					axis.addClass("ui-icon ui-icon-gripsmall-diagonal-se");
				}

				this.handles[handle] = ".ui-resizable-" + handle;
				this.element.append(axis);
			}

		}

		this._renderAxis = function(target) {

			var i, axis, padPos, padWrapper;

			target = target || this.element;

			for (i in this.handles) {

				if (this.handles[i].constructor === String) {
					this.handles[i] = this.element.children( this.handles[ i ] ).first().show();
				} else if ( this.handles[ i ].jquery || this.handles[ i ].nodeType ) {
					this.handles[ i ] = $( this.handles[ i ] );
					this._on( this.handles[ i ], { "mousedown": that._mouseDown });
				}

				if (this.elementIsWrapper && this.originalElement[0].nodeName.match(/^(textarea|input|select|button)$/i)) {

					axis = $(this.handles[i], this.element);

					padWrapper = /sw|ne|nw|se|n|s/.test(i) ? axis.outerHeight() : axis.outerWidth();

					padPos = [ "padding",
						/ne|nw|n/.test(i) ? "Top" :
						/se|sw|s/.test(i) ? "Bottom" :
						/^e$/.test(i) ? "Right" : "Left" ].join("");

					target.css(padPos, padWrapper);

					this._proportionallyResize();
				}

				this._handles = this._handles.add( this.handles[ i ] );
			}
		};

		// TODO: make renderAxis a prototype function
		this._renderAxis(this.element);

		this._handles = this._handles.add( this.element.find( ".ui-resizable-handle" ) );
		this._handles.disableSelection();

		this._handles.mouseover(function() {
			if (!that.resizing) {
				if (this.className) {
					axis = this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i);
				}
				that.axis = axis && axis[1] ? axis[1] : "se";
			}
		});

		if (o.autoHide) {
			this._handles.hide();
			$(this.element)
				.addClass("ui-resizable-autohide")
				.mouseenter(function() {
					if (o.disabled) {
						return;
					}
					$(this).removeClass("ui-resizable-autohide");
					that._handles.show();
				})
				.mouseleave(function() {
					if (o.disabled) {
						return;
					}
					if (!that.resizing) {
						$(this).addClass("ui-resizable-autohide");
						that._handles.hide();
					}
				});
		}

		this._mouseInit();
	},

	_destroy: function() {

		this._mouseDestroy();

		var wrapper,
			_destroy = function(exp) {
				$(exp)
					.removeClass("ui-resizable ui-resizable-disabled ui-resizable-resizing")
					.removeData("resizable")
					.removeData("ui-resizable")
					.unbind(".resizable")
					.find(".ui-resizable-handle")
						.remove();
			};

		// TODO: Unwrap at same DOM position
		if (this.elementIsWrapper) {
			_destroy(this.element);
			wrapper = this.element;
			this.originalElement.css({
				position: wrapper.css("position"),
				width: wrapper.outerWidth(),
				height: wrapper.outerHeight(),
				top: wrapper.css("top"),
				left: wrapper.css("left")
			}).insertAfter( wrapper );
			wrapper.remove();
		}

		this.originalElement.css("resize", this.originalResizeStyle);
		_destroy(this.originalElement);

		return this;
	},

	_mouseCapture: function(event) {
		var i, handle,
			capture = false;

		for (i in this.handles) {
			handle = $(this.handles[i])[0];
			if (handle === event.target || $.contains(handle, event.target)) {
				capture = true;
			}
		}

		return !this.options.disabled && capture;
	},

	_mouseStart: function(event) {

		var curleft, curtop, cursor,
			o = this.options,
			el = this.element;

		this.resizing = true;

		this._renderProxy();

		curleft = this._num(this.helper.css("left"));
		curtop = this._num(this.helper.css("top"));

		if (o.containment) {
			curleft += $(o.containment).scrollLeft() || 0;
			curtop += $(o.containment).scrollTop() || 0;
		}

		this.offset = this.helper.offset();
		this.position = { left: curleft, top: curtop };

		this.size = this._helper ? {
				width: this.helper.width(),
				height: this.helper.height()
			} : {
				width: el.width(),
				height: el.height()
			};

		this.originalSize = this._helper ? {
				width: el.outerWidth(),
				height: el.outerHeight()
			} : {
				width: el.width(),
				height: el.height()
			};

		this.sizeDiff = {
			width: el.outerWidth() - el.width(),
			height: el.outerHeight() - el.height()
		};

		this.originalPosition = { left: curleft, top: curtop };
		this.originalMousePosition = { left: event.pageX, top: event.pageY };

		this.aspectRatio = (typeof o.aspectRatio === "number") ?
			o.aspectRatio :
			((this.originalSize.width / this.originalSize.height) || 1);

		cursor = $(".ui-resizable-" + this.axis).css("cursor");
		$("body").css("cursor", cursor === "auto" ? this.axis + "-resize" : cursor);

		el.addClass("ui-resizable-resizing");
		this._propagate("start", event);
		return true;
	},

	_mouseDrag: function(event) {

		var data, props,
			smp = this.originalMousePosition,
			a = this.axis,
			dx = (event.pageX - smp.left) || 0,
			dy = (event.pageY - smp.top) || 0,
			trigger = this._change[a];

		this._updatePrevProperties();

		if (!trigger) {
			return false;
		}

		data = trigger.apply(this, [ event, dx, dy ]);

		this._updateVirtualBoundaries(event.shiftKey);
		if (this._aspectRatio || event.shiftKey) {
			data = this._updateRatio(data, event);
		}

		data = this._respectSize(data, event);

		this._updateCache(data);

		this._propagate("resize", event);

		props = this._applyChanges();

		if ( !this._helper && this._proportionallyResizeElements.length ) {
			this._proportionallyResize();
		}

		if ( !$.isEmptyObject( props ) ) {
			this._updatePrevProperties();
			this._trigger( "resize", event, this.ui() );
			this._applyChanges();
		}

		return false;
	},

	_mouseStop: function(event) {

		this.resizing = false;
		var pr, ista, soffseth, soffsetw, s, left, top,
			o = this.options, that = this;

		if (this._helper) {

			pr = this._proportionallyResizeElements;
			ista = pr.length && (/textarea/i).test(pr[0].nodeName);
			soffseth = ista && this._hasScroll(pr[0], "left") ? 0 : that.sizeDiff.height;
			soffsetw = ista ? 0 : that.sizeDiff.width;

			s = {
				width: (that.helper.width()  - soffsetw),
				height: (that.helper.height() - soffseth)
			};
			left = (parseInt(that.element.css("left"), 10) +
				(that.position.left - that.originalPosition.left)) || null;
			top = (parseInt(that.element.css("top"), 10) +
				(that.position.top - that.originalPosition.top)) || null;

			if (!o.animate) {
				this.element.css($.extend(s, { top: top, left: left }));
			}

			that.helper.height(that.size.height);
			that.helper.width(that.size.width);

			if (this._helper && !o.animate) {
				this._proportionallyResize();
			}
		}

		$("body").css("cursor", "auto");

		this.element.removeClass("ui-resizable-resizing");

		this._propagate("stop", event);

		if (this._helper) {
			this.helper.remove();
		}

		return false;

	},

	_updatePrevProperties: function() {
		this.prevPosition = {
			top: this.position.top,
			left: this.position.left
		};
		this.prevSize = {
			width: this.size.width,
			height: this.size.height
		};
	},

	_applyChanges: function() {
		var props = {};

		if ( this.position.top !== this.prevPosition.top ) {
			props.top = this.position.top + "px";
		}
		if ( this.position.left !== this.prevPosition.left ) {
			props.left = this.position.left + "px";
		}
		if ( this.size.width !== this.prevSize.width ) {
			props.width = this.size.width + "px";
		}
		if ( this.size.height !== this.prevSize.height ) {
			props.height = this.size.height + "px";
		}

		this.helper.css( props );

		return props;
	},

	_updateVirtualBoundaries: function(forceAspectRatio) {
		var pMinWidth, pMaxWidth, pMinHeight, pMaxHeight, b,
			o = this.options;

		b = {
			minWidth: this._isNumber(o.minWidth) ? o.minWidth : 0,
			maxWidth: this._isNumber(o.maxWidth) ? o.maxWidth : Infinity,
			minHeight: this._isNumber(o.minHeight) ? o.minHeight : 0,
			maxHeight: this._isNumber(o.maxHeight) ? o.maxHeight : Infinity
		};

		if (this._aspectRatio || forceAspectRatio) {
			pMinWidth = b.minHeight * this.aspectRatio;
			pMinHeight = b.minWidth / this.aspectRatio;
			pMaxWidth = b.maxHeight * this.aspectRatio;
			pMaxHeight = b.maxWidth / this.aspectRatio;

			if (pMinWidth > b.minWidth) {
				b.minWidth = pMinWidth;
			}
			if (pMinHeight > b.minHeight) {
				b.minHeight = pMinHeight;
			}
			if (pMaxWidth < b.maxWidth) {
				b.maxWidth = pMaxWidth;
			}
			if (pMaxHeight < b.maxHeight) {
				b.maxHeight = pMaxHeight;
			}
		}
		this._vBoundaries = b;
	},

	_updateCache: function(data) {
		this.offset = this.helper.offset();
		if (this._isNumber(data.left)) {
			this.position.left = data.left;
		}
		if (this._isNumber(data.top)) {
			this.position.top = data.top;
		}
		if (this._isNumber(data.height)) {
			this.size.height = data.height;
		}
		if (this._isNumber(data.width)) {
			this.size.width = data.width;
		}
	},

	_updateRatio: function( data ) {

		var cpos = this.position,
			csize = this.size,
			a = this.axis;

		if (this._isNumber(data.height)) {
			data.width = (data.height * this.aspectRatio);
		} else if (this._isNumber(data.width)) {
			data.height = (data.width / this.aspectRatio);
		}

		if (a === "sw") {
			data.left = cpos.left + (csize.width - data.width);
			data.top = null;
		}
		if (a === "nw") {
			data.top = cpos.top + (csize.height - data.height);
			data.left = cpos.left + (csize.width - data.width);
		}

		return data;
	},

	_respectSize: function( data ) {

		var o = this._vBoundaries,
			a = this.axis,
			ismaxw = this._isNumber(data.width) && o.maxWidth && (o.maxWidth < data.width),
			ismaxh = this._isNumber(data.height) && o.maxHeight && (o.maxHeight < data.height),
			isminw = this._isNumber(data.width) && o.minWidth && (o.minWidth > data.width),
			isminh = this._isNumber(data.height) && o.minHeight && (o.minHeight > data.height),
			dw = this.originalPosition.left + this.originalSize.width,
			dh = this.position.top + this.size.height,
			cw = /sw|nw|w/.test(a), ch = /nw|ne|n/.test(a);
		if (isminw) {
			data.width = o.minWidth;
		}
		if (isminh) {
			data.height = o.minHeight;
		}
		if (ismaxw) {
			data.width = o.maxWidth;
		}
		if (ismaxh) {
			data.height = o.maxHeight;
		}

		if (isminw && cw) {
			data.left = dw - o.minWidth;
		}
		if (ismaxw && cw) {
			data.left = dw - o.maxWidth;
		}
		if (isminh && ch) {
			data.top = dh - o.minHeight;
		}
		if (ismaxh && ch) {
			data.top = dh - o.maxHeight;
		}

		// Fixing jump error on top/left - bug #2330
		if (!data.width && !data.height && !data.left && data.top) {
			data.top = null;
		} else if (!data.width && !data.height && !data.top && data.left) {
			data.left = null;
		}

		return data;
	},

	_getPaddingPlusBorderDimensions: function( element ) {
		var i = 0,
			widths = [],
			borders = [
				element.css( "borderTopWidth" ),
				element.css( "borderRightWidth" ),
				element.css( "borderBottomWidth" ),
				element.css( "borderLeftWidth" )
			],
			paddings = [
				element.css( "paddingTop" ),
				element.css( "paddingRight" ),
				element.css( "paddingBottom" ),
				element.css( "paddingLeft" )
			];

		for ( ; i < 4; i++ ) {
			widths[ i ] = ( parseInt( borders[ i ], 10 ) || 0 );
			widths[ i ] += ( parseInt( paddings[ i ], 10 ) || 0 );
		}

		return {
			height: widths[ 0 ] + widths[ 2 ],
			width: widths[ 1 ] + widths[ 3 ]
		};
	},

	_proportionallyResize: function() {

		if (!this._proportionallyResizeElements.length) {
			return;
		}

		var prel,
			i = 0,
			element = this.helper || this.element;

		for ( ; i < this._proportionallyResizeElements.length; i++) {

			prel = this._proportionallyResizeElements[i];

			// TODO: Seems like a bug to cache this.outerDimensions
			// considering that we are in a loop.
			if (!this.outerDimensions) {
				this.outerDimensions = this._getPaddingPlusBorderDimensions( prel );
			}

			prel.css({
				height: (element.height() - this.outerDimensions.height) || 0,
				width: (element.width() - this.outerDimensions.width) || 0
			});

		}

	},

	_renderProxy: function() {

		var el = this.element, o = this.options;
		this.elementOffset = el.offset();

		if (this._helper) {

			this.helper = this.helper || $("<div style='overflow:hidden;'></div>");

			this.helper.addClass(this._helper).css({
				width: this.element.outerWidth() - 1,
				height: this.element.outerHeight() - 1,
				position: "absolute",
				left: this.elementOffset.left + "px",
				top: this.elementOffset.top + "px",
				zIndex: ++o.zIndex //TODO: Don't modify option
			});

			this.helper
				.appendTo("body")
				.disableSelection();

		} else {
			this.helper = this.element;
		}

	},

	_change: {
		e: function(event, dx) {
			return { width: this.originalSize.width + dx };
		},
		w: function(event, dx) {
			var cs = this.originalSize, sp = this.originalPosition;
			return { left: sp.left + dx, width: cs.width - dx };
		},
		n: function(event, dx, dy) {
			var cs = this.originalSize, sp = this.originalPosition;
			return { top: sp.top + dy, height: cs.height - dy };
		},
		s: function(event, dx, dy) {
			return { height: this.originalSize.height + dy };
		},
		se: function(event, dx, dy) {
			return $.extend(this._change.s.apply(this, arguments),
				this._change.e.apply(this, [ event, dx, dy ]));
		},
		sw: function(event, dx, dy) {
			return $.extend(this._change.s.apply(this, arguments),
				this._change.w.apply(this, [ event, dx, dy ]));
		},
		ne: function(event, dx, dy) {
			return $.extend(this._change.n.apply(this, arguments),
				this._change.e.apply(this, [ event, dx, dy ]));
		},
		nw: function(event, dx, dy) {
			return $.extend(this._change.n.apply(this, arguments),
				this._change.w.apply(this, [ event, dx, dy ]));
		}
	},

	_propagate: function(n, event) {
		$.ui.plugin.call(this, n, [ event, this.ui() ]);
		(n !== "resize" && this._trigger(n, event, this.ui()));
	},

	plugins: {},

	ui: function() {
		return {
			originalElement: this.originalElement,
			element: this.element,
			helper: this.helper,
			position: this.position,
			size: this.size,
			originalSize: this.originalSize,
			originalPosition: this.originalPosition
		};
	}

});

/*
 * Resizable Extensions
 */

$.ui.plugin.add("resizable", "animate", {

	stop: function( event ) {
		var that = $(this).resizable( "instance" ),
			o = that.options,
			pr = that._proportionallyResizeElements,
			ista = pr.length && (/textarea/i).test(pr[0].nodeName),
			soffseth = ista && that._hasScroll(pr[0], "left") ? 0 : that.sizeDiff.height,
			soffsetw = ista ? 0 : that.sizeDiff.width,
			style = { width: (that.size.width - soffsetw), height: (that.size.height - soffseth) },
			left = (parseInt(that.element.css("left"), 10) +
				(that.position.left - that.originalPosition.left)) || null,
			top = (parseInt(that.element.css("top"), 10) +
				(that.position.top - that.originalPosition.top)) || null;

		that.element.animate(
			$.extend(style, top && left ? { top: top, left: left } : {}), {
				duration: o.animateDuration,
				easing: o.animateEasing,
				step: function() {

					var data = {
						width: parseInt(that.element.css("width"), 10),
						height: parseInt(that.element.css("height"), 10),
						top: parseInt(that.element.css("top"), 10),
						left: parseInt(that.element.css("left"), 10)
					};

					if (pr && pr.length) {
						$(pr[0]).css({ width: data.width, height: data.height });
					}

					// propagating resize, and updating values for each animation step
					that._updateCache(data);
					that._propagate("resize", event);

				}
			}
		);
	}

});

$.ui.plugin.add( "resizable", "containment", {

	start: function() {
		var element, p, co, ch, cw, width, height,
			that = $( this ).resizable( "instance" ),
			o = that.options,
			el = that.element,
			oc = o.containment,
			ce = ( oc instanceof $ ) ? oc.get( 0 ) : ( /parent/.test( oc ) ) ? el.parent().get( 0 ) : oc;

		if ( !ce ) {
			return;
		}

		that.containerElement = $( ce );

		if ( /document/.test( oc ) || oc === document ) {
			that.containerOffset = {
				left: 0,
				top: 0
			};
			that.containerPosition = {
				left: 0,
				top: 0
			};

			that.parentData = {
				element: $( document ),
				left: 0,
				top: 0,
				width: $( document ).width(),
				height: $( document ).height() || document.body.parentNode.scrollHeight
			};
		} else {
			element = $( ce );
			p = [];
			$([ "Top", "Right", "Left", "Bottom" ]).each(function( i, name ) {
				p[ i ] = that._num( element.css( "padding" + name ) );
			});

			that.containerOffset = element.offset();
			that.containerPosition = element.position();
			that.containerSize = {
				height: ( element.innerHeight() - p[ 3 ] ),
				width: ( element.innerWidth() - p[ 1 ] )
			};

			co = that.containerOffset;
			ch = that.containerSize.height;
			cw = that.containerSize.width;
			width = ( that._hasScroll ( ce, "left" ) ? ce.scrollWidth : cw );
			height = ( that._hasScroll ( ce ) ? ce.scrollHeight : ch ) ;

			that.parentData = {
				element: ce,
				left: co.left,
				top: co.top,
				width: width,
				height: height
			};
		}
	},

	resize: function( event ) {
		var woset, hoset, isParent, isOffsetRelative,
			that = $( this ).resizable( "instance" ),
			o = that.options,
			co = that.containerOffset,
			cp = that.position,
			pRatio = that._aspectRatio || event.shiftKey,
			cop = {
				top: 0,
				left: 0
			},
			ce = that.containerElement,
			continueResize = true;

		if ( ce[ 0 ] !== document && ( /static/ ).test( ce.css( "position" ) ) ) {
			cop = co;
		}

		if ( cp.left < ( that._helper ? co.left : 0 ) ) {
			that.size.width = that.size.width +
				( that._helper ?
					( that.position.left - co.left ) :
					( that.position.left - cop.left ) );

			if ( pRatio ) {
				that.size.height = that.size.width / that.aspectRatio;
				continueResize = false;
			}
			that.position.left = o.helper ? co.left : 0;
		}

		if ( cp.top < ( that._helper ? co.top : 0 ) ) {
			that.size.height = that.size.height +
				( that._helper ?
					( that.position.top - co.top ) :
					that.position.top );

			if ( pRatio ) {
				that.size.width = that.size.height * that.aspectRatio;
				continueResize = false;
			}
			that.position.top = that._helper ? co.top : 0;
		}

		isParent = that.containerElement.get( 0 ) === that.element.parent().get( 0 );
		isOffsetRelative = /relative|absolute/.test( that.containerElement.css( "position" ) );

		if ( isParent && isOffsetRelative ) {
			that.offset.left = that.parentData.left + that.position.left;
			that.offset.top = that.parentData.top + that.position.top;
		} else {
			that.offset.left = that.element.offset().left;
			that.offset.top = that.element.offset().top;
		}

		woset = Math.abs( that.sizeDiff.width +
			(that._helper ?
				that.offset.left - cop.left :
				(that.offset.left - co.left)) );

		hoset = Math.abs( that.sizeDiff.height +
			(that._helper ?
				that.offset.top - cop.top :
				(that.offset.top - co.top)) );

		if ( woset + that.size.width >= that.parentData.width ) {
			that.size.width = that.parentData.width - woset;
			if ( pRatio ) {
				that.size.height = that.size.width / that.aspectRatio;
				continueResize = false;
			}
		}

		if ( hoset + that.size.height >= that.parentData.height ) {
			that.size.height = that.parentData.height - hoset;
			if ( pRatio ) {
				that.size.width = that.size.height * that.aspectRatio;
				continueResize = false;
			}
		}

		if ( !continueResize ) {
			that.position.left = that.prevPosition.left;
			that.position.top = that.prevPosition.top;
			that.size.width = that.prevSize.width;
			that.size.height = that.prevSize.height;
		}
	},

	stop: function() {
		var that = $( this ).resizable( "instance" ),
			o = that.options,
			co = that.containerOffset,
			cop = that.containerPosition,
			ce = that.containerElement,
			helper = $( that.helper ),
			ho = helper.offset(),
			w = helper.outerWidth() - that.sizeDiff.width,
			h = helper.outerHeight() - that.sizeDiff.height;

		if ( that._helper && !o.animate && ( /relative/ ).test( ce.css( "position" ) ) ) {
			$( this ).css({
				left: ho.left - cop.left - co.left,
				width: w,
				height: h
			});
		}

		if ( that._helper && !o.animate && ( /static/ ).test( ce.css( "position" ) ) ) {
			$( this ).css({
				left: ho.left - cop.left - co.left,
				width: w,
				height: h
			});
		}
	}
});

$.ui.plugin.add("resizable", "alsoResize", {

	start: function() {
		var that = $(this).resizable( "instance" ),
			o = that.options;

		$(o.alsoResize).each(function() {
			var el = $(this);
			el.data("ui-resizable-alsoresize", {
				width: parseInt(el.width(), 10), height: parseInt(el.height(), 10),
				left: parseInt(el.css("left"), 10), top: parseInt(el.css("top"), 10)
			});
		});
	},

	resize: function(event, ui) {
		var that = $(this).resizable( "instance" ),
			o = that.options,
			os = that.originalSize,
			op = that.originalPosition,
			delta = {
				height: (that.size.height - os.height) || 0,
				width: (that.size.width - os.width) || 0,
				top: (that.position.top - op.top) || 0,
				left: (that.position.left - op.left) || 0
			};

			$(o.alsoResize).each(function() {
				var el = $(this), start = $(this).data("ui-resizable-alsoresize"), style = {},
					css = el.parents(ui.originalElement[0]).length ?
							[ "width", "height" ] :
							[ "width", "height", "top", "left" ];

				$.each(css, function(i, prop) {
					var sum = (start[prop] || 0) + (delta[prop] || 0);
					if (sum && sum >= 0) {
						style[prop] = sum || null;
					}
				});

				el.css(style);
			});
	},

	stop: function() {
		$(this).removeData("resizable-alsoresize");
	}
});

$.ui.plugin.add("resizable", "ghost", {

	start: function() {

		var that = $(this).resizable( "instance" ), o = that.options, cs = that.size;

		that.ghost = that.originalElement.clone();
		that.ghost
			.css({
				opacity: 0.25,
				display: "block",
				position: "relative",
				height: cs.height,
				width: cs.width,
				margin: 0,
				left: 0,
				top: 0
			})
			.addClass("ui-resizable-ghost")
			.addClass(typeof o.ghost === "string" ? o.ghost : "");

		that.ghost.appendTo(that.helper);

	},

	resize: function() {
		var that = $(this).resizable( "instance" );
		if (that.ghost) {
			that.ghost.css({
				position: "relative",
				height: that.size.height,
				width: that.size.width
			});
		}
	},

	stop: function() {
		var that = $(this).resizable( "instance" );
		if (that.ghost && that.helper) {
			that.helper.get(0).removeChild(that.ghost.get(0));
		}
	}

});

$.ui.plugin.add("resizable", "grid", {

	resize: function() {
		var outerDimensions,
			that = $(this).resizable( "instance" ),
			o = that.options,
			cs = that.size,
			os = that.originalSize,
			op = that.originalPosition,
			a = that.axis,
			grid = typeof o.grid === "number" ? [ o.grid, o.grid ] : o.grid,
			gridX = (grid[0] || 1),
			gridY = (grid[1] || 1),
			ox = Math.round((cs.width - os.width) / gridX) * gridX,
			oy = Math.round((cs.height - os.height) / gridY) * gridY,
			newWidth = os.width + ox,
			newHeight = os.height + oy,
			isMaxWidth = o.maxWidth && (o.maxWidth < newWidth),
			isMaxHeight = o.maxHeight && (o.maxHeight < newHeight),
			isMinWidth = o.minWidth && (o.minWidth > newWidth),
			isMinHeight = o.minHeight && (o.minHeight > newHeight);

		o.grid = grid;

		if (isMinWidth) {
			newWidth += gridX;
		}
		if (isMinHeight) {
			newHeight += gridY;
		}
		if (isMaxWidth) {
			newWidth -= gridX;
		}
		if (isMaxHeight) {
			newHeight -= gridY;
		}

		if (/^(se|s|e)$/.test(a)) {
			that.size.width = newWidth;
			that.size.height = newHeight;
		} else if (/^(ne)$/.test(a)) {
			that.size.width = newWidth;
			that.size.height = newHeight;
			that.position.top = op.top - oy;
		} else if (/^(sw)$/.test(a)) {
			that.size.width = newWidth;
			that.size.height = newHeight;
			that.position.left = op.left - ox;
		} else {
			if ( newHeight - gridY <= 0 || newWidth - gridX <= 0) {
				outerDimensions = that._getPaddingPlusBorderDimensions( this );
			}

			if ( newHeight - gridY > 0 ) {
				that.size.height = newHeight;
				that.position.top = op.top - oy;
			} else {
				newHeight = gridY - outerDimensions.height;
				that.size.height = newHeight;
				that.position.top = op.top + os.height - newHeight;
			}
			if ( newWidth - gridX > 0 ) {
				that.size.width = newWidth;
				that.position.left = op.left - ox;
			} else {
				newWidth = gridX - outerDimensions.width;
				that.size.width = newWidth;
				that.position.left = op.left + os.width - newWidth;
			}
		}
	}

});

return $.ui.resizable;

}));







/*!
 * jQuery UI Dialog 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/dialog/
 */

(function( factory ) {
	if ( typeof define === "function" && define.amd ) {

		// AMD. Register as an anonymous module.
		define([
			"jquery",
			"./core",
			"./widget",
			"./button",
			"./draggable",
			"./mouse",
			"./position",
			"./resizable"
		], factory );
	} else {

		// Browser globals
		factory( jQuery );
	}
}(function( $ ) {

return $.widget( "ui.dialog", {
	version: "1.11.4",
	options: {
		appendTo: "body",
		autoOpen: true,
		buttons: [],
		closeOnEscape: true,
		closeText: "Close",
		dialogClass: "",
		draggable: true,
		hide: null,
		height: "auto",
		maxHeight: null,
		maxWidth: null,
		minHeight: 150,
		minWidth: 150,
		modal: false,
		position: {
			my: "center",
			at: "center",
			of: window,
			collision: "fit",
			// Ensure the titlebar is always visible
			using: function( pos ) {
				var topOffset = $( this ).css( pos ).offset().top;
				if ( topOffset < 0 ) {
					$( this ).css( "top", pos.top - topOffset );
				}
			}
		},
		resizable: true,
		show: null,
		title: null,
		width: 300,

		// callbacks
		beforeClose: null,
		close: null,
		drag: null,
		dragStart: null,
		dragStop: null,
		focus: null,
		open: null,
		resize: null,
		resizeStart: null,
		resizeStop: null
	},

	sizeRelatedOptions: {
		buttons: true,
		height: true,
		maxHeight: true,
		maxWidth: true,
		minHeight: true,
		minWidth: true,
		width: true
	},

	resizableRelatedOptions: {
		maxHeight: true,
		maxWidth: true,
		minHeight: true,
		minWidth: true
	},

	_create: function() {
		this.originalCss = {
			display: this.element[ 0 ].style.display,
			width: this.element[ 0 ].style.width,
			minHeight: this.element[ 0 ].style.minHeight,
			maxHeight: this.element[ 0 ].style.maxHeight,
			height: this.element[ 0 ].style.height
		};
		this.originalPosition = {
			parent: this.element.parent(),
			index: this.element.parent().children().index( this.element )
		};
		this.originalTitle = this.element.attr( "title" );
		this.options.title = this.options.title || this.originalTitle;

		this._createWrapper();

		this.element
			.show()
			.removeAttr( "title" )
			.addClass( "ui-dialog-content ui-widget-content" )
			.appendTo( this.uiDialog );

		this._createTitlebar();
		this._createButtonPane();

		if ( this.options.draggable && $.fn.draggable ) {
			this._makeDraggable();
		}
		if ( this.options.resizable && $.fn.resizable ) {
			this._makeResizable();
		}

		this._isOpen = false;

		this._trackFocus();
	},

	_init: function() {
		if ( this.options.autoOpen ) {
			this.open();
		}
	},

	_appendTo: function() {
		var element = this.options.appendTo;
		if ( element && (element.jquery || element.nodeType) ) {
			return $( element );
		}
		return this.document.find( element || "body" ).eq( 0 );
	},

	_destroy: function() {
		var next,
			originalPosition = this.originalPosition;

		this._untrackInstance();
		this._destroyOverlay();

		this.element
			.removeUniqueId()
			.removeClass( "ui-dialog-content ui-widget-content" )
			.css( this.originalCss )
			// Without detaching first, the following becomes really slow
			.detach();

		this.uiDialog.stop( true, true ).remove();

		if ( this.originalTitle ) {
			this.element.attr( "title", this.originalTitle );
		}

		next = originalPosition.parent.children().eq( originalPosition.index );
		// Don't try to place the dialog next to itself (#8613)
		if ( next.length && next[ 0 ] !== this.element[ 0 ] ) {
			next.before( this.element );
		} else {
			originalPosition.parent.append( this.element );
		}
	},

	widget: function() {
		return this.uiDialog;
	},

	disable: $.noop,
	enable: $.noop,

	close: function( event ) {
		var activeElement,
			that = this;

		if ( !this._isOpen || this._trigger( "beforeClose", event ) === false ) {
			return;
		}

		this._isOpen = false;
		this._focusedElement = null;
		this._destroyOverlay();
		this._untrackInstance();

		if ( !this.opener.filter( ":focusable" ).focus().length ) {

			// support: IE9
			// IE9 throws an "Unspecified error" accessing document.activeElement from an <iframe>
			try {
				activeElement = this.document[ 0 ].activeElement;

				// Support: IE9, IE10
				// If the <body> is blurred, IE will switch windows, see #4520
				if ( activeElement && activeElement.nodeName.toLowerCase() !== "body" ) {

					// Hiding a focused element doesn't trigger blur in WebKit
					// so in case we have nothing to focus on, explicitly blur the active element
					// https://bugs.webkit.org/show_bug.cgi?id=47182
					$( activeElement ).blur();
				}
			} catch ( error ) {}
		}

		this._hide( this.uiDialog, this.options.hide, function() {
			that._trigger( "close", event );
		});
	},

	isOpen: function() {
		return this._isOpen;
	},

	moveToTop: function() {
		this._moveToTop();
	},

	_moveToTop: function( event, silent ) {
		var moved = false,
			zIndices = this.uiDialog.siblings( ".ui-front:visible" ).map(function() {
				return +$( this ).css( "z-index" );
			}).get(),
			zIndexMax = Math.max.apply( null, zIndices );

		if ( zIndexMax >= +this.uiDialog.css( "z-index" ) ) {
			this.uiDialog.css( "z-index", zIndexMax + 1 );
			moved = true;
		}

		if ( moved && !silent ) {
			this._trigger( "focus", event );
		}
		return moved;
	},

	open: function() {
		var that = this;
		if ( this._isOpen ) {
			if ( this._moveToTop() ) {
				this._focusTabbable();
			}
			return;
		}

		this._isOpen = true;
		this.opener = $( this.document[ 0 ].activeElement );

		this._size();
		this._position();
		this._createOverlay();
		this._moveToTop( null, true );

		// Ensure the overlay is moved to the top with the dialog, but only when
		// opening. The overlay shouldn't move after the dialog is open so that
		// modeless dialogs opened after the modal dialog stack properly.
		if ( this.overlay ) {
			this.overlay.css( "z-index", this.uiDialog.css( "z-index" ) - 1 );
		}

		this._show( this.uiDialog, this.options.show, function() {
			that._focusTabbable();
			that._trigger( "focus" );
		});

		// Track the dialog immediately upon openening in case a focus event
		// somehow occurs outside of the dialog before an element inside the
		// dialog is focused (#10152)
		this._makeFocusTarget();

		this._trigger( "open" );
	},

	_focusTabbable: function() {
		// Set focus to the first match:
		// 1. An element that was focused previously
		// 2. First element inside the dialog matching [autofocus]
		// 3. Tabbable element inside the content element
		// 4. Tabbable element inside the buttonpane
		// 5. The close button
		// 6. The dialog itself
		var hasFocus = this._focusedElement;
		if ( !hasFocus ) {
			hasFocus = this.element.find( "[autofocus]" );
		}
		if ( !hasFocus.length ) {
			hasFocus = this.element.find( ":tabbable" );
		}
		if ( !hasFocus.length ) {
			hasFocus = this.uiDialogButtonPane.find( ":tabbable" );
		}
		if ( !hasFocus.length ) {
			hasFocus = this.uiDialogTitlebarClose.filter( ":tabbable" );
		}
		if ( !hasFocus.length ) {
			hasFocus = this.uiDialog;
		}
		hasFocus.eq( 0 ).focus();
	},

	_keepFocus: function( event ) {
		function checkFocus() {
			var activeElement = this.document[0].activeElement,
				isActive = this.uiDialog[0] === activeElement ||
					$.contains( this.uiDialog[0], activeElement );
			if ( !isActive ) {
				this._focusTabbable();
			}
		}
		event.preventDefault();
		checkFocus.call( this );
		// support: IE
		// IE <= 8 doesn't prevent moving focus even with event.preventDefault()
		// so we check again later
		this._delay( checkFocus );
	},

	_createWrapper: function() {
		this.uiDialog = $("<div>")
			.addClass( "ui-dialog ui-widget ui-widget-content ui-corner-all ui-front " +
				this.options.dialogClass )
			.hide()
			.attr({
				// Setting tabIndex makes the div focusable
				tabIndex: -1,
				role: "dialog"
			})
			.appendTo( this._appendTo() );

		this._on( this.uiDialog, {
			keydown: function( event ) {
				if ( this.options.closeOnEscape && !event.isDefaultPrevented() && event.keyCode &&
						event.keyCode === $.ui.keyCode.ESCAPE ) {
					event.preventDefault();
					this.close( event );
					return;
				}

				// prevent tabbing out of dialogs
				if ( event.keyCode !== $.ui.keyCode.TAB || event.isDefaultPrevented() ) {
					return;
				}
				var tabbables = this.uiDialog.find( ":tabbable" ),
					first = tabbables.filter( ":first" ),
					last = tabbables.filter( ":last" );

				if ( ( event.target === last[0] || event.target === this.uiDialog[0] ) && !event.shiftKey ) {
					this._delay(function() {
						first.focus();
					});
					event.preventDefault();
				} else if ( ( event.target === first[0] || event.target === this.uiDialog[0] ) && event.shiftKey ) {
					this._delay(function() {
						last.focus();
					});
					event.preventDefault();
				}
			},
			mousedown: function( event ) {
				if ( this._moveToTop( event ) ) {
					this._focusTabbable();
				}
			}
		});

		// We assume that any existing aria-describedby attribute means
		// that the dialog content is marked up properly
		// otherwise we brute force the content as the description
		if ( !this.element.find( "[aria-describedby]" ).length ) {
			this.uiDialog.attr({
				"aria-describedby": this.element.uniqueId().attr( "id" )
			});
		}
	},

	_createTitlebar: function() {
		var uiDialogTitle;

		this.uiDialogTitlebar = $( "<div>" )
			.addClass( "ui-dialog-titlebar ui-widget-header ui-corner-all ui-helper-clearfix" )
			.prependTo( this.uiDialog );
		this._on( this.uiDialogTitlebar, {
			mousedown: function( event ) {
				// Don't prevent click on close button (#8838)
				// Focusing a dialog that is partially scrolled out of view
				// causes the browser to scroll it into view, preventing the click event
				if ( !$( event.target ).closest( ".ui-dialog-titlebar-close" ) ) {
					// Dialog isn't getting focus when dragging (#8063)
					this.uiDialog.focus();
				}
			}
		});

		// support: IE
		// Use type="button" to prevent enter keypresses in textboxes from closing the
		// dialog in IE (#9312)
		this.uiDialogTitlebarClose = $( "<button type='button'></button>" )
			.button({
				label: this.options.closeText,
				icons: {
					primary: "ui-icon-closethick"
				},
				text: false
			})
			.addClass( "ui-dialog-titlebar-close" )
			.appendTo( this.uiDialogTitlebar );
		this._on( this.uiDialogTitlebarClose, {
			click: function( event ) {
				event.preventDefault();
				this.close( event );
			}
		});

		uiDialogTitle = $( "<span>" )
			.uniqueId()
			.addClass( "ui-dialog-title" )
			.prependTo( this.uiDialogTitlebar );
		this._title( uiDialogTitle );

		this.uiDialog.attr({
			"aria-labelledby": uiDialogTitle.attr( "id" )
		});
	},

	_title: function( title ) {
		if ( !this.options.title ) {
			title.html( "&#160;" );
		}
		title.text( this.options.title );
	},

	_createButtonPane: function() {
		this.uiDialogButtonPane = $( "<div>" )
			.addClass( "ui-dialog-buttonpane ui-widget-content ui-helper-clearfix" );

		this.uiButtonSet = $( "<div>" )
			.addClass( "ui-dialog-buttonset" )
			.appendTo( this.uiDialogButtonPane );

		this._createButtons();
	},

	_createButtons: function() {
		var that = this,
			buttons = this.options.buttons;

		// if we already have a button pane, remove it
		this.uiDialogButtonPane.remove();
		this.uiButtonSet.empty();

		if ( $.isEmptyObject( buttons ) || ($.isArray( buttons ) && !buttons.length) ) {
			this.uiDialog.removeClass( "ui-dialog-buttons" );
			return;
		}

		$.each( buttons, function( name, props ) {
			var click, buttonOptions;
			props = $.isFunction( props ) ?
				{ click: props, text: name } :
				props;
			// Default to a non-submitting button
			props = $.extend( { type: "button" }, props );
			// Change the context for the click callback to be the main element
			click = props.click;
			props.click = function() {
				click.apply( that.element[ 0 ], arguments );
			};
			buttonOptions = {
				icons: props.icons,
				text: props.showText
			};
			delete props.icons;
			delete props.showText;
			$( "<button></button>", props )
				.button( buttonOptions )
				.appendTo( that.uiButtonSet );
		});
		this.uiDialog.addClass( "ui-dialog-buttons" );
		this.uiDialogButtonPane.appendTo( this.uiDialog );
	},

	_makeDraggable: function() {
		var that = this,
			options = this.options;

		function filteredUi( ui ) {
			return {
				position: ui.position,
				offset: ui.offset
			};
		}

		this.uiDialog.draggable({
			cancel: ".ui-dialog-content, .ui-dialog-titlebar-close",
			handle: ".ui-dialog-titlebar",
			containment: "document",
			start: function( event, ui ) {
				$( this ).addClass( "ui-dialog-dragging" );
				that._blockFrames();
				that._trigger( "dragStart", event, filteredUi( ui ) );
			},
			drag: function( event, ui ) {
				that._trigger( "drag", event, filteredUi( ui ) );
			},
			stop: function( event, ui ) {
				var left = ui.offset.left - that.document.scrollLeft(),
					top = ui.offset.top - that.document.scrollTop();

				options.position = {
					my: "left top",
					at: "left" + (left >= 0 ? "+" : "") + left + " " +
						"top" + (top >= 0 ? "+" : "") + top,
					of: that.window
				};
				$( this ).removeClass( "ui-dialog-dragging" );
				that._unblockFrames();
				that._trigger( "dragStop", event, filteredUi( ui ) );
			}
		});
	},

	_makeResizable: function() {
		var that = this,
			options = this.options,
			handles = options.resizable,
			// .ui-resizable has position: relative defined in the stylesheet
			// but dialogs have to use absolute or fixed positioning
			position = this.uiDialog.css("position"),
			resizeHandles = typeof handles === "string" ?
				handles	:
				"n,e,s,w,se,sw,ne,nw";

		function filteredUi( ui ) {
			return {
				originalPosition: ui.originalPosition,
				originalSize: ui.originalSize,
				position: ui.position,
				size: ui.size
			};
		}

		this.uiDialog.resizable({
			cancel: ".ui-dialog-content",
			containment: "document",
			alsoResize: this.element,
			maxWidth: options.maxWidth,
			maxHeight: options.maxHeight,
			minWidth: options.minWidth,
			minHeight: this._minHeight(),
			handles: resizeHandles,
			start: function( event, ui ) {
				$( this ).addClass( "ui-dialog-resizing" );
				that._blockFrames();
				that._trigger( "resizeStart", event, filteredUi( ui ) );
			},
			resize: function( event, ui ) {
				that._trigger( "resize", event, filteredUi( ui ) );
			},
			stop: function( event, ui ) {
				var offset = that.uiDialog.offset(),
					left = offset.left - that.document.scrollLeft(),
					top = offset.top - that.document.scrollTop();

				options.height = that.uiDialog.height();
				options.width = that.uiDialog.width();
				options.position = {
					my: "left top",
					at: "left" + (left >= 0 ? "+" : "") + left + " " +
						"top" + (top >= 0 ? "+" : "") + top,
					of: that.window
				};
				$( this ).removeClass( "ui-dialog-resizing" );
				that._unblockFrames();
				that._trigger( "resizeStop", event, filteredUi( ui ) );
			}
		})
		.css( "position", position );
	},

	_trackFocus: function() {
		this._on( this.widget(), {
			focusin: function( event ) {
				this._makeFocusTarget();
				this._focusedElement = $( event.target );
			}
		});
	},

	_makeFocusTarget: function() {
		this._untrackInstance();
		this._trackingInstances().unshift( this );
	},

	_untrackInstance: function() {
		var instances = this._trackingInstances(),
			exists = $.inArray( this, instances );
		if ( exists !== -1 ) {
			instances.splice( exists, 1 );
		}
	},

	_trackingInstances: function() {
		var instances = this.document.data( "ui-dialog-instances" );
		if ( !instances ) {
			instances = [];
			this.document.data( "ui-dialog-instances", instances );
		}
		return instances;
	},

	_minHeight: function() {
		var options = this.options;

		return options.height === "auto" ?
			options.minHeight :
			Math.min( options.minHeight, options.height );
	},

	_position: function() {
		// Need to show the dialog to get the actual offset in the position plugin
		var isVisible = this.uiDialog.is( ":visible" );
		if ( !isVisible ) {
			this.uiDialog.show();
		}
		this.uiDialog.position( this.options.position );
		if ( !isVisible ) {
			this.uiDialog.hide();
		}
	},

	_setOptions: function( options ) {
		var that = this,
			resize = false,
			resizableOptions = {};

		$.each( options, function( key, value ) {
			that._setOption( key, value );

			if ( key in that.sizeRelatedOptions ) {
				resize = true;
			}
			if ( key in that.resizableRelatedOptions ) {
				resizableOptions[ key ] = value;
			}
		});

		if ( resize ) {
			this._size();
			this._position();
		}
		if ( this.uiDialog.is( ":data(ui-resizable)" ) ) {
			this.uiDialog.resizable( "option", resizableOptions );
		}
	},

	_setOption: function( key, value ) {
		var isDraggable, isResizable,
			uiDialog = this.uiDialog;

		if ( key === "dialogClass" ) {
			uiDialog
				.removeClass( this.options.dialogClass )
				.addClass( value );
		}

		if ( key === "disabled" ) {
			return;
		}

		this._super( key, value );

		if ( key === "appendTo" ) {
			this.uiDialog.appendTo( this._appendTo() );
		}

		if ( key === "buttons" ) {
			this._createButtons();
		}

		if ( key === "closeText" ) {
			this.uiDialogTitlebarClose.button({
				// Ensure that we always pass a string
				label: "" + value
			});
		}

		if ( key === "draggable" ) {
			isDraggable = uiDialog.is( ":data(ui-draggable)" );
			if ( isDraggable && !value ) {
				uiDialog.draggable( "destroy" );
			}

			if ( !isDraggable && value ) {
				this._makeDraggable();
			}
		}

		if ( key === "position" ) {
			this._position();
		}

		if ( key === "resizable" ) {
			// currently resizable, becoming non-resizable
			isResizable = uiDialog.is( ":data(ui-resizable)" );
			if ( isResizable && !value ) {
				uiDialog.resizable( "destroy" );
			}

			// currently resizable, changing handles
			if ( isResizable && typeof value === "string" ) {
				uiDialog.resizable( "option", "handles", value );
			}

			// currently non-resizable, becoming resizable
			if ( !isResizable && value !== false ) {
				this._makeResizable();
			}
		}

		if ( key === "title" ) {
			this._title( this.uiDialogTitlebar.find( ".ui-dialog-title" ) );
		}
	},

	_size: function() {
		// If the user has resized the dialog, the .ui-dialog and .ui-dialog-content
		// divs will both have width and height set, so we need to reset them
		var nonContentHeight, minContentHeight, maxContentHeight,
			options = this.options;

		// Reset content sizing
		this.element.show().css({
			width: "auto",
			minHeight: 0,
			maxHeight: "none",
			height: 0
		});

		if ( options.minWidth > options.width ) {
			options.width = options.minWidth;
		}

		// reset wrapper sizing
		// determine the height of all the non-content elements
		nonContentHeight = this.uiDialog.css({
				height: "auto",
				width: options.width
			})
			.outerHeight();
		minContentHeight = Math.max( 0, options.minHeight - nonContentHeight );
		maxContentHeight = typeof options.maxHeight === "number" ?
			Math.max( 0, options.maxHeight - nonContentHeight ) :
			"none";

		if ( options.height === "auto" ) {
			this.element.css({
				minHeight: minContentHeight,
				maxHeight: maxContentHeight,
				height: "auto"
			});
		} else {
			this.element.height( Math.max( 0, options.height - nonContentHeight ) );
		}

		if ( this.uiDialog.is( ":data(ui-resizable)" ) ) {
			this.uiDialog.resizable( "option", "minHeight", this._minHeight() );
		}
	},

	_blockFrames: function() {
		this.iframeBlocks = this.document.find( "iframe" ).map(function() {
			var iframe = $( this );

			return $( "<div>" )
				.css({
					position: "absolute",
					width: iframe.outerWidth(),
					height: iframe.outerHeight()
				})
				.appendTo( iframe.parent() )
				.offset( iframe.offset() )[0];
		});
	},

	_unblockFrames: function() {
		if ( this.iframeBlocks ) {
			this.iframeBlocks.remove();
			delete this.iframeBlocks;
		}
	},

	_allowInteraction: function( event ) {
		if ( $( event.target ).closest( ".ui-dialog" ).length ) {
			return true;
		}

		// TODO: Remove hack when datepicker implements
		// the .ui-front logic (#8989)
		return !!$( event.target ).closest( ".ui-datepicker" ).length;
	},

	_createOverlay: function() {
		if ( !this.options.modal ) {
			return;
		}

		// We use a delay in case the overlay is created from an
		// event that we're going to be cancelling (#2804)
		var isOpening = true;
		this._delay(function() {
			isOpening = false;
		});

		if ( !this.document.data( "ui-dialog-overlays" ) ) {

			// Prevent use of anchors and inputs
			// Using _on() for an event handler shared across many instances is
			// safe because the dialogs stack and must be closed in reverse order
			this._on( this.document, {
				focusin: function( event ) {
					if ( isOpening ) {
						return;
					}

					if ( !this._allowInteraction( event ) ) {
						event.preventDefault();
						this._trackingInstances()[ 0 ]._focusTabbable();
					}
				}
			});
		}

		this.overlay = $( "<div>" )
			.addClass( "ui-widget-overlay ui-front" )
			.appendTo( this._appendTo() );
		this._on( this.overlay, {
			mousedown: "_keepFocus"
		});
		this.document.data( "ui-dialog-overlays",
			(this.document.data( "ui-dialog-overlays" ) || 0) + 1 );
	},

	_destroyOverlay: function() {
		if ( !this.options.modal ) {
			return;
		}

		if ( this.overlay ) {
			var overlays = this.document.data( "ui-dialog-overlays" ) - 1;

			if ( !overlays ) {
				this.document
					.unbind( "focusin" )
					.removeData( "ui-dialog-overlays" );
			} else {
				this.document.data( "ui-dialog-overlays", overlays );
			}

			this.overlay.remove();
			this.overlay = null;
		}
	}
});

}));





/*!
 * jQuery UI Droppable 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/droppable/
 */

(function( factory ) {
	if ( typeof define === "function" && define.amd ) {

		// AMD. Register as an anonymous module.
		define([
			"jquery",
			"./core",
			"./widget",
			"./mouse",
			"./draggable"
		], factory );
	} else {

		// Browser globals
		factory( jQuery );
	}
}(function( $ ) {

$.widget( "ui.droppable", {
	version: "1.11.4",
	widgetEventPrefix: "drop",
	options: {
		accept: "*",
		activeClass: false,
		addClasses: true,
		greedy: false,
		hoverClass: false,
		scope: "default",
		tolerance: "intersect",

		// callbacks
		activate: null,
		deactivate: null,
		drop: null,
		out: null,
		over: null
	},
	_create: function() {

		var proportions,
			o = this.options,
			accept = o.accept;

		this.isover = false;
		this.isout = true;

		this.accept = $.isFunction( accept ) ? accept : function( d ) {
			return d.is( accept );
		};

		this.proportions = function( /* valueToWrite */ ) {
			if ( arguments.length ) {
				// Store the droppable's proportions
				proportions = arguments[ 0 ];
			} else {
				// Retrieve or derive the droppable's proportions
				return proportions ?
					proportions :
					proportions = {
						width: this.element[ 0 ].offsetWidth,
						height: this.element[ 0 ].offsetHeight
					};
			}
		};

		this._addToManager( o.scope );

		o.addClasses && this.element.addClass( "ui-droppable" );

	},

	_addToManager: function( scope ) {
		// Add the reference and positions to the manager
		$.ui.ddmanager.droppables[ scope ] = $.ui.ddmanager.droppables[ scope ] || [];
		$.ui.ddmanager.droppables[ scope ].push( this );
	},

	_splice: function( drop ) {
		var i = 0;
		for ( ; i < drop.length; i++ ) {
			if ( drop[ i ] === this ) {
				drop.splice( i, 1 );
			}
		}
	},

	_destroy: function() {
		var drop = $.ui.ddmanager.droppables[ this.options.scope ];

		this._splice( drop );

		this.element.removeClass( "ui-droppable ui-droppable-disabled" );
	},

	_setOption: function( key, value ) {

		if ( key === "accept" ) {
			this.accept = $.isFunction( value ) ? value : function( d ) {
				return d.is( value );
			};
		} else if ( key === "scope" ) {
			var drop = $.ui.ddmanager.droppables[ this.options.scope ];

			this._splice( drop );
			this._addToManager( value );
		}

		this._super( key, value );
	},

	_activate: function( event ) {
		var draggable = $.ui.ddmanager.current;
		if ( this.options.activeClass ) {
			this.element.addClass( this.options.activeClass );
		}
		if ( draggable ){
			this._trigger( "activate", event, this.ui( draggable ) );
		}
	},

	_deactivate: function( event ) {
		var draggable = $.ui.ddmanager.current;
		if ( this.options.activeClass ) {
			this.element.removeClass( this.options.activeClass );
		}
		if ( draggable ){
			this._trigger( "deactivate", event, this.ui( draggable ) );
		}
	},

	_over: function( event ) {

		var draggable = $.ui.ddmanager.current;

		// Bail if draggable and droppable are same element
		if ( !draggable || ( draggable.currentItem || draggable.element )[ 0 ] === this.element[ 0 ] ) {
			return;
		}

		if ( this.accept.call( this.element[ 0 ], ( draggable.currentItem || draggable.element ) ) ) {
			if ( this.options.hoverClass ) {
				this.element.addClass( this.options.hoverClass );
			}
			this._trigger( "over", event, this.ui( draggable ) );
		}

	},

	_out: function( event ) {

		var draggable = $.ui.ddmanager.current;

		// Bail if draggable and droppable are same element
		if ( !draggable || ( draggable.currentItem || draggable.element )[ 0 ] === this.element[ 0 ] ) {
			return;
		}

		if ( this.accept.call( this.element[ 0 ], ( draggable.currentItem || draggable.element ) ) ) {
			if ( this.options.hoverClass ) {
				this.element.removeClass( this.options.hoverClass );
			}
			this._trigger( "out", event, this.ui( draggable ) );
		}

	},

	_drop: function( event, custom ) {

		var draggable = custom || $.ui.ddmanager.current,
			childrenIntersection = false;

		// Bail if draggable and droppable are same element
		if ( !draggable || ( draggable.currentItem || draggable.element )[ 0 ] === this.element[ 0 ] ) {
			return false;
		}

		this.element.find( ":data(ui-droppable)" ).not( ".ui-draggable-dragging" ).each(function() {
			var inst = $( this ).droppable( "instance" );
			if (
				inst.options.greedy &&
				!inst.options.disabled &&
				inst.options.scope === draggable.options.scope &&
				inst.accept.call( inst.element[ 0 ], ( draggable.currentItem || draggable.element ) ) &&
				$.ui.intersect( draggable, $.extend( inst, { offset: inst.element.offset() } ), inst.options.tolerance, event )
			) { childrenIntersection = true; return false; }
		});
		if ( childrenIntersection ) {
			return false;
		}

		if ( this.accept.call( this.element[ 0 ], ( draggable.currentItem || draggable.element ) ) ) {
			if ( this.options.activeClass ) {
				this.element.removeClass( this.options.activeClass );
			}
			if ( this.options.hoverClass ) {
				this.element.removeClass( this.options.hoverClass );
			}
			this._trigger( "drop", event, this.ui( draggable ) );
			return this.element;
		}

		return false;

	},

	ui: function( c ) {
		return {
			draggable: ( c.currentItem || c.element ),
			helper: c.helper,
			position: c.position,
			offset: c.positionAbs
		};
	}

});

$.ui.intersect = (function() {
	function isOverAxis( x, reference, size ) {
		return ( x >= reference ) && ( x < ( reference + size ) );
	}

	return function( draggable, droppable, toleranceMode, event ) {

		if ( !droppable.offset ) {
			return false;
		}

		var x1 = ( draggable.positionAbs || draggable.position.absolute ).left + draggable.margins.left,
			y1 = ( draggable.positionAbs || draggable.position.absolute ).top + draggable.margins.top,
			x2 = x1 + draggable.helperProportions.width,
			y2 = y1 + draggable.helperProportions.height,
			l = droppable.offset.left,
			t = droppable.offset.top,
			r = l + droppable.proportions().width,
			b = t + droppable.proportions().height;

		switch ( toleranceMode ) {
		case "fit":
			return ( l <= x1 && x2 <= r && t <= y1 && y2 <= b );
		case "intersect":
			return ( l < x1 + ( draggable.helperProportions.width / 2 ) && // Right Half
				x2 - ( draggable.helperProportions.width / 2 ) < r && // Left Half
				t < y1 + ( draggable.helperProportions.height / 2 ) && // Bottom Half
				y2 - ( draggable.helperProportions.height / 2 ) < b ); // Top Half
		case "pointer":
			return isOverAxis( event.pageY, t, droppable.proportions().height ) && isOverAxis( event.pageX, l, droppable.proportions().width );
		case "touch":
			return (
				( y1 >= t && y1 <= b ) || // Top edge touching
				( y2 >= t && y2 <= b ) || // Bottom edge touching
				( y1 < t && y2 > b ) // Surrounded vertically
			) && (
				( x1 >= l && x1 <= r ) || // Left edge touching
				( x2 >= l && x2 <= r ) || // Right edge touching
				( x1 < l && x2 > r ) // Surrounded horizontally
			);
		default:
			return false;
		}
	};
})();

/*
	This manager tracks offsets of draggables and droppables
*/
$.ui.ddmanager = {
	current: null,
	droppables: { "default": [] },
	prepareOffsets: function( t, event ) {

		var i, j,
			m = $.ui.ddmanager.droppables[ t.options.scope ] || [],
			type = event ? event.type : null, // workaround for #2317
			list = ( t.currentItem || t.element ).find( ":data(ui-droppable)" ).addBack();

		droppablesLoop: for ( i = 0; i < m.length; i++ ) {

			// No disabled and non-accepted
			if ( m[ i ].options.disabled || ( t && !m[ i ].accept.call( m[ i ].element[ 0 ], ( t.currentItem || t.element ) ) ) ) {
				continue;
			}

			// Filter out elements in the current dragged item
			for ( j = 0; j < list.length; j++ ) {
				if ( list[ j ] === m[ i ].element[ 0 ] ) {
					m[ i ].proportions().height = 0;
					continue droppablesLoop;
				}
			}

			m[ i ].visible = m[ i ].element.css( "display" ) !== "none";
			if ( !m[ i ].visible ) {
				continue;
			}

			// Activate the droppable if used directly from draggables
			if ( type === "mousedown" ) {
				m[ i ]._activate.call( m[ i ], event );
			}

			m[ i ].offset = m[ i ].element.offset();
			m[ i ].proportions({ width: m[ i ].element[ 0 ].offsetWidth, height: m[ i ].element[ 0 ].offsetHeight });

		}

	},
	drop: function( draggable, event ) {

		var dropped = false;
		// Create a copy of the droppables in case the list changes during the drop (#9116)
		$.each( ( $.ui.ddmanager.droppables[ draggable.options.scope ] || [] ).slice(), function() {

			if ( !this.options ) {
				return;
			}
			if ( !this.options.disabled && this.visible && $.ui.intersect( draggable, this, this.options.tolerance, event ) ) {
				dropped = this._drop.call( this, event ) || dropped;
			}

			if ( !this.options.disabled && this.visible && this.accept.call( this.element[ 0 ], ( draggable.currentItem || draggable.element ) ) ) {
				this.isout = true;
				this.isover = false;
				this._deactivate.call( this, event );
			}

		});
		return dropped;

	},
	dragStart: function( draggable, event ) {
		// Listen for scrolling so that if the dragging causes scrolling the position of the droppables can be recalculated (see #5003)
		draggable.element.parentsUntil( "body" ).bind( "scroll.droppable", function() {
			if ( !draggable.options.refreshPositions ) {
				$.ui.ddmanager.prepareOffsets( draggable, event );
			}
		});
	},
	drag: function( draggable, event ) {

		// If you have a highly dynamic page, you might try this option. It renders positions every time you move the mouse.
		if ( draggable.options.refreshPositions ) {
			$.ui.ddmanager.prepareOffsets( draggable, event );
		}

		// Run through all droppables and check their positions based on specific tolerance options
		$.each( $.ui.ddmanager.droppables[ draggable.options.scope ] || [], function() {

			if ( this.options.disabled || this.greedyChild || !this.visible ) {
				return;
			}

			var parentInstance, scope, parent,
				intersects = $.ui.intersect( draggable, this, this.options.tolerance, event ),
				c = !intersects && this.isover ? "isout" : ( intersects && !this.isover ? "isover" : null );
			if ( !c ) {
				return;
			}

			if ( this.options.greedy ) {
				// find droppable parents with same scope
				scope = this.options.scope;
				parent = this.element.parents( ":data(ui-droppable)" ).filter(function() {
					return $( this ).droppable( "instance" ).options.scope === scope;
				});

				if ( parent.length ) {
					parentInstance = $( parent[ 0 ] ).droppable( "instance" );
					parentInstance.greedyChild = ( c === "isover" );
				}
			}

			// we just moved into a greedy child
			if ( parentInstance && c === "isover" ) {
				parentInstance.isover = false;
				parentInstance.isout = true;
				parentInstance._out.call( parentInstance, event );
			}

			this[ c ] = true;
			this[c === "isout" ? "isover" : "isout"] = false;
			this[c === "isover" ? "_over" : "_out"].call( this, event );

			// we just moved out of a greedy child
			if ( parentInstance && c === "isout" ) {
				parentInstance.isout = false;
				parentInstance.isover = true;
				parentInstance._over.call( parentInstance, event );
			}
		});

	},
	dragStop: function( draggable, event ) {
		draggable.element.parentsUntil( "body" ).unbind( "scroll.droppable" );
		// Call prepareOffsets one final time since IE does not fire return scroll events when overflow was caused by drag (see #5003)
		if ( !draggable.options.refreshPositions ) {
			$.ui.ddmanager.prepareOffsets( draggable, event );
		}
	}
};

return $.ui.droppable;

}));
/*!
 * jQuery UI Effects 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/category/effects-core/
 */

(function( factory ) {
	if ( typeof define === "function" && define.amd ) {

		// AMD. Register as an anonymous module.
		define( [ "jquery" ], factory );
	} else {

		// Browser globals
		factory( jQuery );
	}
}(function( $ ) {

var dataSpace = "ui-effects-",

	// Create a local jQuery because jQuery Color relies on it and the
	// global may not exist with AMD and a custom build (#10199)
	jQuery = $;

$.effects = {
	effect: {}
};

/*!
 * jQuery Color Animations v2.1.2
 * https://github.com/jquery/jquery-color
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * Date: Wed Jan 16 08:47:09 2013 -0600
 */
(function( jQuery, undefined ) {

	var stepHooks = "backgroundColor borderBottomColor borderLeftColor borderRightColor borderTopColor color columnRuleColor outlineColor textDecorationColor textEmphasisColor",

	// plusequals test for += 100 -= 100
	rplusequals = /^([\-+])=\s*(\d+\.?\d*)/,
	// a set of RE's that can match strings and generate color tuples.
	stringParsers = [ {
			re: /rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
			parse: function( execResult ) {
				return [
					execResult[ 1 ],
					execResult[ 2 ],
					execResult[ 3 ],
					execResult[ 4 ]
				];
			}
		}, {
			re: /rgba?\(\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
			parse: function( execResult ) {
				return [
					execResult[ 1 ] * 2.55,
					execResult[ 2 ] * 2.55,
					execResult[ 3 ] * 2.55,
					execResult[ 4 ]
				];
			}
		}, {
			// this regex ignores A-F because it's compared against an already lowercased string
			re: /#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})/,
			parse: function( execResult ) {
				return [
					parseInt( execResult[ 1 ], 16 ),
					parseInt( execResult[ 2 ], 16 ),
					parseInt( execResult[ 3 ], 16 )
				];
			}
		}, {
			// this regex ignores A-F because it's compared against an already lowercased string
			re: /#([a-f0-9])([a-f0-9])([a-f0-9])/,
			parse: function( execResult ) {
				return [
					parseInt( execResult[ 1 ] + execResult[ 1 ], 16 ),
					parseInt( execResult[ 2 ] + execResult[ 2 ], 16 ),
					parseInt( execResult[ 3 ] + execResult[ 3 ], 16 )
				];
			}
		}, {
			re: /hsla?\(\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
			space: "hsla",
			parse: function( execResult ) {
				return [
					execResult[ 1 ],
					execResult[ 2 ] / 100,
					execResult[ 3 ] / 100,
					execResult[ 4 ]
				];
			}
		} ],

	// jQuery.Color( )
	color = jQuery.Color = function( color, green, blue, alpha ) {
		return new jQuery.Color.fn.parse( color, green, blue, alpha );
	},
	spaces = {
		rgba: {
			props: {
				red: {
					idx: 0,
					type: "byte"
				},
				green: {
					idx: 1,
					type: "byte"
				},
				blue: {
					idx: 2,
					type: "byte"
				}
			}
		},

		hsla: {
			props: {
				hue: {
					idx: 0,
					type: "degrees"
				},
				saturation: {
					idx: 1,
					type: "percent"
				},
				lightness: {
					idx: 2,
					type: "percent"
				}
			}
		}
	},
	propTypes = {
		"byte": {
			floor: true,
			max: 255
		},
		"percent": {
			max: 1
		},
		"degrees": {
			mod: 360,
			floor: true
		}
	},
	support = color.support = {},

	// element for support tests
	supportElem = jQuery( "<p>" )[ 0 ],

	// colors = jQuery.Color.names
	colors,

	// local aliases of functions called often
	each = jQuery.each;

// determine rgba support immediately
supportElem.style.cssText = "background-color:rgba(1,1,1,.5)";
support.rgba = supportElem.style.backgroundColor.indexOf( "rgba" ) > -1;

// define cache name and alpha properties
// for rgba and hsla spaces
each( spaces, function( spaceName, space ) {
	space.cache = "_" + spaceName;
	space.props.alpha = {
		idx: 3,
		type: "percent",
		def: 1
	};
});

function clamp( value, prop, allowEmpty ) {
	var type = propTypes[ prop.type ] || {};

	if ( value == null ) {
		return (allowEmpty || !prop.def) ? null : prop.def;
	}

	// ~~ is an short way of doing floor for positive numbers
	value = type.floor ? ~~value : parseFloat( value );

	// IE will pass in empty strings as value for alpha,
	// which will hit this case
	if ( isNaN( value ) ) {
		return prop.def;
	}

	if ( type.mod ) {
		// we add mod before modding to make sure that negatives values
		// get converted properly: -10 -> 350
		return (value + type.mod) % type.mod;
	}

	// for now all property types without mod have min and max
	return 0 > value ? 0 : type.max < value ? type.max : value;
}

function stringParse( string ) {
	var inst = color(),
		rgba = inst._rgba = [];

	string = string.toLowerCase();

	each( stringParsers, function( i, parser ) {
		var parsed,
			match = parser.re.exec( string ),
			values = match && parser.parse( match ),
			spaceName = parser.space || "rgba";

		if ( values ) {
			parsed = inst[ spaceName ]( values );

			// if this was an rgba parse the assignment might happen twice
			// oh well....
			inst[ spaces[ spaceName ].cache ] = parsed[ spaces[ spaceName ].cache ];
			rgba = inst._rgba = parsed._rgba;

			// exit each( stringParsers ) here because we matched
			return false;
		}
	});

	// Found a stringParser that handled it
	if ( rgba.length ) {

		// if this came from a parsed string, force "transparent" when alpha is 0
		// chrome, (and maybe others) return "transparent" as rgba(0,0,0,0)
		if ( rgba.join() === "0,0,0,0" ) {
			jQuery.extend( rgba, colors.transparent );
		}
		return inst;
	}

	// named colors
	return colors[ string ];
}

color.fn = jQuery.extend( color.prototype, {
	parse: function( red, green, blue, alpha ) {
		if ( red === undefined ) {
			this._rgba = [ null, null, null, null ];
			return this;
		}
		if ( red.jquery || red.nodeType ) {
			red = jQuery( red ).css( green );
			green = undefined;
		}

		var inst = this,
			type = jQuery.type( red ),
			rgba = this._rgba = [];

		// more than 1 argument specified - assume ( red, green, blue, alpha )
		if ( green !== undefined ) {
			red = [ red, green, blue, alpha ];
			type = "array";
		}

		if ( type === "string" ) {
			return this.parse( stringParse( red ) || colors._default );
		}

		if ( type === "array" ) {
			each( spaces.rgba.props, function( key, prop ) {
				rgba[ prop.idx ] = clamp( red[ prop.idx ], prop );
			});
			return this;
		}

		if ( type === "object" ) {
			if ( red instanceof color ) {
				each( spaces, function( spaceName, space ) {
					if ( red[ space.cache ] ) {
						inst[ space.cache ] = red[ space.cache ].slice();
					}
				});
			} else {
				each( spaces, function( spaceName, space ) {
					var cache = space.cache;
					each( space.props, function( key, prop ) {

						// if the cache doesn't exist, and we know how to convert
						if ( !inst[ cache ] && space.to ) {

							// if the value was null, we don't need to copy it
							// if the key was alpha, we don't need to copy it either
							if ( key === "alpha" || red[ key ] == null ) {
								return;
							}
							inst[ cache ] = space.to( inst._rgba );
						}

						// this is the only case where we allow nulls for ALL properties.
						// call clamp with alwaysAllowEmpty
						inst[ cache ][ prop.idx ] = clamp( red[ key ], prop, true );
					});

					// everything defined but alpha?
					if ( inst[ cache ] && jQuery.inArray( null, inst[ cache ].slice( 0, 3 ) ) < 0 ) {
						// use the default of 1
						inst[ cache ][ 3 ] = 1;
						if ( space.from ) {
							inst._rgba = space.from( inst[ cache ] );
						}
					}
				});
			}
			return this;
		}
	},
	is: function( compare ) {
		var is = color( compare ),
			same = true,
			inst = this;

		each( spaces, function( _, space ) {
			var localCache,
				isCache = is[ space.cache ];
			if (isCache) {
				localCache = inst[ space.cache ] || space.to && space.to( inst._rgba ) || [];
				each( space.props, function( _, prop ) {
					if ( isCache[ prop.idx ] != null ) {
						same = ( isCache[ prop.idx ] === localCache[ prop.idx ] );
						return same;
					}
				});
			}
			return same;
		});
		return same;
	},
	_space: function() {
		var used = [],
			inst = this;
		each( spaces, function( spaceName, space ) {
			if ( inst[ space.cache ] ) {
				used.push( spaceName );
			}
		});
		return used.pop();
	},
	transition: function( other, distance ) {
		var end = color( other ),
			spaceName = end._space(),
			space = spaces[ spaceName ],
			startColor = this.alpha() === 0 ? color( "transparent" ) : this,
			start = startColor[ space.cache ] || space.to( startColor._rgba ),
			result = start.slice();

		end = end[ space.cache ];
		each( space.props, function( key, prop ) {
			var index = prop.idx,
				startValue = start[ index ],
				endValue = end[ index ],
				type = propTypes[ prop.type ] || {};

			// if null, don't override start value
			if ( endValue === null ) {
				return;
			}
			// if null - use end
			if ( startValue === null ) {
				result[ index ] = endValue;
			} else {
				if ( type.mod ) {
					if ( endValue - startValue > type.mod / 2 ) {
						startValue += type.mod;
					} else if ( startValue - endValue > type.mod / 2 ) {
						startValue -= type.mod;
					}
				}
				result[ index ] = clamp( ( endValue - startValue ) * distance + startValue, prop );
			}
		});
		return this[ spaceName ]( result );
	},
	blend: function( opaque ) {
		// if we are already opaque - return ourself
		if ( this._rgba[ 3 ] === 1 ) {
			return this;
		}

		var rgb = this._rgba.slice(),
			a = rgb.pop(),
			blend = color( opaque )._rgba;

		return color( jQuery.map( rgb, function( v, i ) {
			return ( 1 - a ) * blend[ i ] + a * v;
		}));
	},
	toRgbaString: function() {
		var prefix = "rgba(",
			rgba = jQuery.map( this._rgba, function( v, i ) {
				return v == null ? ( i > 2 ? 1 : 0 ) : v;
			});

		if ( rgba[ 3 ] === 1 ) {
			rgba.pop();
			prefix = "rgb(";
		}

		return prefix + rgba.join() + ")";
	},
	toHslaString: function() {
		var prefix = "hsla(",
			hsla = jQuery.map( this.hsla(), function( v, i ) {
				if ( v == null ) {
					v = i > 2 ? 1 : 0;
				}

				// catch 1 and 2
				if ( i && i < 3 ) {
					v = Math.round( v * 100 ) + "%";
				}
				return v;
			});

		if ( hsla[ 3 ] === 1 ) {
			hsla.pop();
			prefix = "hsl(";
		}
		return prefix + hsla.join() + ")";
	},
	toHexString: function( includeAlpha ) {
		var rgba = this._rgba.slice(),
			alpha = rgba.pop();

		if ( includeAlpha ) {
			rgba.push( ~~( alpha * 255 ) );
		}

		return "#" + jQuery.map( rgba, function( v ) {

			// default to 0 when nulls exist
			v = ( v || 0 ).toString( 16 );
			return v.length === 1 ? "0" + v : v;
		}).join("");
	},
	toString: function() {
		return this._rgba[ 3 ] === 0 ? "transparent" : this.toRgbaString();
	}
});
color.fn.parse.prototype = color.fn;

// hsla conversions adapted from:
// https://code.google.com/p/maashaack/source/browse/packages/graphics/trunk/src/graphics/colors/HUE2RGB.as?r=5021

function hue2rgb( p, q, h ) {
	h = ( h + 1 ) % 1;
	if ( h * 6 < 1 ) {
		return p + ( q - p ) * h * 6;
	}
	if ( h * 2 < 1) {
		return q;
	}
	if ( h * 3 < 2 ) {
		return p + ( q - p ) * ( ( 2 / 3 ) - h ) * 6;
	}
	return p;
}

spaces.hsla.to = function( rgba ) {
	if ( rgba[ 0 ] == null || rgba[ 1 ] == null || rgba[ 2 ] == null ) {
		return [ null, null, null, rgba[ 3 ] ];
	}
	var r = rgba[ 0 ] / 255,
		g = rgba[ 1 ] / 255,
		b = rgba[ 2 ] / 255,
		a = rgba[ 3 ],
		max = Math.max( r, g, b ),
		min = Math.min( r, g, b ),
		diff = max - min,
		add = max + min,
		l = add * 0.5,
		h, s;

	if ( min === max ) {
		h = 0;
	} else if ( r === max ) {
		h = ( 60 * ( g - b ) / diff ) + 360;
	} else if ( g === max ) {
		h = ( 60 * ( b - r ) / diff ) + 120;
	} else {
		h = ( 60 * ( r - g ) / diff ) + 240;
	}

	// chroma (diff) == 0 means greyscale which, by definition, saturation = 0%
	// otherwise, saturation is based on the ratio of chroma (diff) to lightness (add)
	if ( diff === 0 ) {
		s = 0;
	} else if ( l <= 0.5 ) {
		s = diff / add;
	} else {
		s = diff / ( 2 - add );
	}
	return [ Math.round(h) % 360, s, l, a == null ? 1 : a ];
};

spaces.hsla.from = function( hsla ) {
	if ( hsla[ 0 ] == null || hsla[ 1 ] == null || hsla[ 2 ] == null ) {
		return [ null, null, null, hsla[ 3 ] ];
	}
	var h = hsla[ 0 ] / 360,
		s = hsla[ 1 ],
		l = hsla[ 2 ],
		a = hsla[ 3 ],
		q = l <= 0.5 ? l * ( 1 + s ) : l + s - l * s,
		p = 2 * l - q;

	return [
		Math.round( hue2rgb( p, q, h + ( 1 / 3 ) ) * 255 ),
		Math.round( hue2rgb( p, q, h ) * 255 ),
		Math.round( hue2rgb( p, q, h - ( 1 / 3 ) ) * 255 ),
		a
	];
};

each( spaces, function( spaceName, space ) {
	var props = space.props,
		cache = space.cache,
		to = space.to,
		from = space.from;

	// makes rgba() and hsla()
	color.fn[ spaceName ] = function( value ) {

		// generate a cache for this space if it doesn't exist
		if ( to && !this[ cache ] ) {
			this[ cache ] = to( this._rgba );
		}
		if ( value === undefined ) {
			return this[ cache ].slice();
		}

		var ret,
			type = jQuery.type( value ),
			arr = ( type === "array" || type === "object" ) ? value : arguments,
			local = this[ cache ].slice();

		each( props, function( key, prop ) {
			var val = arr[ type === "object" ? key : prop.idx ];
			if ( val == null ) {
				val = local[ prop.idx ];
			}
			local[ prop.idx ] = clamp( val, prop );
		});

		if ( from ) {
			ret = color( from( local ) );
			ret[ cache ] = local;
			return ret;
		} else {
			return color( local );
		}
	};

	// makes red() green() blue() alpha() hue() saturation() lightness()
	each( props, function( key, prop ) {
		// alpha is included in more than one space
		if ( color.fn[ key ] ) {
			return;
		}
		color.fn[ key ] = function( value ) {
			var vtype = jQuery.type( value ),
				fn = ( key === "alpha" ? ( this._hsla ? "hsla" : "rgba" ) : spaceName ),
				local = this[ fn ](),
				cur = local[ prop.idx ],
				match;

			if ( vtype === "undefined" ) {
				return cur;
			}

			if ( vtype === "function" ) {
				value = value.call( this, cur );
				vtype = jQuery.type( value );
			}
			if ( value == null && prop.empty ) {
				return this;
			}
			if ( vtype === "string" ) {
				match = rplusequals.exec( value );
				if ( match ) {
					value = cur + parseFloat( match[ 2 ] ) * ( match[ 1 ] === "+" ? 1 : -1 );
				}
			}
			local[ prop.idx ] = value;
			return this[ fn ]( local );
		};
	});
});

// add cssHook and .fx.step function for each named hook.
// accept a space separated string of properties
color.hook = function( hook ) {
	var hooks = hook.split( " " );
	each( hooks, function( i, hook ) {
		jQuery.cssHooks[ hook ] = {
			set: function( elem, value ) {
				var parsed, curElem,
					backgroundColor = "";

				if ( value !== "transparent" && ( jQuery.type( value ) !== "string" || ( parsed = stringParse( value ) ) ) ) {
					value = color( parsed || value );
					if ( !support.rgba && value._rgba[ 3 ] !== 1 ) {
						curElem = hook === "backgroundColor" ? elem.parentNode : elem;
						while (
							(backgroundColor === "" || backgroundColor === "transparent") &&
							curElem && curElem.style
						) {
							try {
								backgroundColor = jQuery.css( curElem, "backgroundColor" );
								curElem = curElem.parentNode;
							} catch ( e ) {
							}
						}

						value = value.blend( backgroundColor && backgroundColor !== "transparent" ?
							backgroundColor :
							"_default" );
					}

					value = value.toRgbaString();
				}
				try {
					elem.style[ hook ] = value;
				} catch ( e ) {
					// wrapped to prevent IE from throwing errors on "invalid" values like 'auto' or 'inherit'
				}
			}
		};
		jQuery.fx.step[ hook ] = function( fx ) {
			if ( !fx.colorInit ) {
				fx.start = color( fx.elem, hook );
				fx.end = color( fx.end );
				fx.colorInit = true;
			}
			jQuery.cssHooks[ hook ].set( fx.elem, fx.start.transition( fx.end, fx.pos ) );
		};
	});

};

color.hook( stepHooks );

jQuery.cssHooks.borderColor = {
	expand: function( value ) {
		var expanded = {};

		each( [ "Top", "Right", "Bottom", "Left" ], function( i, part ) {
			expanded[ "border" + part + "Color" ] = value;
		});
		return expanded;
	}
};

// Basic color names only.
// Usage of any of the other color names requires adding yourself or including
// jquery.color.svg-names.js.
colors = jQuery.Color.names = {
	// 4.1. Basic color keywords
	aqua: "#00ffff",
	black: "#000000",
	blue: "#0000ff",
	fuchsia: "#ff00ff",
	gray: "#808080",
	green: "#008000",
	lime: "#00ff00",
	maroon: "#800000",
	navy: "#000080",
	olive: "#808000",
	purple: "#800080",
	red: "#ff0000",
	silver: "#c0c0c0",
	teal: "#008080",
	white: "#ffffff",
	yellow: "#ffff00",

	// 4.2.3. "transparent" color keyword
	transparent: [ null, null, null, 0 ],

	_default: "#ffffff"
};

})( jQuery );

/******************************************************************************/
/****************************** CLASS ANIMATIONS ******************************/
/******************************************************************************/
(function() {

var classAnimationActions = [ "add", "remove", "toggle" ],
	shorthandStyles = {
		border: 1,
		borderBottom: 1,
		borderColor: 1,
		borderLeft: 1,
		borderRight: 1,
		borderTop: 1,
		borderWidth: 1,
		margin: 1,
		padding: 1
	};

$.each([ "borderLeftStyle", "borderRightStyle", "borderBottomStyle", "borderTopStyle" ], function( _, prop ) {
	$.fx.step[ prop ] = function( fx ) {
		if ( fx.end !== "none" && !fx.setAttr || fx.pos === 1 && !fx.setAttr ) {
			jQuery.style( fx.elem, prop, fx.end );
			fx.setAttr = true;
		}
	};
});

function getElementStyles( elem ) {
	var key, len,
		style = elem.ownerDocument.defaultView ?
			elem.ownerDocument.defaultView.getComputedStyle( elem, null ) :
			elem.currentStyle,
		styles = {};

	if ( style && style.length && style[ 0 ] && style[ style[ 0 ] ] ) {
		len = style.length;
		while ( len-- ) {
			key = style[ len ];
			if ( typeof style[ key ] === "string" ) {
				styles[ $.camelCase( key ) ] = style[ key ];
			}
		}
	// support: Opera, IE <9
	} else {
		for ( key in style ) {
			if ( typeof style[ key ] === "string" ) {
				styles[ key ] = style[ key ];
			}
		}
	}

	return styles;
}

function styleDifference( oldStyle, newStyle ) {
	var diff = {},
		name, value;

	for ( name in newStyle ) {
		value = newStyle[ name ];
		if ( oldStyle[ name ] !== value ) {
			if ( !shorthandStyles[ name ] ) {
				if ( $.fx.step[ name ] || !isNaN( parseFloat( value ) ) ) {
					diff[ name ] = value;
				}
			}
		}
	}

	return diff;
}

// support: jQuery <1.8
if ( !$.fn.addBack ) {
	$.fn.addBack = function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	};
}

$.effects.animateClass = function( value, duration, easing, callback ) {
	var o = $.speed( duration, easing, callback );

	return this.queue( function() {
		var animated = $( this ),
			baseClass = animated.attr( "class" ) || "",
			applyClassChange,
			allAnimations = o.children ? animated.find( "*" ).addBack() : animated;

		// map the animated objects to store the original styles.
		allAnimations = allAnimations.map(function() {
			var el = $( this );
			return {
				el: el,
				start: getElementStyles( this )
			};
		});

		// apply class change
		applyClassChange = function() {
			$.each( classAnimationActions, function(i, action) {
				if ( value[ action ] ) {
					animated[ action + "Class" ]( value[ action ] );
				}
			});
		};
		applyClassChange();

		// map all animated objects again - calculate new styles and diff
		allAnimations = allAnimations.map(function() {
			this.end = getElementStyles( this.el[ 0 ] );
			this.diff = styleDifference( this.start, this.end );
			return this;
		});

		// apply original class
		animated.attr( "class", baseClass );

		// map all animated objects again - this time collecting a promise
		allAnimations = allAnimations.map(function() {
			var styleInfo = this,
				dfd = $.Deferred(),
				opts = $.extend({}, o, {
					queue: false,
					complete: function() {
						dfd.resolve( styleInfo );
					}
				});

			this.el.animate( this.diff, opts );
			return dfd.promise();
		});

		// once all animations have completed:
		$.when.apply( $, allAnimations.get() ).done(function() {

			// set the final class
			applyClassChange();

			// for each animated element,
			// clear all css properties that were animated
			$.each( arguments, function() {
				var el = this.el;
				$.each( this.diff, function(key) {
					el.css( key, "" );
				});
			});

			// this is guarnteed to be there if you use jQuery.speed()
			// it also handles dequeuing the next anim...
			o.complete.call( animated[ 0 ] );
		});
	});
};

$.fn.extend({
	addClass: (function( orig ) {
		return function( classNames, speed, easing, callback ) {
			return speed ?
				$.effects.animateClass.call( this,
					{ add: classNames }, speed, easing, callback ) :
				orig.apply( this, arguments );
		};
	})( $.fn.addClass ),

	removeClass: (function( orig ) {
		return function( classNames, speed, easing, callback ) {
			return arguments.length > 1 ?
				$.effects.animateClass.call( this,
					{ remove: classNames }, speed, easing, callback ) :
				orig.apply( this, arguments );
		};
	})( $.fn.removeClass ),

	toggleClass: (function( orig ) {
		return function( classNames, force, speed, easing, callback ) {
			if ( typeof force === "boolean" || force === undefined ) {
				if ( !speed ) {
					// without speed parameter
					return orig.apply( this, arguments );
				} else {
					return $.effects.animateClass.call( this,
						(force ? { add: classNames } : { remove: classNames }),
						speed, easing, callback );
				}
			} else {
				// without force parameter
				return $.effects.animateClass.call( this,
					{ toggle: classNames }, force, speed, easing );
			}
		};
	})( $.fn.toggleClass ),

	switchClass: function( remove, add, speed, easing, callback) {
		return $.effects.animateClass.call( this, {
			add: add,
			remove: remove
		}, speed, easing, callback );
	}
});

})();

/******************************************************************************/
/*********************************** EFFECTS **********************************/
/******************************************************************************/

(function() {

$.extend( $.effects, {
	version: "1.11.4",

	// Saves a set of properties in a data storage
	save: function( element, set ) {
		for ( var i = 0; i < set.length; i++ ) {
			if ( set[ i ] !== null ) {
				element.data( dataSpace + set[ i ], element[ 0 ].style[ set[ i ] ] );
			}
		}
	},

	// Restores a set of previously saved properties from a data storage
	restore: function( element, set ) {
		var val, i;
		for ( i = 0; i < set.length; i++ ) {
			if ( set[ i ] !== null ) {
				val = element.data( dataSpace + set[ i ] );
				// support: jQuery 1.6.2
				// http://bugs.jquery.com/ticket/9917
				// jQuery 1.6.2 incorrectly returns undefined for any falsy value.
				// We can't differentiate between "" and 0 here, so we just assume
				// empty string since it's likely to be a more common value...
				if ( val === undefined ) {
					val = "";
				}
				element.css( set[ i ], val );
			}
		}
	},

	setMode: function( el, mode ) {
		if (mode === "toggle") {
			mode = el.is( ":hidden" ) ? "show" : "hide";
		}
		return mode;
	},

	// Translates a [top,left] array into a baseline value
	// this should be a little more flexible in the future to handle a string & hash
	getBaseline: function( origin, original ) {
		var y, x;
		switch ( origin[ 0 ] ) {
			case "top": y = 0; break;
			case "middle": y = 0.5; break;
			case "bottom": y = 1; break;
			default: y = origin[ 0 ] / original.height;
		}
		switch ( origin[ 1 ] ) {
			case "left": x = 0; break;
			case "center": x = 0.5; break;
			case "right": x = 1; break;
			default: x = origin[ 1 ] / original.width;
		}
		return {
			x: x,
			y: y
		};
	},

	// Wraps the element around a wrapper that copies position properties
	createWrapper: function( element ) {

		// if the element is already wrapped, return it
		if ( element.parent().is( ".ui-effects-wrapper" )) {
			return element.parent();
		}

		// wrap the element
		var props = {
				width: element.outerWidth(true),
				height: element.outerHeight(true),
				"float": element.css( "float" )
			},
			wrapper = $( "<div></div>" )
				.addClass( "ui-effects-wrapper" )
				.css({
					fontSize: "100%",
					background: "transparent",
					border: "none",
					margin: 0,
					padding: 0
				}),
			// Store the size in case width/height are defined in % - Fixes #5245
			size = {
				width: element.width(),
				height: element.height()
			},
			active = document.activeElement;

		// support: Firefox
		// Firefox incorrectly exposes anonymous content
		// https://bugzilla.mozilla.org/show_bug.cgi?id=561664
		try {
			active.id;
		} catch ( e ) {
			active = document.body;
		}

		element.wrap( wrapper );

		// Fixes #7595 - Elements lose focus when wrapped.
		if ( element[ 0 ] === active || $.contains( element[ 0 ], active ) ) {
			$( active ).focus();
		}

		wrapper = element.parent(); //Hotfix for jQuery 1.4 since some change in wrap() seems to actually lose the reference to the wrapped element

		// transfer positioning properties to the wrapper
		if ( element.css( "position" ) === "static" ) {
			wrapper.css({ position: "relative" });
			element.css({ position: "relative" });
		} else {
			$.extend( props, {
				position: element.css( "position" ),
				zIndex: element.css( "z-index" )
			});
			$.each([ "top", "left", "bottom", "right" ], function(i, pos) {
				props[ pos ] = element.css( pos );
				if ( isNaN( parseInt( props[ pos ], 10 ) ) ) {
					props[ pos ] = "auto";
				}
			});
			element.css({
				position: "relative",
				top: 0,
				left: 0,
				right: "auto",
				bottom: "auto"
			});
		}
		element.css(size);

		return wrapper.css( props ).show();
	},

	removeWrapper: function( element ) {
		var active = document.activeElement;

		if ( element.parent().is( ".ui-effects-wrapper" ) ) {
			element.parent().replaceWith( element );

			// Fixes #7595 - Elements lose focus when wrapped.
			if ( element[ 0 ] === active || $.contains( element[ 0 ], active ) ) {
				$( active ).focus();
			}
		}

		return element;
	},

	setTransition: function( element, list, factor, value ) {
		value = value || {};
		$.each( list, function( i, x ) {
			var unit = element.cssUnit( x );
			if ( unit[ 0 ] > 0 ) {
				value[ x ] = unit[ 0 ] * factor + unit[ 1 ];
			}
		});
		return value;
	}
});

// return an effect options object for the given parameters:
function _normalizeArguments( effect, options, speed, callback ) {

	// allow passing all options as the first parameter
	if ( $.isPlainObject( effect ) ) {
		options = effect;
		effect = effect.effect;
	}

	// convert to an object
	effect = { effect: effect };

	// catch (effect, null, ...)
	if ( options == null ) {
		options = {};
	}

	// catch (effect, callback)
	if ( $.isFunction( options ) ) {
		callback = options;
		speed = null;
		options = {};
	}

	// catch (effect, speed, ?)
	if ( typeof options === "number" || $.fx.speeds[ options ] ) {
		callback = speed;
		speed = options;
		options = {};
	}

	// catch (effect, options, callback)
	if ( $.isFunction( speed ) ) {
		callback = speed;
		speed = null;
	}

	// add options to effect
	if ( options ) {
		$.extend( effect, options );
	}

	speed = speed || options.duration;
	effect.duration = $.fx.off ? 0 :
		typeof speed === "number" ? speed :
		speed in $.fx.speeds ? $.fx.speeds[ speed ] :
		$.fx.speeds._default;

	effect.complete = callback || options.complete;

	return effect;
}

function standardAnimationOption( option ) {
	// Valid standard speeds (nothing, number, named speed)
	if ( !option || typeof option === "number" || $.fx.speeds[ option ] ) {
		return true;
	}

	// Invalid strings - treat as "normal" speed
	if ( typeof option === "string" && !$.effects.effect[ option ] ) {
		return true;
	}

	// Complete callback
	if ( $.isFunction( option ) ) {
		return true;
	}

	// Options hash (but not naming an effect)
	if ( typeof option === "object" && !option.effect ) {
		return true;
	}

	// Didn't match any standard API
	return false;
}

$.fn.extend({
	effect: function( /* effect, options, speed, callback */ ) {
		var args = _normalizeArguments.apply( this, arguments ),
			mode = args.mode,
			queue = args.queue,
			effectMethod = $.effects.effect[ args.effect ];

		if ( $.fx.off || !effectMethod ) {
			// delegate to the original method (e.g., .show()) if possible
			if ( mode ) {
				return this[ mode ]( args.duration, args.complete );
			} else {
				return this.each( function() {
					if ( args.complete ) {
						args.complete.call( this );
					}
				});
			}
		}

		function run( next ) {
			var elem = $( this ),
				complete = args.complete,
				mode = args.mode;

			function done() {
				if ( $.isFunction( complete ) ) {
					complete.call( elem[0] );
				}
				if ( $.isFunction( next ) ) {
					next();
				}
			}

			// If the element already has the correct final state, delegate to
			// the core methods so the internal tracking of "olddisplay" works.
			if ( elem.is( ":hidden" ) ? mode === "hide" : mode === "show" ) {
				elem[ mode ]();
				done();
			} else {
				effectMethod.call( elem[0], args, done );
			}
		}

		return queue === false ? this.each( run ) : this.queue( queue || "fx", run );
	},

	show: (function( orig ) {
		return function( option ) {
			if ( standardAnimationOption( option ) ) {
				return orig.apply( this, arguments );
			} else {
				var args = _normalizeArguments.apply( this, arguments );
				args.mode = "show";
				return this.effect.call( this, args );
			}
		};
	})( $.fn.show ),

	hide: (function( orig ) {
		return function( option ) {
			if ( standardAnimationOption( option ) ) {
				return orig.apply( this, arguments );
			} else {
				var args = _normalizeArguments.apply( this, arguments );
				args.mode = "hide";
				return this.effect.call( this, args );
			}
		};
	})( $.fn.hide ),

	toggle: (function( orig ) {
		return function( option ) {
			if ( standardAnimationOption( option ) || typeof option === "boolean" ) {
				return orig.apply( this, arguments );
			} else {
				var args = _normalizeArguments.apply( this, arguments );
				args.mode = "toggle";
				return this.effect.call( this, args );
			}
		};
	})( $.fn.toggle ),

	// helper functions
	cssUnit: function(key) {
		var style = this.css( key ),
			val = [];

		$.each( [ "em", "px", "%", "pt" ], function( i, unit ) {
			if ( style.indexOf( unit ) > 0 ) {
				val = [ parseFloat( style ), unit ];
			}
		});
		return val;
	}
});

})();

/******************************************************************************/
/*********************************** EASING ***********************************/
/******************************************************************************/

(function() {

// based on easing equations from Robert Penner (http://www.robertpenner.com/easing)

var baseEasings = {};

$.each( [ "Quad", "Cubic", "Quart", "Quint", "Expo" ], function( i, name ) {
	baseEasings[ name ] = function( p ) {
		return Math.pow( p, i + 2 );
	};
});

$.extend( baseEasings, {
	Sine: function( p ) {
		return 1 - Math.cos( p * Math.PI / 2 );
	},
	Circ: function( p ) {
		return 1 - Math.sqrt( 1 - p * p );
	},
	Elastic: function( p ) {
		return p === 0 || p === 1 ? p :
			-Math.pow( 2, 8 * (p - 1) ) * Math.sin( ( (p - 1) * 80 - 7.5 ) * Math.PI / 15 );
	},
	Back: function( p ) {
		return p * p * ( 3 * p - 2 );
	},
	Bounce: function( p ) {
		var pow2,
			bounce = 4;

		while ( p < ( ( pow2 = Math.pow( 2, --bounce ) ) - 1 ) / 11 ) {}
		return 1 / Math.pow( 4, 3 - bounce ) - 7.5625 * Math.pow( ( pow2 * 3 - 2 ) / 22 - p, 2 );
	}
});

$.each( baseEasings, function( name, easeIn ) {
	$.easing[ "easeIn" + name ] = easeIn;
	$.easing[ "easeOut" + name ] = function( p ) {
		return 1 - easeIn( 1 - p );
	};
	$.easing[ "easeInOut" + name ] = function( p ) {
		return p < 0.5 ?
			easeIn( p * 2 ) / 2 :
			1 - easeIn( p * -2 + 2 ) / 2;
	};
});

})();

return $.effects;

}));


/*!
 * jQuery UI Effects Blind 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/blind-effect/
 */

(function( factory ) {
	if ( typeof define === "function" && define.amd ) {

		// AMD. Register as an anonymous module.
		define([
			"jquery",
			"./effect"
		], factory );
	} else {

		// Browser globals
		factory( jQuery );
	}
}(function( $ ) {

return $.effects.effect.blind = function( o, done ) {
	// Create element
	var el = $( this ),
		rvertical = /up|down|vertical/,
		rpositivemotion = /up|left|vertical|horizontal/,
		props = [ "position", "top", "bottom", "left", "right", "height", "width" ],
		mode = $.effects.setMode( el, o.mode || "hide" ),
		direction = o.direction || "up",
		vertical = rvertical.test( direction ),
		ref = vertical ? "height" : "width",
		ref2 = vertical ? "top" : "left",
		motion = rpositivemotion.test( direction ),
		animation = {},
		show = mode === "show",
		wrapper, distance, margin;

	// if already wrapped, the wrapper's properties are my property. #6245
	if ( el.parent().is( ".ui-effects-wrapper" ) ) {
		$.effects.save( el.parent(), props );
	} else {
		$.effects.save( el, props );
	}
	el.show();
	wrapper = $.effects.createWrapper( el ).css({
		overflow: "hidden"
	});

	distance = wrapper[ ref ]();
	margin = parseFloat( wrapper.css( ref2 ) ) || 0;

	animation[ ref ] = show ? distance : 0;
	if ( !motion ) {
		el
			.css( vertical ? "bottom" : "right", 0 )
			.css( vertical ? "top" : "left", "auto" )
			.css({ position: "absolute" });

		animation[ ref2 ] = show ? margin : distance + margin;
	}

	// start at 0 if we are showing
	if ( show ) {
		wrapper.css( ref, 0 );
		if ( !motion ) {
			wrapper.css( ref2, margin + distance );
		}
	}

	// Animate
	wrapper.animate( animation, {
		duration: o.duration,
		easing: o.easing,
		queue: false,
		complete: function() {
			if ( mode === "hide" ) {
				el.hide();
			}
			$.effects.restore( el, props );
			$.effects.removeWrapper( el );
			done();
		}
	});
};

}));


/*!
 * jQuery UI Effects Bounce 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/bounce-effect/
 */

(function( factory ) {
	if ( typeof define === "function" && define.amd ) {

		// AMD. Register as an anonymous module.
		define([
			"jquery",
			"./effect"
		], factory );
	} else {

		// Browser globals
		factory( jQuery );
	}
}(function( $ ) {

return $.effects.effect.bounce = function( o, done ) {
	var el = $( this ),
		props = [ "position", "top", "bottom", "left", "right", "height", "width" ],

		// defaults:
		mode = $.effects.setMode( el, o.mode || "effect" ),
		hide = mode === "hide",
		show = mode === "show",
		direction = o.direction || "up",
		distance = o.distance,
		times = o.times || 5,

		// number of internal animations
		anims = times * 2 + ( show || hide ? 1 : 0 ),
		speed = o.duration / anims,
		easing = o.easing,

		// utility:
		ref = ( direction === "up" || direction === "down" ) ? "top" : "left",
		motion = ( direction === "up" || direction === "left" ),
		i,
		upAnim,
		downAnim,

		// we will need to re-assemble the queue to stack our animations in place
		queue = el.queue(),
		queuelen = queue.length;

	// Avoid touching opacity to prevent clearType and PNG issues in IE
	if ( show || hide ) {
		props.push( "opacity" );
	}

	$.effects.save( el, props );
	el.show();
	$.effects.createWrapper( el ); // Create Wrapper

	// default distance for the BIGGEST bounce is the outer Distance / 3
	if ( !distance ) {
		distance = el[ ref === "top" ? "outerHeight" : "outerWidth" ]() / 3;
	}

	if ( show ) {
		downAnim = { opacity: 1 };
		downAnim[ ref ] = 0;

		// if we are showing, force opacity 0 and set the initial position
		// then do the "first" animation
		el.css( "opacity", 0 )
			.css( ref, motion ? -distance * 2 : distance * 2 )
			.animate( downAnim, speed, easing );
	}

	// start at the smallest distance if we are hiding
	if ( hide ) {
		distance = distance / Math.pow( 2, times - 1 );
	}

	downAnim = {};
	downAnim[ ref ] = 0;
	// Bounces up/down/left/right then back to 0 -- times * 2 animations happen here
	for ( i = 0; i < times; i++ ) {
		upAnim = {};
		upAnim[ ref ] = ( motion ? "-=" : "+=" ) + distance;

		el.animate( upAnim, speed, easing )
			.animate( downAnim, speed, easing );

		distance = hide ? distance * 2 : distance / 2;
	}

	// Last Bounce when Hiding
	if ( hide ) {
		upAnim = { opacity: 0 };
		upAnim[ ref ] = ( motion ? "-=" : "+=" ) + distance;

		el.animate( upAnim, speed, easing );
	}

	el.queue(function() {
		if ( hide ) {
			el.hide();
		}
		$.effects.restore( el, props );
		$.effects.removeWrapper( el );
		done();
	});

	// inject all the animations we just queued to be first in line (after "inprogress")
	if ( queuelen > 1) {
		queue.splice.apply( queue,
			[ 1, 0 ].concat( queue.splice( queuelen, anims + 1 ) ) );
	}
	el.dequeue();

};

}));


/*!
 * jQuery UI Effects Clip 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/clip-effect/
 */

(function( factory ) {
	if ( typeof define === "function" && define.amd ) {

		// AMD. Register as an anonymous module.
		define([
			"jquery",
			"./effect"
		], factory );
	} else {

		// Browser globals
		factory( jQuery );
	}
}(function( $ ) {

return $.effects.effect.clip = function( o, done ) {
	// Create element
	var el = $( this ),
		props = [ "position", "top", "bottom", "left", "right", "height", "width" ],
		mode = $.effects.setMode( el, o.mode || "hide" ),
		show = mode === "show",
		direction = o.direction || "vertical",
		vert = direction === "vertical",
		size = vert ? "height" : "width",
		position = vert ? "top" : "left",
		animation = {},
		wrapper, animate, distance;

	// Save & Show
	$.effects.save( el, props );
	el.show();

	// Create Wrapper
	wrapper = $.effects.createWrapper( el ).css({
		overflow: "hidden"
	});
	animate = ( el[0].tagName === "IMG" ) ? wrapper : el;
	distance = animate[ size ]();

	// Shift
	if ( show ) {
		animate.css( size, 0 );
		animate.css( position, distance / 2 );
	}

	// Create Animation Object:
	animation[ size ] = show ? distance : 0;
	animation[ position ] = show ? 0 : distance / 2;

	// Animate
	animate.animate( animation, {
		queue: false,
		duration: o.duration,
		easing: o.easing,
		complete: function() {
			if ( !show ) {
				el.hide();
			}
			$.effects.restore( el, props );
			$.effects.removeWrapper( el );
			done();
		}
	});

};

}));


/*!
 * jQuery UI Effects Drop 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/drop-effect/
 */

(function( factory ) {
	if ( typeof define === "function" && define.amd ) {

		// AMD. Register as an anonymous module.
		define([
			"jquery",
			"./effect"
		], factory );
	} else {

		// Browser globals
		factory( jQuery );
	}
}(function( $ ) {

return $.effects.effect.drop = function( o, done ) {

	var el = $( this ),
		props = [ "position", "top", "bottom", "left", "right", "opacity", "height", "width" ],
		mode = $.effects.setMode( el, o.mode || "hide" ),
		show = mode === "show",
		direction = o.direction || "left",
		ref = ( direction === "up" || direction === "down" ) ? "top" : "left",
		motion = ( direction === "up" || direction === "left" ) ? "pos" : "neg",
		animation = {
			opacity: show ? 1 : 0
		},
		distance;

	// Adjust
	$.effects.save( el, props );
	el.show();
	$.effects.createWrapper( el );

	distance = o.distance || el[ ref === "top" ? "outerHeight" : "outerWidth" ]( true ) / 2;

	if ( show ) {
		el
			.css( "opacity", 0 )
			.css( ref, motion === "pos" ? -distance : distance );
	}

	// Animation
	animation[ ref ] = ( show ?
		( motion === "pos" ? "+=" : "-=" ) :
		( motion === "pos" ? "-=" : "+=" ) ) +
		distance;

	// Animate
	el.animate( animation, {
		queue: false,
		duration: o.duration,
		easing: o.easing,
		complete: function() {
			if ( mode === "hide" ) {
				el.hide();
			}
			$.effects.restore( el, props );
			$.effects.removeWrapper( el );
			done();
		}
	});
};

}));


/*!
 * jQuery UI Effects Explode 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/explode-effect/
 */

(function( factory ) {
	if ( typeof define === "function" && define.amd ) {

		// AMD. Register as an anonymous module.
		define([
			"jquery",
			"./effect"
		], factory );
	} else {

		// Browser globals
		factory( jQuery );
	}
}(function( $ ) {

return $.effects.effect.explode = function( o, done ) {

	var rows = o.pieces ? Math.round( Math.sqrt( o.pieces ) ) : 3,
		cells = rows,
		el = $( this ),
		mode = $.effects.setMode( el, o.mode || "hide" ),
		show = mode === "show",

		// show and then visibility:hidden the element before calculating offset
		offset = el.show().css( "visibility", "hidden" ).offset(),

		// width and height of a piece
		width = Math.ceil( el.outerWidth() / cells ),
		height = Math.ceil( el.outerHeight() / rows ),
		pieces = [],

		// loop
		i, j, left, top, mx, my;

	// children animate complete:
	function childComplete() {
		pieces.push( this );
		if ( pieces.length === rows * cells ) {
			animComplete();
		}
	}

	// clone the element for each row and cell.
	for ( i = 0; i < rows ; i++ ) { // ===>
		top = offset.top + i * height;
		my = i - ( rows - 1 ) / 2 ;

		for ( j = 0; j < cells ; j++ ) { // |||
			left = offset.left + j * width;
			mx = j - ( cells - 1 ) / 2 ;

			// Create a clone of the now hidden main element that will be absolute positioned
			// within a wrapper div off the -left and -top equal to size of our pieces
			el
				.clone()
				.appendTo( "body" )
				.wrap( "<div></div>" )
				.css({
					position: "absolute",
					visibility: "visible",
					left: -j * width,
					top: -i * height
				})

			// select the wrapper - make it overflow: hidden and absolute positioned based on
			// where the original was located +left and +top equal to the size of pieces
				.parent()
				.addClass( "ui-effects-explode" )
				.css({
					position: "absolute",
					overflow: "hidden",
					width: width,
					height: height,
					left: left + ( show ? mx * width : 0 ),
					top: top + ( show ? my * height : 0 ),
					opacity: show ? 0 : 1
				}).animate({
					left: left + ( show ? 0 : mx * width ),
					top: top + ( show ? 0 : my * height ),
					opacity: show ? 1 : 0
				}, o.duration || 500, o.easing, childComplete );
		}
	}

	function animComplete() {
		el.css({
			visibility: "visible"
		});
		$( pieces ).remove();
		if ( !show ) {
			el.hide();
		}
		done();
	}
};

}));


/*!
 * jQuery UI Effects Fade 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/fade-effect/
 */

(function( factory ) {
	if ( typeof define === "function" && define.amd ) {

		// AMD. Register as an anonymous module.
		define([
			"jquery",
			"./effect"
		], factory );
	} else {

		// Browser globals
		factory( jQuery );
	}
}(function( $ ) {

return $.effects.effect.fade = function( o, done ) {
	var el = $( this ),
		mode = $.effects.setMode( el, o.mode || "toggle" );

	el.animate({
		opacity: mode
	}, {
		queue: false,
		duration: o.duration,
		easing: o.easing,
		complete: done
	});
};

}));


/*!
 * jQuery UI Effects Fold 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/fold-effect/
 */

(function( factory ) {
	if ( typeof define === "function" && define.amd ) {

		// AMD. Register as an anonymous module.
		define([
			"jquery",
			"./effect"
		], factory );
	} else {

		// Browser globals
		factory( jQuery );
	}
}(function( $ ) {

return $.effects.effect.fold = function( o, done ) {

	// Create element
	var el = $( this ),
		props = [ "position", "top", "bottom", "left", "right", "height", "width" ],
		mode = $.effects.setMode( el, o.mode || "hide" ),
		show = mode === "show",
		hide = mode === "hide",
		size = o.size || 15,
		percent = /([0-9]+)%/.exec( size ),
		horizFirst = !!o.horizFirst,
		widthFirst = show !== horizFirst,
		ref = widthFirst ? [ "width", "height" ] : [ "height", "width" ],
		duration = o.duration / 2,
		wrapper, distance,
		animation1 = {},
		animation2 = {};

	$.effects.save( el, props );
	el.show();

	// Create Wrapper
	wrapper = $.effects.createWrapper( el ).css({
		overflow: "hidden"
	});
	distance = widthFirst ?
		[ wrapper.width(), wrapper.height() ] :
		[ wrapper.height(), wrapper.width() ];

	if ( percent ) {
		size = parseInt( percent[ 1 ], 10 ) / 100 * distance[ hide ? 0 : 1 ];
	}
	if ( show ) {
		wrapper.css( horizFirst ? {
			height: 0,
			width: size
		} : {
			height: size,
			width: 0
		});
	}

	// Animation
	animation1[ ref[ 0 ] ] = show ? distance[ 0 ] : size;
	animation2[ ref[ 1 ] ] = show ? distance[ 1 ] : 0;

	// Animate
	wrapper
		.animate( animation1, duration, o.easing )
		.animate( animation2, duration, o.easing, function() {
			if ( hide ) {
				el.hide();
			}
			$.effects.restore( el, props );
			$.effects.removeWrapper( el );
			done();
		});

};

}));


/*!
 * jQuery UI Effects Highlight 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/highlight-effect/
 */

(function( factory ) {
	if ( typeof define === "function" && define.amd ) {

		// AMD. Register as an anonymous module.
		define([
			"jquery",
			"./effect"
		], factory );
	} else {

		// Browser globals
		factory( jQuery );
	}
}(function( $ ) {

return $.effects.effect.highlight = function( o, done ) {
	var elem = $( this ),
		props = [ "backgroundImage", "backgroundColor", "opacity" ],
		mode = $.effects.setMode( elem, o.mode || "show" ),
		animation = {
			backgroundColor: elem.css( "backgroundColor" )
		};

	if (mode === "hide") {
		animation.opacity = 0;
	}

	$.effects.save( elem, props );

	elem
		.show()
		.css({
			backgroundImage: "none",
			backgroundColor: o.color || "#ffff99"
		})
		.animate( animation, {
			queue: false,
			duration: o.duration,
			easing: o.easing,
			complete: function() {
				if ( mode === "hide" ) {
					elem.hide();
				}
				$.effects.restore( elem, props );
				done();
			}
		});
};

}));


/*!
 * jQuery UI Effects Size 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/size-effect/
 */

(function( factory ) {
	if ( typeof define === "function" && define.amd ) {

		// AMD. Register as an anonymous module.
		define([
			"jquery",
			"./effect"
		], factory );
	} else {

		// Browser globals
		factory( jQuery );
	}
}(function( $ ) {

return $.effects.effect.size = function( o, done ) {

	// Create element
	var original, baseline, factor,
		el = $( this ),
		props0 = [ "position", "top", "bottom", "left", "right", "width", "height", "overflow", "opacity" ],

		// Always restore
		props1 = [ "position", "top", "bottom", "left", "right", "overflow", "opacity" ],

		// Copy for children
		props2 = [ "width", "height", "overflow" ],
		cProps = [ "fontSize" ],
		vProps = [ "borderTopWidth", "borderBottomWidth", "paddingTop", "paddingBottom" ],
		hProps = [ "borderLeftWidth", "borderRightWidth", "paddingLeft", "paddingRight" ],

		// Set options
		mode = $.effects.setMode( el, o.mode || "effect" ),
		restore = o.restore || mode !== "effect",
		scale = o.scale || "both",
		origin = o.origin || [ "middle", "center" ],
		position = el.css( "position" ),
		props = restore ? props0 : props1,
		zero = {
			height: 0,
			width: 0,
			outerHeight: 0,
			outerWidth: 0
		};

	if ( mode === "show" ) {
		el.show();
	}
	original = {
		height: el.height(),
		width: el.width(),
		outerHeight: el.outerHeight(),
		outerWidth: el.outerWidth()
	};

	if ( o.mode === "toggle" && mode === "show" ) {
		el.from = o.to || zero;
		el.to = o.from || original;
	} else {
		el.from = o.from || ( mode === "show" ? zero : original );
		el.to = o.to || ( mode === "hide" ? zero : original );
	}

	// Set scaling factor
	factor = {
		from: {
			y: el.from.height / original.height,
			x: el.from.width / original.width
		},
		to: {
			y: el.to.height / original.height,
			x: el.to.width / original.width
		}
	};

	// Scale the css box
	if ( scale === "box" || scale === "both" ) {

		// Vertical props scaling
		if ( factor.from.y !== factor.to.y ) {
			props = props.concat( vProps );
			el.from = $.effects.setTransition( el, vProps, factor.from.y, el.from );
			el.to = $.effects.setTransition( el, vProps, factor.to.y, el.to );
		}

		// Horizontal props scaling
		if ( factor.from.x !== factor.to.x ) {
			props = props.concat( hProps );
			el.from = $.effects.setTransition( el, hProps, factor.from.x, el.from );
			el.to = $.effects.setTransition( el, hProps, factor.to.x, el.to );
		}
	}

	// Scale the content
	if ( scale === "content" || scale === "both" ) {

		// Vertical props scaling
		if ( factor.from.y !== factor.to.y ) {
			props = props.concat( cProps ).concat( props2 );
			el.from = $.effects.setTransition( el, cProps, factor.from.y, el.from );
			el.to = $.effects.setTransition( el, cProps, factor.to.y, el.to );
		}
	}

	$.effects.save( el, props );
	el.show();
	$.effects.createWrapper( el );
	el.css( "overflow", "hidden" ).css( el.from );

	// Adjust
	if (origin) { // Calculate baseline shifts
		baseline = $.effects.getBaseline( origin, original );
		el.from.top = ( original.outerHeight - el.outerHeight() ) * baseline.y;
		el.from.left = ( original.outerWidth - el.outerWidth() ) * baseline.x;
		el.to.top = ( original.outerHeight - el.to.outerHeight ) * baseline.y;
		el.to.left = ( original.outerWidth - el.to.outerWidth ) * baseline.x;
	}
	el.css( el.from ); // set top & left

	// Animate
	if ( scale === "content" || scale === "both" ) { // Scale the children

		// Add margins/font-size
		vProps = vProps.concat([ "marginTop", "marginBottom" ]).concat(cProps);
		hProps = hProps.concat([ "marginLeft", "marginRight" ]);
		props2 = props0.concat(vProps).concat(hProps);

		el.find( "*[width]" ).each( function() {
			var child = $( this ),
				c_original = {
					height: child.height(),
					width: child.width(),
					outerHeight: child.outerHeight(),
					outerWidth: child.outerWidth()
				};
			if (restore) {
				$.effects.save(child, props2);
			}

			child.from = {
				height: c_original.height * factor.from.y,
				width: c_original.width * factor.from.x,
				outerHeight: c_original.outerHeight * factor.from.y,
				outerWidth: c_original.outerWidth * factor.from.x
			};
			child.to = {
				height: c_original.height * factor.to.y,
				width: c_original.width * factor.to.x,
				outerHeight: c_original.height * factor.to.y,
				outerWidth: c_original.width * factor.to.x
			};

			// Vertical props scaling
			if ( factor.from.y !== factor.to.y ) {
				child.from = $.effects.setTransition( child, vProps, factor.from.y, child.from );
				child.to = $.effects.setTransition( child, vProps, factor.to.y, child.to );
			}

			// Horizontal props scaling
			if ( factor.from.x !== factor.to.x ) {
				child.from = $.effects.setTransition( child, hProps, factor.from.x, child.from );
				child.to = $.effects.setTransition( child, hProps, factor.to.x, child.to );
			}

			// Animate children
			child.css( child.from );
			child.animate( child.to, o.duration, o.easing, function() {

				// Restore children
				if ( restore ) {
					$.effects.restore( child, props2 );
				}
			});
		});
	}

	// Animate
	el.animate( el.to, {
		queue: false,
		duration: o.duration,
		easing: o.easing,
		complete: function() {
			if ( el.to.opacity === 0 ) {
				el.css( "opacity", el.from.opacity );
			}
			if ( mode === "hide" ) {
				el.hide();
			}
			$.effects.restore( el, props );
			if ( !restore ) {

				// we need to calculate our new positioning based on the scaling
				if ( position === "static" ) {
					el.css({
						position: "relative",
						top: el.to.top,
						left: el.to.left
					});
				} else {
					$.each([ "top", "left" ], function( idx, pos ) {
						el.css( pos, function( _, str ) {
							var val = parseInt( str, 10 ),
								toRef = idx ? el.to.left : el.to.top;

							// if original was "auto", recalculate the new value from wrapper
							if ( str === "auto" ) {
								return toRef + "px";
							}

							return val + toRef + "px";
						});
					});
				}
			}

			$.effects.removeWrapper( el );
			done();
		}
	});

};

}));



/*!
 * jQuery UI Effects Scale 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/scale-effect/
 */

(function( factory ) {
	if ( typeof define === "function" && define.amd ) {

		// AMD. Register as an anonymous module.
		define([
			"jquery",
			"./effect",
			"./effect-size"
		], factory );
	} else {

		// Browser globals
		factory( jQuery );
	}
}(function( $ ) {

return $.effects.effect.scale = function( o, done ) {

	// Create element
	var el = $( this ),
		options = $.extend( true, {}, o ),
		mode = $.effects.setMode( el, o.mode || "effect" ),
		percent = parseInt( o.percent, 10 ) ||
			( parseInt( o.percent, 10 ) === 0 ? 0 : ( mode === "hide" ? 0 : 100 ) ),
		direction = o.direction || "both",
		origin = o.origin,
		original = {
			height: el.height(),
			width: el.width(),
			outerHeight: el.outerHeight(),
			outerWidth: el.outerWidth()
		},
		factor = {
			y: direction !== "horizontal" ? (percent / 100) : 1,
			x: direction !== "vertical" ? (percent / 100) : 1
		};

	// We are going to pass this effect to the size effect:
	options.effect = "size";
	options.queue = false;
	options.complete = done;

	// Set default origin and restore for show/hide
	if ( mode !== "effect" ) {
		options.origin = origin || [ "middle", "center" ];
		options.restore = true;
	}

	options.from = o.from || ( mode === "show" ? {
		height: 0,
		width: 0,
		outerHeight: 0,
		outerWidth: 0
	} : original );
	options.to = {
		height: original.height * factor.y,
		width: original.width * factor.x,
		outerHeight: original.outerHeight * factor.y,
		outerWidth: original.outerWidth * factor.x
	};

	// Fade option to support puff
	if ( options.fade ) {
		if ( mode === "show" ) {
			options.from.opacity = 0;
			options.to.opacity = 1;
		}
		if ( mode === "hide" ) {
			options.from.opacity = 1;
			options.to.opacity = 0;
		}
	}

	// Animate
	el.effect( options );

};

}));



/*!
 * jQuery UI Effects Puff 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/puff-effect/
 */

(function( factory ) {
	if ( typeof define === "function" && define.amd ) {

		// AMD. Register as an anonymous module.
		define([
			"jquery",
			"./effect",
			"./effect-scale"
		], factory );
	} else {

		// Browser globals
		factory( jQuery );
	}
}(function( $ ) {

return $.effects.effect.puff = function( o, done ) {
	var elem = $( this ),
		mode = $.effects.setMode( elem, o.mode || "hide" ),
		hide = mode === "hide",
		percent = parseInt( o.percent, 10 ) || 150,
		factor = percent / 100,
		original = {
			height: elem.height(),
			width: elem.width(),
			outerHeight: elem.outerHeight(),
			outerWidth: elem.outerWidth()
		};

	$.extend( o, {
		effect: "scale",
		queue: false,
		fade: true,
		mode: mode,
		complete: done,
		percent: hide ? percent : 100,
		from: hide ?
			original :
			{
				height: original.height * factor,
				width: original.width * factor,
				outerHeight: original.outerHeight * factor,
				outerWidth: original.outerWidth * factor
			}
	});

	elem.effect( o );
};

}));


/*!
 * jQuery UI Effects Pulsate 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/pulsate-effect/
 */

(function( factory ) {
	if ( typeof define === "function" && define.amd ) {

		// AMD. Register as an anonymous module.
		define([
			"jquery",
			"./effect"
		], factory );
	} else {

		// Browser globals
		factory( jQuery );
	}
}(function( $ ) {

return $.effects.effect.pulsate = function( o, done ) {
	var elem = $( this ),
		mode = $.effects.setMode( elem, o.mode || "show" ),
		show = mode === "show",
		hide = mode === "hide",
		showhide = ( show || mode === "hide" ),

		// showing or hiding leaves of the "last" animation
		anims = ( ( o.times || 5 ) * 2 ) + ( showhide ? 1 : 0 ),
		duration = o.duration / anims,
		animateTo = 0,
		queue = elem.queue(),
		queuelen = queue.length,
		i;

	if ( show || !elem.is(":visible")) {
		elem.css( "opacity", 0 ).show();
		animateTo = 1;
	}

	// anims - 1 opacity "toggles"
	for ( i = 1; i < anims; i++ ) {
		elem.animate({
			opacity: animateTo
		}, duration, o.easing );
		animateTo = 1 - animateTo;
	}

	elem.animate({
		opacity: animateTo
	}, duration, o.easing);

	elem.queue(function() {
		if ( hide ) {
			elem.hide();
		}
		done();
	});

	// We just queued up "anims" animations, we need to put them next in the queue
	if ( queuelen > 1 ) {
		queue.splice.apply( queue,
			[ 1, 0 ].concat( queue.splice( queuelen, anims + 1 ) ) );
	}
	elem.dequeue();
};

}));


/*!
 * jQuery UI Effects Shake 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/shake-effect/
 */

(function( factory ) {
	if ( typeof define === "function" && define.amd ) {

		// AMD. Register as an anonymous module.
		define([
			"jquery",
			"./effect"
		], factory );
	} else {

		// Browser globals
		factory( jQuery );
	}
}(function( $ ) {

return $.effects.effect.shake = function( o, done ) {

	var el = $( this ),
		props = [ "position", "top", "bottom", "left", "right", "height", "width" ],
		mode = $.effects.setMode( el, o.mode || "effect" ),
		direction = o.direction || "left",
		distance = o.distance || 20,
		times = o.times || 3,
		anims = times * 2 + 1,
		speed = Math.round( o.duration / anims ),
		ref = (direction === "up" || direction === "down") ? "top" : "left",
		positiveMotion = (direction === "up" || direction === "left"),
		animation = {},
		animation1 = {},
		animation2 = {},
		i,

		// we will need to re-assemble the queue to stack our animations in place
		queue = el.queue(),
		queuelen = queue.length;

	$.effects.save( el, props );
	el.show();
	$.effects.createWrapper( el );

	// Animation
	animation[ ref ] = ( positiveMotion ? "-=" : "+=" ) + distance;
	animation1[ ref ] = ( positiveMotion ? "+=" : "-=" ) + distance * 2;
	animation2[ ref ] = ( positiveMotion ? "-=" : "+=" ) + distance * 2;

	// Animate
	el.animate( animation, speed, o.easing );

	// Shakes
	for ( i = 1; i < times; i++ ) {
		el.animate( animation1, speed, o.easing ).animate( animation2, speed, o.easing );
	}
	el
		.animate( animation1, speed, o.easing )
		.animate( animation, speed / 2, o.easing )
		.queue(function() {
			if ( mode === "hide" ) {
				el.hide();
			}
			$.effects.restore( el, props );
			$.effects.removeWrapper( el );
			done();
		});

	// inject all the animations we just queued to be first in line (after "inprogress")
	if ( queuelen > 1) {
		queue.splice.apply( queue,
			[ 1, 0 ].concat( queue.splice( queuelen, anims + 1 ) ) );
	}
	el.dequeue();

};

}));


/*!
 * jQuery UI Effects Slide 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/slide-effect/
 */

(function( factory ) {
	if ( typeof define === "function" && define.amd ) {

		// AMD. Register as an anonymous module.
		define([
			"jquery",
			"./effect"
		], factory );
	} else {

		// Browser globals
		factory( jQuery );
	}
}(function( $ ) {

return $.effects.effect.slide = function( o, done ) {

	// Create element
	var el = $( this ),
		props = [ "position", "top", "bottom", "left", "right", "width", "height" ],
		mode = $.effects.setMode( el, o.mode || "show" ),
		show = mode === "show",
		direction = o.direction || "left",
		ref = (direction === "up" || direction === "down") ? "top" : "left",
		positiveMotion = (direction === "up" || direction === "left"),
		distance,
		animation = {};

	// Adjust
	$.effects.save( el, props );
	el.show();
	distance = o.distance || el[ ref === "top" ? "outerHeight" : "outerWidth" ]( true );

	$.effects.createWrapper( el ).css({
		overflow: "hidden"
	});

	if ( show ) {
		el.css( ref, positiveMotion ? (isNaN(distance) ? "-" + distance : -distance) : distance );
	}

	// Animation
	animation[ ref ] = ( show ?
		( positiveMotion ? "+=" : "-=") :
		( positiveMotion ? "-=" : "+=")) +
		distance;

	// Animate
	el.animate( animation, {
		queue: false,
		duration: o.duration,
		easing: o.easing,
		complete: function() {
			if ( mode === "hide" ) {
				el.hide();
			}
			$.effects.restore( el, props );
			$.effects.removeWrapper( el );
			done();
		}
	});
};

}));


/*!
 * jQuery UI Effects Transfer 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/transfer-effect/
 */

(function( factory ) {
	if ( typeof define === "function" && define.amd ) {

		// AMD. Register as an anonymous module.
		define([
			"jquery",
			"./effect"
		], factory );
	} else {

		// Browser globals
		factory( jQuery );
	}
}(function( $ ) {

return $.effects.effect.transfer = function( o, done ) {
	var elem = $( this ),
		target = $( o.to ),
		targetFixed = target.css( "position" ) === "fixed",
		body = $("body"),
		fixTop = targetFixed ? body.scrollTop() : 0,
		fixLeft = targetFixed ? body.scrollLeft() : 0,
		endPosition = target.offset(),
		animation = {
			top: endPosition.top - fixTop,
			left: endPosition.left - fixLeft,
			height: target.innerHeight(),
			width: target.innerWidth()
		},
		startPosition = elem.offset(),
		transfer = $( "<div class='ui-effects-transfer'></div>" )
			.appendTo( document.body )
			.addClass( o.className )
			.css({
				top: startPosition.top - fixTop,
				left: startPosition.left - fixLeft,
				height: elem.innerHeight(),
				width: elem.innerWidth(),
				position: targetFixed ? "fixed" : "absolute"
			})
			.animate( animation, o.duration, o.easing, function() {
				transfer.remove();
				done();
			});
};

}));



/*!
 * jQuery UI Progressbar 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/progressbar/
 */

(function( factory ) {
	if ( typeof define === "function" && define.amd ) {

		// AMD. Register as an anonymous module.
		define([
			"jquery",
			"./core",
			"./widget"
		], factory );
	} else {

		// Browser globals
		factory( jQuery );
	}
}(function( $ ) {

return $.widget( "ui.progressbar", {
	version: "1.11.4",
	options: {
		max: 100,
		value: 0,

		change: null,
		complete: null
	},

	min: 0,

	_create: function() {
		// Constrain initial value
		this.oldValue = this.options.value = this._constrainedValue();

		this.element
			.addClass( "ui-progressbar ui-widget ui-widget-content ui-corner-all" )
			.attr({
				// Only set static values, aria-valuenow and aria-valuemax are
				// set inside _refreshValue()
				role: "progressbar",
				"aria-valuemin": this.min
			});

		this.valueDiv = $( "<div class='ui-progressbar-value ui-widget-header ui-corner-left'></div>" )
			.appendTo( this.element );

		this._refreshValue();
	},

	_destroy: function() {
		this.element
			.removeClass( "ui-progressbar ui-widget ui-widget-content ui-corner-all" )
			.removeAttr( "role" )
			.removeAttr( "aria-valuemin" )
			.removeAttr( "aria-valuemax" )
			.removeAttr( "aria-valuenow" );

		this.valueDiv.remove();
	},

	value: function( newValue ) {
		if ( newValue === undefined ) {
			return this.options.value;
		}

		this.options.value = this._constrainedValue( newValue );
		this._refreshValue();
	},

	_constrainedValue: function( newValue ) {
		if ( newValue === undefined ) {
			newValue = this.options.value;
		}

		this.indeterminate = newValue === false;

		// sanitize value
		if ( typeof newValue !== "number" ) {
			newValue = 0;
		}

		return this.indeterminate ? false :
			Math.min( this.options.max, Math.max( this.min, newValue ) );
	},

	_setOptions: function( options ) {
		// Ensure "value" option is set after other values (like max)
		var value = options.value;
		delete options.value;

		this._super( options );

		this.options.value = this._constrainedValue( value );
		this._refreshValue();
	},

	_setOption: function( key, value ) {
		if ( key === "max" ) {
			// Don't allow a max less than min
			value = Math.max( this.min, value );
		}
		if ( key === "disabled" ) {
			this.element
				.toggleClass( "ui-state-disabled", !!value )
				.attr( "aria-disabled", value );
		}
		this._super( key, value );
	},

	_percentage: function() {
		return this.indeterminate ? 100 : 100 * ( this.options.value - this.min ) / ( this.options.max - this.min );
	},

	_refreshValue: function() {
		var value = this.options.value,
			percentage = this._percentage();

		this.valueDiv
			.toggle( this.indeterminate || value > this.min )
			.toggleClass( "ui-corner-right", value === this.options.max )
			.width( percentage.toFixed(0) + "%" );

		this.element.toggleClass( "ui-progressbar-indeterminate", this.indeterminate );

		if ( this.indeterminate ) {
			this.element.removeAttr( "aria-valuenow" );
			if ( !this.overlayDiv ) {
				this.overlayDiv = $( "<div class='ui-progressbar-overlay'></div>" ).appendTo( this.valueDiv );
			}
		} else {
			this.element.attr({
				"aria-valuemax": this.options.max,
				"aria-valuenow": value
			});
			if ( this.overlayDiv ) {
				this.overlayDiv.remove();
				this.overlayDiv = null;
			}
		}

		if ( this.oldValue !== value ) {
			this.oldValue = value;
			this._trigger( "change" );
		}
		if ( value === this.options.max ) {
			this._trigger( "complete" );
		}
	}
});

}));




/*!
 * jQuery UI Selectable 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/selectable/
 */

(function( factory ) {
	if ( typeof define === "function" && define.amd ) {

		// AMD. Register as an anonymous module.
		define([
			"jquery",
			"./core",
			"./mouse",
			"./widget"
		], factory );
	} else {

		// Browser globals
		factory( jQuery );
	}
}(function( $ ) {

return $.widget("ui.selectable", $.ui.mouse, {
	version: "1.11.4",
	options: {
		appendTo: "body",
		autoRefresh: true,
		distance: 0,
		filter: "*",
		tolerance: "touch",

		// callbacks
		selected: null,
		selecting: null,
		start: null,
		stop: null,
		unselected: null,
		unselecting: null
	},
	_create: function() {
		var selectees,
			that = this;

		this.element.addClass("ui-selectable");

		this.dragged = false;

		// cache selectee children based on filter
		this.refresh = function() {
			selectees = $(that.options.filter, that.element[0]);
			selectees.addClass("ui-selectee");
			selectees.each(function() {
				var $this = $(this),
					pos = $this.offset();
				$.data(this, "selectable-item", {
					element: this,
					$element: $this,
					left: pos.left,
					top: pos.top,
					right: pos.left + $this.outerWidth(),
					bottom: pos.top + $this.outerHeight(),
					startselected: false,
					selected: $this.hasClass("ui-selected"),
					selecting: $this.hasClass("ui-selecting"),
					unselecting: $this.hasClass("ui-unselecting")
				});
			});
		};
		this.refresh();

		this.selectees = selectees.addClass("ui-selectee");

		this._mouseInit();

		this.helper = $("<div class='ui-selectable-helper'></div>");
	},

	_destroy: function() {
		this.selectees
			.removeClass("ui-selectee")
			.removeData("selectable-item");
		this.element
			.removeClass("ui-selectable ui-selectable-disabled");
		this._mouseDestroy();
	},

	_mouseStart: function(event) {
		var that = this,
			options = this.options;

		this.opos = [ event.pageX, event.pageY ];

		if (this.options.disabled) {
			return;
		}

		this.selectees = $(options.filter, this.element[0]);

		this._trigger("start", event);

		$(options.appendTo).append(this.helper);
		// position helper (lasso)
		this.helper.css({
			"left": event.pageX,
			"top": event.pageY,
			"width": 0,
			"height": 0
		});

		if (options.autoRefresh) {
			this.refresh();
		}

		this.selectees.filter(".ui-selected").each(function() {
			var selectee = $.data(this, "selectable-item");
			selectee.startselected = true;
			if (!event.metaKey && !event.ctrlKey) {
				selectee.$element.removeClass("ui-selected");
				selectee.selected = false;
				selectee.$element.addClass("ui-unselecting");
				selectee.unselecting = true;
				// selectable UNSELECTING callback
				that._trigger("unselecting", event, {
					unselecting: selectee.element
				});
			}
		});

		$(event.target).parents().addBack().each(function() {
			var doSelect,
				selectee = $.data(this, "selectable-item");
			if (selectee) {
				doSelect = (!event.metaKey && !event.ctrlKey) || !selectee.$element.hasClass("ui-selected");
				selectee.$element
					.removeClass(doSelect ? "ui-unselecting" : "ui-selected")
					.addClass(doSelect ? "ui-selecting" : "ui-unselecting");
				selectee.unselecting = !doSelect;
				selectee.selecting = doSelect;
				selectee.selected = doSelect;
				// selectable (UN)SELECTING callback
				if (doSelect) {
					that._trigger("selecting", event, {
						selecting: selectee.element
					});
				} else {
					that._trigger("unselecting", event, {
						unselecting: selectee.element
					});
				}
				return false;
			}
		});

	},

	_mouseDrag: function(event) {

		this.dragged = true;

		if (this.options.disabled) {
			return;
		}

		var tmp,
			that = this,
			options = this.options,
			x1 = this.opos[0],
			y1 = this.opos[1],
			x2 = event.pageX,
			y2 = event.pageY;

		if (x1 > x2) { tmp = x2; x2 = x1; x1 = tmp; }
		if (y1 > y2) { tmp = y2; y2 = y1; y1 = tmp; }
		this.helper.css({ left: x1, top: y1, width: x2 - x1, height: y2 - y1 });

		this.selectees.each(function() {
			var selectee = $.data(this, "selectable-item"),
				hit = false;

			//prevent helper from being selected if appendTo: selectable
			if (!selectee || selectee.element === that.element[0]) {
				return;
			}

			if (options.tolerance === "touch") {
				hit = ( !(selectee.left > x2 || selectee.right < x1 || selectee.top > y2 || selectee.bottom < y1) );
			} else if (options.tolerance === "fit") {
				hit = (selectee.left > x1 && selectee.right < x2 && selectee.top > y1 && selectee.bottom < y2);
			}

			if (hit) {
				// SELECT
				if (selectee.selected) {
					selectee.$element.removeClass("ui-selected");
					selectee.selected = false;
				}
				if (selectee.unselecting) {
					selectee.$element.removeClass("ui-unselecting");
					selectee.unselecting = false;
				}
				if (!selectee.selecting) {
					selectee.$element.addClass("ui-selecting");
					selectee.selecting = true;
					// selectable SELECTING callback
					that._trigger("selecting", event, {
						selecting: selectee.element
					});
				}
			} else {
				// UNSELECT
				if (selectee.selecting) {
					if ((event.metaKey || event.ctrlKey) && selectee.startselected) {
						selectee.$element.removeClass("ui-selecting");
						selectee.selecting = false;
						selectee.$element.addClass("ui-selected");
						selectee.selected = true;
					} else {
						selectee.$element.removeClass("ui-selecting");
						selectee.selecting = false;
						if (selectee.startselected) {
							selectee.$element.addClass("ui-unselecting");
							selectee.unselecting = true;
						}
						// selectable UNSELECTING callback
						that._trigger("unselecting", event, {
							unselecting: selectee.element
						});
					}
				}
				if (selectee.selected) {
					if (!event.metaKey && !event.ctrlKey && !selectee.startselected) {
						selectee.$element.removeClass("ui-selected");
						selectee.selected = false;

						selectee.$element.addClass("ui-unselecting");
						selectee.unselecting = true;
						// selectable UNSELECTING callback
						that._trigger("unselecting", event, {
							unselecting: selectee.element
						});
					}
				}
			}
		});

		return false;
	},

	_mouseStop: function(event) {
		var that = this;

		this.dragged = false;

		$(".ui-unselecting", this.element[0]).each(function() {
			var selectee = $.data(this, "selectable-item");
			selectee.$element.removeClass("ui-unselecting");
			selectee.unselecting = false;
			selectee.startselected = false;
			that._trigger("unselected", event, {
				unselected: selectee.element
			});
		});
		$(".ui-selecting", this.element[0]).each(function() {
			var selectee = $.data(this, "selectable-item");
			selectee.$element.removeClass("ui-selecting").addClass("ui-selected");
			selectee.selecting = false;
			selectee.selected = true;
			selectee.startselected = true;
			that._trigger("selected", event, {
				selected: selectee.element
			});
		});
		this._trigger("stop", event);

		this.helper.remove();

		return false;
	}

});

}));





/*!
 * jQuery UI Selectmenu 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/selectmenu
 */

(function( factory ) {
	if ( typeof define === "function" && define.amd ) {

		// AMD. Register as an anonymous module.
		define([
			"jquery",
			"./core",
			"./widget",
			"./position",
			"./menu"
		], factory );
	} else {

		// Browser globals
		factory( jQuery );
	}
}(function( $ ) {

return $.widget( "ui.selectmenu", {
	version: "1.11.4",
	defaultElement: "<select>",
	options: {
		appendTo: null,
		disabled: null,
		icons: {
			button: "ui-icon-triangle-1-s"
		},
		position: {
			my: "left top",
			at: "left bottom",
			collision: "none"
		},
		width: null,

		// callbacks
		change: null,
		close: null,
		focus: null,
		open: null,
		select: null
	},

	_create: function() {
		var selectmenuId = this.element.uniqueId().attr( "id" );
		this.ids = {
			element: selectmenuId,
			button: selectmenuId + "-button",
			menu: selectmenuId + "-menu"
		};

		this._drawButton();
		this._drawMenu();

		if ( this.options.disabled ) {
			this.disable();
		}
	},

	_drawButton: function() {
		var that = this;

		// Associate existing label with the new button
		this.label = $( "label[for='" + this.ids.element + "']" ).attr( "for", this.ids.button );
		this._on( this.label, {
			click: function( event ) {
				this.button.focus();
				event.preventDefault();
			}
		});

		// Hide original select element
		this.element.hide();

		// Create button
		this.button = $( "<span>", {
			"class": "ui-selectmenu-button ui-widget ui-state-default ui-corner-all",
			tabindex: this.options.disabled ? -1 : 0,
			id: this.ids.button,
			role: "combobox",
			"aria-expanded": "false",
			"aria-autocomplete": "list",
			"aria-owns": this.ids.menu,
			"aria-haspopup": "true"
		})
			.insertAfter( this.element );

		$( "<span>", {
			"class": "ui-icon " + this.options.icons.button
		})
			.prependTo( this.button );

		this.buttonText = $( "<span>", {
			"class": "ui-selectmenu-text"
		})
			.appendTo( this.button );

		this._setText( this.buttonText, this.element.find( "option:selected" ).text() );
		this._resizeButton();

		this._on( this.button, this._buttonEvents );
		this.button.one( "focusin", function() {

			// Delay rendering the menu items until the button receives focus.
			// The menu may have already been rendered via a programmatic open.
			if ( !that.menuItems ) {
				that._refreshMenu();
			}
		});
		this._hoverable( this.button );
		this._focusable( this.button );
	},

	_drawMenu: function() {
		var that = this;

		// Create menu
		this.menu = $( "<ul>", {
			"aria-hidden": "true",
			"aria-labelledby": this.ids.button,
			id: this.ids.menu
		});

		// Wrap menu
		this.menuWrap = $( "<div>", {
			"class": "ui-selectmenu-menu ui-front"
		})
			.append( this.menu )
			.appendTo( this._appendTo() );

		// Initialize menu widget
		this.menuInstance = this.menu
			.menu({
				role: "listbox",
				select: function( event, ui ) {
					event.preventDefault();

					// support: IE8
					// If the item was selected via a click, the text selection
					// will be destroyed in IE
					that._setSelection();

					that._select( ui.item.data( "ui-selectmenu-item" ), event );
				},
				focus: function( event, ui ) {
					var item = ui.item.data( "ui-selectmenu-item" );

					// Prevent inital focus from firing and check if its a newly focused item
					if ( that.focusIndex != null && item.index !== that.focusIndex ) {
						that._trigger( "focus", event, { item: item } );
						if ( !that.isOpen ) {
							that._select( item, event );
						}
					}
					that.focusIndex = item.index;

					that.button.attr( "aria-activedescendant",
						that.menuItems.eq( item.index ).attr( "id" ) );
				}
			})
			.menu( "instance" );

		// Adjust menu styles to dropdown
		this.menu
			.addClass( "ui-corner-bottom" )
			.removeClass( "ui-corner-all" );

		// Don't close the menu on mouseleave
		this.menuInstance._off( this.menu, "mouseleave" );

		// Cancel the menu's collapseAll on document click
		this.menuInstance._closeOnDocumentClick = function() {
			return false;
		};

		// Selects often contain empty items, but never contain dividers
		this.menuInstance._isDivider = function() {
			return false;
		};
	},

	refresh: function() {
		this._refreshMenu();
		this._setText( this.buttonText, this._getSelectedItem().text() );
		if ( !this.options.width ) {
			this._resizeButton();
		}
	},

	_refreshMenu: function() {
		this.menu.empty();

		var item,
			options = this.element.find( "option" );

		if ( !options.length ) {
			return;
		}

		this._parseOptions( options );
		this._renderMenu( this.menu, this.items );

		this.menuInstance.refresh();
		this.menuItems = this.menu.find( "li" ).not( ".ui-selectmenu-optgroup" );

		item = this._getSelectedItem();

		// Update the menu to have the correct item focused
		this.menuInstance.focus( null, item );
		this._setAria( item.data( "ui-selectmenu-item" ) );

		// Set disabled state
		this._setOption( "disabled", this.element.prop( "disabled" ) );
	},

	open: function( event ) {
		if ( this.options.disabled ) {
			return;
		}

		// If this is the first time the menu is being opened, render the items
		if ( !this.menuItems ) {
			this._refreshMenu();
		} else {

			// Menu clears focus on close, reset focus to selected item
			this.menu.find( ".ui-state-focus" ).removeClass( "ui-state-focus" );
			this.menuInstance.focus( null, this._getSelectedItem() );
		}

		this.isOpen = true;
		this._toggleAttr();
		this._resizeMenu();
		this._position();

		this._on( this.document, this._documentClick );

		this._trigger( "open", event );
	},

	_position: function() {
		this.menuWrap.position( $.extend( { of: this.button }, this.options.position ) );
	},

	close: function( event ) {
		if ( !this.isOpen ) {
			return;
		}

		this.isOpen = false;
		this._toggleAttr();

		this.range = null;
		this._off( this.document );

		this._trigger( "close", event );
	},

	widget: function() {
		return this.button;
	},

	menuWidget: function() {
		return this.menu;
	},

	_renderMenu: function( ul, items ) {
		var that = this,
			currentOptgroup = "";

		$.each( items, function( index, item ) {
			if ( item.optgroup !== currentOptgroup ) {
				$( "<li>", {
					"class": "ui-selectmenu-optgroup ui-menu-divider" +
						( item.element.parent( "optgroup" ).prop( "disabled" ) ?
							" ui-state-disabled" :
							"" ),
					text: item.optgroup
				})
					.appendTo( ul );

				currentOptgroup = item.optgroup;
			}

			that._renderItemData( ul, item );
		});
	},

	_renderItemData: function( ul, item ) {
		return this._renderItem( ul, item ).data( "ui-selectmenu-item", item );
	},

	_renderItem: function( ul, item ) {
		var li = $( "<li>" );

		if ( item.disabled ) {
			li.addClass( "ui-state-disabled" );
		}
		this._setText( li, item.label );

		return li.appendTo( ul );
	},

	_setText: function( element, value ) {
		if ( value ) {
			element.text( value );
		} else {
			element.html( "&#160;" );
		}
	},

	_move: function( direction, event ) {
		var item, next,
			filter = ".ui-menu-item";

		if ( this.isOpen ) {
			item = this.menuItems.eq( this.focusIndex );
		} else {
			item = this.menuItems.eq( this.element[ 0 ].selectedIndex );
			filter += ":not(.ui-state-disabled)";
		}

		if ( direction === "first" || direction === "last" ) {
			next = item[ direction === "first" ? "prevAll" : "nextAll" ]( filter ).eq( -1 );
		} else {
			next = item[ direction + "All" ]( filter ).eq( 0 );
		}

		if ( next.length ) {
			this.menuInstance.focus( event, next );
		}
	},

	_getSelectedItem: function() {
		return this.menuItems.eq( this.element[ 0 ].selectedIndex );
	},

	_toggle: function( event ) {
		this[ this.isOpen ? "close" : "open" ]( event );
	},

	_setSelection: function() {
		var selection;

		if ( !this.range ) {
			return;
		}

		if ( window.getSelection ) {
			selection = window.getSelection();
			selection.removeAllRanges();
			selection.addRange( this.range );

		// support: IE8
		} else {
			this.range.select();
		}

		// support: IE
		// Setting the text selection kills the button focus in IE, but
		// restoring the focus doesn't kill the selection.
		this.button.focus();
	},

	_documentClick: {
		mousedown: function( event ) {
			if ( !this.isOpen ) {
				return;
			}

			if ( !$( event.target ).closest( ".ui-selectmenu-menu, #" + this.ids.button ).length ) {
				this.close( event );
			}
		}
	},

	_buttonEvents: {

		// Prevent text selection from being reset when interacting with the selectmenu (#10144)
		mousedown: function() {
			var selection;

			if ( window.getSelection ) {
				selection = window.getSelection();
				if ( selection.rangeCount ) {
					this.range = selection.getRangeAt( 0 );
				}

			// support: IE8
			} else {
				this.range = document.selection.createRange();
			}
		},

		click: function( event ) {
			this._setSelection();
			this._toggle( event );
		},

		keydown: function( event ) {
			var preventDefault = true;
			switch ( event.keyCode ) {
				case $.ui.keyCode.TAB:
				case $.ui.keyCode.ESCAPE:
					this.close( event );
					preventDefault = false;
					break;
				case $.ui.keyCode.ENTER:
					if ( this.isOpen ) {
						this._selectFocusedItem( event );
					}
					break;
				case $.ui.keyCode.UP:
					if ( event.altKey ) {
						this._toggle( event );
					} else {
						this._move( "prev", event );
					}
					break;
				case $.ui.keyCode.DOWN:
					if ( event.altKey ) {
						this._toggle( event );
					} else {
						this._move( "next", event );
					}
					break;
				case $.ui.keyCode.SPACE:
					if ( this.isOpen ) {
						this._selectFocusedItem( event );
					} else {
						this._toggle( event );
					}
					break;
				case $.ui.keyCode.LEFT:
					this._move( "prev", event );
					break;
				case $.ui.keyCode.RIGHT:
					this._move( "next", event );
					break;
				case $.ui.keyCode.HOME:
				case $.ui.keyCode.PAGE_UP:
					this._move( "first", event );
					break;
				case $.ui.keyCode.END:
				case $.ui.keyCode.PAGE_DOWN:
					this._move( "last", event );
					break;
				default:
					this.menu.trigger( event );
					preventDefault = false;
			}

			if ( preventDefault ) {
				event.preventDefault();
			}
		}
	},

	_selectFocusedItem: function( event ) {
		var item = this.menuItems.eq( this.focusIndex );
		if ( !item.hasClass( "ui-state-disabled" ) ) {
			this._select( item.data( "ui-selectmenu-item" ), event );
		}
	},

	_select: function( item, event ) {
		var oldIndex = this.element[ 0 ].selectedIndex;

		// Change native select element
		this.element[ 0 ].selectedIndex = item.index;
		this._setText( this.buttonText, item.label );
		this._setAria( item );
		this._trigger( "select", event, { item: item } );

		if ( item.index !== oldIndex ) {
			this._trigger( "change", event, { item: item } );
		}

		this.close( event );
	},

	_setAria: function( item ) {
		var id = this.menuItems.eq( item.index ).attr( "id" );

		this.button.attr({
			"aria-labelledby": id,
			"aria-activedescendant": id
		});
		this.menu.attr( "aria-activedescendant", id );
	},

	_setOption: function( key, value ) {
		if ( key === "icons" ) {
			this.button.find( "span.ui-icon" )
				.removeClass( this.options.icons.button )
				.addClass( value.button );
		}

		this._super( key, value );

		if ( key === "appendTo" ) {
			this.menuWrap.appendTo( this._appendTo() );
		}

		if ( key === "disabled" ) {
			this.menuInstance.option( "disabled", value );
			this.button
				.toggleClass( "ui-state-disabled", value )
				.attr( "aria-disabled", value );

			this.element.prop( "disabled", value );
			if ( value ) {
				this.button.attr( "tabindex", -1 );
				this.close();
			} else {
				this.button.attr( "tabindex", 0 );
			}
		}

		if ( key === "width" ) {
			this._resizeButton();
		}
	},

	_appendTo: function() {
		var element = this.options.appendTo;

		if ( element ) {
			element = element.jquery || element.nodeType ?
				$( element ) :
				this.document.find( element ).eq( 0 );
		}

		if ( !element || !element[ 0 ] ) {
			element = this.element.closest( ".ui-front" );
		}

		if ( !element.length ) {
			element = this.document[ 0 ].body;
		}

		return element;
	},

	_toggleAttr: function() {
		this.button
			.toggleClass( "ui-corner-top", this.isOpen )
			.toggleClass( "ui-corner-all", !this.isOpen )
			.attr( "aria-expanded", this.isOpen );
		this.menuWrap.toggleClass( "ui-selectmenu-open", this.isOpen );
		this.menu.attr( "aria-hidden", !this.isOpen );
	},

	_resizeButton: function() {
		var width = this.options.width;

		if ( !width ) {
			width = this.element.show().outerWidth();
			this.element.hide();
		}

		this.button.outerWidth( width );
	},

	_resizeMenu: function() {
		this.menu.outerWidth( Math.max(
			this.button.outerWidth(),

			// support: IE10
			// IE10 wraps long text (possibly a rounding bug)
			// so we add 1px to avoid the wrapping
			this.menu.width( "" ).outerWidth() + 1
		) );
	},

	_getCreateOptions: function() {
		return { disabled: this.element.prop( "disabled" ) };
	},

	_parseOptions: function( options ) {
		var data = [];
		options.each(function( index, item ) {
			var option = $( item ),
				optgroup = option.parent( "optgroup" );
			data.push({
				element: option,
				index: index,
				value: option.val(),
				label: option.text(),
				optgroup: optgroup.attr( "label" ) || "",
				disabled: optgroup.prop( "disabled" ) || option.prop( "disabled" )
			});
		});
		this.items = data;
	},

	_destroy: function() {
		this.menuWrap.remove();
		this.button.remove();
		this.element.show();
		this.element.removeUniqueId();
		this.label.attr( "for", this.ids.element );
	}
});

}));




/*!
 * jQuery UI Slider 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/slider/
 */

(function( factory ) {
	if ( typeof define === "function" && define.amd ) {

		// AMD. Register as an anonymous module.
		define([
			"jquery",
			"./core",
			"./mouse",
			"./widget"
		], factory );
	} else {

		// Browser globals
		factory( jQuery );
	}
}(function( $ ) {

return $.widget( "ui.slider", $.ui.mouse, {
	version: "1.11.4",
	widgetEventPrefix: "slide",

	options: {
		animate: false,
		distance: 0,
		max: 100,
		min: 0,
		orientation: "horizontal",
		range: false,
		step: 1,
		value: 0,
		values: null,

		// callbacks
		change: null,
		slide: null,
		start: null,
		stop: null
	},

	// number of pages in a slider
	// (how many times can you page up/down to go through the whole range)
	numPages: 5,

	_create: function() {
		this._keySliding = false;
		this._mouseSliding = false;
		this._animateOff = true;
		this._handleIndex = null;
		this._detectOrientation();
		this._mouseInit();
		this._calculateNewMax();

		this.element
			.addClass( "ui-slider" +
				" ui-slider-" + this.orientation +
				" ui-widget" +
				" ui-widget-content" +
				" ui-corner-all");

		this._refresh();
		this._setOption( "disabled", this.options.disabled );

		this._animateOff = false;
	},

	_refresh: function() {
		this._createRange();
		this._createHandles();
		this._setupEvents();
		this._refreshValue();
	},

	_createHandles: function() {
		var i, handleCount,
			options = this.options,
			existingHandles = this.element.find( ".ui-slider-handle" ).addClass( "ui-state-default ui-corner-all" ),
			handle = "<span class='ui-slider-handle ui-state-default ui-corner-all' tabindex='0'></span>",
			handles = [];

		handleCount = ( options.values && options.values.length ) || 1;

		if ( existingHandles.length > handleCount ) {
			existingHandles.slice( handleCount ).remove();
			existingHandles = existingHandles.slice( 0, handleCount );
		}

		for ( i = existingHandles.length; i < handleCount; i++ ) {
			handles.push( handle );
		}

		this.handles = existingHandles.add( $( handles.join( "" ) ).appendTo( this.element ) );

		this.handle = this.handles.eq( 0 );

		this.handles.each(function( i ) {
			$( this ).data( "ui-slider-handle-index", i );
		});
	},

	_createRange: function() {
		var options = this.options,
			classes = "";

		if ( options.range ) {
			if ( options.range === true ) {
				if ( !options.values ) {
					options.values = [ this._valueMin(), this._valueMin() ];
				} else if ( options.values.length && options.values.length !== 2 ) {
					options.values = [ options.values[0], options.values[0] ];
				} else if ( $.isArray( options.values ) ) {
					options.values = options.values.slice(0);
				}
			}

			if ( !this.range || !this.range.length ) {
				this.range = $( "<div></div>" )
					.appendTo( this.element );

				classes = "ui-slider-range" +
				// note: this isn't the most fittingly semantic framework class for this element,
				// but worked best visually with a variety of themes
				" ui-widget-header ui-corner-all";
			} else {
				this.range.removeClass( "ui-slider-range-min ui-slider-range-max" )
					// Handle range switching from true to min/max
					.css({
						"left": "",
						"bottom": ""
					});
			}

			this.range.addClass( classes +
				( ( options.range === "min" || options.range === "max" ) ? " ui-slider-range-" + options.range : "" ) );
		} else {
			if ( this.range ) {
				this.range.remove();
			}
			this.range = null;
		}
	},

	_setupEvents: function() {
		this._off( this.handles );
		this._on( this.handles, this._handleEvents );
		this._hoverable( this.handles );
		this._focusable( this.handles );
	},

	_destroy: function() {
		this.handles.remove();
		if ( this.range ) {
			this.range.remove();
		}

		this.element
			.removeClass( "ui-slider" +
				" ui-slider-horizontal" +
				" ui-slider-vertical" +
				" ui-widget" +
				" ui-widget-content" +
				" ui-corner-all" );

		this._mouseDestroy();
	},

	_mouseCapture: function( event ) {
		var position, normValue, distance, closestHandle, index, allowed, offset, mouseOverHandle,
			that = this,
			o = this.options;

		if ( o.disabled ) {
			return false;
		}

		this.elementSize = {
			width: this.element.outerWidth(),
			height: this.element.outerHeight()
		};
		this.elementOffset = this.element.offset();

		position = { x: event.pageX, y: event.pageY };
		normValue = this._normValueFromMouse( position );
		distance = this._valueMax() - this._valueMin() + 1;
		this.handles.each(function( i ) {
			var thisDistance = Math.abs( normValue - that.values(i) );
			if (( distance > thisDistance ) ||
				( distance === thisDistance &&
					(i === that._lastChangedValue || that.values(i) === o.min ))) {
				distance = thisDistance;
				closestHandle = $( this );
				index = i;
			}
		});

		allowed = this._start( event, index );
		if ( allowed === false ) {
			return false;
		}
		this._mouseSliding = true;

		this._handleIndex = index;

		closestHandle
			.addClass( "ui-state-active" )
			.focus();

		offset = closestHandle.offset();
		mouseOverHandle = !$( event.target ).parents().addBack().is( ".ui-slider-handle" );
		this._clickOffset = mouseOverHandle ? { left: 0, top: 0 } : {
			left: event.pageX - offset.left - ( closestHandle.width() / 2 ),
			top: event.pageY - offset.top -
				( closestHandle.height() / 2 ) -
				( parseInt( closestHandle.css("borderTopWidth"), 10 ) || 0 ) -
				( parseInt( closestHandle.css("borderBottomWidth"), 10 ) || 0) +
				( parseInt( closestHandle.css("marginTop"), 10 ) || 0)
		};

		if ( !this.handles.hasClass( "ui-state-hover" ) ) {
			this._slide( event, index, normValue );
		}
		this._animateOff = true;
		return true;
	},

	_mouseStart: function() {
		return true;
	},

	_mouseDrag: function( event ) {
		var position = { x: event.pageX, y: event.pageY },
			normValue = this._normValueFromMouse( position );

		this._slide( event, this._handleIndex, normValue );

		return false;
	},

	_mouseStop: function( event ) {
		this.handles.removeClass( "ui-state-active" );
		this._mouseSliding = false;

		this._stop( event, this._handleIndex );
		this._change( event, this._handleIndex );

		this._handleIndex = null;
		this._clickOffset = null;
		this._animateOff = false;

		return false;
	},

	_detectOrientation: function() {
		this.orientation = ( this.options.orientation === "vertical" ) ? "vertical" : "horizontal";
	},

	_normValueFromMouse: function( position ) {
		var pixelTotal,
			pixelMouse,
			percentMouse,
			valueTotal,
			valueMouse;

		if ( this.orientation === "horizontal" ) {
			pixelTotal = this.elementSize.width;
			pixelMouse = position.x - this.elementOffset.left - ( this._clickOffset ? this._clickOffset.left : 0 );
		} else {
			pixelTotal = this.elementSize.height;
			pixelMouse = position.y - this.elementOffset.top - ( this._clickOffset ? this._clickOffset.top : 0 );
		}

		percentMouse = ( pixelMouse / pixelTotal );
		if ( percentMouse > 1 ) {
			percentMouse = 1;
		}
		if ( percentMouse < 0 ) {
			percentMouse = 0;
		}
		if ( this.orientation === "vertical" ) {
			percentMouse = 1 - percentMouse;
		}

		valueTotal = this._valueMax() - this._valueMin();
		valueMouse = this._valueMin() + percentMouse * valueTotal;

		return this._trimAlignValue( valueMouse );
	},

	_start: function( event, index ) {
		var uiHash = {
			handle: this.handles[ index ],
			value: this.value()
		};
		if ( this.options.values && this.options.values.length ) {
			uiHash.value = this.values( index );
			uiHash.values = this.values();
		}
		return this._trigger( "start", event, uiHash );
	},

	_slide: function( event, index, newVal ) {
		var otherVal,
			newValues,
			allowed;

		if ( this.options.values && this.options.values.length ) {
			otherVal = this.values( index ? 0 : 1 );

			if ( ( this.options.values.length === 2 && this.options.range === true ) &&
					( ( index === 0 && newVal > otherVal) || ( index === 1 && newVal < otherVal ) )
				) {
				newVal = otherVal;
			}

			if ( newVal !== this.values( index ) ) {
				newValues = this.values();
				newValues[ index ] = newVal;
				// A slide can be canceled by returning false from the slide callback
				allowed = this._trigger( "slide", event, {
					handle: this.handles[ index ],
					value: newVal,
					values: newValues
				} );
				otherVal = this.values( index ? 0 : 1 );
				if ( allowed !== false ) {
					this.values( index, newVal );
				}
			}
		} else {
			if ( newVal !== this.value() ) {
				// A slide can be canceled by returning false from the slide callback
				allowed = this._trigger( "slide", event, {
					handle: this.handles[ index ],
					value: newVal
				} );
				if ( allowed !== false ) {
					this.value( newVal );
				}
			}
		}
	},

	_stop: function( event, index ) {
		var uiHash = {
			handle: this.handles[ index ],
			value: this.value()
		};
		if ( this.options.values && this.options.values.length ) {
			uiHash.value = this.values( index );
			uiHash.values = this.values();
		}

		this._trigger( "stop", event, uiHash );
	},

	_change: function( event, index ) {
		if ( !this._keySliding && !this._mouseSliding ) {
			var uiHash = {
				handle: this.handles[ index ],
				value: this.value()
			};
			if ( this.options.values && this.options.values.length ) {
				uiHash.value = this.values( index );
				uiHash.values = this.values();
			}

			//store the last changed value index for reference when handles overlap
			this._lastChangedValue = index;

			this._trigger( "change", event, uiHash );
		}
	},

	value: function( newValue ) {
		if ( arguments.length ) {
			this.options.value = this._trimAlignValue( newValue );
			this._refreshValue();
			this._change( null, 0 );
			return;
		}

		return this._value();
	},

	values: function( index, newValue ) {
		var vals,
			newValues,
			i;

		if ( arguments.length > 1 ) {
			this.options.values[ index ] = this._trimAlignValue( newValue );
			this._refreshValue();
			this._change( null, index );
			return;
		}

		if ( arguments.length ) {
			if ( $.isArray( arguments[ 0 ] ) ) {
				vals = this.options.values;
				newValues = arguments[ 0 ];
				for ( i = 0; i < vals.length; i += 1 ) {
					vals[ i ] = this._trimAlignValue( newValues[ i ] );
					this._change( null, i );
				}
				this._refreshValue();
			} else {
				if ( this.options.values && this.options.values.length ) {
					return this._values( index );
				} else {
					return this.value();
				}
			}
		} else {
			return this._values();
		}
	},

	_setOption: function( key, value ) {
		var i,
			valsLength = 0;

		if ( key === "range" && this.options.range === true ) {
			if ( value === "min" ) {
				this.options.value = this._values( 0 );
				this.options.values = null;
			} else if ( value === "max" ) {
				this.options.value = this._values( this.options.values.length - 1 );
				this.options.values = null;
			}
		}

		if ( $.isArray( this.options.values ) ) {
			valsLength = this.options.values.length;
		}

		if ( key === "disabled" ) {
			this.element.toggleClass( "ui-state-disabled", !!value );
		}

		this._super( key, value );

		switch ( key ) {
			case "orientation":
				this._detectOrientation();
				this.element
					.removeClass( "ui-slider-horizontal ui-slider-vertical" )
					.addClass( "ui-slider-" + this.orientation );
				this._refreshValue();

				// Reset positioning from previous orientation
				this.handles.css( value === "horizontal" ? "bottom" : "left", "" );
				break;
			case "value":
				this._animateOff = true;
				this._refreshValue();
				this._change( null, 0 );
				this._animateOff = false;
				break;
			case "values":
				this._animateOff = true;
				this._refreshValue();
				for ( i = 0; i < valsLength; i += 1 ) {
					this._change( null, i );
				}
				this._animateOff = false;
				break;
			case "step":
			case "min":
			case "max":
				this._animateOff = true;
				this._calculateNewMax();
				this._refreshValue();
				this._animateOff = false;
				break;
			case "range":
				this._animateOff = true;
				this._refresh();
				this._animateOff = false;
				break;
		}
	},

	//internal value getter
	// _value() returns value trimmed by min and max, aligned by step
	_value: function() {
		var val = this.options.value;
		val = this._trimAlignValue( val );

		return val;
	},

	//internal values getter
	// _values() returns array of values trimmed by min and max, aligned by step
	// _values( index ) returns single value trimmed by min and max, aligned by step
	_values: function( index ) {
		var val,
			vals,
			i;

		if ( arguments.length ) {
			val = this.options.values[ index ];
			val = this._trimAlignValue( val );

			return val;
		} else if ( this.options.values && this.options.values.length ) {
			// .slice() creates a copy of the array
			// this copy gets trimmed by min and max and then returned
			vals = this.options.values.slice();
			for ( i = 0; i < vals.length; i += 1) {
				vals[ i ] = this._trimAlignValue( vals[ i ] );
			}

			return vals;
		} else {
			return [];
		}
	},

	// returns the step-aligned value that val is closest to, between (inclusive) min and max
	_trimAlignValue: function( val ) {
		if ( val <= this._valueMin() ) {
			return this._valueMin();
		}
		if ( val >= this._valueMax() ) {
			return this._valueMax();
		}
		var step = ( this.options.step > 0 ) ? this.options.step : 1,
			valModStep = (val - this._valueMin()) % step,
			alignValue = val - valModStep;

		if ( Math.abs(valModStep) * 2 >= step ) {
			alignValue += ( valModStep > 0 ) ? step : ( -step );
		}

		// Since JavaScript has problems with large floats, round
		// the final value to 5 digits after the decimal point (see #4124)
		return parseFloat( alignValue.toFixed(5) );
	},

	_calculateNewMax: function() {
		var max = this.options.max,
			min = this._valueMin(),
			step = this.options.step,
			aboveMin = Math.floor( ( +( max - min ).toFixed( this._precision() ) ) / step ) * step;
		max = aboveMin + min;
		this.max = parseFloat( max.toFixed( this._precision() ) );
	},

	_precision: function() {
		var precision = this._precisionOf( this.options.step );
		if ( this.options.min !== null ) {
			precision = Math.max( precision, this._precisionOf( this.options.min ) );
		}
		return precision;
	},

	_precisionOf: function( num ) {
		var str = num.toString(),
			decimal = str.indexOf( "." );
		return decimal === -1 ? 0 : str.length - decimal - 1;
	},

	_valueMin: function() {
		return this.options.min;
	},

	_valueMax: function() {
		return this.max;
	},

	_refreshValue: function() {
		var lastValPercent, valPercent, value, valueMin, valueMax,
			oRange = this.options.range,
			o = this.options,
			that = this,
			animate = ( !this._animateOff ) ? o.animate : false,
			_set = {};

		if ( this.options.values && this.options.values.length ) {
			this.handles.each(function( i ) {
				valPercent = ( that.values(i) - that._valueMin() ) / ( that._valueMax() - that._valueMin() ) * 100;
				_set[ that.orientation === "horizontal" ? "left" : "bottom" ] = valPercent + "%";
				$( this ).stop( 1, 1 )[ animate ? "animate" : "css" ]( _set, o.animate );
				if ( that.options.range === true ) {
					if ( that.orientation === "horizontal" ) {
						if ( i === 0 ) {
							that.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { left: valPercent + "%" }, o.animate );
						}
						if ( i === 1 ) {
							that.range[ animate ? "animate" : "css" ]( { width: ( valPercent - lastValPercent ) + "%" }, { queue: false, duration: o.animate } );
						}
					} else {
						if ( i === 0 ) {
							that.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { bottom: ( valPercent ) + "%" }, o.animate );
						}
						if ( i === 1 ) {
							that.range[ animate ? "animate" : "css" ]( { height: ( valPercent - lastValPercent ) + "%" }, { queue: false, duration: o.animate } );
						}
					}
				}
				lastValPercent = valPercent;
			});
		} else {
			value = this.value();
			valueMin = this._valueMin();
			valueMax = this._valueMax();
			valPercent = ( valueMax !== valueMin ) ?
					( value - valueMin ) / ( valueMax - valueMin ) * 100 :
					0;
			_set[ this.orientation === "horizontal" ? "left" : "bottom" ] = valPercent + "%";
			this.handle.stop( 1, 1 )[ animate ? "animate" : "css" ]( _set, o.animate );

			if ( oRange === "min" && this.orientation === "horizontal" ) {
				this.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { width: valPercent + "%" }, o.animate );
			}
			if ( oRange === "max" && this.orientation === "horizontal" ) {
				this.range[ animate ? "animate" : "css" ]( { width: ( 100 - valPercent ) + "%" }, { queue: false, duration: o.animate } );
			}
			if ( oRange === "min" && this.orientation === "vertical" ) {
				this.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { height: valPercent + "%" }, o.animate );
			}
			if ( oRange === "max" && this.orientation === "vertical" ) {
				this.range[ animate ? "animate" : "css" ]( { height: ( 100 - valPercent ) + "%" }, { queue: false, duration: o.animate } );
			}
		}
	},

	_handleEvents: {
		keydown: function( event ) {
			var allowed, curVal, newVal, step,
				index = $( event.target ).data( "ui-slider-handle-index" );

			switch ( event.keyCode ) {
				case $.ui.keyCode.HOME:
				case $.ui.keyCode.END:
				case $.ui.keyCode.PAGE_UP:
				case $.ui.keyCode.PAGE_DOWN:
				case $.ui.keyCode.UP:
				case $.ui.keyCode.RIGHT:
				case $.ui.keyCode.DOWN:
				case $.ui.keyCode.LEFT:
					event.preventDefault();
					if ( !this._keySliding ) {
						this._keySliding = true;
						$( event.target ).addClass( "ui-state-active" );
						allowed = this._start( event, index );
						if ( allowed === false ) {
							return;
						}
					}
					break;
			}

			step = this.options.step;
			if ( this.options.values && this.options.values.length ) {
				curVal = newVal = this.values( index );
			} else {
				curVal = newVal = this.value();
			}

			switch ( event.keyCode ) {
				case $.ui.keyCode.HOME:
					newVal = this._valueMin();
					break;
				case $.ui.keyCode.END:
					newVal = this._valueMax();
					break;
				case $.ui.keyCode.PAGE_UP:
					newVal = this._trimAlignValue(
						curVal + ( ( this._valueMax() - this._valueMin() ) / this.numPages )
					);
					break;
				case $.ui.keyCode.PAGE_DOWN:
					newVal = this._trimAlignValue(
						curVal - ( (this._valueMax() - this._valueMin()) / this.numPages ) );
					break;
				case $.ui.keyCode.UP:
				case $.ui.keyCode.RIGHT:
					if ( curVal === this._valueMax() ) {
						return;
					}
					newVal = this._trimAlignValue( curVal + step );
					break;
				case $.ui.keyCode.DOWN:
				case $.ui.keyCode.LEFT:
					if ( curVal === this._valueMin() ) {
						return;
					}
					newVal = this._trimAlignValue( curVal - step );
					break;
			}

			this._slide( event, index, newVal );
		},
		keyup: function( event ) {
			var index = $( event.target ).data( "ui-slider-handle-index" );

			if ( this._keySliding ) {
				this._keySliding = false;
				this._stop( event, index );
				this._change( event, index );
				$( event.target ).removeClass( "ui-state-active" );
			}
		}
	}
});

}));




/*!
 * jQuery UI Sortable 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/sortable/
 */

(function( factory ) {
	if ( typeof define === "function" && define.amd ) {

		// AMD. Register as an anonymous module.
		define([
			"jquery",
			"./core",
			"./mouse",
			"./widget"
		], factory );
	} else {

		// Browser globals
		factory( jQuery );
	}
}(function( $ ) {

return $.widget("ui.sortable", $.ui.mouse, {
	version: "1.11.4",
	widgetEventPrefix: "sort",
	ready: false,
	options: {
		appendTo: "parent",
		axis: false,
		connectWith: false,
		containment: false,
		cursor: "auto",
		cursorAt: false,
		dropOnEmpty: true,
		forcePlaceholderSize: false,
		forceHelperSize: false,
		grid: false,
		handle: false,
		helper: "original",
		items: "> *",
		opacity: false,
		placeholder: false,
		revert: false,
		scroll: true,
		scrollSensitivity: 20,
		scrollSpeed: 20,
		scope: "default",
		tolerance: "intersect",
		zIndex: 1000,

		// callbacks
		activate: null,
		beforeStop: null,
		change: null,
		deactivate: null,
		out: null,
		over: null,
		receive: null,
		remove: null,
		sort: null,
		start: null,
		stop: null,
		update: null
	},

	_isOverAxis: function( x, reference, size ) {
		return ( x >= reference ) && ( x < ( reference + size ) );
	},

	_isFloating: function( item ) {
		return (/left|right/).test(item.css("float")) || (/inline|table-cell/).test(item.css("display"));
	},

	_create: function() {
		this.containerCache = {};
		this.element.addClass("ui-sortable");

		//Get the items
		this.refresh();

		//Let's determine the parent's offset
		this.offset = this.element.offset();

		//Initialize mouse events for interaction
		this._mouseInit();

		this._setHandleClassName();

		//We're ready to go
		this.ready = true;

	},

	_setOption: function( key, value ) {
		this._super( key, value );

		if ( key === "handle" ) {
			this._setHandleClassName();
		}
	},

	_setHandleClassName: function() {
		this.element.find( ".ui-sortable-handle" ).removeClass( "ui-sortable-handle" );
		$.each( this.items, function() {
			( this.instance.options.handle ?
				this.item.find( this.instance.options.handle ) : this.item )
				.addClass( "ui-sortable-handle" );
		});
	},

	_destroy: function() {
		this.element
			.removeClass( "ui-sortable ui-sortable-disabled" )
			.find( ".ui-sortable-handle" )
				.removeClass( "ui-sortable-handle" );
		this._mouseDestroy();

		for ( var i = this.items.length - 1; i >= 0; i-- ) {
			this.items[i].item.removeData(this.widgetName + "-item");
		}

		return this;
	},

	_mouseCapture: function(event, overrideHandle) {
		var currentItem = null,
			validHandle = false,
			that = this;

		if (this.reverting) {
			return false;
		}

		if(this.options.disabled || this.options.type === "static") {
			return false;
		}

		//We have to refresh the items data once first
		this._refreshItems(event);

		//Find out if the clicked node (or one of its parents) is a actual item in this.items
		$(event.target).parents().each(function() {
			if($.data(this, that.widgetName + "-item") === that) {
				currentItem = $(this);
				return false;
			}
		});
		if($.data(event.target, that.widgetName + "-item") === that) {
			currentItem = $(event.target);
		}

		if(!currentItem) {
			return false;
		}
		if(this.options.handle && !overrideHandle) {
			$(this.options.handle, currentItem).find("*").addBack().each(function() {
				if(this === event.target) {
					validHandle = true;
				}
			});
			if(!validHandle) {
				return false;
			}
		}

		this.currentItem = currentItem;
		this._removeCurrentsFromItems();
		return true;

	},

	_mouseStart: function(event, overrideHandle, noActivation) {

		var i, body,
			o = this.options;

		this.currentContainer = this;

		//We only need to call refreshPositions, because the refreshItems call has been moved to mouseCapture
		this.refreshPositions();

		//Create and append the visible helper
		this.helper = this._createHelper(event);

		//Cache the helper size
		this._cacheHelperProportions();

		/*
		 * - Position generation -
		 * This block generates everything position related - it's the core of draggables.
		 */

		//Cache the margins of the original element
		this._cacheMargins();

		//Get the next scrolling parent
		this.scrollParent = this.helper.scrollParent();

		//The element's absolute position on the page minus margins
		this.offset = this.currentItem.offset();
		this.offset = {
			top: this.offset.top - this.margins.top,
			left: this.offset.left - this.margins.left
		};

		$.extend(this.offset, {
			click: { //Where the click happened, relative to the element
				left: event.pageX - this.offset.left,
				top: event.pageY - this.offset.top
			},
			parent: this._getParentOffset(),
			relative: this._getRelativeOffset() //This is a relative to absolute position minus the actual position calculation - only used for relative positioned helper
		});

		// Only after we got the offset, we can change the helper's position to absolute
		// TODO: Still need to figure out a way to make relative sorting possible
		this.helper.css("position", "absolute");
		this.cssPosition = this.helper.css("position");

		//Generate the original position
		this.originalPosition = this._generatePosition(event);
		this.originalPageX = event.pageX;
		this.originalPageY = event.pageY;

		//Adjust the mouse offset relative to the helper if "cursorAt" is supplied
		(o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt));

		//Cache the former DOM position
		this.domPosition = { prev: this.currentItem.prev()[0], parent: this.currentItem.parent()[0] };

		//If the helper is not the original, hide the original so it's not playing any role during the drag, won't cause anything bad this way
		if(this.helper[0] !== this.currentItem[0]) {
			this.currentItem.hide();
		}

		//Create the placeholder
		this._createPlaceholder();

		//Set a containment if given in the options
		if(o.containment) {
			this._setContainment();
		}

		if( o.cursor && o.cursor !== "auto" ) { // cursor option
			body = this.document.find( "body" );

			// support: IE
			this.storedCursor = body.css( "cursor" );
			body.css( "cursor", o.cursor );

			this.storedStylesheet = $( "<style>*{ cursor: "+o.cursor+" !important; }</style>" ).appendTo( body );
		}

		if(o.opacity) { // opacity option
			if (this.helper.css("opacity")) {
				this._storedOpacity = this.helper.css("opacity");
			}
			this.helper.css("opacity", o.opacity);
		}

		if(o.zIndex) { // zIndex option
			if (this.helper.css("zIndex")) {
				this._storedZIndex = this.helper.css("zIndex");
			}
			this.helper.css("zIndex", o.zIndex);
		}

		//Prepare scrolling
		if(this.scrollParent[0] !== this.document[0] && this.scrollParent[0].tagName !== "HTML") {
			this.overflowOffset = this.scrollParent.offset();
		}

		//Call callbacks
		this._trigger("start", event, this._uiHash());

		//Recache the helper size
		if(!this._preserveHelperProportions) {
			this._cacheHelperProportions();
		}


		//Post "activate" events to possible containers
		if( !noActivation ) {
			for ( i = this.containers.length - 1; i >= 0; i-- ) {
				this.containers[ i ]._trigger( "activate", event, this._uiHash( this ) );
			}
		}

		//Prepare possible droppables
		if($.ui.ddmanager) {
			$.ui.ddmanager.current = this;
		}

		if ($.ui.ddmanager && !o.dropBehaviour) {
			$.ui.ddmanager.prepareOffsets(this, event);
		}

		this.dragging = true;

		this.helper.addClass("ui-sortable-helper");
		this._mouseDrag(event); //Execute the drag once - this causes the helper not to be visible before getting its correct position
		return true;

	},

	_mouseDrag: function(event) {
		var i, item, itemElement, intersection,
			o = this.options,
			scrolled = false;

		//Compute the helpers position
		this.position = this._generatePosition(event);
		this.positionAbs = this._convertPositionTo("absolute");

		if (!this.lastPositionAbs) {
			this.lastPositionAbs = this.positionAbs;
		}

		//Do scrolling
		if(this.options.scroll) {
			if(this.scrollParent[0] !== this.document[0] && this.scrollParent[0].tagName !== "HTML") {

				if((this.overflowOffset.top + this.scrollParent[0].offsetHeight) - event.pageY < o.scrollSensitivity) {
					this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop + o.scrollSpeed;
				} else if(event.pageY - this.overflowOffset.top < o.scrollSensitivity) {
					this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop - o.scrollSpeed;
				}

				if((this.overflowOffset.left + this.scrollParent[0].offsetWidth) - event.pageX < o.scrollSensitivity) {
					this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft + o.scrollSpeed;
				} else if(event.pageX - this.overflowOffset.left < o.scrollSensitivity) {
					this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft - o.scrollSpeed;
				}

			} else {

				if(event.pageY - this.document.scrollTop() < o.scrollSensitivity) {
					scrolled = this.document.scrollTop(this.document.scrollTop() - o.scrollSpeed);
				} else if(this.window.height() - (event.pageY - this.document.scrollTop()) < o.scrollSensitivity) {
					scrolled = this.document.scrollTop(this.document.scrollTop() + o.scrollSpeed);
				}

				if(event.pageX - this.document.scrollLeft() < o.scrollSensitivity) {
					scrolled = this.document.scrollLeft(this.document.scrollLeft() - o.scrollSpeed);
				} else if(this.window.width() - (event.pageX - this.document.scrollLeft()) < o.scrollSensitivity) {
					scrolled = this.document.scrollLeft(this.document.scrollLeft() + o.scrollSpeed);
				}

			}

			if(scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {
				$.ui.ddmanager.prepareOffsets(this, event);
			}
		}

		//Regenerate the absolute position used for position checks
		this.positionAbs = this._convertPositionTo("absolute");

		//Set the helper position
		if(!this.options.axis || this.options.axis !== "y") {
			this.helper[0].style.left = this.position.left+"px";
		}
		if(!this.options.axis || this.options.axis !== "x") {
			this.helper[0].style.top = this.position.top+"px";
		}

		//Rearrange
		for (i = this.items.length - 1; i >= 0; i--) {

			//Cache variables and intersection, continue if no intersection
			item = this.items[i];
			itemElement = item.item[0];
			intersection = this._intersectsWithPointer(item);
			if (!intersection) {
				continue;
			}

			// Only put the placeholder inside the current Container, skip all
			// items from other containers. This works because when moving
			// an item from one container to another the
			// currentContainer is switched before the placeholder is moved.
			//
			// Without this, moving items in "sub-sortables" can cause
			// the placeholder to jitter between the outer and inner container.
			if (item.instance !== this.currentContainer) {
				continue;
			}

			// cannot intersect with itself
			// no useless actions that have been done before
			// no action if the item moved is the parent of the item checked
			if (itemElement !== this.currentItem[0] &&
				this.placeholder[intersection === 1 ? "next" : "prev"]()[0] !== itemElement &&
				!$.contains(this.placeholder[0], itemElement) &&
				(this.options.type === "semi-dynamic" ? !$.contains(this.element[0], itemElement) : true)
			) {

				this.direction = intersection === 1 ? "down" : "up";

				if (this.options.tolerance === "pointer" || this._intersectsWithSides(item)) {
					this._rearrange(event, item);
				} else {
					break;
				}

				this._trigger("change", event, this._uiHash());
				break;
			}
		}

		//Post events to containers
		this._contactContainers(event);

		//Interconnect with droppables
		if($.ui.ddmanager) {
			$.ui.ddmanager.drag(this, event);
		}

		//Call callbacks
		this._trigger("sort", event, this._uiHash());

		this.lastPositionAbs = this.positionAbs;
		return false;

	},

	_mouseStop: function(event, noPropagation) {

		if(!event) {
			return;
		}

		//If we are using droppables, inform the manager about the drop
		if ($.ui.ddmanager && !this.options.dropBehaviour) {
			$.ui.ddmanager.drop(this, event);
		}

		if(this.options.revert) {
			var that = this,
				cur = this.placeholder.offset(),
				axis = this.options.axis,
				animation = {};

			if ( !axis || axis === "x" ) {
				animation.left = cur.left - this.offset.parent.left - this.margins.left + (this.offsetParent[0] === this.document[0].body ? 0 : this.offsetParent[0].scrollLeft);
			}
			if ( !axis || axis === "y" ) {
				animation.top = cur.top - this.offset.parent.top - this.margins.top + (this.offsetParent[0] === this.document[0].body ? 0 : this.offsetParent[0].scrollTop);
			}
			this.reverting = true;
			$(this.helper).animate( animation, parseInt(this.options.revert, 10) || 500, function() {
				that._clear(event);
			});
		} else {
			this._clear(event, noPropagation);
		}

		return false;

	},

	cancel: function() {

		if(this.dragging) {

			this._mouseUp({ target: null });

			if(this.options.helper === "original") {
				this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper");
			} else {
				this.currentItem.show();
			}

			//Post deactivating events to containers
			for (var i = this.containers.length - 1; i >= 0; i--){
				this.containers[i]._trigger("deactivate", null, this._uiHash(this));
				if(this.containers[i].containerCache.over) {
					this.containers[i]._trigger("out", null, this._uiHash(this));
					this.containers[i].containerCache.over = 0;
				}
			}

		}

		if (this.placeholder) {
			//$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!
			if(this.placeholder[0].parentNode) {
				this.placeholder[0].parentNode.removeChild(this.placeholder[0]);
			}
			if(this.options.helper !== "original" && this.helper && this.helper[0].parentNode) {
				this.helper.remove();
			}

			$.extend(this, {
				helper: null,
				dragging: false,
				reverting: false,
				_noFinalSort: null
			});

			if(this.domPosition.prev) {
				$(this.domPosition.prev).after(this.currentItem);
			} else {
				$(this.domPosition.parent).prepend(this.currentItem);
			}
		}

		return this;

	},

	serialize: function(o) {

		var items = this._getItemsAsjQuery(o && o.connected),
			str = [];
		o = o || {};

		$(items).each(function() {
			var res = ($(o.item || this).attr(o.attribute || "id") || "").match(o.expression || (/(.+)[\-=_](.+)/));
			if (res) {
				str.push((o.key || res[1]+"[]")+"="+(o.key && o.expression ? res[1] : res[2]));
			}
		});

		if(!str.length && o.key) {
			str.push(o.key + "=");
		}

		return str.join("&");

	},

	toArray: function(o) {

		var items = this._getItemsAsjQuery(o && o.connected),
			ret = [];

		o = o || {};

		items.each(function() { ret.push($(o.item || this).attr(o.attribute || "id") || ""); });
		return ret;

	},

	/* Be careful with the following core functions */
	_intersectsWith: function(item) {

		var x1 = this.positionAbs.left,
			x2 = x1 + this.helperProportions.width,
			y1 = this.positionAbs.top,
			y2 = y1 + this.helperProportions.height,
			l = item.left,
			r = l + item.width,
			t = item.top,
			b = t + item.height,
			dyClick = this.offset.click.top,
			dxClick = this.offset.click.left,
			isOverElementHeight = ( this.options.axis === "x" ) || ( ( y1 + dyClick ) > t && ( y1 + dyClick ) < b ),
			isOverElementWidth = ( this.options.axis === "y" ) || ( ( x1 + dxClick ) > l && ( x1 + dxClick ) < r ),
			isOverElement = isOverElementHeight && isOverElementWidth;

		if ( this.options.tolerance === "pointer" ||
			this.options.forcePointerForContainers ||
			(this.options.tolerance !== "pointer" && this.helperProportions[this.floating ? "width" : "height"] > item[this.floating ? "width" : "height"])
		) {
			return isOverElement;
		} else {

			return (l < x1 + (this.helperProportions.width / 2) && // Right Half
				x2 - (this.helperProportions.width / 2) < r && // Left Half
				t < y1 + (this.helperProportions.height / 2) && // Bottom Half
				y2 - (this.helperProportions.height / 2) < b ); // Top Half

		}
	},

	_intersectsWithPointer: function(item) {

		var isOverElementHeight = (this.options.axis === "x") || this._isOverAxis(this.positionAbs.top + this.offset.click.top, item.top, item.height),
			isOverElementWidth = (this.options.axis === "y") || this._isOverAxis(this.positionAbs.left + this.offset.click.left, item.left, item.width),
			isOverElement = isOverElementHeight && isOverElementWidth,
			verticalDirection = this._getDragVerticalDirection(),
			horizontalDirection = this._getDragHorizontalDirection();

		if (!isOverElement) {
			return false;
		}

		return this.floating ?
			( ((horizontalDirection && horizontalDirection === "right") || verticalDirection === "down") ? 2 : 1 )
			: ( verticalDirection && (verticalDirection === "down" ? 2 : 1) );

	},

	_intersectsWithSides: function(item) {

		var isOverBottomHalf = this._isOverAxis(this.positionAbs.top + this.offset.click.top, item.top + (item.height/2), item.height),
			isOverRightHalf = this._isOverAxis(this.positionAbs.left + this.offset.click.left, item.left + (item.width/2), item.width),
			verticalDirection = this._getDragVerticalDirection(),
			horizontalDirection = this._getDragHorizontalDirection();

		if (this.floating && horizontalDirection) {
			return ((horizontalDirection === "right" && isOverRightHalf) || (horizontalDirection === "left" && !isOverRightHalf));
		} else {
			return verticalDirection && ((verticalDirection === "down" && isOverBottomHalf) || (verticalDirection === "up" && !isOverBottomHalf));
		}

	},

	_getDragVerticalDirection: function() {
		var delta = this.positionAbs.top - this.lastPositionAbs.top;
		return delta !== 0 && (delta > 0 ? "down" : "up");
	},

	_getDragHorizontalDirection: function() {
		var delta = this.positionAbs.left - this.lastPositionAbs.left;
		return delta !== 0 && (delta > 0 ? "right" : "left");
	},

	refresh: function(event) {
		this._refreshItems(event);
		this._setHandleClassName();
		this.refreshPositions();
		return this;
	},

	_connectWith: function() {
		var options = this.options;
		return options.connectWith.constructor === String ? [options.connectWith] : options.connectWith;
	},

	_getItemsAsjQuery: function(connected) {

		var i, j, cur, inst,
			items = [],
			queries = [],
			connectWith = this._connectWith();

		if(connectWith && connected) {
			for (i = connectWith.length - 1; i >= 0; i--){
				cur = $(connectWith[i], this.document[0]);
				for ( j = cur.length - 1; j >= 0; j--){
					inst = $.data(cur[j], this.widgetFullName);
					if(inst && inst !== this && !inst.options.disabled) {
						queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element) : $(inst.options.items, inst.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), inst]);
					}
				}
			}
		}

		queries.push([$.isFunction(this.options.items) ? this.options.items.call(this.element, null, { options: this.options, item: this.currentItem }) : $(this.options.items, this.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), this]);

		function addItems() {
			items.push( this );
		}
		for (i = queries.length - 1; i >= 0; i--){
			queries[i][0].each( addItems );
		}

		return $(items);

	},

	_removeCurrentsFromItems: function() {

		var list = this.currentItem.find(":data(" + this.widgetName + "-item)");

		this.items = $.grep(this.items, function (item) {
			for (var j=0; j < list.length; j++) {
				if(list[j] === item.item[0]) {
					return false;
				}
			}
			return true;
		});

	},

	_refreshItems: function(event) {

		this.items = [];
		this.containers = [this];

		var i, j, cur, inst, targetData, _queries, item, queriesLength,
			items = this.items,
			queries = [[$.isFunction(this.options.items) ? this.options.items.call(this.element[0], event, { item: this.currentItem }) : $(this.options.items, this.element), this]],
			connectWith = this._connectWith();

		if(connectWith && this.ready) { //Shouldn't be run the first time through due to massive slow-down
			for (i = connectWith.length - 1; i >= 0; i--){
				cur = $(connectWith[i], this.document[0]);
				for (j = cur.length - 1; j >= 0; j--){
					inst = $.data(cur[j], this.widgetFullName);
					if(inst && inst !== this && !inst.options.disabled) {
						queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element[0], event, { item: this.currentItem }) : $(inst.options.items, inst.element), inst]);
						this.containers.push(inst);
					}
				}
			}
		}

		for (i = queries.length - 1; i >= 0; i--) {
			targetData = queries[i][1];
			_queries = queries[i][0];

			for (j=0, queriesLength = _queries.length; j < queriesLength; j++) {
				item = $(_queries[j]);

				item.data(this.widgetName + "-item", targetData); // Data for target checking (mouse manager)

				items.push({
					item: item,
					instance: targetData,
					width: 0, height: 0,
					left: 0, top: 0
				});
			}
		}

	},

	refreshPositions: function(fast) {

		// Determine whether items are being displayed horizontally
		this.floating = this.items.length ?
			this.options.axis === "x" || this._isFloating( this.items[ 0 ].item ) :
			false;

		//This has to be redone because due to the item being moved out/into the offsetParent, the offsetParent's position will change
		if(this.offsetParent && this.helper) {
			this.offset.parent = this._getParentOffset();
		}

		var i, item, t, p;

		for (i = this.items.length - 1; i >= 0; i--){
			item = this.items[i];

			//We ignore calculating positions of all connected containers when we're not over them
			if(item.instance !== this.currentContainer && this.currentContainer && item.item[0] !== this.currentItem[0]) {
				continue;
			}

			t = this.options.toleranceElement ? $(this.options.toleranceElement, item.item) : item.item;

			if (!fast) {
				item.width = t.outerWidth();
				item.height = t.outerHeight();
			}

			p = t.offset();
			item.left = p.left;
			item.top = p.top;
		}

		if(this.options.custom && this.options.custom.refreshContainers) {
			this.options.custom.refreshContainers.call(this);
		} else {
			for (i = this.containers.length - 1; i >= 0; i--){
				p = this.containers[i].element.offset();
				this.containers[i].containerCache.left = p.left;
				this.containers[i].containerCache.top = p.top;
				this.containers[i].containerCache.width = this.containers[i].element.outerWidth();
				this.containers[i].containerCache.height = this.containers[i].element.outerHeight();
			}
		}

		return this;
	},

	_createPlaceholder: function(that) {
		that = that || this;
		var className,
			o = that.options;

		if(!o.placeholder || o.placeholder.constructor === String) {
			className = o.placeholder;
			o.placeholder = {
				element: function() {

					var nodeName = that.currentItem[0].nodeName.toLowerCase(),
						element = $( "<" + nodeName + ">", that.document[0] )
							.addClass(className || that.currentItem[0].className+" ui-sortable-placeholder")
							.removeClass("ui-sortable-helper");

					if ( nodeName === "tbody" ) {
						that._createTrPlaceholder(
							that.currentItem.find( "tr" ).eq( 0 ),
							$( "<tr>", that.document[ 0 ] ).appendTo( element )
						);
					} else if ( nodeName === "tr" ) {
						that._createTrPlaceholder( that.currentItem, element );
					} else if ( nodeName === "img" ) {
						element.attr( "src", that.currentItem.attr( "src" ) );
					}

					if ( !className ) {
						element.css( "visibility", "hidden" );
					}

					return element;
				},
				update: function(container, p) {

					// 1. If a className is set as 'placeholder option, we don't force sizes - the class is responsible for that
					// 2. The option 'forcePlaceholderSize can be enabled to force it even if a class name is specified
					if(className && !o.forcePlaceholderSize) {
						return;
					}

					//If the element doesn't have a actual height by itself (without styles coming from a stylesheet), it receives the inline height from the dragged item
					if(!p.height()) { p.height(that.currentItem.innerHeight() - parseInt(that.currentItem.css("paddingTop")||0, 10) - parseInt(that.currentItem.css("paddingBottom")||0, 10)); }
					if(!p.width()) { p.width(that.currentItem.innerWidth() - parseInt(that.currentItem.css("paddingLeft")||0, 10) - parseInt(that.currentItem.css("paddingRight")||0, 10)); }
				}
			};
		}

		//Create the placeholder
		that.placeholder = $(o.placeholder.element.call(that.element, that.currentItem));

		//Append it after the actual current item
		that.currentItem.after(that.placeholder);

		//Update the size of the placeholder (TODO: Logic to fuzzy, see line 316/317)
		o.placeholder.update(that, that.placeholder);

	},

	_createTrPlaceholder: function( sourceTr, targetTr ) {
		var that = this;

		sourceTr.children().each(function() {
			$( "<td>&#160;</td>", that.document[ 0 ] )
				.attr( "colspan", $( this ).attr( "colspan" ) || 1 )
				.appendTo( targetTr );
		});
	},

	_contactContainers: function(event) {
		var i, j, dist, itemWithLeastDistance, posProperty, sizeProperty, cur, nearBottom, floating, axis,
			innermostContainer = null,
			innermostIndex = null;

		// get innermost container that intersects with item
		for (i = this.containers.length - 1; i >= 0; i--) {

			// never consider a container that's located within the item itself
			if($.contains(this.currentItem[0], this.containers[i].element[0])) {
				continue;
			}

			if(this._intersectsWith(this.containers[i].containerCache)) {

				// if we've already found a container and it's more "inner" than this, then continue
				if(innermostContainer && $.contains(this.containers[i].element[0], innermostContainer.element[0])) {
					continue;
				}

				innermostContainer = this.containers[i];
				innermostIndex = i;

			} else {
				// container doesn't intersect. trigger "out" event if necessary
				if(this.containers[i].containerCache.over) {
					this.containers[i]._trigger("out", event, this._uiHash(this));
					this.containers[i].containerCache.over = 0;
				}
			}

		}

		// if no intersecting containers found, return
		if(!innermostContainer) {
			return;
		}

		// move the item into the container if it's not there already
		if(this.containers.length === 1) {
			if (!this.containers[innermostIndex].containerCache.over) {
				this.containers[innermostIndex]._trigger("over", event, this._uiHash(this));
				this.containers[innermostIndex].containerCache.over = 1;
			}
		} else {

			//When entering a new container, we will find the item with the least distance and append our item near it
			dist = 10000;
			itemWithLeastDistance = null;
			floating = innermostContainer.floating || this._isFloating(this.currentItem);
			posProperty = floating ? "left" : "top";
			sizeProperty = floating ? "width" : "height";
			axis = floating ? "clientX" : "clientY";

			for (j = this.items.length - 1; j >= 0; j--) {
				if(!$.contains(this.containers[innermostIndex].element[0], this.items[j].item[0])) {
					continue;
				}
				if(this.items[j].item[0] === this.currentItem[0]) {
					continue;
				}

				cur = this.items[j].item.offset()[posProperty];
				nearBottom = false;
				if ( event[ axis ] - cur > this.items[ j ][ sizeProperty ] / 2 ) {
					nearBottom = true;
				}

				if ( Math.abs( event[ axis ] - cur ) < dist ) {
					dist = Math.abs( event[ axis ] - cur );
					itemWithLeastDistance = this.items[ j ];
					this.direction = nearBottom ? "up": "down";
				}
			}

			//Check if dropOnEmpty is enabled
			if(!itemWithLeastDistance && !this.options.dropOnEmpty) {
				return;
			}

			if(this.currentContainer === this.containers[innermostIndex]) {
				if ( !this.currentContainer.containerCache.over ) {
					this.containers[ innermostIndex ]._trigger( "over", event, this._uiHash() );
					this.currentContainer.containerCache.over = 1;
				}
				return;
			}

			itemWithLeastDistance ? this._rearrange(event, itemWithLeastDistance, null, true) : this._rearrange(event, null, this.containers[innermostIndex].element, true);
			this._trigger("change", event, this._uiHash());
			this.containers[innermostIndex]._trigger("change", event, this._uiHash(this));
			this.currentContainer = this.containers[innermostIndex];

			//Update the placeholder
			this.options.placeholder.update(this.currentContainer, this.placeholder);

			this.containers[innermostIndex]._trigger("over", event, this._uiHash(this));
			this.containers[innermostIndex].containerCache.over = 1;
		}


	},

	_createHelper: function(event) {

		var o = this.options,
			helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event, this.currentItem])) : (o.helper === "clone" ? this.currentItem.clone() : this.currentItem);

		//Add the helper to the DOM if that didn't happen already
		if(!helper.parents("body").length) {
			$(o.appendTo !== "parent" ? o.appendTo : this.currentItem[0].parentNode)[0].appendChild(helper[0]);
		}

		if(helper[0] === this.currentItem[0]) {
			this._storedCSS = { width: this.currentItem[0].style.width, height: this.currentItem[0].style.height, position: this.currentItem.css("position"), top: this.currentItem.css("top"), left: this.currentItem.css("left") };
		}

		if(!helper[0].style.width || o.forceHelperSize) {
			helper.width(this.currentItem.width());
		}
		if(!helper[0].style.height || o.forceHelperSize) {
			helper.height(this.currentItem.height());
		}

		return helper;

	},

	_adjustOffsetFromHelper: function(obj) {
		if (typeof obj === "string") {
			obj = obj.split(" ");
		}
		if ($.isArray(obj)) {
			obj = {left: +obj[0], top: +obj[1] || 0};
		}
		if ("left" in obj) {
			this.offset.click.left = obj.left + this.margins.left;
		}
		if ("right" in obj) {
			this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
		}
		if ("top" in obj) {
			this.offset.click.top = obj.top + this.margins.top;
		}
		if ("bottom" in obj) {
			this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
		}
	},

	_getParentOffset: function() {


		//Get the offsetParent and cache its position
		this.offsetParent = this.helper.offsetParent();
		var po = this.offsetParent.offset();

		// This is a special case where we need to modify a offset calculated on start, since the following happened:
		// 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent
		// 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that
		//    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag
		if(this.cssPosition === "absolute" && this.scrollParent[0] !== this.document[0] && $.contains(this.scrollParent[0], this.offsetParent[0])) {
			po.left += this.scrollParent.scrollLeft();
			po.top += this.scrollParent.scrollTop();
		}

		// This needs to be actually done for all browsers, since pageX/pageY includes this information
		// with an ugly IE fix
		if( this.offsetParent[0] === this.document[0].body || (this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() === "html" && $.ui.ie)) {
			po = { top: 0, left: 0 };
		}

		return {
			top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"),10) || 0),
			left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"),10) || 0)
		};

	},

	_getRelativeOffset: function() {

		if(this.cssPosition === "relative") {
			var p = this.currentItem.position();
			return {
				top: p.top - (parseInt(this.helper.css("top"),10) || 0) + this.scrollParent.scrollTop(),
				left: p.left - (parseInt(this.helper.css("left"),10) || 0) + this.scrollParent.scrollLeft()
			};
		} else {
			return { top: 0, left: 0 };
		}

	},

	_cacheMargins: function() {
		this.margins = {
			left: (parseInt(this.currentItem.css("marginLeft"),10) || 0),
			top: (parseInt(this.currentItem.css("marginTop"),10) || 0)
		};
	},

	_cacheHelperProportions: function() {
		this.helperProportions = {
			width: this.helper.outerWidth(),
			height: this.helper.outerHeight()
		};
	},

	_setContainment: function() {

		var ce, co, over,
			o = this.options;
		if(o.containment === "parent") {
			o.containment = this.helper[0].parentNode;
		}
		if(o.containment === "document" || o.containment === "window") {
			this.containment = [
				0 - this.offset.relative.left - this.offset.parent.left,
				0 - this.offset.relative.top - this.offset.parent.top,
				o.containment === "document" ? this.document.width() : this.window.width() - this.helperProportions.width - this.margins.left,
				(o.containment === "document" ? this.document.width() : this.window.height() || this.document[0].body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top
			];
		}

		if(!(/^(document|window|parent)$/).test(o.containment)) {
			ce = $(o.containment)[0];
			co = $(o.containment).offset();
			over = ($(ce).css("overflow") !== "hidden");

			this.containment = [
				co.left + (parseInt($(ce).css("borderLeftWidth"),10) || 0) + (parseInt($(ce).css("paddingLeft"),10) || 0) - this.margins.left,
				co.top + (parseInt($(ce).css("borderTopWidth"),10) || 0) + (parseInt($(ce).css("paddingTop"),10) || 0) - this.margins.top,
				co.left+(over ? Math.max(ce.scrollWidth,ce.offsetWidth) : ce.offsetWidth) - (parseInt($(ce).css("borderLeftWidth"),10) || 0) - (parseInt($(ce).css("paddingRight"),10) || 0) - this.helperProportions.width - this.margins.left,
				co.top+(over ? Math.max(ce.scrollHeight,ce.offsetHeight) : ce.offsetHeight) - (parseInt($(ce).css("borderTopWidth"),10) || 0) - (parseInt($(ce).css("paddingBottom"),10) || 0) - this.helperProportions.height - this.margins.top
			];
		}

	},

	_convertPositionTo: function(d, pos) {

		if(!pos) {
			pos = this.position;
		}
		var mod = d === "absolute" ? 1 : -1,
			scroll = this.cssPosition === "absolute" && !(this.scrollParent[0] !== this.document[0] && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent,
			scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);

		return {
			top: (
				pos.top	+																// The absolute mouse position
				this.offset.relative.top * mod +										// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.parent.top * mod -											// The offsetParent's offset without borders (offset + border)
				( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ) * mod)
			),
			left: (
				pos.left +																// The absolute mouse position
				this.offset.relative.left * mod +										// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.parent.left * mod	-										// The offsetParent's offset without borders (offset + border)
				( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ) * mod)
			)
		};

	},

	_generatePosition: function(event) {

		var top, left,
			o = this.options,
			pageX = event.pageX,
			pageY = event.pageY,
			scroll = this.cssPosition === "absolute" && !(this.scrollParent[0] !== this.document[0] && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);

		// This is another very weird special case that only happens for relative elements:
		// 1. If the css position is relative
		// 2. and the scroll parent is the document or similar to the offset parent
		// we have to refresh the relative offset during the scroll so there are no jumps
		if(this.cssPosition === "relative" && !(this.scrollParent[0] !== this.document[0] && this.scrollParent[0] !== this.offsetParent[0])) {
			this.offset.relative = this._getRelativeOffset();
		}

		/*
		 * - Position constraining -
		 * Constrain the position to a mix of grid, containment.
		 */

		if(this.originalPosition) { //If we are not dragging yet, we won't check for options

			if(this.containment) {
				if(event.pageX - this.offset.click.left < this.containment[0]) {
					pageX = this.containment[0] + this.offset.click.left;
				}
				if(event.pageY - this.offset.click.top < this.containment[1]) {
					pageY = this.containment[1] + this.offset.click.top;
				}
				if(event.pageX - this.offset.click.left > this.containment[2]) {
					pageX = this.containment[2] + this.offset.click.left;
				}
				if(event.pageY - this.offset.click.top > this.containment[3]) {
					pageY = this.containment[3] + this.offset.click.top;
				}
			}

			if(o.grid) {
				top = this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1];
				pageY = this.containment ? ( (top - this.offset.click.top >= this.containment[1] && top - this.offset.click.top <= this.containment[3]) ? top : ((top - this.offset.click.top >= this.containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;

				left = this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0];
				pageX = this.containment ? ( (left - this.offset.click.left >= this.containment[0] && left - this.offset.click.left <= this.containment[2]) ? left : ((left - this.offset.click.left >= this.containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;
			}

		}

		return {
			top: (
				pageY -																// The absolute mouse position
				this.offset.click.top -													// Click offset (relative to the element)
				this.offset.relative.top	-											// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.parent.top +												// The offsetParent's offset without borders (offset + border)
				( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ))
			),
			left: (
				pageX -																// The absolute mouse position
				this.offset.click.left -												// Click offset (relative to the element)
				this.offset.relative.left	-											// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.parent.left +												// The offsetParent's offset without borders (offset + border)
				( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ))
			)
		};

	},

	_rearrange: function(event, i, a, hardRefresh) {

		a ? a[0].appendChild(this.placeholder[0]) : i.item[0].parentNode.insertBefore(this.placeholder[0], (this.direction === "down" ? i.item[0] : i.item[0].nextSibling));

		//Various things done here to improve the performance:
		// 1. we create a setTimeout, that calls refreshPositions
		// 2. on the instance, we have a counter variable, that get's higher after every append
		// 3. on the local scope, we copy the counter variable, and check in the timeout, if it's still the same
		// 4. this lets only the last addition to the timeout stack through
		this.counter = this.counter ? ++this.counter : 1;
		var counter = this.counter;

		this._delay(function() {
			if(counter === this.counter) {
				this.refreshPositions(!hardRefresh); //Precompute after each DOM insertion, NOT on mousemove
			}
		});

	},

	_clear: function(event, noPropagation) {

		this.reverting = false;
		// We delay all events that have to be triggered to after the point where the placeholder has been removed and
		// everything else normalized again
		var i,
			delayedTriggers = [];

		// We first have to update the dom position of the actual currentItem
		// Note: don't do it if the current item is already removed (by a user), or it gets reappended (see #4088)
		if(!this._noFinalSort && this.currentItem.parent().length) {
			this.placeholder.before(this.currentItem);
		}
		this._noFinalSort = null;

		if(this.helper[0] === this.currentItem[0]) {
			for(i in this._storedCSS) {
				if(this._storedCSS[i] === "auto" || this._storedCSS[i] === "static") {
					this._storedCSS[i] = "";
				}
			}
			this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper");
		} else {
			this.currentItem.show();
		}

		if(this.fromOutside && !noPropagation) {
			delayedTriggers.push(function(event) { this._trigger("receive", event, this._uiHash(this.fromOutside)); });
		}
		if((this.fromOutside || this.domPosition.prev !== this.currentItem.prev().not(".ui-sortable-helper")[0] || this.domPosition.parent !== this.currentItem.parent()[0]) && !noPropagation) {
			delayedTriggers.push(function(event) { this._trigger("update", event, this._uiHash()); }); //Trigger update callback if the DOM position has changed
		}

		// Check if the items Container has Changed and trigger appropriate
		// events.
		if (this !== this.currentContainer) {
			if(!noPropagation) {
				delayedTriggers.push(function(event) { this._trigger("remove", event, this._uiHash()); });
				delayedTriggers.push((function(c) { return function(event) { c._trigger("receive", event, this._uiHash(this)); };  }).call(this, this.currentContainer));
				delayedTriggers.push((function(c) { return function(event) { c._trigger("update", event, this._uiHash(this));  }; }).call(this, this.currentContainer));
			}
		}


		//Post events to containers
		function delayEvent( type, instance, container ) {
			return function( event ) {
				container._trigger( type, event, instance._uiHash( instance ) );
			};
		}
		for (i = this.containers.length - 1; i >= 0; i--){
			if (!noPropagation) {
				delayedTriggers.push( delayEvent( "deactivate", this, this.containers[ i ] ) );
			}
			if(this.containers[i].containerCache.over) {
				delayedTriggers.push( delayEvent( "out", this, this.containers[ i ] ) );
				this.containers[i].containerCache.over = 0;
			}
		}

		//Do what was originally in plugins
		if ( this.storedCursor ) {
			this.document.find( "body" ).css( "cursor", this.storedCursor );
			this.storedStylesheet.remove();
		}
		if(this._storedOpacity) {
			this.helper.css("opacity", this._storedOpacity);
		}
		if(this._storedZIndex) {
			this.helper.css("zIndex", this._storedZIndex === "auto" ? "" : this._storedZIndex);
		}

		this.dragging = false;

		if(!noPropagation) {
			this._trigger("beforeStop", event, this._uiHash());
		}

		//$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!
		this.placeholder[0].parentNode.removeChild(this.placeholder[0]);

		if ( !this.cancelHelperRemoval ) {
			if ( this.helper[ 0 ] !== this.currentItem[ 0 ] ) {
				this.helper.remove();
			}
			this.helper = null;
		}

		if(!noPropagation) {
			for (i=0; i < delayedTriggers.length; i++) {
				delayedTriggers[i].call(this, event);
			} //Trigger all delayed events
			this._trigger("stop", event, this._uiHash());
		}

		this.fromOutside = false;
		return !this.cancelHelperRemoval;

	},

	_trigger: function() {
		if ($.Widget.prototype._trigger.apply(this, arguments) === false) {
			this.cancel();
		}
	},

	_uiHash: function(_inst) {
		var inst = _inst || this;
		return {
			helper: inst.helper,
			placeholder: inst.placeholder || $([]),
			position: inst.position,
			originalPosition: inst.originalPosition,
			offset: inst.positionAbs,
			item: inst.currentItem,
			sender: _inst ? _inst.element : null
		};
	}

});

}));




/*!
 * jQuery UI Spinner 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/spinner/
 */

(function( factory ) {
	if ( typeof define === "function" && define.amd ) {

		// AMD. Register as an anonymous module.
		define([
			"jquery",
			"./core",
			"./widget",
			"./button"
		], factory );
	} else {

		// Browser globals
		factory( jQuery );
	}
}(function( $ ) {

function spinner_modifier( fn ) {
	return function() {
		var previous = this.element.val();
		fn.apply( this, arguments );
		this._refresh();
		if ( previous !== this.element.val() ) {
			this._trigger( "change" );
		}
	};
}

return $.widget( "ui.spinner", {
	version: "1.11.4",
	defaultElement: "<input>",
	widgetEventPrefix: "spin",
	options: {
		culture: null,
		icons: {
			down: "ui-icon-triangle-1-s",
			up: "ui-icon-triangle-1-n"
		},
		incremental: true,
		max: null,
		min: null,
		numberFormat: null,
		page: 10,
		step: 1,

		change: null,
		spin: null,
		start: null,
		stop: null
	},

	_create: function() {
		// handle string values that need to be parsed
		this._setOption( "max", this.options.max );
		this._setOption( "min", this.options.min );
		this._setOption( "step", this.options.step );

		// Only format if there is a value, prevents the field from being marked
		// as invalid in Firefox, see #9573.
		if ( this.value() !== "" ) {
			// Format the value, but don't constrain.
			this._value( this.element.val(), true );
		}

		this._draw();
		this._on( this._events );
		this._refresh();

		// turning off autocomplete prevents the browser from remembering the
		// value when navigating through history, so we re-enable autocomplete
		// if the page is unloaded before the widget is destroyed. #7790
		this._on( this.window, {
			beforeunload: function() {
				this.element.removeAttr( "autocomplete" );
			}
		});
	},

	_getCreateOptions: function() {
		var options = {},
			element = this.element;

		$.each( [ "min", "max", "step" ], function( i, option ) {
			var value = element.attr( option );
			if ( value !== undefined && value.length ) {
				options[ option ] = value;
			}
		});

		return options;
	},

	_events: {
		keydown: function( event ) {
			if ( this._start( event ) && this._keydown( event ) ) {
				event.preventDefault();
			}
		},
		keyup: "_stop",
		focus: function() {
			this.previous = this.element.val();
		},
		blur: function( event ) {
			if ( this.cancelBlur ) {
				delete this.cancelBlur;
				return;
			}

			this._stop();
			this._refresh();
			if ( this.previous !== this.element.val() ) {
				this._trigger( "change", event );
			}
		},
		mousewheel: function( event, delta ) {
			if ( !delta ) {
				return;
			}
			if ( !this.spinning && !this._start( event ) ) {
				return false;
			}

			this._spin( (delta > 0 ? 1 : -1) * this.options.step, event );
			clearTimeout( this.mousewheelTimer );
			this.mousewheelTimer = this._delay(function() {
				if ( this.spinning ) {
					this._stop( event );
				}
			}, 100 );
			event.preventDefault();
		},
		"mousedown .ui-spinner-button": function( event ) {
			var previous;

			// We never want the buttons to have focus; whenever the user is
			// interacting with the spinner, the focus should be on the input.
			// If the input is focused then this.previous is properly set from
			// when the input first received focus. If the input is not focused
			// then we need to set this.previous based on the value before spinning.
			previous = this.element[0] === this.document[0].activeElement ?
				this.previous : this.element.val();
			function checkFocus() {
				var isActive = this.element[0] === this.document[0].activeElement;
				if ( !isActive ) {
					this.element.focus();
					this.previous = previous;
					// support: IE
					// IE sets focus asynchronously, so we need to check if focus
					// moved off of the input because the user clicked on the button.
					this._delay(function() {
						this.previous = previous;
					});
				}
			}

			// ensure focus is on (or stays on) the text field
			event.preventDefault();
			checkFocus.call( this );

			// support: IE
			// IE doesn't prevent moving focus even with event.preventDefault()
			// so we set a flag to know when we should ignore the blur event
			// and check (again) if focus moved off of the input.
			this.cancelBlur = true;
			this._delay(function() {
				delete this.cancelBlur;
				checkFocus.call( this );
			});

			if ( this._start( event ) === false ) {
				return;
			}

			this._repeat( null, $( event.currentTarget ).hasClass( "ui-spinner-up" ) ? 1 : -1, event );
		},
		"mouseup .ui-spinner-button": "_stop",
		"mouseenter .ui-spinner-button": function( event ) {
			// button will add ui-state-active if mouse was down while mouseleave and kept down
			if ( !$( event.currentTarget ).hasClass( "ui-state-active" ) ) {
				return;
			}

			if ( this._start( event ) === false ) {
				return false;
			}
			this._repeat( null, $( event.currentTarget ).hasClass( "ui-spinner-up" ) ? 1 : -1, event );
		},
		// TODO: do we really want to consider this a stop?
		// shouldn't we just stop the repeater and wait until mouseup before
		// we trigger the stop event?
		"mouseleave .ui-spinner-button": "_stop"
	},

	_draw: function() {
		var uiSpinner = this.uiSpinner = this.element
			.addClass( "ui-spinner-input" )
			.attr( "autocomplete", "off" )
			.wrap( this._uiSpinnerHtml() )
			.parent()
				// add buttons
				.append( this._buttonHtml() );

		this.element.attr( "role", "spinbutton" );

		// button bindings
		this.buttons = uiSpinner.find( ".ui-spinner-button" )
			.attr( "tabIndex", -1 )
			.button()
			.removeClass( "ui-corner-all" );

		// IE 6 doesn't understand height: 50% for the buttons
		// unless the wrapper has an explicit height
		if ( this.buttons.height() > Math.ceil( uiSpinner.height() * 0.5 ) &&
				uiSpinner.height() > 0 ) {
			uiSpinner.height( uiSpinner.height() );
		}

		// disable spinner if element was already disabled
		if ( this.options.disabled ) {
			this.disable();
		}
	},

	_keydown: function( event ) {
		var options = this.options,
			keyCode = $.ui.keyCode;

		switch ( event.keyCode ) {
		case keyCode.UP:
			this._repeat( null, 1, event );
			return true;
		case keyCode.DOWN:
			this._repeat( null, -1, event );
			return true;
		case keyCode.PAGE_UP:
			this._repeat( null, options.page, event );
			return true;
		case keyCode.PAGE_DOWN:
			this._repeat( null, -options.page, event );
			return true;
		}

		return false;
	},

	_uiSpinnerHtml: function() {
		return "<span class='ui-spinner ui-widget ui-widget-content ui-corner-all'></span>";
	},

	_buttonHtml: function() {
		return "" +
			"<a class='ui-spinner-button ui-spinner-up ui-corner-tr'>" +
				"<span class='ui-icon " + this.options.icons.up + "'>&#9650;</span>" +
			"</a>" +
			"<a class='ui-spinner-button ui-spinner-down ui-corner-br'>" +
				"<span class='ui-icon " + this.options.icons.down + "'>&#9660;</span>" +
			"</a>";
	},

	_start: function( event ) {
		if ( !this.spinning && this._trigger( "start", event ) === false ) {
			return false;
		}

		if ( !this.counter ) {
			this.counter = 1;
		}
		this.spinning = true;
		return true;
	},

	_repeat: function( i, steps, event ) {
		i = i || 500;

		clearTimeout( this.timer );
		this.timer = this._delay(function() {
			this._repeat( 40, steps, event );
		}, i );

		this._spin( steps * this.options.step, event );
	},

	_spin: function( step, event ) {
		var value = this.value() || 0;

		if ( !this.counter ) {
			this.counter = 1;
		}

		value = this._adjustValue( value + step * this._increment( this.counter ) );

		if ( !this.spinning || this._trigger( "spin", event, { value: value } ) !== false) {
			this._value( value );
			this.counter++;
		}
	},

	_increment: function( i ) {
		var incremental = this.options.incremental;

		if ( incremental ) {
			return $.isFunction( incremental ) ?
				incremental( i ) :
				Math.floor( i * i * i / 50000 - i * i / 500 + 17 * i / 200 + 1 );
		}

		return 1;
	},

	_precision: function() {
		var precision = this._precisionOf( this.options.step );
		if ( this.options.min !== null ) {
			precision = Math.max( precision, this._precisionOf( this.options.min ) );
		}
		return precision;
	},

	_precisionOf: function( num ) {
		var str = num.toString(),
			decimal = str.indexOf( "." );
		return decimal === -1 ? 0 : str.length - decimal - 1;
	},

	_adjustValue: function( value ) {
		var base, aboveMin,
			options = this.options;

		// make sure we're at a valid step
		// - find out where we are relative to the base (min or 0)
		base = options.min !== null ? options.min : 0;
		aboveMin = value - base;
		// - round to the nearest step
		aboveMin = Math.round(aboveMin / options.step) * options.step;
		// - rounding is based on 0, so adjust back to our base
		value = base + aboveMin;

		// fix precision from bad JS floating point math
		value = parseFloat( value.toFixed( this._precision() ) );

		// clamp the value
		if ( options.max !== null && value > options.max) {
			return options.max;
		}
		if ( options.min !== null && value < options.min ) {
			return options.min;
		}

		return value;
	},

	_stop: function( event ) {
		if ( !this.spinning ) {
			return;
		}

		clearTimeout( this.timer );
		clearTimeout( this.mousewheelTimer );
		this.counter = 0;
		this.spinning = false;
		this._trigger( "stop", event );
	},

	_setOption: function( key, value ) {
		if ( key === "culture" || key === "numberFormat" ) {
			var prevValue = this._parse( this.element.val() );
			this.options[ key ] = value;
			this.element.val( this._format( prevValue ) );
			return;
		}

		if ( key === "max" || key === "min" || key === "step" ) {
			if ( typeof value === "string" ) {
				value = this._parse( value );
			}
		}
		if ( key === "icons" ) {
			this.buttons.first().find( ".ui-icon" )
				.removeClass( this.options.icons.up )
				.addClass( value.up );
			this.buttons.last().find( ".ui-icon" )
				.removeClass( this.options.icons.down )
				.addClass( value.down );
		}

		this._super( key, value );

		if ( key === "disabled" ) {
			this.widget().toggleClass( "ui-state-disabled", !!value );
			this.element.prop( "disabled", !!value );
			this.buttons.button( value ? "disable" : "enable" );
		}
	},

	_setOptions: spinner_modifier(function( options ) {
		this._super( options );
	}),

	_parse: function( val ) {
		if ( typeof val === "string" && val !== "" ) {
			val = window.Globalize && this.options.numberFormat ?
				Globalize.parseFloat( val, 10, this.options.culture ) : +val;
		}
		return val === "" || isNaN( val ) ? null : val;
	},

	_format: function( value ) {
		if ( value === "" ) {
			return "";
		}
		return window.Globalize && this.options.numberFormat ?
			Globalize.format( value, this.options.numberFormat, this.options.culture ) :
			value;
	},

	_refresh: function() {
		this.element.attr({
			"aria-valuemin": this.options.min,
			"aria-valuemax": this.options.max,
			// TODO: what should we do with values that can't be parsed?
			"aria-valuenow": this._parse( this.element.val() )
		});
	},

	isValid: function() {
		var value = this.value();

		// null is invalid
		if ( value === null ) {
			return false;
		}

		// if value gets adjusted, it's invalid
		return value === this._adjustValue( value );
	},

	// update the value without triggering change
	_value: function( value, allowAny ) {
		var parsed;
		if ( value !== "" ) {
			parsed = this._parse( value );
			if ( parsed !== null ) {
				if ( !allowAny ) {
					parsed = this._adjustValue( parsed );
				}
				value = this._format( parsed );
			}
		}
		this.element.val( value );
		this._refresh();
	},

	_destroy: function() {
		this.element
			.removeClass( "ui-spinner-input" )
			.prop( "disabled", false )
			.removeAttr( "autocomplete" )
			.removeAttr( "role" )
			.removeAttr( "aria-valuemin" )
			.removeAttr( "aria-valuemax" )
			.removeAttr( "aria-valuenow" );
		this.uiSpinner.replaceWith( this.element );
	},

	stepUp: spinner_modifier(function( steps ) {
		this._stepUp( steps );
	}),
	_stepUp: function( steps ) {
		if ( this._start() ) {
			this._spin( (steps || 1) * this.options.step );
			this._stop();
		}
	},

	stepDown: spinner_modifier(function( steps ) {
		this._stepDown( steps );
	}),
	_stepDown: function( steps ) {
		if ( this._start() ) {
			this._spin( (steps || 1) * -this.options.step );
			this._stop();
		}
	},

	pageUp: spinner_modifier(function( pages ) {
		this._stepUp( (pages || 1) * this.options.page );
	}),

	pageDown: spinner_modifier(function( pages ) {
		this._stepDown( (pages || 1) * this.options.page );
	}),

	value: function( newVal ) {
		if ( !arguments.length ) {
			return this._parse( this.element.val() );
		}
		spinner_modifier( this._value ).call( this, newVal );
	},

	widget: function() {
		return this.uiSpinner;
	}
});

}));



/*!
 * jQuery UI Tabs 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/tabs/
 */

(function( factory ) {
	if ( typeof define === "function" && define.amd ) {

		// AMD. Register as an anonymous module.
		define([
			"jquery",
			"./core",
			"./widget"
		], factory );
	} else {

		// Browser globals
		factory( jQuery );
	}
}(function( $ ) {

return $.widget( "ui.tabs", {
	version: "1.11.4",
	delay: 300,
	options: {
		active: null,
		collapsible: false,
		event: "click",
		heightStyle: "content",
		hide: null,
		show: null,

		// callbacks
		activate: null,
		beforeActivate: null,
		beforeLoad: null,
		load: null
	},

	_isLocal: (function() {
		var rhash = /#.*$/;

		return function( anchor ) {
			var anchorUrl, locationUrl;

			// support: IE7
			// IE7 doesn't normalize the href property when set via script (#9317)
			anchor = anchor.cloneNode( false );

			anchorUrl = anchor.href.replace( rhash, "" );
			locationUrl = location.href.replace( rhash, "" );

			// decoding may throw an error if the URL isn't UTF-8 (#9518)
			try {
				anchorUrl = decodeURIComponent( anchorUrl );
			} catch ( error ) {}
			try {
				locationUrl = decodeURIComponent( locationUrl );
			} catch ( error ) {}

			return anchor.hash.length > 1 && anchorUrl === locationUrl;
		};
	})(),

	_create: function() {
		var that = this,
			options = this.options;

		this.running = false;

		this.element
			.addClass( "ui-tabs ui-widget ui-widget-content ui-corner-all" )
			.toggleClass( "ui-tabs-collapsible", options.collapsible );

		this._processTabs();
		options.active = this._initialActive();

		// Take disabling tabs via class attribute from HTML
		// into account and update option properly.
		if ( $.isArray( options.disabled ) ) {
			options.disabled = $.unique( options.disabled.concat(
				$.map( this.tabs.filter( ".ui-state-disabled" ), function( li ) {
					return that.tabs.index( li );
				})
			) ).sort();
		}

		// check for length avoids error when initializing empty list
		if ( this.options.active !== false && this.anchors.length ) {
			this.active = this._findActive( options.active );
		} else {
			this.active = $();
		}

		this._refresh();

		if ( this.active.length ) {
			this.load( options.active );
		}
	},

	_initialActive: function() {
		var active = this.options.active,
			collapsible = this.options.collapsible,
			locationHash = location.hash.substring( 1 );

		if ( active === null ) {
			// check the fragment identifier in the URL
			if ( locationHash ) {
				this.tabs.each(function( i, tab ) {
					if ( $( tab ).attr( "aria-controls" ) === locationHash ) {
						active = i;
						return false;
					}
				});
			}

			// check for a tab marked active via a class
			if ( active === null ) {
				active = this.tabs.index( this.tabs.filter( ".ui-tabs-active" ) );
			}

			// no active tab, set to false
			if ( active === null || active === -1 ) {
				active = this.tabs.length ? 0 : false;
			}
		}

		// handle numbers: negative, out of range
		if ( active !== false ) {
			active = this.tabs.index( this.tabs.eq( active ) );
			if ( active === -1 ) {
				active = collapsible ? false : 0;
			}
		}

		// don't allow collapsible: false and active: false
		if ( !collapsible && active === false && this.anchors.length ) {
			active = 0;
		}

		return active;
	},

	_getCreateEventData: function() {
		return {
			tab: this.active,
			panel: !this.active.length ? $() : this._getPanelForTab( this.active )
		};
	},

	_tabKeydown: function( event ) {
		var focusedTab = $( this.document[0].activeElement ).closest( "li" ),
			selectedIndex = this.tabs.index( focusedTab ),
			goingForward = true;

		if ( this._handlePageNav( event ) ) {
			return;
		}

		switch ( event.keyCode ) {
			case $.ui.keyCode.RIGHT:
			case $.ui.keyCode.DOWN:
				selectedIndex++;
				break;
			case $.ui.keyCode.UP:
			case $.ui.keyCode.LEFT:
				goingForward = false;
				selectedIndex--;
				break;
			case $.ui.keyCode.END:
				selectedIndex = this.anchors.length - 1;
				break;
			case $.ui.keyCode.HOME:
				selectedIndex = 0;
				break;
			case $.ui.keyCode.SPACE:
				// Activate only, no collapsing
				event.preventDefault();
				clearTimeout( this.activating );
				this._activate( selectedIndex );
				return;
			case $.ui.keyCode.ENTER:
				// Toggle (cancel delayed activation, allow collapsing)
				event.preventDefault();
				clearTimeout( this.activating );
				// Determine if we should collapse or activate
				this._activate( selectedIndex === this.options.active ? false : selectedIndex );
				return;
			default:
				return;
		}

		// Focus the appropriate tab, based on which key was pressed
		event.preventDefault();
		clearTimeout( this.activating );
		selectedIndex = this._focusNextTab( selectedIndex, goingForward );

		// Navigating with control/command key will prevent automatic activation
		if ( !event.ctrlKey && !event.metaKey ) {

			// Update aria-selected immediately so that AT think the tab is already selected.
			// Otherwise AT may confuse the user by stating that they need to activate the tab,
			// but the tab will already be activated by the time the announcement finishes.
			focusedTab.attr( "aria-selected", "false" );
			this.tabs.eq( selectedIndex ).attr( "aria-selected", "true" );

			this.activating = this._delay(function() {
				this.option( "active", selectedIndex );
			}, this.delay );
		}
	},

	_panelKeydown: function( event ) {
		if ( this._handlePageNav( event ) ) {
			return;
		}

		// Ctrl+up moves focus to the current tab
		if ( event.ctrlKey && event.keyCode === $.ui.keyCode.UP ) {
			event.preventDefault();
			this.active.focus();
		}
	},

	// Alt+page up/down moves focus to the previous/next tab (and activates)
	_handlePageNav: function( event ) {
		if ( event.altKey && event.keyCode === $.ui.keyCode.PAGE_UP ) {
			this._activate( this._focusNextTab( this.options.active - 1, false ) );
			return true;
		}
		if ( event.altKey && event.keyCode === $.ui.keyCode.PAGE_DOWN ) {
			this._activate( this._focusNextTab( this.options.active + 1, true ) );
			return true;
		}
	},

	_findNextTab: function( index, goingForward ) {
		var lastTabIndex = this.tabs.length - 1;

		function constrain() {
			if ( index > lastTabIndex ) {
				index = 0;
			}
			if ( index < 0 ) {
				index = lastTabIndex;
			}
			return index;
		}

		while ( $.inArray( constrain(), this.options.disabled ) !== -1 ) {
			index = goingForward ? index + 1 : index - 1;
		}

		return index;
	},

	_focusNextTab: function( index, goingForward ) {
		index = this._findNextTab( index, goingForward );
		this.tabs.eq( index ).focus();
		return index;
	},

	_setOption: function( key, value ) {
		if ( key === "active" ) {
			// _activate() will handle invalid values and update this.options
			this._activate( value );
			return;
		}

		if ( key === "disabled" ) {
			// don't use the widget factory's disabled handling
			this._setupDisabled( value );
			return;
		}

		this._super( key, value);

		if ( key === "collapsible" ) {
			this.element.toggleClass( "ui-tabs-collapsible", value );
			// Setting collapsible: false while collapsed; open first panel
			if ( !value && this.options.active === false ) {
				this._activate( 0 );
			}
		}

		if ( key === "event" ) {
			this._setupEvents( value );
		}

		if ( key === "heightStyle" ) {
			this._setupHeightStyle( value );
		}
	},

	_sanitizeSelector: function( hash ) {
		return hash ? hash.replace( /[!"$%&'()*+,.\/:;<=>?@\[\]\^`{|}~]/g, "\\$&" ) : "";
	},

	refresh: function() {
		var options = this.options,
			lis = this.tablist.children( ":has(a[href])" );

		// get disabled tabs from class attribute from HTML
		// this will get converted to a boolean if needed in _refresh()
		options.disabled = $.map( lis.filter( ".ui-state-disabled" ), function( tab ) {
			return lis.index( tab );
		});

		this._processTabs();

		// was collapsed or no tabs
		if ( options.active === false || !this.anchors.length ) {
			options.active = false;
			this.active = $();
		// was active, but active tab is gone
		} else if ( this.active.length && !$.contains( this.tablist[ 0 ], this.active[ 0 ] ) ) {
			// all remaining tabs are disabled
			if ( this.tabs.length === options.disabled.length ) {
				options.active = false;
				this.active = $();
			// activate previous tab
			} else {
				this._activate( this._findNextTab( Math.max( 0, options.active - 1 ), false ) );
			}
		// was active, active tab still exists
		} else {
			// make sure active index is correct
			options.active = this.tabs.index( this.active );
		}

		this._refresh();
	},

	_refresh: function() {
		this._setupDisabled( this.options.disabled );
		this._setupEvents( this.options.event );
		this._setupHeightStyle( this.options.heightStyle );

		this.tabs.not( this.active ).attr({
			"aria-selected": "false",
			"aria-expanded": "false",
			tabIndex: -1
		});
		this.panels.not( this._getPanelForTab( this.active ) )
			.hide()
			.attr({
				"aria-hidden": "true"
			});

		// Make sure one tab is in the tab order
		if ( !this.active.length ) {
			this.tabs.eq( 0 ).attr( "tabIndex", 0 );
		} else {
			this.active
				.addClass( "ui-tabs-active ui-state-active" )
				.attr({
					"aria-selected": "true",
					"aria-expanded": "true",
					tabIndex: 0
				});
			this._getPanelForTab( this.active )
				.show()
				.attr({
					"aria-hidden": "false"
				});
		}
	},

	_processTabs: function() {
		var that = this,
			prevTabs = this.tabs,
			prevAnchors = this.anchors,
			prevPanels = this.panels;

		this.tablist = this._getList()
			.addClass( "ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all" )
			.attr( "role", "tablist" )

			// Prevent users from focusing disabled tabs via click
			.delegate( "> li", "mousedown" + this.eventNamespace, function( event ) {
				if ( $( this ).is( ".ui-state-disabled" ) ) {
					event.preventDefault();
				}
			})

			// support: IE <9
			// Preventing the default action in mousedown doesn't prevent IE
			// from focusing the element, so if the anchor gets focused, blur.
			// We don't have to worry about focusing the previously focused
			// element since clicking on a non-focusable element should focus
			// the body anyway.
			.delegate( ".ui-tabs-anchor", "focus" + this.eventNamespace, function() {
				if ( $( this ).closest( "li" ).is( ".ui-state-disabled" ) ) {
					this.blur();
				}
			});

		this.tabs = this.tablist.find( "> li:has(a[href])" )
			.addClass( "ui-state-default ui-corner-top" )
			.attr({
				role: "tab",
				tabIndex: -1
			});

		this.anchors = this.tabs.map(function() {
				return $( "a", this )[ 0 ];
			})
			.addClass( "ui-tabs-anchor" )
			.attr({
				role: "presentation",
				tabIndex: -1
			});

		this.panels = $();

		this.anchors.each(function( i, anchor ) {
			var selector, panel, panelId,
				anchorId = $( anchor ).uniqueId().attr( "id" ),
				tab = $( anchor ).closest( "li" ),
				originalAriaControls = tab.attr( "aria-controls" );

			// inline tab
			if ( that._isLocal( anchor ) ) {
				selector = anchor.hash;
				panelId = selector.substring( 1 );
				panel = that.element.find( that._sanitizeSelector( selector ) );
			// remote tab
			} else {
				// If the tab doesn't already have aria-controls,
				// generate an id by using a throw-away element
				panelId = tab.attr( "aria-controls" ) || $( {} ).uniqueId()[ 0 ].id;
				selector = "#" + panelId;
				panel = that.element.find( selector );
				if ( !panel.length ) {
					panel = that._createPanel( panelId );
					panel.insertAfter( that.panels[ i - 1 ] || that.tablist );
				}
				panel.attr( "aria-live", "polite" );
			}

			if ( panel.length) {
				that.panels = that.panels.add( panel );
			}
			if ( originalAriaControls ) {
				tab.data( "ui-tabs-aria-controls", originalAriaControls );
			}
			tab.attr({
				"aria-controls": panelId,
				"aria-labelledby": anchorId
			});
			panel.attr( "aria-labelledby", anchorId );
		});

		this.panels
			.addClass( "ui-tabs-panel ui-widget-content ui-corner-bottom" )
			.attr( "role", "tabpanel" );

		// Avoid memory leaks (#10056)
		if ( prevTabs ) {
			this._off( prevTabs.not( this.tabs ) );
			this._off( prevAnchors.not( this.anchors ) );
			this._off( prevPanels.not( this.panels ) );
		}
	},

	// allow overriding how to find the list for rare usage scenarios (#7715)
	_getList: function() {
		return this.tablist || this.element.find( "ol,ul" ).eq( 0 );
	},

	_createPanel: function( id ) {
		return $( "<div>" )
			.attr( "id", id )
			.addClass( "ui-tabs-panel ui-widget-content ui-corner-bottom" )
			.data( "ui-tabs-destroy", true );
	},

	_setupDisabled: function( disabled ) {
		if ( $.isArray( disabled ) ) {
			if ( !disabled.length ) {
				disabled = false;
			} else if ( disabled.length === this.anchors.length ) {
				disabled = true;
			}
		}

		// disable tabs
		for ( var i = 0, li; ( li = this.tabs[ i ] ); i++ ) {
			if ( disabled === true || $.inArray( i, disabled ) !== -1 ) {
				$( li )
					.addClass( "ui-state-disabled" )
					.attr( "aria-disabled", "true" );
			} else {
				$( li )
					.removeClass( "ui-state-disabled" )
					.removeAttr( "aria-disabled" );
			}
		}

		this.options.disabled = disabled;
	},

	_setupEvents: function( event ) {
		var events = {};
		if ( event ) {
			$.each( event.split(" "), function( index, eventName ) {
				events[ eventName ] = "_eventHandler";
			});
		}

		this._off( this.anchors.add( this.tabs ).add( this.panels ) );
		// Always prevent the default action, even when disabled
		this._on( true, this.anchors, {
			click: function( event ) {
				event.preventDefault();
			}
		});
		this._on( this.anchors, events );
		this._on( this.tabs, { keydown: "_tabKeydown" } );
		this._on( this.panels, { keydown: "_panelKeydown" } );

		this._focusable( this.tabs );
		this._hoverable( this.tabs );
	},

	_setupHeightStyle: function( heightStyle ) {
		var maxHeight,
			parent = this.element.parent();

		if ( heightStyle === "fill" ) {
			maxHeight = parent.height();
			maxHeight -= this.element.outerHeight() - this.element.height();

			this.element.siblings( ":visible" ).each(function() {
				var elem = $( this ),
					position = elem.css( "position" );

				if ( position === "absolute" || position === "fixed" ) {
					return;
				}
				maxHeight -= elem.outerHeight( true );
			});

			this.element.children().not( this.panels ).each(function() {
				maxHeight -= $( this ).outerHeight( true );
			});

			this.panels.each(function() {
				$( this ).height( Math.max( 0, maxHeight -
					$( this ).innerHeight() + $( this ).height() ) );
			})
			.css( "overflow", "auto" );
		} else if ( heightStyle === "auto" ) {
			maxHeight = 0;
			this.panels.each(function() {
				maxHeight = Math.max( maxHeight, $( this ).height( "" ).height() );
			}).height( maxHeight );
		}
	},

	_eventHandler: function( event ) {
		var options = this.options,
			active = this.active,
			anchor = $( event.currentTarget ),
			tab = anchor.closest( "li" ),
			clickedIsActive = tab[ 0 ] === active[ 0 ],
			collapsing = clickedIsActive && options.collapsible,
			toShow = collapsing ? $() : this._getPanelForTab( tab ),
			toHide = !active.length ? $() : this._getPanelForTab( active ),
			eventData = {
				oldTab: active,
				oldPanel: toHide,
				newTab: collapsing ? $() : tab,
				newPanel: toShow
			};

		event.preventDefault();

		if ( tab.hasClass( "ui-state-disabled" ) ||
				// tab is already loading
				tab.hasClass( "ui-tabs-loading" ) ||
				// can't switch durning an animation
				this.running ||
				// click on active header, but not collapsible
				( clickedIsActive && !options.collapsible ) ||
				// allow canceling activation
				( this._trigger( "beforeActivate", event, eventData ) === false ) ) {
			return;
		}

		options.active = collapsing ? false : this.tabs.index( tab );

		this.active = clickedIsActive ? $() : tab;
		if ( this.xhr ) {
			this.xhr.abort();
		}

		if ( !toHide.length && !toShow.length ) {
			$.error( "jQuery UI Tabs: Mismatching fragment identifier." );
		}

		if ( toShow.length ) {
			this.load( this.tabs.index( tab ), event );
		}
		this._toggle( event, eventData );
	},

	// handles show/hide for selecting tabs
	_toggle: function( event, eventData ) {
		var that = this,
			toShow = eventData.newPanel,
			toHide = eventData.oldPanel;

		this.running = true;

		function complete() {
			that.running = false;
			that._trigger( "activate", event, eventData );
		}

		function show() {
			eventData.newTab.closest( "li" ).addClass( "ui-tabs-active ui-state-active" );

			if ( toShow.length && that.options.show ) {
				that._show( toShow, that.options.show, complete );
			} else {
				toShow.show();
				complete();
			}
		}

		// start out by hiding, then showing, then completing
		if ( toHide.length && this.options.hide ) {
			this._hide( toHide, this.options.hide, function() {
				eventData.oldTab.closest( "li" ).removeClass( "ui-tabs-active ui-state-active" );
				show();
			});
		} else {
			eventData.oldTab.closest( "li" ).removeClass( "ui-tabs-active ui-state-active" );
			toHide.hide();
			show();
		}

		toHide.attr( "aria-hidden", "true" );
		eventData.oldTab.attr({
			"aria-selected": "false",
			"aria-expanded": "false"
		});
		// If we're switching tabs, remove the old tab from the tab order.
		// If we're opening from collapsed state, remove the previous tab from the tab order.
		// If we're collapsing, then keep the collapsing tab in the tab order.
		if ( toShow.length && toHide.length ) {
			eventData.oldTab.attr( "tabIndex", -1 );
		} else if ( toShow.length ) {
			this.tabs.filter(function() {
				return $( this ).attr( "tabIndex" ) === 0;
			})
			.attr( "tabIndex", -1 );
		}

		toShow.attr( "aria-hidden", "false" );
		eventData.newTab.attr({
			"aria-selected": "true",
			"aria-expanded": "true",
			tabIndex: 0
		});
	},

	_activate: function( index ) {
		var anchor,
			active = this._findActive( index );

		// trying to activate the already active panel
		if ( active[ 0 ] === this.active[ 0 ] ) {
			return;
		}

		// trying to collapse, simulate a click on the current active header
		if ( !active.length ) {
			active = this.active;
		}

		anchor = active.find( ".ui-tabs-anchor" )[ 0 ];
		this._eventHandler({
			target: anchor,
			currentTarget: anchor,
			preventDefault: $.noop
		});
	},

	_findActive: function( index ) {
		return index === false ? $() : this.tabs.eq( index );
	},

	_getIndex: function( index ) {
		// meta-function to give users option to provide a href string instead of a numerical index.
		if ( typeof index === "string" ) {
			index = this.anchors.index( this.anchors.filter( "[href$='" + index + "']" ) );
		}

		return index;
	},

	_destroy: function() {
		if ( this.xhr ) {
			this.xhr.abort();
		}

		this.element.removeClass( "ui-tabs ui-widget ui-widget-content ui-corner-all ui-tabs-collapsible" );

		this.tablist
			.removeClass( "ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all" )
			.removeAttr( "role" );

		this.anchors
			.removeClass( "ui-tabs-anchor" )
			.removeAttr( "role" )
			.removeAttr( "tabIndex" )
			.removeUniqueId();

		this.tablist.unbind( this.eventNamespace );

		this.tabs.add( this.panels ).each(function() {
			if ( $.data( this, "ui-tabs-destroy" ) ) {
				$( this ).remove();
			} else {
				$( this )
					.removeClass( "ui-state-default ui-state-active ui-state-disabled " +
						"ui-corner-top ui-corner-bottom ui-widget-content ui-tabs-active ui-tabs-panel" )
					.removeAttr( "tabIndex" )
					.removeAttr( "aria-live" )
					.removeAttr( "aria-busy" )
					.removeAttr( "aria-selected" )
					.removeAttr( "aria-labelledby" )
					.removeAttr( "aria-hidden" )
					.removeAttr( "aria-expanded" )
					.removeAttr( "role" );
			}
		});

		this.tabs.each(function() {
			var li = $( this ),
				prev = li.data( "ui-tabs-aria-controls" );
			if ( prev ) {
				li
					.attr( "aria-controls", prev )
					.removeData( "ui-tabs-aria-controls" );
			} else {
				li.removeAttr( "aria-controls" );
			}
		});

		this.panels.show();

		if ( this.options.heightStyle !== "content" ) {
			this.panels.css( "height", "" );
		}
	},

	enable: function( index ) {
		var disabled = this.options.disabled;
		if ( disabled === false ) {
			return;
		}

		if ( index === undefined ) {
			disabled = false;
		} else {
			index = this._getIndex( index );
			if ( $.isArray( disabled ) ) {
				disabled = $.map( disabled, function( num ) {
					return num !== index ? num : null;
				});
			} else {
				disabled = $.map( this.tabs, function( li, num ) {
					return num !== index ? num : null;
				});
			}
		}
		this._setupDisabled( disabled );
	},

	disable: function( index ) {
		var disabled = this.options.disabled;
		if ( disabled === true ) {
			return;
		}

		if ( index === undefined ) {
			disabled = true;
		} else {
			index = this._getIndex( index );
			if ( $.inArray( index, disabled ) !== -1 ) {
				return;
			}
			if ( $.isArray( disabled ) ) {
				disabled = $.merge( [ index ], disabled ).sort();
			} else {
				disabled = [ index ];
			}
		}
		this._setupDisabled( disabled );
	},

	load: function( index, event ) {
		index = this._getIndex( index );
		var that = this,
			tab = this.tabs.eq( index ),
			anchor = tab.find( ".ui-tabs-anchor" ),
			panel = this._getPanelForTab( tab ),
			eventData = {
				tab: tab,
				panel: panel
			},
			complete = function( jqXHR, status ) {
				if ( status === "abort" ) {
					that.panels.stop( false, true );
				}

				tab.removeClass( "ui-tabs-loading" );
				panel.removeAttr( "aria-busy" );

				if ( jqXHR === that.xhr ) {
					delete that.xhr;
				}
			};

		// not remote
		if ( this._isLocal( anchor[ 0 ] ) ) {
			return;
		}

		this.xhr = $.ajax( this._ajaxSettings( anchor, event, eventData ) );

		// support: jQuery <1.8
		// jQuery <1.8 returns false if the request is canceled in beforeSend,
		// but as of 1.8, $.ajax() always returns a jqXHR object.
		if ( this.xhr && this.xhr.statusText !== "canceled" ) {
			tab.addClass( "ui-tabs-loading" );
			panel.attr( "aria-busy", "true" );

			this.xhr
				.done(function( response, status, jqXHR ) {
					// support: jQuery <1.8
					// http://bugs.jquery.com/ticket/11778
					setTimeout(function() {
						panel.html( response );
						that._trigger( "load", event, eventData );

						complete( jqXHR, status );
					}, 1 );
				})
				.fail(function( jqXHR, status ) {
					// support: jQuery <1.8
					// http://bugs.jquery.com/ticket/11778
					setTimeout(function() {
						complete( jqXHR, status );
					}, 1 );
				});
		}
	},

	_ajaxSettings: function( anchor, event, eventData ) {
		var that = this;
		return {
			url: anchor.attr( "href" ),
			beforeSend: function( jqXHR, settings ) {
				return that._trigger( "beforeLoad", event,
					$.extend( { jqXHR: jqXHR, ajaxSettings: settings }, eventData ) );
			}
		};
	},

	_getPanelForTab: function( tab ) {
		var id = $( tab ).attr( "aria-controls" );
		return this.element.find( this._sanitizeSelector( "#" + id ) );
	}
});

}));




/*!
 * jQuery UI Tooltip 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/tooltip/
 */

(function( factory ) {
	if ( typeof define === "function" && define.amd ) {

		// AMD. Register as an anonymous module.
		define([
			"jquery",
			"./core",
			"./widget",
			"./position"
		], factory );
	} else {

		// Browser globals
		factory( jQuery );
	}
}(function( $ ) {

return $.widget( "ui.tooltip", {
	version: "1.11.4",
	options: {
		content: function() {
			// support: IE<9, Opera in jQuery <1.7
			// .text() can't accept undefined, so coerce to a string
			var title = $( this ).attr( "title" ) || "";
			// Escape title, since we're going from an attribute to raw HTML
			return $( "<a>" ).text( title ).html();
		},
		hide: true,
		// Disabled elements have inconsistent behavior across browsers (#8661)
		items: "[title]:not([disabled])",
		position: {
			my: "left top+15",
			at: "left bottom",
			collision: "flipfit flip"
		},
		show: true,
		tooltipClass: null,
		track: false,

		// callbacks
		close: null,
		open: null
	},

	_addDescribedBy: function( elem, id ) {
		var describedby = (elem.attr( "aria-describedby" ) || "").split( /\s+/ );
		describedby.push( id );
		elem
			.data( "ui-tooltip-id", id )
			.attr( "aria-describedby", $.trim( describedby.join( " " ) ) );
	},

	_removeDescribedBy: function( elem ) {
		var id = elem.data( "ui-tooltip-id" ),
			describedby = (elem.attr( "aria-describedby" ) || "").split( /\s+/ ),
			index = $.inArray( id, describedby );

		if ( index !== -1 ) {
			describedby.splice( index, 1 );
		}

		elem.removeData( "ui-tooltip-id" );
		describedby = $.trim( describedby.join( " " ) );
		if ( describedby ) {
			elem.attr( "aria-describedby", describedby );
		} else {
			elem.removeAttr( "aria-describedby" );
		}
	},

	_create: function() {
		this._on({
			mouseover: "open",
			focusin: "open"
		});

		// IDs of generated tooltips, needed for destroy
		this.tooltips = {};

		// IDs of parent tooltips where we removed the title attribute
		this.parents = {};

		if ( this.options.disabled ) {
			this._disable();
		}

		// Append the aria-live region so tooltips announce correctly
		this.liveRegion = $( "<div>" )
			.attr({
				role: "log",
				"aria-live": "assertive",
				"aria-relevant": "additions"
			})
			.addClass( "ui-helper-hidden-accessible" )
			.appendTo( this.document[ 0 ].body );
	},

	_setOption: function( key, value ) {
		var that = this;

		if ( key === "disabled" ) {
			this[ value ? "_disable" : "_enable" ]();
			this.options[ key ] = value;
			// disable element style changes
			return;
		}

		this._super( key, value );

		if ( key === "content" ) {
			$.each( this.tooltips, function( id, tooltipData ) {
				that._updateContent( tooltipData.element );
			});
		}
	},

	_disable: function() {
		var that = this;

		// close open tooltips
		$.each( this.tooltips, function( id, tooltipData ) {
			var event = $.Event( "blur" );
			event.target = event.currentTarget = tooltipData.element[ 0 ];
			that.close( event, true );
		});

		// remove title attributes to prevent native tooltips
		this.element.find( this.options.items ).addBack().each(function() {
			var element = $( this );
			if ( element.is( "[title]" ) ) {
				element
					.data( "ui-tooltip-title", element.attr( "title" ) )
					.removeAttr( "title" );
			}
		});
	},

	_enable: function() {
		// restore title attributes
		this.element.find( this.options.items ).addBack().each(function() {
			var element = $( this );
			if ( element.data( "ui-tooltip-title" ) ) {
				element.attr( "title", element.data( "ui-tooltip-title" ) );
			}
		});
	},

	open: function( event ) {
		var that = this,
			target = $( event ? event.target : this.element )
				// we need closest here due to mouseover bubbling,
				// but always pointing at the same event target
				.closest( this.options.items );

		// No element to show a tooltip for or the tooltip is already open
		if ( !target.length || target.data( "ui-tooltip-id" ) ) {
			return;
		}

		if ( target.attr( "title" ) ) {
			target.data( "ui-tooltip-title", target.attr( "title" ) );
		}

		target.data( "ui-tooltip-open", true );

		// kill parent tooltips, custom or native, for hover
		if ( event && event.type === "mouseover" ) {
			target.parents().each(function() {
				var parent = $( this ),
					blurEvent;
				if ( parent.data( "ui-tooltip-open" ) ) {
					blurEvent = $.Event( "blur" );
					blurEvent.target = blurEvent.currentTarget = this;
					that.close( blurEvent, true );
				}
				if ( parent.attr( "title" ) ) {
					parent.uniqueId();
					that.parents[ this.id ] = {
						element: this,
						title: parent.attr( "title" )
					};
					parent.attr( "title", "" );
				}
			});
		}

		this._registerCloseHandlers( event, target );
		this._updateContent( target, event );
	},

	_updateContent: function( target, event ) {
		var content,
			contentOption = this.options.content,
			that = this,
			eventType = event ? event.type : null;

		if ( typeof contentOption === "string" ) {
			return this._open( event, target, contentOption );
		}

		content = contentOption.call( target[0], function( response ) {

			// IE may instantly serve a cached response for ajax requests
			// delay this call to _open so the other call to _open runs first
			that._delay(function() {

				// Ignore async response if tooltip was closed already
				if ( !target.data( "ui-tooltip-open" ) ) {
					return;
				}

				// jQuery creates a special event for focusin when it doesn't
				// exist natively. To improve performance, the native event
				// object is reused and the type is changed. Therefore, we can't
				// rely on the type being correct after the event finished
				// bubbling, so we set it back to the previous value. (#8740)
				if ( event ) {
					event.type = eventType;
				}
				this._open( event, target, response );
			});
		});
		if ( content ) {
			this._open( event, target, content );
		}
	},

	_open: function( event, target, content ) {
		var tooltipData, tooltip, delayedShow, a11yContent,
			positionOption = $.extend( {}, this.options.position );

		if ( !content ) {
			return;
		}

		// Content can be updated multiple times. If the tooltip already
		// exists, then just update the content and bail.
		tooltipData = this._find( target );
		if ( tooltipData ) {
			tooltipData.tooltip.find( ".ui-tooltip-content" ).html( content );
			return;
		}

		// if we have a title, clear it to prevent the native tooltip
		// we have to check first to avoid defining a title if none exists
		// (we don't want to cause an element to start matching [title])
		//
		// We use removeAttr only for key events, to allow IE to export the correct
		// accessible attributes. For mouse events, set to empty string to avoid
		// native tooltip showing up (happens only when removing inside mouseover).
		if ( target.is( "[title]" ) ) {
			if ( event && event.type === "mouseover" ) {
				target.attr( "title", "" );
			} else {
				target.removeAttr( "title" );
			}
		}

		tooltipData = this._tooltip( target );
		tooltip = tooltipData.tooltip;
		this._addDescribedBy( target, tooltip.attr( "id" ) );
		tooltip.find( ".ui-tooltip-content" ).html( content );

		// Support: Voiceover on OS X, JAWS on IE <= 9
		// JAWS announces deletions even when aria-relevant="additions"
		// Voiceover will sometimes re-read the entire log region's contents from the beginning
		this.liveRegion.children().hide();
		if ( content.clone ) {
			a11yContent = content.clone();
			a11yContent.removeAttr( "id" ).find( "[id]" ).removeAttr( "id" );
		} else {
			a11yContent = content;
		}
		$( "<div>" ).html( a11yContent ).appendTo( this.liveRegion );

		function position( event ) {
			positionOption.of = event;
			if ( tooltip.is( ":hidden" ) ) {
				return;
			}
			tooltip.position( positionOption );
		}
		if ( this.options.track && event && /^mouse/.test( event.type ) ) {
			this._on( this.document, {
				mousemove: position
			});
			// trigger once to override element-relative positioning
			position( event );
		} else {
			tooltip.position( $.extend({
				of: target
			}, this.options.position ) );
		}

		tooltip.hide();

		this._show( tooltip, this.options.show );
		// Handle tracking tooltips that are shown with a delay (#8644). As soon
		// as the tooltip is visible, position the tooltip using the most recent
		// event.
		if ( this.options.show && this.options.show.delay ) {
			delayedShow = this.delayedShow = setInterval(function() {
				if ( tooltip.is( ":visible" ) ) {
					position( positionOption.of );
					clearInterval( delayedShow );
				}
			}, $.fx.interval );
		}

		this._trigger( "open", event, { tooltip: tooltip } );
	},

	_registerCloseHandlers: function( event, target ) {
		var events = {
			keyup: function( event ) {
				if ( event.keyCode === $.ui.keyCode.ESCAPE ) {
					var fakeEvent = $.Event(event);
					fakeEvent.currentTarget = target[0];
					this.close( fakeEvent, true );
				}
			}
		};

		// Only bind remove handler for delegated targets. Non-delegated
		// tooltips will handle this in destroy.
		if ( target[ 0 ] !== this.element[ 0 ] ) {
			events.remove = function() {
				this._removeTooltip( this._find( target ).tooltip );
			};
		}

		if ( !event || event.type === "mouseover" ) {
			events.mouseleave = "close";
		}
		if ( !event || event.type === "focusin" ) {
			events.focusout = "close";
		}
		this._on( true, target, events );
	},

	close: function( event ) {
		var tooltip,
			that = this,
			target = $( event ? event.currentTarget : this.element ),
			tooltipData = this._find( target );

		// The tooltip may already be closed
		if ( !tooltipData ) {

			// We set ui-tooltip-open immediately upon open (in open()), but only set the
			// additional data once there's actually content to show (in _open()). So even if the
			// tooltip doesn't have full data, we always remove ui-tooltip-open in case we're in
			// the period between open() and _open().
			target.removeData( "ui-tooltip-open" );
			return;
		}

		tooltip = tooltipData.tooltip;

		// disabling closes the tooltip, so we need to track when we're closing
		// to avoid an infinite loop in case the tooltip becomes disabled on close
		if ( tooltipData.closing ) {
			return;
		}

		// Clear the interval for delayed tracking tooltips
		clearInterval( this.delayedShow );

		// only set title if we had one before (see comment in _open())
		// If the title attribute has changed since open(), don't restore
		if ( target.data( "ui-tooltip-title" ) && !target.attr( "title" ) ) {
			target.attr( "title", target.data( "ui-tooltip-title" ) );
		}

		this._removeDescribedBy( target );

		tooltipData.hiding = true;
		tooltip.stop( true );
		this._hide( tooltip, this.options.hide, function() {
			that._removeTooltip( $( this ) );
		});

		target.removeData( "ui-tooltip-open" );
		this._off( target, "mouseleave focusout keyup" );

		// Remove 'remove' binding only on delegated targets
		if ( target[ 0 ] !== this.element[ 0 ] ) {
			this._off( target, "remove" );
		}
		this._off( this.document, "mousemove" );

		if ( event && event.type === "mouseleave" ) {
			$.each( this.parents, function( id, parent ) {
				$( parent.element ).attr( "title", parent.title );
				delete that.parents[ id ];
			});
		}

		tooltipData.closing = true;
		this._trigger( "close", event, { tooltip: tooltip } );
		if ( !tooltipData.hiding ) {
			tooltipData.closing = false;
		}
	},

	_tooltip: function( element ) {
		var tooltip = $( "<div>" )
				.attr( "role", "tooltip" )
				.addClass( "ui-tooltip ui-widget ui-corner-all ui-widget-content " +
					( this.options.tooltipClass || "" ) ),
			id = tooltip.uniqueId().attr( "id" );

		$( "<div>" )
			.addClass( "ui-tooltip-content" )
			.appendTo( tooltip );

		tooltip.appendTo( this.document[0].body );

		return this.tooltips[ id ] = {
			element: element,
			tooltip: tooltip
		};
	},

	_find: function( target ) {
		var id = target.data( "ui-tooltip-id" );
		return id ? this.tooltips[ id ] : null;
	},

	_removeTooltip: function( tooltip ) {
		tooltip.remove();
		delete this.tooltips[ tooltip.attr( "id" ) ];
	},

	_destroy: function() {
		var that = this;

		// close open tooltips
		$.each( this.tooltips, function( id, tooltipData ) {
			// Delegate to close method to handle common cleanup
			var event = $.Event( "blur" ),
				element = tooltipData.element;
			event.target = event.currentTarget = element[ 0 ];
			that.close( event, true );

			// Remove immediately; destroying an open tooltip doesn't use the
			// hide animation
			$( "#" + id ).remove();

			// Restore the title
			if ( element.data( "ui-tooltip-title" ) ) {
				// If the title attribute has changed since open(), don't restore
				if ( !element.attr( "title" ) ) {
					element.attr( "title", element.data( "ui-tooltip-title" ) );
				}
				element.removeData( "ui-tooltip-title" );
			}
		});
		this.liveRegion.remove();
	}
});

}));





































/**
 * @preserve
 * jquery.layout 1.3.0 - Release Candidate 30.79
 * $Date: 2013-01-12 08:00:00 (Sat, 12 Jan 2013) $
 * $Rev: 303007 $
 *
 * Copyright (c) 2012 
 *   Fabrizio Balliano (http://www.fabrizioballiano.net)
 *   Kevin Dalman (http://allpro.net)
 *
 * Dual licensed under the GPL (http://www.gnu.org/licenses/gpl.html)
 * and MIT (http://www.opensource.org/licenses/mit-license.php) licenses.
 *
 * Changelog: http://layout.jquery-dev.net/changelog.cfm#1.3.0.rc30.79
 *
 * Docs: http://layout.jquery-dev.net/documentation.html
 * Tips: http://layout.jquery-dev.net/tips.html
 * Help: http://groups.google.com/group/jquery-ui-layout
 */

/* JavaDoc Info: http://code.google.com/closure/compiler/docs/js-for-compiler.html
 * {!Object}	non-nullable type (never NULL)
 * {?string}	nullable type (sometimes NULL) - default for {Object}
 * {number=}	optional parameter
 * {*}			ALL types
 */
/*	TODO for jQ 2.0 
 *	change .andSelf() to .addBack()
 *	$.fn.disableSelection won't work
 */

// NOTE: For best readability, view with a fixed-width font and tabs equal to 4-chars

;(function ($) {

// alias Math methods - used a lot!
var	min		= Math.min
,	max		= Math.max
,	round	= Math.floor

,	isStr	=  function (v) { return $.type(v) === "string"; }

	/**
	* @param {!Object}			Instance
	* @param {Array.<string>}	a_fn
	*/
,	runPluginCallbacks = function (Instance, a_fn) {
		if ($.isArray(a_fn))
			for (var i=0, c=a_fn.length; i<c; i++) {
				var fn = a_fn[i];
				try {
					if (isStr(fn)) // 'name' of a function
						fn = eval(fn);
					if ($.isFunction(fn))
						g(fn)( Instance );
				} catch (ex) {}
			}
		function g (f) { return f; }; // compiler hack
	}
;

/*
 *	GENERIC $.layout METHODS - used by all layouts
 */
$.layout = {

	version:	"1.3.rc30.79"
,	revision:	0.033007 // 1.3.0 final = 1.0300 - major(n+).minor(nn)+patch(nn+)

	// $.layout.browser REPLACES $.browser
,	browser:	{} // set below

	// *PREDEFINED* EFFECTS & DEFAULTS 
	// MUST list effect here - OR MUST set an fxSettings option (can be an empty hash: {})
,	effects: {

	//	Pane Open/Close Animations
		slide: {
			all:	{ duration:  "fast"	} // eg: duration: 1000, easing: "easeOutBounce"
		,	north:	{ direction: "up"	}
		,	south:	{ direction: "down"	}
		,	east:	{ direction: "right"}
		,	west:	{ direction: "left"	}
		}
	,	drop: {
			all:	{ duration:  "slow"	}
		,	north:	{ direction: "up"	}
		,	south:	{ direction: "down"	}
		,	east:	{ direction: "right"}
		,	west:	{ direction: "left"	}
		}
	,	scale: {
			all:	{ duration:	"fast"	}
		}
	//	these are not recommended, but can be used
	,	blind:		{}
	,	clip:		{}
	,	explode:	{}
	,	fade:		{}
	,	fold:		{}
	,	puff:		{}

	//	Pane Resize Animations
	,	size: {
			all:	{ easing:	"swing"	}
		}
	}

	// INTERNAL CONFIG DATA - DO NOT CHANGE THIS!
,	config: {
		optionRootKeys:	"effects,panes,north,south,west,east,center".split(",")
	,	allPanes:		"north,south,west,east,center".split(",")
	,	borderPanes:	"north,south,west,east".split(",")
	,	oppositeEdge: {
			north:	"south"
		,	south:	"north"
		,	east: 	"west"
		,	west: 	"east"
		}
	//	offscreen data
	,	offscreenCSS:	{ left: "-99999px", right: "auto" } // used by hide/close if useOffscreenClose=true
	,	offscreenReset:	"offscreenReset" // key used for data
	//	CSS used in multiple places
	,	hidden:		{ visibility: "hidden" }
	,	visible:	{ visibility: "visible" }
	//	layout element settings
	,	resizers: {
			cssReq: {
				position: 	"absolute"
			,	padding: 	0
			,	margin: 	0
			,	fontSize:	"1px"
			,	textAlign:	"left"	// to counter-act "center" alignment!
			,	overflow: 	"hidden" // prevent toggler-button from overflowing
			//	SEE $.layout.defaults.zIndexes.resizer_normal
			}
		,	cssDemo: { // DEMO CSS - applied if: options.PANE.applyDemoStyles=true
				background: "#DDD"
			,	border:		"none"
			}
		}
	,	togglers: {
			cssReq: {
				position: 	"absolute"
			,	display: 	"block"
			,	padding: 	0
			,	margin: 	0
			,	overflow:	"hidden"
			,	textAlign:	"center"
			,	fontSize:	"1px"
			,	cursor: 	"pointer"
			,	zIndex: 	1
			}
		,	cssDemo: { // DEMO CSS - applied if: options.PANE.applyDemoStyles=true
				background: "#AAA"
			}
		}
	,	content: {
			cssReq: {
				position:	"relative" /* contain floated or positioned elements */
			}
		,	cssDemo: { // DEMO CSS - applied if: options.PANE.applyDemoStyles=true
				overflow:	"auto"
			,	padding:	"10px"
			}
		,	cssDemoPane: { // DEMO CSS - REMOVE scrolling from 'pane' when it has a content-div
				overflow:	"hidden"
			,	padding:	0
			}
		}
	,	panes: { // defaults for ALL panes - overridden by 'per-pane settings' below
			cssReq: {
				position: 	"absolute"
			,	margin:		0
			//	$.layout.defaults.zIndexes.pane_normal
			}
		,	cssDemo: { // DEMO CSS - applied if: options.PANE.applyDemoStyles=true
				padding:	"10px"
			,	background:	"#FFF"
			,	border:		"1px solid #BBB"
			,	overflow:	"auto"
			}
		}
	,	north: {
			side:			"top"
		,	sizeType:		"Height"
		,	dir:			"horz"
		,	cssReq: {
				top: 		0
			,	bottom: 	"auto"
			,	left: 		0
			,	right: 		0
			,	width: 		"auto"
			//	height: 	DYNAMIC
			}
		}
	,	south: {
			side:			"bottom"
		,	sizeType:		"Height"
		,	dir:			"horz"
		,	cssReq: {
				top: 		"auto"
			,	bottom: 	0
			,	left: 		0
			,	right: 		0
			,	width: 		"auto"
			//	height: 	DYNAMIC
			}
		}
	,	east: {
			side:			"right"
		,	sizeType:		"Width"
		,	dir:			"vert"
		,	cssReq: {
				left: 		"auto"
			,	right: 		0
			,	top: 		"auto" // DYNAMIC
			,	bottom: 	"auto" // DYNAMIC
			,	height: 	"auto"
			//	width: 		DYNAMIC
			}
		}
	,	west: {
			side:			"left"
		,	sizeType:		"Width"
		,	dir:			"vert"
		,	cssReq: {
				left: 		0
			,	right: 		"auto"
			,	top: 		"auto" // DYNAMIC
			,	bottom: 	"auto" // DYNAMIC
			,	height: 	"auto"
			//	width: 		DYNAMIC
			}
		}
	,	center: {
			dir:			"center"
		,	cssReq: {
				left: 		"auto" // DYNAMIC
			,	right: 		"auto" // DYNAMIC
			,	top: 		"auto" // DYNAMIC
			,	bottom: 	"auto" // DYNAMIC
			,	height: 	"auto"
			,	width: 		"auto"
			}
		}
	}

	// CALLBACK FUNCTION NAMESPACE - used to store reusable callback functions
,	callbacks: {}

,	getParentPaneElem: function (el) {
		// must pass either a container or pane element
		var $el = $(el)
		,	layout = $el.data("layout") || $el.data("parentLayout");
		if (layout) {
			var $cont = layout.container;
			// see if this container is directly-nested inside an outer-pane
			if ($cont.data("layoutPane")) return $cont;
			var $pane = $cont.closest("."+ $.layout.defaults.panes.paneClass);
			// if a pane was found, return it
			if ($pane.data("layoutPane")) return $pane;
		}
		return null;
	}

,	getParentPaneInstance: function (el) {
		// must pass either a container or pane element
		var $pane = $.layout.getParentPaneElem(el);
		return $pane ? $pane.data("layoutPane") : null;
	}

,	getParentLayoutInstance: function (el) {
		// must pass either a container or pane element
		var $pane = $.layout.getParentPaneElem(el);
		return $pane ? $pane.data("parentLayout") : null;
	}

,	getEventObject: function (evt) {
		return typeof evt === "object" && evt.stopPropagation ? evt : null;
	}
,	parsePaneName: function (evt_or_pane) {
		var evt = $.layout.getEventObject( evt_or_pane )
		,	pane = evt_or_pane;
		if (evt) {
			// ALWAYS stop propagation of events triggered in Layout!
			evt.stopPropagation();
			pane = $(this).data("layoutEdge");
		}
		if (pane && !/^(west|east|north|south|center)$/.test(pane)) {
			$.layout.msg('LAYOUT ERROR - Invalid pane-name: "'+ pane +'"');
			pane = "error";
		}
		return pane;
	}


	// LAYOUT-PLUGIN REGISTRATION
	// more plugins can added beyond this default list
,	plugins: {
		draggable:		!!$.fn.draggable // resizing
	,	effects: {
			core:		!!$.effects		// animimations (specific effects tested by initOptions)
		,	slide:		$.effects && ($.effects.slide || ($.effects.effect && $.effects.effect.slide)) // default effect
		}
	}

//	arrays of plugin or other methods to be triggered for events in *each layout* - will be passed 'Instance'
,	onCreate:	[]	// runs when layout is just starting to be created - right after options are set
,	onLoad:		[]	// runs after layout container and global events init, but before initPanes is called
,	onReady:	[]	// runs after initialization *completes* - ie, after initPanes completes successfully
,	onDestroy:	[]	// runs after layout is destroyed
,	onUnload:	[]	// runs after layout is destroyed OR when page unloads
,	afterOpen:	[]	// runs after setAsOpen() completes
,	afterClose:	[]	// runs after setAsClosed() completes

	/*
	*	GENERIC UTILITY METHODS
	*/

	// calculate and return the scrollbar width, as an integer
,	scrollbarWidth:		function () { return window.scrollbarWidth  || $.layout.getScrollbarSize('width'); }
,	scrollbarHeight:	function () { return window.scrollbarHeight || $.layout.getScrollbarSize('height'); }
,	getScrollbarSize:	function (dim) {
		var $c	= $('<div style="position: absolute; top: -10000px; left: -10000px; width: 100px; height: 100px; overflow: scroll;"></div>').appendTo("body");
		var d	= { width: $c.css("width") - $c[0].clientWidth, height: $c.height() - $c[0].clientHeight };
		$c.remove();
		window.scrollbarWidth	= d.width;
		window.scrollbarHeight	= d.height;
		return dim.match(/^(width|height)$/) ? d[dim] : d;
	}


	/**
	* Returns hash container 'display' and 'visibility'
	*
	* @see	$.swap() - swaps CSS, runs callback, resets CSS
	* @param  {!Object}		$E				jQuery element
	* @param  {boolean=}	[force=false]	Run even if display != none
	* @return {!Object}						Returns current style props, if applicable
	*/
,	showInvisibly: function ($E, force) {
		if ($E && $E.length && (force || $E.css("display") === "none")) { // only if not *already hidden*
			var s = $E[0].style
				// save ONLY the 'style' props because that is what we must restore
			,	CSS = { display: s.display || '', visibility: s.visibility || '' };
			// show element 'invisibly' so can be measured
			$E.css({ display: "block", visibility: "hidden" });
			return CSS;
		}
		return {};
	}

	/**
	* Returns data for setting size of an element (container or a pane).
	*
	* @see  _create(), onWindowResize() for container, plus others for pane
	* @return JSON  Returns a hash of all dimensions: top, bottom, left, right, outerWidth, innerHeight, etc
	*/
,	getElementDimensions: function ($E, inset) {
		var
		//	dimensions hash - start with current data IF passed
			d	= { css: {}, inset: {} }
		,	x	= d.css			// CSS hash
		,	i	= { bottom: 0 }	// TEMP insets (bottom = complier hack)
		,	N	= $.layout.cssNum
		,	off = $E.offset()
		,	b, p, ei			// TEMP border, padding
		;
		d.offsetLeft = off.left;
		d.offsetTop  = off.top;

		if (!inset) inset = {}; // simplify logic below

		$.each("Left,Right,Top,Bottom".split(","), function (idx, e) { // e = edge
			b = x["border" + e] = $.layout.borderWidth($E, e);
			p = x["padding"+ e] = $.layout.cssNum($E, "padding"+e);
			ei = e.toLowerCase();
			d.inset[ei] = inset[ei] >= 0 ? inset[ei] : p; // any missing insetX value = paddingX
			i[ei] = d.inset[ei] + b; // total offset of content from outer side
		});

		x.width		= $E.width();
		x.height	= $E.height();
		x.top		= N($E,"top",true);
		x.bottom	= N($E,"bottom",true);
		x.left		= N($E,"left",true);
		x.right		= N($E,"right",true);

		d.outerWidth	= $E.outerWidth();
		d.outerHeight	= $E.outerHeight();
		// calc the TRUE inner-dimensions, even in quirks-mode!
		d.innerWidth	= max(0, d.outerWidth  - i.left - i.right);
		d.innerHeight	= max(0, d.outerHeight - i.top  - i.bottom);
		// layoutWidth/Height is used in calcs for manual resizing
		// layoutW/H only differs from innerW/H when in quirks-mode - then is like outerW/H
		d.layoutWidth	= $E.innerWidth();
		d.layoutHeight	= $E.innerHeight();

		//if ($E.prop('tagName') === 'BODY') { debugData( d, $E.prop('tagName') ); } // DEBUG

		//d.visible	= $E.is(":visible");// && x.width > 0 && x.height > 0;

		return d;
	}

,	getElementStyles: function ($E, list) {
		var
			CSS	= {}
		,	style	= $E[0].style
		,	props	= list.split(",")
		,	sides	= "Top,Bottom,Left,Right".split(",")
		,	attrs	= "Color,Style,Width".split(",")
		,	p, s, a, i, j, k
		;
		for (i=0; i < props.length; i++) {
			p = props[i];
			if (p.match(/(border|padding|margin)$/))
				for (j=0; j < 4; j++) {
					s = sides[j];
					if (p === "border")
						for (k=0; k < 3; k++) {
							a = attrs[k];
							CSS[p+s+a] = style[p+s+a];
						}
					else
						CSS[p+s] = style[p+s];
				}
			else
				CSS[p] = style[p];
		};
		return CSS
	}

	/**
	* Return the innerWidth for the current browser/doctype
	*
	* @see  initPanes(), sizeMidPanes(), initHandles(), sizeHandles()
	* @param  {Array.<Object>}	$E  Must pass a jQuery object - first element is processed
	* @param  {number=}			outerWidth (optional) Can pass a width, allowing calculations BEFORE element is resized
	* @return {number}			Returns the innerWidth of the elem by subtracting padding and borders
	*/
,	cssWidth: function ($E, outerWidth) {
		// a 'calculated' outerHeight can be passed so borders and/or padding are removed if needed
		if (outerWidth <= 0) return 0;

		var bs	= !$.layout.browser.boxModel ? "border-box" : $.support.boxSizing ? $E.css("boxSizing") : "content-box"
		,	b	= $.layout.borderWidth
		,	n	= $.layout.cssNum
		,	W	= outerWidth
		;
		// strip border and/or padding from outerWidth to get CSS Width
		if (bs !== "border-box")
			W -= (b($E, "Left") + b($E, "Right"));
		if (bs === "content-box")
			W -= (n($E, "paddingLeft") + n($E, "paddingRight"));
		return max(0,W);
	}

	/**
	* Return the innerHeight for the current browser/doctype
	*
	* @see  initPanes(), sizeMidPanes(), initHandles(), sizeHandles()
	* @param  {Array.<Object>}	$E  Must pass a jQuery object - first element is processed
	* @param  {number=}			outerHeight  (optional) Can pass a width, allowing calculations BEFORE element is resized
	* @return {number}			Returns the innerHeight of the elem by subtracting padding and borders
	*/
,	cssHeight: function ($E, outerHeight) {
		// a 'calculated' outerHeight can be passed so borders and/or padding are removed if needed
		if (outerHeight <= 0) return 0;

		var bs	= !$.layout.browser.boxModel ? "border-box" : $.support.boxSizing ? $E.css("boxSizing") : "content-box"
		,	b	= $.layout.borderWidth
		,	n	= $.layout.cssNum
		,	H	= outerHeight
		;
		// strip border and/or padding from outerHeight to get CSS Height
		if (bs !== "border-box")
			H -= (b($E, "Top") + b($E, "Bottom"));
		if (bs === "content-box")
			H -= (n($E, "paddingTop") + n($E, "paddingBottom"));
		return max(0,H);
	}

	/**
	* Returns the 'current CSS numeric value' for a CSS property - 0 if property does not exist
	*
	* @see  Called by many methods
	* @param {Array.<Object>}	$E					Must pass a jQuery object - first element is processed
	* @param {string}			prop				The name of the CSS property, eg: top, width, etc.
	* @param {boolean=}			[allowAuto=false]	true = return 'auto' if that is value; false = return 0
	* @return {(string|number)}						Usually used to get an integer value for position (top, left) or size (height, width)
	*/
,	cssNum: function ($E, prop, allowAuto) {
		if (!$E.jquery) $E = $($E);
		var CSS = $.layout.showInvisibly($E)
		,	p	= $.css($E[0], prop, true)
		,	v	= allowAuto && p=="auto" ? p : Math.round(parseFloat(p) || 0);
		$E.css( CSS ); // RESET
		return v;
	}

,	borderWidth: function (el, side) {
		if (el.jquery) el = el[0];
		var b = "border"+ side.substr(0,1).toUpperCase() + side.substr(1); // left => Left
		return $.css(el, b+"Style", true) === "none" ? 0 : Math.round(parseFloat($.css(el, b+"Width", true)) || 0);
	}

	/**
	* Mouse-tracking utility - FUTURE REFERENCE
	*
	* init: if (!window.mouse) {
	*			window.mouse = { x: 0, y: 0 };
	*			$(document).mousemove( $.layout.trackMouse );
	*		}
	*
	* @param {Object}		evt
	*
,	trackMouse: function (evt) {
		window.mouse = { x: evt.clientX, y: evt.clientY };
	}
	*/

	/**
	* SUBROUTINE for preventPrematureSlideClose option
	*
	* @param {Object}		evt
	* @param {Object=}		el
	*/
,	isMouseOverElem: function (evt, el) {
		var
			$E	= $(el || this)
		,	d	= $E.offset()
		,	T	= d.top
		,	L	= d.left
		,	R	= L + $E.outerWidth()
		,	B	= T + $E.outerHeight()
		,	x	= evt.pageX	// evt.clientX ?
		,	y	= evt.pageY	// evt.clientY ?
		;
		// if X & Y are < 0, probably means is over an open SELECT
		return ($.layout.browser.msie && x < 0 && y < 0) || ((x >= L && x <= R) && (y >= T && y <= B));
	}

	/**
	* Message/Logging Utility
	*
	* @example $.layout.msg("My message");				// log text
	* @example $.layout.msg("My message", true);		// alert text
	* @example $.layout.msg({ foo: "bar" }, "Title");	// log hash-data, with custom title
	* @example $.layout.msg({ foo: "bar" }, true, "Title", { sort: false }); -OR-
	* @example $.layout.msg({ foo: "bar" }, "Title", { sort: false, display: true }); // alert hash-data
	*
	* @param {(Object|string)}			info			String message OR Hash/Array
	* @param {(Boolean|string|Object)=}	[popup=false]	True means alert-box - can be skipped
	* @param {(Object|string)=}			[debugTitle=""]	Title for Hash data - can be skipped
	* @param {Object=}					[debugOpts]		Extra options for debug output
	*/
,	msg: function (info, popup, debugTitle, debugOpts) {
		if ($.isPlainObject(info) && window.debugData) {
			if (typeof popup === "string") {
				debugOpts	= debugTitle;
				debugTitle	= popup;
			}
			else if (typeof debugTitle === "object") {
				debugOpts	= debugTitle;
				debugTitle	= null;
			}
			var t = debugTitle || "log( <object> )"
			,	o = $.extend({ sort: false, returnHTML: false, display: false }, debugOpts);
			if (popup === true || o.display)
				debugData( info, t, o );
			else if (window.console)
				console.log(debugData( info, t, o ));
		}
		else if (popup)
			alert(info);
		else if (window.console)
			console.log(info);
		else {
			var id	= "#layoutLogger"
			,	$l = $(id);
			if (!$l.length)
				$l = createLog();
			$l.children("ul").append('<li style="padding: 4px 10px; margin: 0; border-top: 1px solid #CCC;">'+ info.replace(/\</g,"&lt;").replace(/\>/g,"&gt;") +'</li>');
		}

		function createLog () {
			var pos = $.support.fixedPosition ? 'fixed' : 'absolute'
			,	$e = $('<div id="layoutLogger" style="position: '+ pos +'; top: 5px; z-index: 999999; max-width: 25%; overflow: hidden; border: 1px solid #000; border-radius: 5px; background: #FBFBFB; box-shadow: 0 2px 10px rgba(0,0,0,0.3);">'
				+	'<div style="font-size: 13px; font-weight: bold; padding: 5px 10px; background: #F6F6F6; border-radius: 5px 5px 0 0; cursor: move;">'
				+	'<span style="float: right; padding-left: 7px; cursor: pointer;" title="Remove Console" onclick="$(this).closest(\'#layoutLogger\').remove()">X</span>Layout console.log</div>'
				+	'<ul style="font-size: 13px; font-weight: none; list-style: none; margin: 0; padding: 0 0 2px;"></ul>'
				+ '</div>'
				).appendTo("body");
			$e.css('left', $(window).width() - $e.outerWidth() - 5)
			if ($.ui.draggable) $e.draggable({ handle: ':first-child' });
			return $e;
		};
	}

};


/*
 *	$.layout.browser REPLACES removed $.browser, with extra data
 *	Parsing code here adapted from jQuery 1.8 $.browse
 */
var u = navigator.userAgent.toLowerCase()
,	m = /(chrome)[ \/]([\w.]+)/.exec( u )
	||	/(webkit)[ \/]([\w.]+)/.exec( u )
	||	/(opera)(?:.*version|)[ \/]([\w.]+)/.exec( u )
	||	/(msie) ([\w.]+)/.exec( u )
	||	u.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec( u )
	||	[]
,	b = m[1] || ""
,	v = m[2] || 0
,	ie = b === "msie"
;
$.layout.browser = {
	version:	v
,	safari:		b === "webkit"	// webkit (NOT chrome) = safari
,	webkit:		b === "chrome"	// chrome = webkit
,	msie:		ie
,	isIE6:		ie && v == 6
	// ONLY IE reverts to old box-model - update for older jQ onReady
,	boxModel:	!ie || $.support.boxModel !== false
};
if (b) $.layout.browser[b] = true; // set CURRENT browser
/*	OLD versions of jQuery only set $.support.boxModel after page is loaded
 *	so if this is IE, use support.boxModel to test for quirks-mode (ONLY IE changes boxModel) */
if (ie) $(function(){ $.layout.browser.boxModel = $.support.boxModel; });


// DEFAULT OPTIONS
$.layout.defaults = {
/*
 *	LAYOUT & LAYOUT-CONTAINER OPTIONS
 *	- none of these options are applicable to individual panes
 */
	name:						""			// Not required, but useful for buttons and used for the state-cookie
,	containerClass:				"ui-layout-container" // layout-container element
,	inset:						null		// custom container-inset values (override padding)
,	scrollToBookmarkOnLoad:		true		// after creating a layout, scroll to bookmark in URL (.../page.htm#myBookmark)
,	resizeWithWindow:			true		// bind thisLayout.resizeAll() to the window.resize event
,	resizeWithWindowDelay:		200			// delay calling resizeAll because makes window resizing very jerky
,	resizeWithWindowMaxDelay:	0			// 0 = none - force resize every XX ms while window is being resized
,	maskPanesEarly:				false		// true = create pane-masks on resizer.mouseDown instead of waiting for resizer.dragstart
,	onresizeall_start:			null		// CALLBACK when resizeAll() STARTS	- NOT pane-specific
,	onresizeall_end:			null		// CALLBACK when resizeAll() ENDS	- NOT pane-specific
,	onload_start:				null		// CALLBACK when Layout inits - after options initialized, but before elements
,	onload_end:					null		// CALLBACK when Layout inits - after EVERYTHING has been initialized
,	onunload_start:				null		// CALLBACK when Layout is destroyed OR onWindowUnload
,	onunload_end:				null		// CALLBACK when Layout is destroyed OR onWindowUnload
,	initPanes:					true		// false = DO NOT initialize the panes onLoad - will init later
,	showErrorMessages:			true		// enables fatal error messages to warn developers of common errors
,	showDebugMessages:			false		// display console-and-alert debug msgs - IF this Layout version _has_ debugging code!
//	Changing this zIndex value will cause other zIndex values to automatically change
,	zIndex:						null		// the PANE zIndex - resizers and masks will be +1
//	DO NOT CHANGE the zIndex values below unless you clearly understand their relationships
,	zIndexes: {								// set _default_ z-index values here...
		pane_normal:			0			// normal z-index for panes
	,	content_mask:			1			// applied to overlays used to mask content INSIDE panes during resizing
	,	resizer_normal:			2			// normal z-index for resizer-bars
	,	pane_sliding:			100			// applied to *BOTH* the pane and its resizer when a pane is 'slid open'
	,	pane_animate:			1000		// applied to the pane when being animated - not applied to the resizer
	,	resizer_drag:			10000		// applied to the CLONED resizer-bar when being 'dragged'
	}
,	errors: {
		pane:					"pane"		// description of "layout pane element" - used only in error messages
	,	selector:				"selector"	// description of "jQuery-selector" - used only in error messages
	,	addButtonError:			"Error Adding Button\nInvalid "
	,	containerMissing:		"UI Layout Initialization Error\nThe specified layout-container does not exist."
	,	centerPaneMissing:		"UI Layout Initialization Error\nThe center-pane element does not exist.\nThe center-pane is a required element."
	,	noContainerHeight:		"UI Layout Initialization Warning\nThe layout-container \"CONTAINER\" has no height.\nTherefore the layout is 0-height and hence 'invisible'!"
	,	callbackError:			"UI Layout Callback Error\nThe EVENT callback is not a valid function."
	}
/*
 *	PANE DEFAULT SETTINGS
 *	- settings under the 'panes' key become the default settings for *all panes*
 *	- ALL pane-options can also be set specifically for each panes, which will override these 'default values'
 */
,	panes: { // default options for 'all panes' - will be overridden by 'per-pane settings'
		applyDemoStyles: 		false		// NOTE: renamed from applyDefaultStyles for clarity
	,	closable:				true		// pane can open & close
	,	resizable:				true		// when open, pane can be resized 
	,	slidable:				true		// when closed, pane can 'slide open' over other panes - closes on mouse-out
	,	initClosed:				false		// true = init pane as 'closed'
	,	initHidden: 			false 		// true = init pane as 'hidden' - no resizer-bar/spacing
	//	SELECTORS
	//,	paneSelector:			""			// MUST be pane-specific - jQuery selector for pane
	,	contentSelector:		".ui-layout-content" // INNER div/element to auto-size so only it scrolls, not the entire pane!
	,	contentIgnoreSelector:	".ui-layout-ignore"	// element(s) to 'ignore' when measuring 'content'
	,	findNestedContent:		false		// true = $P.find(contentSelector), false = $P.children(contentSelector)
	//	GENERIC ROOT-CLASSES - for auto-generated classNames
	,	paneClass:				"ui-layout-pane"	// Layout Pane
	,	resizerClass:			"ui-layout-resizer"	// Resizer Bar
	,	togglerClass:			"ui-layout-toggler"	// Toggler Button
	,	buttonClass:			"ui-layout-button"	// CUSTOM Buttons	- eg: '[ui-layout-button]-toggle/-open/-close/-pin'
	//	ELEMENT SIZE & SPACING
	//,	size:					100			// MUST be pane-specific -initial size of pane
	,	minSize:				0			// when manually resizing a pane
	,	maxSize:				0			// ditto, 0 = no limit
	,	spacing_open:			6			// space between pane and adjacent panes - when pane is 'open'
	,	spacing_closed:			6			// ditto - when pane is 'closed'
	,	togglerLength_open:		50			// Length = WIDTH of toggler button on north/south sides - HEIGHT on east/west sides
	,	togglerLength_closed: 	50			// 100% OR -1 means 'full height/width of resizer bar' - 0 means 'hidden'
	,	togglerAlign_open:		"center"	// top/left, bottom/right, center, OR...
	,	togglerAlign_closed:	"center"	// 1 => nn = offset from top/left, -1 => -nn == offset from bottom/right
	,	togglerContent_open:	""			// text or HTML to put INSIDE the toggler
	,	togglerContent_closed:	""			// ditto
	//	RESIZING OPTIONS
	,	resizerDblClickToggle:	true		// 
	,	autoResize:				true		// IF size is 'auto' or a percentage, then recalc 'pixel size' whenever the layout resizes
	,	autoReopen:				true		// IF a pane was auto-closed due to noRoom, reopen it when there is room? False = leave it closed
	,	resizerDragOpacity:		1			// option for ui.draggable
	//,	resizerCursor:			""			// MUST be pane-specific - cursor when over resizer-bar
	,	maskContents:			false		// true = add DIV-mask over-or-inside this pane so can 'drag' over IFRAMES
	,	maskObjects:			false		// true = add IFRAME-mask over-or-inside this pane to cover objects/applets - content-mask will overlay this mask
	,	maskZindex:				null		// will override zIndexes.content_mask if specified - not applicable to iframe-panes
	,	resizingGrid:			false		// grid size that the resizers will snap-to during resizing, eg: [20,20]
	,	livePaneResizing:		false		// true = LIVE Resizing as resizer is dragged
	,	liveContentResizing:	false		// true = re-measure header/footer heights as resizer is dragged
	,	liveResizingTolerance:	1			// how many px change before pane resizes, to control performance
	//	SLIDING OPTIONS
	,	sliderCursor:			"pointer"	// cursor when resizer-bar will trigger 'sliding'
	,	slideTrigger_open:		"click"		// click, dblclick, mouseenter
	,	slideTrigger_close:		"mouseleave"// click, mouseleave
	,	slideDelay_open:		300			// applies only for mouseenter event - 0 = instant open
	,	slideDelay_close:		300			// applies only for mouseleave event (300ms is the minimum!)
	,	hideTogglerOnSlide:		false		// when pane is slid-open, should the toggler show?
	,	preventQuickSlideClose:	$.layout.browser.webkit // Chrome triggers slideClosed as it is opening
	,	preventPrematureSlideClose: false	// handle incorrect mouseleave trigger, like when over a SELECT-list in IE
	//	PANE-SPECIFIC TIPS & MESSAGES
	,	tips: {
			Open:				"Open"		// eg: "Open Pane"
		,	Close:				"Close"
		,	Resize:				"Resize"
		,	Slide:				"Slide Open"
		,	Pin:				"Pin"
		,	Unpin:				"Un-Pin"
		,	noRoomToOpen:		"Not enough room to show this panel."	// alert if user tries to open a pane that cannot
		,	minSizeWarning:		"Panel has reached its minimum size"	// displays in browser statusbar
		,	maxSizeWarning:		"Panel has reached its maximum size"	// ditto
		}
	//	HOT-KEYS & MISC
	,	showOverflowOnHover:	false		// will bind allowOverflow() utility to pane.onMouseOver
	,	enableCursorHotkey:		true		// enabled 'cursor' hotkeys
	//,	customHotkey:			""			// MUST be pane-specific - EITHER a charCode OR a character
	,	customHotkeyModifier:	"SHIFT"		// either 'SHIFT', 'CTRL' or 'CTRL+SHIFT' - NOT 'ALT'
	//	PANE ANIMATION
	//	NOTE: fxSss_open, fxSss_close & fxSss_size options (eg: fxName_open) are auto-generated if not passed
	,	fxName:					"slide" 	// ('none' or blank), slide, drop, scale -- only relevant to 'open' & 'close', NOT 'size'
	,	fxSpeed:				null		// slow, normal, fast, 200, nnn - if passed, will OVERRIDE fxSettings.duration
	,	fxSettings:				{}			// can be passed, eg: { easing: "easeOutBounce", duration: 1500 }
	,	fxOpacityFix:			true		// tries to fix opacity in IE to restore anti-aliasing after animation
	,	animatePaneSizing:		false		// true = animate resizing after dragging resizer-bar OR sizePane() is called
	/*  NOTE: Action-specific FX options are auto-generated from the options above if not specifically set:
		fxName_open:			"slide"		// 'Open' pane animation
		fnName_close:			"slide"		// 'Close' pane animation
		fxName_size:			"slide"		// 'Size' pane animation - when animatePaneSizing = true
		fxSpeed_open:			null
		fxSpeed_close:			null
		fxSpeed_size:			null
		fxSettings_open:		{}
		fxSettings_close:		{}
		fxSettings_size:		{}
	*/
	//	CHILD/NESTED LAYOUTS
	,	children:				null		// Layout-options for nested/child layout - even {} is valid as options
	,	containerSelector:		''			// if child is NOT 'directly nested', a selector to find it/them (can have more than one child layout!)
	,	initChildren:			true		// true = child layout will be created as soon as _this_ layout completes initialization
	,	destroyChildren:		true		// true = destroy child-layout if this pane is destroyed
	,	resizeChildren:			true		// true = trigger child-layout.resizeAll() when this pane is resized
	//	EVENT TRIGGERING
	,	triggerEventsOnLoad:	false		// true = trigger onopen OR onclose callbacks when layout initializes
	,	triggerEventsDuringLiveResize: true	// true = trigger onresize callback REPEATEDLY if livePaneResizing==true
	//	PANE CALLBACKS
	,	onshow_start:			null		// CALLBACK when pane STARTS to Show	- BEFORE onopen/onhide_start
	,	onshow_end:				null		// CALLBACK when pane ENDS being Shown	- AFTER  onopen/onhide_end
	,	onhide_start:			null		// CALLBACK when pane STARTS to Close	- BEFORE onclose_start
	,	onhide_end:				null		// CALLBACK when pane ENDS being Closed	- AFTER  onclose_end
	,	onopen_start:			null		// CALLBACK when pane STARTS to Open
	,	onopen_end:				null		// CALLBACK when pane ENDS being Opened
	,	onclose_start:			null		// CALLBACK when pane STARTS to Close
	,	onclose_end:			null		// CALLBACK when pane ENDS being Closed
	,	onresize_start:			null		// CALLBACK when pane STARTS being Resized ***FOR ANY REASON***
	,	onresize_end:			null		// CALLBACK when pane ENDS being Resized ***FOR ANY REASON***
	,	onsizecontent_start:	null		// CALLBACK when sizing of content-element STARTS
	,	onsizecontent_end:		null		// CALLBACK when sizing of content-element ENDS
	,	onswap_start:			null		// CALLBACK when pane STARTS to Swap
	,	onswap_end:				null		// CALLBACK when pane ENDS being Swapped
	,	ondrag_start:			null		// CALLBACK when pane STARTS being ***MANUALLY*** Resized
	,	ondrag_end:				null		// CALLBACK when pane ENDS being ***MANUALLY*** Resized
	}
/*
 *	PANE-SPECIFIC SETTINGS
 *	- options listed below MUST be specified per-pane - they CANNOT be set under 'panes'
 *	- all options under the 'panes' key can also be set specifically for any pane
 *	- most options under the 'panes' key apply only to 'border-panes' - NOT the the center-pane
 */
,	north: {
		paneSelector:			".ui-layout-north"
	,	size:					"auto"		// eg: "auto", "30%", .30, 200
	,	resizerCursor:			"n-resize"	// custom = url(myCursor.cur)
	,	customHotkey:			""			// EITHER a charCode (43) OR a character ("o")
	}
,	south: {
		paneSelector:			".ui-layout-south"
	,	size:					"auto"
	,	resizerCursor:			"s-resize"
	,	customHotkey:			""
	}
,	east: {
		paneSelector:			".ui-layout-east"
	,	size:					200
	,	resizerCursor:			"e-resize"
	,	customHotkey:			""
	}
,	west: {
		paneSelector:			".ui-layout-west"
	,	size:					200
	,	resizerCursor:			"w-resize"
	,	customHotkey:			""
	}
,	center: {
		paneSelector:			".ui-layout-center"
	,	minWidth:				0
	,	minHeight:				0
	}
};

$.layout.optionsMap = {
	// layout/global options - NOT pane-options
	layout: ("name,instanceKey,stateManagement,effects,inset,zIndexes,errors,"
	+	"zIndex,scrollToBookmarkOnLoad,showErrorMessages,maskPanesEarly,"
	+	"outset,resizeWithWindow,resizeWithWindowDelay,resizeWithWindowMaxDelay,"
	+	"onresizeall,onresizeall_start,onresizeall_end,onload,onload_start,onload_end,onunload,onunload_start,onunload_end").split(",")
//	borderPanes: [ ALL options that are NOT specified as 'layout' ]
	// default.panes options that apply to the center-pane (most options apply _only_ to border-panes)
,	center: ("paneClass,contentSelector,contentIgnoreSelector,findNestedContent,applyDemoStyles,triggerEventsOnLoad,"
	+	"showOverflowOnHover,maskContents,maskObjects,liveContentResizing,"
	+	"containerSelector,children,initChildren,resizeChildren,destroyChildren,"
	+	"onresize,onresize_start,onresize_end,onsizecontent,onsizecontent_start,onsizecontent_end").split(",")
	// options that MUST be specifically set 'per-pane' - CANNOT set in the panes (defaults) key
,	noDefault: ("paneSelector,resizerCursor,customHotkey").split(",")
};

/**
 * Processes options passed in converts flat-format data into subkey (JSON) format
 * In flat-format, subkeys are _currently_ separated with 2 underscores, like north__optName
 * Plugins may also call this method so they can transform their own data
 *
 * @param  {!Object}	hash			Data/options passed by user - may be a single level or nested levels
 * @param  {boolean=}	[addKeys=false]	Should the primary layout.options keys be added if they do not exist?
 * @return {Object}						Returns hash of minWidth & minHeight
 */
$.layout.transformData = function (hash, addKeys) {
	var	json = addKeys ? { panes: {}, center: {} } : {} // init return object
	,	branch, optKey, keys, key, val, i, c;

	if (typeof hash !== "object") return json; // no options passed

	// convert all 'flat-keys' to 'sub-key' format
	for (optKey in hash) {
		branch	= json;
		val		= hash[ optKey ];
		keys	= optKey.split("__"); // eg: west__size or north__fxSettings__duration
		c		= keys.length - 1;
		// convert underscore-delimited to subkeys
		for (i=0; i <= c; i++) {
			key = keys[i];
			if (i === c) {	// last key = value
				if ($.isPlainObject( val ))
					branch[key] = $.layout.transformData( val ); // RECURSE
				else
					branch[key] = val;
			}
			else {
				if (!branch[key])
					branch[key] = {}; // create the subkey
				// recurse to sub-key for next loop - if not done
				branch = branch[key];
			}
		}
	}
	return json;
};

// INTERNAL CONFIG DATA - DO NOT CHANGE THIS!
$.layout.backwardCompatibility = {
	// data used by renameOldOptions()
	map: {
	//	OLD Option Name:			NEW Option Name
		applyDefaultStyles:			"applyDemoStyles"
	//	CHILD/NESTED LAYOUTS
	,	childOptions:				"children"
	,	initChildLayout:			"initChildren"
	,	destroyChildLayout:			"destroyChildren"
	,	resizeChildLayout:			"resizeChildren"
	,	resizeNestedLayout:			"resizeChildren"
	//	MISC Options
	,	resizeWhileDragging:		"livePaneResizing"
	,	resizeContentWhileDragging:	"liveContentResizing"
	,	triggerEventsWhileDragging:	"triggerEventsDuringLiveResize"
	,	maskIframesOnResize:		"maskContents"
	//	STATE MANAGEMENT
	,	useStateCookie:				"stateManagement.enabled"
	,	"cookie.autoLoad":			"stateManagement.autoLoad"
	,	"cookie.autoSave":			"stateManagement.autoSave"
	,	"cookie.keys":				"stateManagement.stateKeys"
	,	"cookie.name":				"stateManagement.cookie.name"
	,	"cookie.domain":			"stateManagement.cookie.domain"
	,	"cookie.path":				"stateManagement.cookie.path"
	,	"cookie.expires":			"stateManagement.cookie.expires"
	,	"cookie.secure":			"stateManagement.cookie.secure"
	//	OLD Language options
	,	noRoomToOpenTip:			"tips.noRoomToOpen"
	,	togglerTip_open:			"tips.Close"	// open   = Close
	,	togglerTip_closed:			"tips.Open"		// closed = Open
	,	resizerTip:					"tips.Resize"
	,	sliderTip:					"tips.Slide"
	}

/**
* @param {Object}	opts
*/
,	renameOptions: function (opts) {
		var map = $.layout.backwardCompatibility.map
		,	oldData, newData, value
		;
		for (var itemPath in map) {
			oldData	= getBranch( itemPath );
			value	= oldData.branch[ oldData.key ];
			if (value !== undefined) {
				newData = getBranch( map[itemPath], true );
				newData.branch[ newData.key ] = value;
				delete oldData.branch[ oldData.key ];
			}
		}

		/**
		* @param {string}	path
		* @param {boolean=}	[create=false]	Create path if does not exist
		*/
		function getBranch (path, create) {
			var a = path.split(".") // split keys into array
			,	c = a.length - 1
			,	D = { branch: opts, key: a[c] } // init branch at top & set key (last item)
			,	i = 0, k, undef;
			for (; i<c; i++) { // skip the last key (data)
				k = a[i];
				if (D.branch[ k ] == undefined) { // child-key does not exist
					if (create) {
						D.branch = D.branch[ k ] = {}; // create child-branch
					}
					else // can't go any farther
						D.branch = {}; // branch is undefined
				}
				else
					D.branch = D.branch[ k ]; // get child-branch
			}
			return D;
		};
	}

/**
* @param {Object}	opts
*/
,	renameAllOptions: function (opts) {
		var ren = $.layout.backwardCompatibility.renameOptions;
		// rename root (layout) options
		ren( opts );
		// rename 'defaults' to 'panes'
		if (opts.defaults) {
			if (typeof opts.panes !== "object")
				opts.panes = {};
			$.extend(true, opts.panes, opts.defaults);
			delete opts.defaults;
		}
		// rename options in the the options.panes key
		if (opts.panes) ren( opts.panes );
		// rename options inside *each pane key*, eg: options.west
		$.each($.layout.config.allPanes, function (i, pane) {
			if (opts[pane]) ren( opts[pane] );
		});	
		return opts;
	}
};




/*	============================================================
 *	BEGIN WIDGET: $( selector ).layout( {options} );
 *	============================================================
 */
$.fn.layout = function (opts) {
	var

	// local aliases to global data
	browser	= $.layout.browser
,	_c		= $.layout.config

	// local aliases to utlity methods
,	cssW	= $.layout.cssWidth
,	cssH	= $.layout.cssHeight
,	elDims	= $.layout.getElementDimensions
,	styles	= $.layout.getElementStyles
,	evtObj	= $.layout.getEventObject
,	evtPane	= $.layout.parsePaneName

/**
 * options - populated by initOptions()
 */
,	options = $.extend(true, {}, $.layout.defaults)
,	effects	= options.effects = $.extend(true, {}, $.layout.effects)

/**
 * layout-state object
 */
,	state = {
		// generate unique ID to use for event.namespace so can unbind only events added by 'this layout'
		id:				"layout"+ $.now()	// code uses alias: sID
	,	initialized:	false
	,	paneResizing:	false
	,	panesSliding:	{}
	,	container:	{ 	// list all keys referenced in code to avoid compiler error msgs
			innerWidth:		0
		,	innerHeight:	0
		,	outerWidth:		0
		,	outerHeight:	0
		,	layoutWidth:	0
		,	layoutHeight:	0
		}
	,	north:		{ childIdx: 0 }
	,	south:		{ childIdx: 0 }
	,	east:		{ childIdx: 0 }
	,	west:		{ childIdx: 0 }
	,	center:		{ childIdx: 0 }
	}

/**
 * parent/child-layout pointers
 */
//,	hasParentLayout	= false	- exists ONLY inside Instance so can be set externally
,	children = {
		north:		null
	,	south:		null
	,	east:		null
	,	west:		null
	,	center:		null
	}

/*
 * ###########################
 *  INTERNAL HELPER FUNCTIONS
 * ###########################
 */

	/**
	* Manages all internal timers
	*/
,	timer = {
		data:	{}
	,	set:	function (s, fn, ms) { timer.clear(s); timer.data[s] = setTimeout(fn, ms); }
	,	clear:	function (s) { var t=timer.data; if (t[s]) {clearTimeout(t[s]); delete t[s];} }
	}

	/**
	* Alert or console.log a message - IF option is enabled.
	*
	* @param {(string|!Object)}	msg				Message (or debug-data) to display
	* @param {boolean=}			[popup=false]	True by default, means 'alert', false means use console.log
	* @param {boolean=}			[debug=false]	True means is a widget debugging message
	*/
,	_log = function (msg, popup, debug) {
		var o = options;
		if ((o.showErrorMessages && !debug) || (debug && o.showDebugMessages))
			$.layout.msg( o.name +' / '+ msg, (popup !== false) );
		return false;
	}

	/**
	* Executes a Callback function after a trigger event, like resize, open or close
	*
	* @param {string}				evtName					Name of the layout callback, eg "onresize_start"
	* @param {(string|boolean)=}	[pane=""]				This is passed only so we can pass the 'pane object' to the callback
	* @param {(string|boolean)=}	[skipBoundEvents=false]	True = do not run events bound to the elements - only the callbacks set in options
	*/
,	_runCallbacks = function (evtName, pane, skipBoundEvents) {
		var	hasPane	= pane && isStr(pane)
		,	s		= hasPane ? state[pane] : state
		,	o		= hasPane ? options[pane] : options
		,	lName	= options.name
			// names like onopen and onopen_end separate are interchangeable in options...
		,	lng		= evtName + (evtName.match(/_/) ? "" : "_end")
		,	shrt	= lng.match(/_end$/) ? lng.substr(0, lng.length - 4) : ""
		,	fn		= o[lng] || o[shrt]
		,	retVal	= "NC" // NC = No Callback
		,	args	= []
		,	$P
		;
		if ( !hasPane && $.type(pane) === 'boolean' ) {
			skipBoundEvents = pane; // allow pane param to be skipped for Layout callback
			pane = "";
		}

		// first trigger the callback set in the options
		if (fn) {
			try {
				// convert function name (string) to function object
				if (isStr( fn )) {
					if (fn.match(/,/)) {
						// function name cannot contain a comma, 
						// so must be a function name AND a parameter to pass
						args = fn.split(",")
						,	fn = eval(args[0]);
					}
					else // just the name of an external function?
						fn = eval(fn);
				}
				// execute the callback, if exists
				if ($.isFunction( fn )) {
					if (args.length)
						retVal = g(fn)(args[1]); // pass the argument parsed from 'list'
					else if ( hasPane )
						// pass data: pane-name, pane-element, pane-state, pane-options, and layout-name
						retVal = g(fn)( pane, $Ps[pane], s, o, lName );
					else // must be a layout/container callback - pass suitable info
						retVal = g(fn)( Instance, s, o, lName );
				}
			}
			catch (ex) {
				_log( options.errors.callbackError.replace(/EVENT/, $.trim((pane || "") +" "+ lng)), false );
				if ($.type(ex) === 'string' && string.length)
					_log('Exception:  '+ ex, false );
			}
		}

		// trigger additional events bound directly to the pane
		if (!skipBoundEvents && retVal !== false) {
			if ( hasPane ) { // PANE events can be bound to each pane-elements
				$P	= $Ps[pane];
				o	= options[pane];
				s	= state[pane];
				$P.triggerHandler('layoutpane'+ lng, [ pane, $P, s, o, lName ]);
				if (shrt)
					$P.triggerHandler('layoutpane'+ shrt, [ pane, $P, s, o, lName ]);
			}
			else { // LAYOUT events can be bound to the container-element
				$N.triggerHandler('layout'+ lng, [ Instance, s, o, lName ]);
				if (shrt)
					$N.triggerHandler('layout'+ shrt, [ Instance, s, o, lName ]);
			}
		}

		// ALWAYS resizeChildren after an onresize_end event - even during initialization
		// IGNORE onsizecontent_end event because causes child-layouts to resize TWICE
		if (hasPane && evtName === "onresize_end") // BAD: || evtName === "onsizecontent_end"
			resizeChildren(pane+"", true); // compiler hack -force string

		return retVal;

		function g (f) { return f; }; // compiler hack
	}


	/**
	* cure iframe display issues in IE & other browsers
	*/
,	_fixIframe = function (pane) {
		if (browser.mozilla) return; // skip FireFox - it auto-refreshes iframes onShow
		var $P = $Ps[pane];
		// if the 'pane' is an iframe, do it
		if (state[pane].tagName === "IFRAME")
			$P.css(_c.hidden).css(_c.visible); 
		else // ditto for any iframes INSIDE the pane
			$P.find('IFRAME').css(_c.hidden).css(_c.visible);
	}

	/**
	* @param  {string}		pane		Can accept ONLY a 'pane' (east, west, etc)
	* @param  {number=}		outerSize	(optional) Can pass a width, allowing calculations BEFORE element is resized
	* @return {number}		Returns the innerHeight/Width of el by subtracting padding and borders
	*/
,	cssSize = function (pane, outerSize) {
		var fn = _c[pane].dir=="horz" ? cssH : cssW;
		return fn($Ps[pane], outerSize);
	}

	/**
	* @param  {string}		pane		Can accept ONLY a 'pane' (east, west, etc)
	* @return {Object}		Returns hash of minWidth & minHeight
	*/
,	cssMinDims = function (pane) {
		// minWidth/Height means CSS width/height = 1px
		var	$P	= $Ps[pane]
		,	dir	= _c[pane].dir
		,	d	= {
				minWidth:	1001 - cssW($P, 1000)
			,	minHeight:	1001 - cssH($P, 1000)
			}
		;
		if (dir === "horz") d.minSize = d.minHeight;
		if (dir === "vert") d.minSize = d.minWidth;
		return d;
	}

	// TODO: see if these methods can be made more useful...
	// TODO: *maybe* return cssW/H from these so caller can use this info

	/**
	* @param {(string|!Object)}		el
	* @param {number=}				outerWidth
	* @param {boolean=}				[autoHide=false]
	*/
,	setOuterWidth = function (el, outerWidth, autoHide) {
		var $E = el, w;
		if (isStr(el)) $E = $Ps[el]; // west
		else if (!el.jquery) $E = $(el);
		w = cssW($E, outerWidth);
		$E.css({ width: w });
		if (w > 0) {
			if (autoHide && $E.data('autoHidden') && $E.innerHeight() > 0) {
				$E.show().data('autoHidden', false);
				if (!browser.mozilla) // FireFox refreshes iframes - IE does not
					// make hidden, then visible to 'refresh' display after animation
					$E.css(_c.hidden).css(_c.visible);
			}
		}
		else if (autoHide && !$E.data('autoHidden'))
			$E.hide().data('autoHidden', true);
	}

	/**
	* @param {(string|!Object)}		el
	* @param {number=}				outerHeight
	* @param {boolean=}				[autoHide=false]
	*/
,	setOuterHeight = function (el, outerHeight, autoHide) {
		var $E = el, h;
		if (isStr(el)) $E = $Ps[el]; // west
		else if (!el.jquery) $E = $(el);
		h = cssH($E, outerHeight);
		$E.css({ height: h, visibility: "visible" }); // may have been 'hidden' by sizeContent
		if (h > 0 && $E.innerWidth() > 0) {
			if (autoHide && $E.data('autoHidden')) {
				$E.show().data('autoHidden', false);
				if (!browser.mozilla) // FireFox refreshes iframes - IE does not
					$E.css(_c.hidden).css(_c.visible);
			}
		}
		else if (autoHide && !$E.data('autoHidden'))
			$E.hide().data('autoHidden', true);
	}


	/**
	* Converts any 'size' params to a pixel/integer size, if not already
	* If 'auto' or a decimal/percentage is passed as 'size', a pixel-size is calculated
	*
	/**
	* @param  {string}				pane
	* @param  {(string|number)=}	size
	* @param  {string=}				[dir]
	* @return {number}
	*/
,	_parseSize = function (pane, size, dir) {
		if (!dir) dir = _c[pane].dir;

		if (isStr(size) && size.match(/%/))
			size = (size === '100%') ? -1 : parseInt(size, 10) / 100; // convert % to decimal

		if (size === 0)
			return 0;
		else if (size >= 1)
			return parseInt(size, 10);

		var o = options, avail = 0;
		if (dir=="horz") // north or south or center.minHeight
			avail = sC.innerHeight - ($Ps.north ? o.north.spacing_open : 0) - ($Ps.south ? o.south.spacing_open : 0);
		else if (dir=="vert") // east or west or center.minWidth
			avail = sC.innerWidth - ($Ps.west ? o.west.spacing_open : 0) - ($Ps.east ? o.east.spacing_open : 0);

		if (size === -1) // -1 == 100%
			return avail;
		else if (size > 0) // percentage, eg: .25
			return round(avail * size);
		else if (pane=="center")
			return 0;
		else { // size < 0 || size=='auto' || size==Missing || size==Invalid
			// auto-size the pane
			var	dim	= (dir === "horz" ? "height" : "width")
			,	$P	= $Ps[pane]
			,	$C	= dim === 'height' ? $Cs[pane] : false
			,	vis	= $.layout.showInvisibly($P) // show pane invisibly if hidden
			,	szP	= $P.css(dim) // SAVE current pane size
			,	szC	= $C ? $C.css(dim) : 0 // SAVE current content size
			;
			$P.css(dim, "auto");
			if ($C) $C.css(dim, "auto");
			size = (dim === "height") ? $P.outerHeight() : $P.outerWidth(); // MEASURE
			$P.css(dim, szP).css(vis); // RESET size & visibility
			if ($C) $C.css(dim, szC);
			return size;
		}
	}

	/**
	* Calculates current 'size' (outer-width or outer-height) of a border-pane - optionally with 'pane-spacing' added
	*
	* @param  {(string|!Object)}	pane
	* @param  {boolean=}			[inclSpace=false]
	* @return {number}				Returns EITHER Width for east/west panes OR Height for north/south panes
	*/
,	getPaneSize = function (pane, inclSpace) {
		var 
			$P	= $Ps[pane]
		,	o	= options[pane]
		,	s	= state[pane]
		,	oSp	= (inclSpace ? o.spacing_open : 0)
		,	cSp	= (inclSpace ? o.spacing_closed : 0)
		;
		if (!$P || s.isHidden)
			return 0;
		else if (s.isClosed || (s.isSliding && inclSpace))
			return cSp;
		else if (_c[pane].dir === "horz")
			return $P.outerHeight() + oSp;
		else // dir === "vert"
			return $P.outerWidth() + oSp;
	}

	/**
	* Calculate min/max pane dimensions and limits for resizing
	*
	* @param  {string}		pane
	* @param  {boolean=}	[slide=false]
	*/
,	setSizeLimits = function (pane, slide) {
		if (!isInitialized()) return;
		var 
			o				= options[pane]
		,	s				= state[pane]
		,	c				= _c[pane]
		,	dir				= c.dir
		,	type			= c.sizeType.toLowerCase()
		,	isSliding		= (slide != undefined ? slide : s.isSliding) // only open() passes 'slide' param
		,	$P				= $Ps[pane]
		,	paneSpacing		= o.spacing_open
		//	measure the pane on the *opposite side* from this pane
		,	altPane			= _c.oppositeEdge[pane]
		,	altS			= state[altPane]
		,	$altP			= $Ps[altPane]
		,	altPaneSize		= (!$altP || altS.isVisible===false || altS.isSliding ? 0 : (dir=="horz" ? $altP.outerHeight() : $altP.outerWidth()))
		,	altPaneSpacing	= ((!$altP || altS.isHidden ? 0 : options[altPane][ altS.isClosed !== false ? "spacing_closed" : "spacing_open" ]) || 0)
		//	limitSize prevents this pane from 'overlapping' opposite pane
		,	containerSize	= (dir=="horz" ? sC.innerHeight : sC.innerWidth)
		,	minCenterDims	= cssMinDims("center")
		,	minCenterSize	= dir=="horz" ? max(options.center.minHeight, minCenterDims.minHeight) : max(options.center.minWidth, minCenterDims.minWidth)
		//	if pane is 'sliding', then ignore center and alt-pane sizes - because 'overlays' them
		,	limitSize		= (containerSize - paneSpacing - (isSliding ? 0 : (_parseSize("center", minCenterSize, dir) + altPaneSize + altPaneSpacing)))
		,	minSize			= s.minSize = max( _parseSize(pane, o.minSize), cssMinDims(pane).minSize )
		,	maxSize			= s.maxSize = min( (o.maxSize ? _parseSize(pane, o.maxSize) : 100000), limitSize )
		,	r				= s.resizerPosition = {} // used to set resizing limits
		,	top				= sC.inset.top
		,	left			= sC.inset.left
		,	W				= sC.innerWidth
		,	H				= sC.innerHeight
		,	rW				= o.spacing_open // subtract resizer-width to get top/left position for south/east
		;
		switch (pane) {
			case "north":	r.min = top + minSize;
							r.max = top + maxSize;
							break;
			case "west":	r.min = left + minSize;
							r.max = left + maxSize;
							break;
			case "south":	r.min = top + H - maxSize - rW;
							r.max = top + H - minSize - rW;
							break;
			case "east":	r.min = left + W - maxSize - rW;
							r.max = left + W - minSize - rW;
							break;
		};
	}

	/**
	* Returns data for setting the size/position of center pane. Also used to set Height for east/west panes
	*
	* @return JSON  Returns a hash of all dimensions: top, bottom, left, right, (outer) width and (outer) height
	*/
,	calcNewCenterPaneDims = function () {
		var d = {
			top:	getPaneSize("north", true) // true = include 'spacing' value for pane
		,	bottom:	getPaneSize("south", true)
		,	left:	getPaneSize("west", true)
		,	right:	getPaneSize("east", true)
		,	width:	0
		,	height:	0
		};

		// NOTE: sC = state.container
		// calc center-pane outer dimensions
		d.width		= sC.innerWidth - d.left - d.right;  // outerWidth
		d.height	= sC.innerHeight - d.bottom - d.top; // outerHeight
		// add the 'container border/padding' to get final positions relative to the container
		d.top		+= sC.inset.top;
		d.bottom	+= sC.inset.bottom;
		d.left		+= sC.inset.left;
		d.right		+= sC.inset.right;

		return d;
	}


	/**
	* @param {!Object}		el
	* @param {boolean=}		[allStates=false]
	*/
,	getHoverClasses = function (el, allStates) {
		var
			$El		= $(el)
		,	type	= $El.data("layoutRole")
		,	pane	= $El.data("layoutEdge")
		,	o		= options[pane]
		,	root	= o[type +"Class"]
		,	_pane	= "-"+ pane // eg: "-west"
		,	_open	= "-open"
		,	_closed	= "-closed"
		,	_slide	= "-sliding"
		,	_hover	= "-hover " // NOTE the trailing space
		,	_state	= $El.hasClass(root+_closed) ? _closed : _open
		,	_alt	= _state === _closed ? _open : _closed
		,	classes = (root+_hover) + (root+_pane+_hover) + (root+_state+_hover) + (root+_pane+_state+_hover)
		;
		if (allStates) // when 'removing' classes, also remove alternate-state classes
			classes += (root+_alt+_hover) + (root+_pane+_alt+_hover);

		if (type=="resizer" && $El.hasClass(root+_slide))
			classes += (root+_slide+_hover) + (root+_pane+_slide+_hover);

		return $.trim(classes);
	}
,	addHover	= function (evt, el) {
		var $E = $(el || this);
		if (evt && $E.data("layoutRole") === "toggler")
			evt.stopPropagation(); // prevent triggering 'slide' on Resizer-bar
		$E.addClass( getHoverClasses($E) );
	}
,	removeHover	= function (evt, el) {
		var $E = $(el || this);
		$E.removeClass( getHoverClasses($E, true) );
	}

,	onResizerEnter	= function (evt) { // ALSO called by toggler.mouseenter
		var pane	= $(this).data("layoutEdge")
		,	s		= state[pane]
		;
		// ignore closed-panes and mouse moving back & forth over resizer!
		// also ignore if ANY pane is currently resizing
		if ( s.isClosed || s.isResizing || state.paneResizing ) return;

		if ($.fn.disableSelection)
			$("body").disableSelection();
		if (options.maskPanesEarly)
			showMasks( pane, { resizing: true });
	}
,	onResizerLeave	= function (evt, el) {
		var	e		= el || this // el is only passed when called by the timer
		,	pane	= $(e).data("layoutEdge")
		,	name	= pane +"ResizerLeave"
		;
		timer.clear(pane+"_openSlider"); // cancel slideOpen timer, if set
		timer.clear(name); // cancel enableSelection timer - may re/set below
		// this method calls itself on a timer because it needs to allow
		// enough time for dragging to kick-in and set the isResizing flag
		// dragging has a 100ms delay set, so this delay must be >100
		if (!el) // 1st call - mouseleave event
			timer.set(name, function(){ onResizerLeave(evt, e); }, 200);
		// if user is resizing, then dragStop will enableSelection(), so can skip it here
		else if ( !state.paneResizing ) { // 2nd call - by timer
			if ($.fn.enableSelection)
				$("body").enableSelection();
			if (options.maskPanesEarly)
				hideMasks();
		}
	}

/*
 * ###########################
 *   INITIALIZATION METHODS
 * ###########################
 */

	/**
	* Initialize the layout - called automatically whenever an instance of layout is created
	*
	* @see  none - triggered onInit
	* @return  mixed	true = fully initialized | false = panes not initialized (yet) | 'cancel' = abort
	*/
,	_create = function () {
		// initialize config/options
		initOptions();
		var o = options
		,	s = state;

		// TEMP state so isInitialized returns true during init process
		s.creatingLayout = true;

		// init plugins for this layout, if there are any (eg: stateManagement)
		runPluginCallbacks( Instance, $.layout.onCreate );

		// options & state have been initialized, so now run beforeLoad callback
		// onload will CANCEL layout creation if it returns false
		if (false === _runCallbacks("onload_start"))
			return 'cancel';

		// initialize the container element
		_initContainer();

		// bind hotkey function - keyDown - if required
		initHotkeys();

		// bind window.onunload
		$(window).bind("unload."+ sID, unload);

		// init plugins for this layout, if there are any (eg: customButtons)
		runPluginCallbacks( Instance, $.layout.onLoad );

		// if layout elements are hidden, then layout WILL NOT complete initialization!
		// initLayoutElements will set initialized=true and run the onload callback IF successful
		if (o.initPanes) _initLayoutElements();

		delete s.creatingLayout;

		return state.initialized;
	}

	/**
	* Initialize the layout IF not already
	*
	* @see  All methods in Instance run this test
	* @return  boolean	true = layoutElements have been initialized | false = panes are not initialized (yet)
	*/
,	isInitialized = function () {
		if (state.initialized || state.creatingLayout) return true;	// already initialized
		else return _initLayoutElements();	// try to init panes NOW
	}

	/**
	* Initialize the layout - called automatically whenever an instance of layout is created
	*
	* @see  _create() & isInitialized
	* @param {boolean=}		[retry=false]	// indicates this is a 2nd try
	* @return  An object pointer to the instance created
	*/
,	_initLayoutElements = function (retry) {
		// initialize config/options
		var o = options;
		// CANNOT init panes inside a hidden container!
		if (!$N.is(":visible")) {
			// handle Chrome bug where popup window 'has no height'
			// if layout is BODY element, try again in 50ms
			// SEE: http://layout.jquery-dev.net/samples/test_popup_window.html
			if ( !retry && browser.webkit && $N[0].tagName === "BODY" )
				setTimeout(function(){ _initLayoutElements(true); }, 50);
			return false;
		}

		// a center pane is required, so make sure it exists
		if (!getPane("center").length) {
			return _log( o.errors.centerPaneMissing );
		}

		// TEMP state so isInitialized returns true during init process
		state.creatingLayout = true;

		// update Container dims
		$.extend(sC, elDims( $N, o.inset )); // passing inset means DO NOT include insetX values

		// initialize all layout elements
		initPanes();	// size & position panes - calls initHandles() - which calls initResizable()

		if (o.scrollToBookmarkOnLoad) {
			var l = self.location;
			if (l.hash) l.replace( l.hash ); // scrollTo Bookmark
		}

		// check to see if this layout 'nested' inside a pane
		if (Instance.hasParentLayout)
			o.resizeWithWindow = false;
		// bind resizeAll() for 'this layout instance' to window.resize event
		else if (o.resizeWithWindow)
			$(window).bind("resize."+ sID, windowResize);

		delete state.creatingLayout;
		state.initialized = true;

		// init plugins for this layout, if there are any
		runPluginCallbacks( Instance, $.layout.onReady );

		// now run the onload callback, if exists
		_runCallbacks("onload_end");

		return true; // elements initialized successfully
	}

	/**
	* Initialize nested layouts for a specific pane - can optionally pass layout-options
	*
	* @param {(string|Object)}	evt_or_pane	The pane being opened, ie: north, south, east, or west
	* @param {Object=}			[opts]		Layout-options - if passed, will OVERRRIDE options[pane].children
	* @return  An object pointer to the layout instance created - or null
	*/
,	createChildren = function (evt_or_pane, opts) {
		var	pane = evtPane.call(this, evt_or_pane)
		,	$P	= $Ps[pane]
		;
		if (!$P) return;
		var	$C	= $Cs[pane]
		,	s	= state[pane]
		,	o	= options[pane]
		,	sm	= options.stateManagement || {}
		,	cos = opts ? (o.children = opts) : o.children
		;
		if ( $.isPlainObject( cos ) )
			cos = [ cos ]; // convert a hash to a 1-elem array
		else if (!cos || !$.isArray( cos ))
			return;

		$.each( cos, function (idx, co) {
			if ( !$.isPlainObject( co ) ) return;

			// determine which element is supposed to be the 'child container'
			// if pane has a 'containerSelector' OR a 'content-div', use those instead of the pane
			var $containers = co.containerSelector ? $P.find( co.containerSelector ) : ($C || $P);

			$containers.each(function(){
				var $cont	= $(this)
				,	child	= $cont.data("layout") //	see if a child-layout ALREADY exists on this element
				;
				// if no layout exists, but children are set, try to create the layout now
				if (!child) {
					// TODO: see about moving this to the stateManagement plugin, as a method
					// set a unique child-instance key for this layout, if not already set
					setInstanceKey({ container: $cont, options: co }, s );
					// If THIS layout has a hash in stateManagement.autoLoad,
					// then see if it also contains state-data for this child-layout
					// If so, copy the stateData to child.options.stateManagement.autoLoad
					if ( sm.includeChildren && state.stateData[pane] ) {
						//	THIS layout's state was cached when its state was loaded
						var	paneChildren = state.stateData[pane].children || {}
						,	childState	= paneChildren[ co.instanceKey ]
						,	co_sm		= co.stateManagement || (co.stateManagement = { autoLoad: true })
						;
						// COPY the stateData into the autoLoad key
						if ( co_sm.autoLoad === true && childState ) {
							co_sm.autoSave			= false; // disable autoSave because saving handled by parent-layout
							co_sm.includeChildren	= true;  // cascade option - FOR NOW
							co_sm.autoLoad = $.extend(true, {}, childState); // COPY the state-hash
						}
					}

					// create the layout
					child = $cont.layout( co );

					// if successful, update data
					if (child) {
						// add the child and update all layout-pointers
						// MAY have already been done by child-layout calling parent.refreshChildren()
						refreshChildren( pane, child );
					}
				}
			});
		});
	}

,	setInstanceKey = function (child, parentPaneState) {
		// create a named key for use in state and instance branches
		var	$c	= child.container
		,	o	= child.options
		,	sm	= o.stateManagement
		,	key	= o.instanceKey || $c.data("layoutInstanceKey")
		;
		if (!key) key = (sm && sm.cookie ? sm.cookie.name : '') || o.name; // look for a name/key
		if (!key) key = "layout"+ (++parentPaneState.childIdx);	// if no name/key found, generate one
		else key = key.replace(/[^\w-]/gi, '_').replace(/_{2,}/g, '_');	 // ensure is valid as a hash key
		o.instanceKey = key;
		$c.data("layoutInstanceKey", key); // useful if layout is destroyed and then recreated
		return key;
	}

	/**
	* @param {string}		pane		The pane being opened, ie: north, south, east, or west
	* @param {Object=}		newChild	New child-layout Instance to add to this pane
	*/
,	refreshChildren = function (pane, newChild) {
		var	$P	= $Ps[pane]
		,	pC	= children[pane]
		,	s	= state[pane]
		,	o
		;
		// check for destroy()ed layouts and update the child pointers & arrays
		if ($.isPlainObject( pC )) {
			$.each( pC, function (key, child) {
				if (child.destroyed) delete pC[key]
			});
			// if no more children, remove the children hash
			if ($.isEmptyObject( pC ))
				pC = children[pane] = null; // clear children hash
		}

		// see if there is a directly-nested layout inside this pane
		// if there is, then there can be only ONE child-layout, so check that...
		if (!newChild && !pC) {
			newChild = $P.data("layout");
		}

		// if a newChild instance was passed, add it to children[pane]
		if (newChild) {
			// update child.state
			newChild.hasParentLayout = true; // set parent-flag in child
			// instanceKey is a key-name used in both state and children
			o = newChild.options;
			// set a unique child-instance key for this layout, if not already set
			setInstanceKey( newChild, s );
			// add pointer to pane.children hash
			if (!pC) pC = children[pane] = {}; // create an empty children hash
			pC[ o.instanceKey ] = newChild.container.data("layout"); // add childLayout instance
		}

		// ALWAYS refresh the pane.children alias, even if null
		Instance[pane].children = children[pane];

		// if newChild was NOT passed - see if there is a child layout NOW
		if (!newChild) {
			createChildren(pane); // MAY create a child and re-call this method
		}
	}

,	windowResize = function () {
		var	o = options
		,	delay = Number(o.resizeWithWindowDelay);
		if (delay < 10) delay = 100; // MUST have a delay!
		// resizing uses a delay-loop because the resize event fires repeatly - except in FF, but delay anyway
		timer.clear("winResize"); // if already running
		timer.set("winResize", function(){
			timer.clear("winResize");
			timer.clear("winResizeRepeater");
			var dims = elDims( $N, o.inset );
			// only trigger resizeAll() if container has changed size
			if (dims.innerWidth !== sC.innerWidth || dims.innerHeight !== sC.innerHeight)
				resizeAll();
		}, delay);
		// ALSO set fixed-delay timer, if not already running
		if (!timer.data["winResizeRepeater"]) setWindowResizeRepeater();
	}

,	setWindowResizeRepeater = function () {
		var delay = Number(options.resizeWithWindowMaxDelay);
		if (delay > 0)
			timer.set("winResizeRepeater", function(){ setWindowResizeRepeater(); resizeAll(); }, delay);
	}

,	unload = function () {
		var o = options;

		_runCallbacks("onunload_start");

		// trigger plugin callabacks for this layout (eg: stateManagement)
		runPluginCallbacks( Instance, $.layout.onUnload );

		_runCallbacks("onunload_end");
	}

	/**
	* Validate and initialize container CSS and events
	*
	* @see  _create()
	*/
,	_initContainer = function () {
		var
			N		= $N[0]	
		,	$H		= $("html")
		,	tag		= sC.tagName = N.tagName
		,	id		= sC.id = N.id
		,	cls		= sC.className = N.className
		,	o		= options
		,	name	= o.name
		,	props	= "position,margin,padding,border"
		,	css		= "layoutCSS"
		,	CSS		= {}
		,	hid		= "hidden" // used A LOT!
		//	see if this container is a 'pane' inside an outer-layout
		,	parent	= $N.data("parentLayout")	// parent-layout Instance
		,	pane	= $N.data("layoutEdge")		// pane-name in parent-layout
		,	isChild	= parent && pane
		,	num		= $.layout.cssNum
		,	$parent, n
		;
		// sC = state.container
		sC.selector = $N.selector.split(".slice")[0];
		sC.ref		= (o.name ? o.name +' layout / ' : '') + tag + (id ? "#"+id : cls ? '.['+cls+']' : ''); // used in messages
		sC.isBody	= (tag === "BODY");

		// try to find a parent-layout
		if (!isChild && !sC.isBody) {
			$parent = $N.closest("."+ $.layout.defaults.panes.paneClass);
			parent	= $parent.data("parentLayout");
			pane	= $parent.data("layoutEdge");
			isChild	= parent && pane;
		}

		$N	.data({
				layout: Instance
			,	layoutContainer: sID // FLAG to indicate this is a layout-container - contains unique internal ID
			})
			.addClass(o.containerClass)
		;
		var layoutMethods = {
			destroy:	''
		,	initPanes:	''
		,	resizeAll:	'resizeAll'
		,	resize:		'resizeAll'
		};
		// loop hash and bind all methods - include layoutID namespacing
		for (name in layoutMethods) {
			$N.bind("layout"+ name.toLowerCase() +"."+ sID, Instance[ layoutMethods[name] || name ]);
		}

		// if this container is another layout's 'pane', then set child/parent pointers
		if (isChild) {
			// update parent flag
			Instance.hasParentLayout = true;
			// set pointers to THIS child-layout (Instance) in parent-layout
			parent.refreshChildren( pane, Instance );
		}

		// SAVE original container CSS for use in destroy()
		if (!$N.data(css)) {
			// handle props like overflow different for BODY & HTML - has 'system default' values
			if (sC.isBody) {
				// SAVE <BODY> CSS
				$N.data(css, $.extend( styles($N, props), {
					height:		$N.css("height")
				,	overflow:	$N.css("overflow")
				,	overflowX:	$N.css("overflowX")
				,	overflowY:	$N.css("overflowY")
				}));
				// ALSO SAVE <HTML> CSS
				$H.data(css, $.extend( styles($H, 'padding'), {
					height:		"auto" // FF would return a fixed px-size!
				,	overflow:	$H.css("overflow")
				,	overflowX:	$H.css("overflowX")
				,	overflowY:	$H.css("overflowY")
				}));
			}
			else // handle props normally for non-body elements
				$N.data(css, styles($N, props+",top,bottom,left,right,width,height,overflow,overflowX,overflowY") );
		}

		try {
			// common container CSS
			CSS = {
				overflow:	hid
			,	overflowX:	hid
			,	overflowY:	hid
			};
			$N.css( CSS );

			if (o.inset && !$.isPlainObject(o.inset)) {
				// can specify a single number for equal outset all-around
				n = parseInt(o.inset, 10) || 0
				o.inset = {
					top:	n
				,	bottom:	n
				,	left:	n
				,	right:	n
				};
			}

			// format html & body if this is a full page layout
			if (sC.isBody) {
				// if HTML has padding, use this as an outer-spacing around BODY
				if (!o.outset) {
					// use padding from parent-elem (HTML) as outset
					o.outset = {
						top:	num($H, "paddingTop")
					,	bottom:	num($H, "paddingBottom")
					,	left:	num($H, "paddingLeft")
					,	right:	num($H, "paddingRight")
					};
				}
				else if (!$.isPlainObject(o.outset)) {
					// can specify a single number for equal outset all-around
					n = parseInt(o.outset, 10) || 0
					o.outset = {
						top:	n
					,	bottom:	n
					,	left:	n
					,	right:	n
					};
				}
				// HTML
				$H.css( CSS ).css({
					height:		"100%"
				,	border:		"none"	// no border or padding allowed when using height = 100%
				,	padding:	0		// ditto
				,	margin:		0
				});
				// BODY
				if (browser.isIE6) {
					// IE6 CANNOT use the trick of setting absolute positioning on all 4 sides - must have 'height'
					$N.css({
						width:		"100%"
					,	height:		"100%"
					,	border:		"none"	// no border or padding allowed when using height = 100%
					,	padding:	0		// ditto
					,	margin:		0
					,	position:	"relative"
					});
					// convert body padding to an inset option - the border cannot be measured in IE6!
					if (!o.inset) o.inset = elDims( $N ).inset;
				}
				else { // use absolute positioning for BODY to allow borders & padding without overflow
					$N.css({
						width:		"auto"
					,	height:		"auto"
					,	margin:		0
					,	position:	"absolute"	// allows for border and padding on BODY
					});
					// apply edge-positioning created above
					$N.css( o.outset );
				}
				// set current layout-container dimensions
				$.extend(sC, elDims( $N, o.inset )); // passing inset means DO NOT include insetX values
			}
			else {
				// container MUST have 'position'
				var	p = $N.css("position");
				if (!p || !p.match(/(fixed|absolute|relative)/))
					$N.css("position","relative");

				// set current layout-container dimensions
				if ( $N.is(":visible") ) {
					$.extend(sC, elDims( $N, o.inset )); // passing inset means DO NOT change insetX (padding) values
					if (sC.innerHeight < 1) // container has no 'height' - warn developer
						_log( o.errors.noContainerHeight.replace(/CONTAINER/, sC.ref) );
				}
			}

			// if container has min-width/height, then enable scrollbar(s)
			if ( num($N, "minWidth")  ) $N.parent().css("overflowX","auto");
			if ( num($N, "minHeight") ) $N.parent().css("overflowY","auto");

		} catch (ex) {}
	}

	/**
	* Bind layout hotkeys - if options enabled
	*
	* @see  _create() and addPane()
	* @param {string=}	[panes=""]	The edge(s) to process
	*/
,	initHotkeys = function (panes) {
		panes = panes ? panes.split(",") : _c.borderPanes;
		// bind keyDown to capture hotkeys, if option enabled for ANY pane
		$.each(panes, function (i, pane) {
			var o = options[pane];
			if (o.enableCursorHotkey || o.customHotkey) {
				$(document).bind("keydown."+ sID, keyDown); // only need to bind this ONCE
				return false; // BREAK - binding was done
			}
		});
	}

	/**
	* Build final OPTIONS data
	*
	* @see  _create()
	*/
,	initOptions = function () {
		var data, d, pane, key, val, i, c, o;

		// reprocess user's layout-options to have correct options sub-key structure
		opts = $.layout.transformData( opts, true ); // panes = default subkey

		// auto-rename old options for backward compatibility
		opts = $.layout.backwardCompatibility.renameAllOptions( opts );

		// if user-options has 'panes' key (pane-defaults), clean it...
		if (!$.isEmptyObject(opts.panes)) {
			// REMOVE any pane-defaults that MUST be set per-pane
			data = $.layout.optionsMap.noDefault;
			for (i=0, c=data.length; i<c; i++) {
				key = data[i];
				delete opts.panes[key]; // OK if does not exist
			}
			// REMOVE any layout-options specified under opts.panes
			data = $.layout.optionsMap.layout;
			for (i=0, c=data.length; i<c; i++) {
				key = data[i];
				delete opts.panes[key]; // OK if does not exist
			}
		}

		// MOVE any NON-layout-options from opts-root to opts.panes
		data = $.layout.optionsMap.layout;
		var rootKeys = $.layout.config.optionRootKeys;
		for (key in opts) {
			val = opts[key];
			if ($.inArray(key, rootKeys) < 0 && $.inArray(key, data) < 0) {
				if (!opts.panes[key])
					opts.panes[key] = $.isPlainObject(val) ? $.extend(true, {}, val) : val;
				delete opts[key]
			}
		}

		// START by updating ALL options from opts
		$.extend(true, options, opts);

		// CREATE final options (and config) for EACH pane
		$.each(_c.allPanes, function (i, pane) {

			// apply 'pane-defaults' to CONFIG.[PANE]
			_c[pane] = $.extend(true, {}, _c.panes, _c[pane]);

			d = options.panes;
			o = options[pane];

			// center-pane uses SOME keys in defaults.panes branch
			if (pane === 'center') {
				// ONLY copy keys from opts.panes listed in: $.layout.optionsMap.center
				data = $.layout.optionsMap.center;		// list of 'center-pane keys'
				for (i=0, c=data.length; i<c; i++) {	// loop the list...
					key = data[i];
					// only need to use pane-default if pane-specific value not set
					if (!opts.center[key] && (opts.panes[key] || !o[key]))
						o[key] = d[key]; // pane-default
				}
			}
			else {
				// border-panes use ALL keys in defaults.panes branch
				o = options[pane] = $.extend(true, {}, d, o); // re-apply pane-specific opts AFTER pane-defaults
				createFxOptions( pane );
				// ensure all border-pane-specific base-classes exist
				if (!o.resizerClass)	o.resizerClass	= "ui-layout-resizer";
				if (!o.togglerClass)	o.togglerClass	= "ui-layout-toggler";
			}
			// ensure we have base pane-class (ALL panes)
			if (!o.paneClass) o.paneClass = "ui-layout-pane";
		});

		// update options.zIndexes if a zIndex-option specified
		var zo	= opts.zIndex
		,	z	= options.zIndexes;
		if (zo > 0) {
			z.pane_normal		= zo;
			z.content_mask		= max(zo+1, z.content_mask);	// MIN = +1
			z.resizer_normal	= max(zo+2, z.resizer_normal);	// MIN = +2
		}

		// DELETE 'panes' key now that we are done - values were copied to EACH pane
		delete options.panes;


		function createFxOptions ( pane ) {
			var	o = options[pane]
			,	d = options.panes;
			// ensure fxSettings key to avoid errors
			if (!o.fxSettings) o.fxSettings = {};
			if (!d.fxSettings) d.fxSettings = {};

			$.each(["_open","_close","_size"], function (i,n) { 
				var
					sName		= "fxName"+ n
				,	sSpeed		= "fxSpeed"+ n
				,	sSettings	= "fxSettings"+ n
					// recalculate fxName according to specificity rules
				,	fxName = o[sName] =
						o[sName]	// options.west.fxName_open
					||	d[sName]	// options.panes.fxName_open
					||	o.fxName	// options.west.fxName
					||	d.fxName	// options.panes.fxName
					||	"none"		// MEANS $.layout.defaults.panes.fxName == "" || false || null || 0
				,	fxExists	= $.effects && ($.effects[fxName] || ($.effects.effect && $.effects.effect[fxName]))
				;
				// validate fxName to ensure is valid effect - MUST have effect-config data in options.effects
				if (fxName === "none" || !options.effects[fxName] || !fxExists)
					fxName = o[sName] = "none"; // effect not loaded OR unrecognized fxName

				// set vars for effects subkeys to simplify logic
				var	fx		= options.effects[fxName] || {}	// effects.slide
				,	fx_all	= fx.all	|| null				// effects.slide.all
				,	fx_pane	= fx[pane]	|| null				// effects.slide.west
				;
				// create fxSpeed[_open|_close|_size]
				o[sSpeed] =
					o[sSpeed]				// options.west.fxSpeed_open
				||	d[sSpeed]				// options.west.fxSpeed_open
				||	o.fxSpeed				// options.west.fxSpeed
				||	d.fxSpeed				// options.panes.fxSpeed
				||	null					// DEFAULT - let fxSetting.duration control speed
				;
				// create fxSettings[_open|_close|_size]
				o[sSettings] = $.extend(
					true
				,	{}
				,	fx_all					// effects.slide.all
				,	fx_pane					// effects.slide.west
				,	d.fxSettings			// options.panes.fxSettings
				,	o.fxSettings			// options.west.fxSettings
				,	d[sSettings]			// options.panes.fxSettings_open
				,	o[sSettings]			// options.west.fxSettings_open
				);
			});

			// DONE creating action-specific-settings for this pane,
			// so DELETE generic options - are no longer meaningful
			delete o.fxName;
			delete o.fxSpeed;
			delete o.fxSettings;
		}
	}

	/**
	* Initialize module objects, styling, size and position for all panes
	*
	* @see  _initElements()
	* @param {string}	pane		The pane to process
	*/
,	getPane = function (pane) {
		var sel = options[pane].paneSelector
		if (sel.substr(0,1)==="#") // ID selector
			// NOTE: elements selected 'by ID' DO NOT have to be 'children'
			return $N.find(sel).eq(0);
		else { // class or other selector
			var $P = $N.children(sel).eq(0);
			// look for the pane nested inside a 'form' element
			return $P.length ? $P : $N.children("form:first").children(sel).eq(0);
		}
	}

	/**
	* @param {Object=}		evt
	*/
,	initPanes = function (evt) {
		// stopPropagation if called by trigger("layoutinitpanes") - use evtPane utility 
		evtPane(evt);

		// NOTE: do north & south FIRST so we can measure their height - do center LAST
		$.each(_c.allPanes, function (idx, pane) {
			addPane( pane, true );
		});

		// init the pane-handles NOW in case we have to hide or close the pane below
		initHandles();

		// now that all panes have been initialized and initially-sized,
		// make sure there is really enough space available for each pane
		$.each(_c.borderPanes, function (i, pane) {
			if ($Ps[pane] && state[pane].isVisible) { // pane is OPEN
				setSizeLimits(pane);
				makePaneFit(pane); // pane may be Closed, Hidden or Resized by makePaneFit()
			}
		});
		// size center-pane AGAIN in case we 'closed' a border-pane in loop above
		sizeMidPanes("center");

		//	Chrome/Webkit sometimes fires callbacks BEFORE it completes resizing!
		//	Before RC30.3, there was a 10ms delay here, but that caused layout 
		//	to load asynchrously, which is BAD, so try skipping delay for now

		// process pane contents and callbacks, and init/resize child-layout if exists
		$.each(_c.allPanes, function (idx, pane) {
			afterInitPane(pane);
		});
	}

	/**
	* Add a pane to the layout - subroutine of initPanes()
	*
	* @see  initPanes()
	* @param {string}	pane			The pane to process
	* @param {boolean=}	[force=false]	Size content after init
	*/
,	addPane = function (pane, force) {
		if (!force && !isInitialized()) return;
		var
			o		= options[pane]
		,	s		= state[pane]
		,	c		= _c[pane]
		,	dir		= c.dir
		,	fx		= s.fx
		,	spacing	= o.spacing_open || 0
		,	isCenter = (pane === "center")
		,	CSS		= {}
		,	$P		= $Ps[pane]
		,	size, minSize, maxSize, child
		;
		// if pane-pointer already exists, remove the old one first
		if ($P)
			removePane( pane, false, true, false );
		else
			$Cs[pane] = false; // init

		$P = $Ps[pane] = getPane(pane);
		if (!$P.length) {
			$Ps[pane] = false; // logic
			return;
		}

		// SAVE original Pane CSS
		if (!$P.data("layoutCSS")) {
			var props = "position,top,left,bottom,right,width,height,overflow,zIndex,display,backgroundColor,padding,margin,border";
			$P.data("layoutCSS", styles($P, props));
		}

		// create alias for pane data in Instance - initHandles will add more
		Instance[pane] = {
			name:		pane
		,	pane:		$Ps[pane]
		,	content:	$Cs[pane]
		,	options:	options[pane]
		,	state:		state[pane]
		,	children:	children[pane]
		};

		// add classes, attributes & events
		$P	.data({
				parentLayout:	Instance		// pointer to Layout Instance
			,	layoutPane:		Instance[pane]	// NEW pointer to pane-alias-object
			,	layoutEdge:		pane
			,	layoutRole:		"pane"
			})
			.css(c.cssReq).css("zIndex", options.zIndexes.pane_normal)
			.css(o.applyDemoStyles ? c.cssDemo : {}) // demo styles
			.addClass( o.paneClass +" "+ o.paneClass+"-"+pane ) // default = "ui-layout-pane ui-layout-pane-west" - may be a dupe of 'paneSelector'
			.bind("mouseenter."+ sID, addHover )
			.bind("mouseleave."+ sID, removeHover )
			;
		var paneMethods = {
				hide:				''
			,	show:				''
			,	toggle:				''
			,	close:				''
			,	open:				''
			,	slideOpen:			''
			,	slideClose:			''
			,	slideToggle:		''
			,	size:				'sizePane'
			,	sizePane:			'sizePane'
			,	sizeContent:		''
			,	sizeHandles:		''
			,	enableClosable:		''
			,	disableClosable:	''
			,	enableSlideable:	''
			,	disableSlideable:	''
			,	enableResizable:	''
			,	disableResizable:	''
			,	swapPanes:			'swapPanes'
			,	swap:				'swapPanes'
			,	move:				'swapPanes'
			,	removePane:			'removePane'
			,	remove:				'removePane'
			,	createChildren:		''
			,	resizeChildren:		''
			,	resizeAll:			'resizeAll'
			,	resizeLayout:		'resizeAll'
			}
		,	name;
		// loop hash and bind all methods - include layoutID namespacing
		for (name in paneMethods) {
			$P.bind("layoutpane"+ name.toLowerCase() +"."+ sID, Instance[ paneMethods[name] || name ]);
		}

		// see if this pane has a 'scrolling-content element'
		initContent(pane, false); // false = do NOT sizeContent() - called later

		if (!isCenter) {
			// call _parseSize AFTER applying pane classes & styles - but before making visible (if hidden)
			// if o.size is auto or not valid, then MEASURE the pane and use that as its 'size'
			size	= s.size = _parseSize(pane, o.size);
			minSize	= _parseSize(pane,o.minSize) || 1;
			maxSize	= _parseSize(pane,o.maxSize) || 100000;
			if (size > 0) size = max(min(size, maxSize), minSize);
			s.autoResize = o.autoResize; // used with percentage sizes

			// state for border-panes
			s.isClosed  = false; // true = pane is closed
			s.isSliding = false; // true = pane is currently open by 'sliding' over adjacent panes
			s.isResizing= false; // true = pane is in process of being resized
			s.isHidden	= false; // true = pane is hidden - no spacing, resizer or toggler is visible!

			// array for 'pin buttons' whose classNames are auto-updated on pane-open/-close
			if (!s.pins) s.pins = [];
		}
		//	states common to ALL panes
		s.tagName	= $P[0].tagName;
		s.edge		= pane;		// useful if pane is (or about to be) 'swapped' - easy find out where it is (or is going)
		s.noRoom	= false;	// true = pane 'automatically' hidden due to insufficient room - will unhide automatically
		s.isVisible	= true;		// false = pane is invisible - closed OR hidden - simplify logic

		// init pane positioning
		setPanePosition( pane );

		// if pane is not visible, 
		if (dir === "horz") // north or south pane
			CSS.height = cssH($P, size);
		else if (dir === "vert") // east or west pane
			CSS.width = cssW($P, size);
		//else if (isCenter) {}

		$P.css(CSS); // apply size -- top, bottom & height will be set by sizeMidPanes
		if (dir != "horz") sizeMidPanes(pane, true); // true = skipCallback

		// if manually adding a pane AFTER layout initialization, then...
		if (state.initialized) {
			initHandles( pane );
			initHotkeys( pane );
		}

		// close or hide the pane if specified in settings
		if (o.initClosed && o.closable && !o.initHidden)
			close(pane, true, true); // true, true = force, noAnimation
		else if (o.initHidden || o.initClosed)
			hide(pane); // will be completely invisible - no resizer or spacing
		else if (!s.noRoom)
			// make the pane visible - in case was initially hidden
			$P.css("display","block");
		// ELSE setAsOpen() - called later by initHandles()

		// RESET visibility now - pane will appear IF display:block
		$P.css("visibility","visible");

		// check option for auto-handling of pop-ups & drop-downs
		if (o.showOverflowOnHover)
			$P.hover( allowOverflow, resetOverflow );

		// if manually adding a pane AFTER layout initialization, then...
		if (state.initialized) {
			afterInitPane( pane );
		}
	}

,	afterInitPane = function (pane) {
		var	$P	= $Ps[pane]
		,	s	= state[pane]
		,	o	= options[pane]
		;
		if (!$P) return;

		// see if there is a directly-nested layout inside this pane
		if ($P.data("layout"))
			refreshChildren( pane, $P.data("layout") );

		// process pane contents and callbacks, and init/resize child-layout if exists
		if (s.isVisible) { // pane is OPEN
			if (state.initialized) // this pane was added AFTER layout was created
				resizeAll(); // will also sizeContent
			else
				sizeContent(pane);

			if (o.triggerEventsOnLoad)
				_runCallbacks("onresize_end", pane);
			else // automatic if onresize called, otherwise call it specifically
				// resize child - IF inner-layout already exists (created before this layout)
				resizeChildren(pane, true); // a previously existing childLayout
		}

		// init childLayouts - even if pane is not visible
		if (o.initChildren && o.children)
			createChildren(pane);
	}

	/**
	* @param {string=}	panes		The pane(s) to process
	*/
,	setPanePosition = function (panes) {
		panes = panes ? panes.split(",") : _c.borderPanes;

		// create toggler DIVs for each pane, and set object pointers for them, eg: $R.north = north toggler DIV
		$.each(panes, function (i, pane) {
			var $P	= $Ps[pane]
			,	$R	= $Rs[pane]
			,	o	= options[pane]
			,	s	= state[pane]
			,	side =  _c[pane].side
			,	CSS	= {}
			;
			if (!$P) return; // pane does not exist - skip

			// set css-position to account for container borders & padding
			switch (pane) {
				case "north": 	CSS.top 	= sC.inset.top;
								CSS.left 	= sC.inset.left;
								CSS.right	= sC.inset.right;
								break;
				case "south": 	CSS.bottom	= sC.inset.bottom;
								CSS.left 	= sC.inset.left;
								CSS.right 	= sC.inset.right;
								break;
				case "west": 	CSS.left 	= sC.inset.left; // top, bottom & height set by sizeMidPanes()
								break;
				case "east": 	CSS.right 	= sC.inset.right; // ditto
								break;
				case "center":	// top, left, width & height set by sizeMidPanes()
			}
			// apply position
			$P.css(CSS); 

			// update resizer position
			if ($R && s.isClosed)
				$R.css(side, sC.inset[side]);
			else if ($R && !s.isHidden)
				$R.css(side, sC.inset[side] + getPaneSize(pane));
		});
	}

	/**
	* Initialize module objects, styling, size and position for all resize bars and toggler buttons
	*
	* @see  _create()
	* @param {string=}	[panes=""]	The edge(s) to process
	*/
,	initHandles = function (panes) {
		panes = panes ? panes.split(",") : _c.borderPanes;

		// create toggler DIVs for each pane, and set object pointers for them, eg: $R.north = north toggler DIV
		$.each(panes, function (i, pane) {
			var $P		= $Ps[pane];
			$Rs[pane]	= false; // INIT
			$Ts[pane]	= false;
			if (!$P) return; // pane does not exist - skip

			var	o		= options[pane]
			,	s		= state[pane]
			,	c		= _c[pane]
			,	paneId	= o.paneSelector.substr(0,1) === "#" ? o.paneSelector.substr(1) : ""
			,	rClass	= o.resizerClass
			,	tClass	= o.togglerClass
			,	spacing	= (s.isVisible ? o.spacing_open : o.spacing_closed)
			,	_pane	= "-"+ pane // used for classNames
			,	_state	= (s.isVisible ? "-open" : "-closed") // used for classNames
			,	I		= Instance[pane]
				// INIT RESIZER BAR
			,	$R		= I.resizer = $Rs[pane] = $("<div></div>")
				// INIT TOGGLER BUTTON
			,	$T		= I.toggler = (o.closable ? $Ts[pane] = $("<div></div>") : false)
			;

			//if (s.isVisible && o.resizable) ... handled by initResizable
			if (!s.isVisible && o.slidable)
				$R.attr("title", o.tips.Slide).css("cursor", o.sliderCursor);

			$R	// if paneSelector is an ID, then create a matching ID for the resizer, eg: "#paneLeft" => "paneLeft-resizer"
				.attr("id", paneId ? paneId +"-resizer" : "" )
				.data({
					parentLayout:	Instance
				,	layoutPane:		Instance[pane]	// NEW pointer to pane-alias-object
				,	layoutEdge:		pane
				,	layoutRole:		"resizer"
				})
				.css(_c.resizers.cssReq).css("zIndex", options.zIndexes.resizer_normal)
				.css(o.applyDemoStyles ? _c.resizers.cssDemo : {}) // add demo styles
				.addClass(rClass +" "+ rClass+_pane)
				.hover(addHover, removeHover) // ALWAYS add hover-classes, even if resizing is not enabled - handle with CSS instead
				.hover(onResizerEnter, onResizerLeave) // ALWAYS NEED resizer.mouseleave to balance toggler.mouseenter
				.appendTo($N) // append DIV to container
			;
			if (o.resizerDblClickToggle)
				$R.bind("dblclick."+ sID, toggle );

			if ($T) {
				$T	// if paneSelector is an ID, then create a matching ID for the resizer, eg: "#paneLeft" => "#paneLeft-toggler"
					.attr("id", paneId ? paneId +"-toggler" : "" )
					.data({
						parentLayout:	Instance
					,	layoutPane:		Instance[pane]	// NEW pointer to pane-alias-object
					,	layoutEdge:		pane
					,	layoutRole:		"toggler"
					})
					.css(_c.togglers.cssReq) // add base/required styles
					.css(o.applyDemoStyles ? _c.togglers.cssDemo : {}) // add demo styles
					.addClass(tClass +" "+ tClass+_pane)
					.hover(addHover, removeHover) // ALWAYS add hover-classes, even if toggling is not enabled - handle with CSS instead
					.bind("mouseenter", onResizerEnter) // NEED toggler.mouseenter because mouseenter MAY NOT fire on resizer
					.appendTo($R) // append SPAN to resizer DIV
				;
				// ADD INNER-SPANS TO TOGGLER
				if (o.togglerContent_open) // ui-layout-open
					$("<span>"+ o.togglerContent_open +"</span>")
						.data({
							layoutEdge:		pane
						,	layoutRole:		"togglerContent"
						})
						.data("layoutRole", "togglerContent")
						.data("layoutEdge", pane)
						.addClass("content content-open")
						.css("display","none")
						.appendTo( $T )
						//.hover( addHover, removeHover ) // use ui-layout-toggler-west-hover .content-open instead!
					;
				if (o.togglerContent_closed) // ui-layout-closed
					$("<span>"+ o.togglerContent_closed +"</span>")
						.data({
							layoutEdge:		pane
						,	layoutRole:		"togglerContent"
						})
						.addClass("content content-closed")
						.css("display","none")
						.appendTo( $T )
						//.hover( addHover, removeHover ) // use ui-layout-toggler-west-hover .content-closed instead!
					;
				// ADD TOGGLER.click/.hover
				enableClosable(pane);
			}

			// add Draggable events
			initResizable(pane);

			// ADD CLASSNAMES & SLIDE-BINDINGS - eg: class="resizer resizer-west resizer-open"
			if (s.isVisible)
				setAsOpen(pane);	// onOpen will be called, but NOT onResize
			else {
				setAsClosed(pane);	// onClose will be called
				bindStartSlidingEvents(pane, true); // will enable events IF option is set
			}

		});

		// SET ALL HANDLE DIMENSIONS
		sizeHandles();
	}


	/**
	* Initialize scrolling ui-layout-content div - if exists
	*
	* @see  initPane() - or externally after an Ajax injection
	* @param {string}	pane			The pane to process
	* @param {boolean=}	[resize=true]	Size content after init
	*/
,	initContent = function (pane, resize) {
		if (!isInitialized()) return;
		var 
			o	= options[pane]
		,	sel	= o.contentSelector
		,	I	= Instance[pane]
		,	$P	= $Ps[pane]
		,	$C
		;
		if (sel) $C = I.content = $Cs[pane] = (o.findNestedContent)
			? $P.find(sel).eq(0) // match 1-element only
			: $P.children(sel).eq(0)
		;
		if ($C && $C.length) {
			$C.data("layoutRole", "content");
			// SAVE original Content CSS
			if (!$C.data("layoutCSS"))
				$C.data("layoutCSS", styles($C, "height"));
			$C.css( _c.content.cssReq );
			if (o.applyDemoStyles) {
				$C.css( _c.content.cssDemo ); // add padding & overflow: auto to content-div
				$P.css( _c.content.cssDemoPane ); // REMOVE padding/scrolling from pane
			}
			// ensure no vertical scrollbar on pane - will mess up measurements
			if ($P.css("overflowX").match(/(scroll|auto)/)) {
				$P.css("overflow", "hidden");
			}
			state[pane].content = {}; // init content state
			if (resize !== false) sizeContent(pane);
			// sizeContent() is called AFTER init of all elements
		}
		else
			I.content = $Cs[pane] = false;
	}


	/**
	* Add resize-bars to all panes that specify it in options
	* -dependancy: $.fn.resizable - will skip if not found
	*
	* @see  _create()
	* @param {string=}	[panes=""]	The edge(s) to process
	*/
,	initResizable = function (panes) {
		var	draggingAvailable = $.layout.plugins.draggable
		,	side // set in start()
		;
		panes = panes ? panes.split(",") : _c.borderPanes;

		$.each(panes, function (idx, pane) {
			var o = options[pane];
			if (!draggingAvailable || !$Ps[pane] || !o.resizable) {
				o.resizable = false;
				return true; // skip to next
			}

			var s		= state[pane]
			,	z		= options.zIndexes
			,	c		= _c[pane]
			,	side	= c.dir=="horz" ? "top" : "left"
			,	$P 		= $Ps[pane]
			,	$R		= $Rs[pane]
			,	base	= o.resizerClass
			,	lastPos	= 0 // used when live-resizing
			,	r, live // set in start because may change
			//	'drag' classes are applied to the ORIGINAL resizer-bar while dragging is in process
			,	resizerClass		= base+"-drag"				// resizer-drag
			,	resizerPaneClass	= base+"-"+pane+"-drag"		// resizer-north-drag
			//	'helper' class is applied to the CLONED resizer-bar while it is being dragged
			,	helperClass			= base+"-dragging"			// resizer-dragging
			,	helperPaneClass		= base+"-"+pane+"-dragging" // resizer-north-dragging
			,	helperLimitClass	= base+"-dragging-limit"	// resizer-drag
			,	helperPaneLimitClass = base+"-"+pane+"-dragging-limit"	// resizer-north-drag
			,	helperClassesSet	= false 					// logic var
			;

			if (!s.isClosed)
				$R.attr("title", o.tips.Resize)
				  .css("cursor", o.resizerCursor); // n-resize, s-resize, etc

			$R.draggable({
				containment:	$N[0] // limit resizing to layout container
			,	axis:			(c.dir=="horz" ? "y" : "x") // limit resizing to horz or vert axis
			,	delay:			0
			,	distance:		1
			,	grid:			o.resizingGrid
			//	basic format for helper - style it using class: .ui-draggable-dragging
			,	helper:			"clone"
			,	opacity:		o.resizerDragOpacity
			,	addClasses:		false // avoid ui-state-disabled class when disabled
			//,	iframeFix:		o.draggableIframeFix // TODO: consider using when bug is fixed
			,	zIndex:			z.resizer_drag

			,	start: function (e, ui) {
					// REFRESH options & state pointers in case we used swapPanes
					o = options[pane];
					s = state[pane];
					// re-read options
					live = o.livePaneResizing;

					// ondrag_start callback - will CANCEL hide if returns false
					// TODO: dragging CANNOT be cancelled like this, so see if there is a way?
					if (false === _runCallbacks("ondrag_start", pane)) return false;

					s.isResizing		= true; // prevent pane from closing while resizing
					state.paneResizing	= pane; // easy to see if ANY pane is resizing
					timer.clear(pane+"_closeSlider"); // just in case already triggered

					// SET RESIZER LIMITS - used in drag()
					setSizeLimits(pane); // update pane/resizer state
					r = s.resizerPosition;
					lastPos = ui.position[ side ]

					$R.addClass( resizerClass +" "+ resizerPaneClass ); // add drag classes
					helperClassesSet = false; // reset logic var - see drag()

					// DISABLE TEXT SELECTION (probably already done by resizer.mouseOver)
					$('body').disableSelection(); 

					// MASK PANES CONTAINING IFRAMES, APPLETS OR OTHER TROUBLESOME ELEMENTS
					showMasks( pane, { resizing: true });
				}

			,	drag: function (e, ui) {
					if (!helperClassesSet) { // can only add classes after clone has been added to the DOM
						//$(".ui-draggable-dragging")
						ui.helper
							.addClass( helperClass +" "+ helperPaneClass ) // add helper classes
							.css({ right: "auto", bottom: "auto" })	// fix dir="rtl" issue
							.children().css("visibility","hidden")	// hide toggler inside dragged resizer-bar
						;
						helperClassesSet = true;
						// draggable bug!? RE-SET zIndex to prevent E/W resize-bar showing through N/S pane!
						if (s.isSliding) $Ps[pane].css("zIndex", z.pane_sliding);
					}
					// CONTAIN RESIZER-BAR TO RESIZING LIMITS
					var limit = 0;
					if (ui.position[side] < r.min) {
						ui.position[side] = r.min;
						limit = -1;
					}
					else if (ui.position[side] > r.max) {
						ui.position[side] = r.max;
						limit = 1;
					}
					// ADD/REMOVE dragging-limit CLASS
					if (limit) {
						ui.helper.addClass( helperLimitClass +" "+ helperPaneLimitClass ); // at dragging-limit
						window.defaultStatus = (limit>0 && pane.match(/(north|west)/)) || (limit<0 && pane.match(/(south|east)/)) ? o.tips.maxSizeWarning : o.tips.minSizeWarning;
					}
					else {
						ui.helper.removeClass( helperLimitClass +" "+ helperPaneLimitClass ); // not at dragging-limit
						window.defaultStatus = "";
					}
					// DYNAMICALLY RESIZE PANES IF OPTION ENABLED
					// won't trigger unless resizer has actually moved!
					if (live && Math.abs(ui.position[side] - lastPos) >= o.liveResizingTolerance) {
						lastPos = ui.position[side];
						resizePanes(e, ui, pane)
					}
				}

			,	stop: function (e, ui) {
					$('body').enableSelection(); // RE-ENABLE TEXT SELECTION
					window.defaultStatus = ""; // clear 'resizing limit' message from statusbar
					$R.removeClass( resizerClass +" "+ resizerPaneClass ); // remove drag classes from Resizer
					s.isResizing		= false;
					state.paneResizing	= false; // easy to see if ANY pane is resizing
					resizePanes(e, ui, pane, true); // true = resizingDone
				}

			});
		});

		/**
		* resizePanes
		*
		* Sub-routine called from stop() - and drag() if livePaneResizing
		*
		* @param {!Object}		evt
		* @param {!Object}		ui
		* @param {string}		pane
		* @param {boolean=}		[resizingDone=false]
		*/
		var resizePanes = function (evt, ui, pane, resizingDone) {
			var	dragPos	= ui.position
			,	c		= _c[pane]
			,	o		= options[pane]
			,	s		= state[pane]
			,	resizerPos
			;
			switch (pane) {
				case "north":	resizerPos = dragPos.top; break;
				case "west":	resizerPos = dragPos.left; break;
				case "south":	resizerPos = sC.layoutHeight - dragPos.top  - o.spacing_open; break;
				case "east":	resizerPos = sC.layoutWidth  - dragPos.left - o.spacing_open; break;
			};
			// remove container margin from resizer position to get the pane size
			var newSize = resizerPos - sC.inset[c.side];

			// Disable OR Resize Mask(s) created in drag.start
			if (!resizingDone) {
				// ensure we meet liveResizingTolerance criteria
				if (Math.abs(newSize - s.size) < o.liveResizingTolerance)
					return; // SKIP resize this time
				// resize the pane
				manualSizePane(pane, newSize, false, true); // true = noAnimation
				sizeMasks(); // resize all visible masks
			}
			else { // resizingDone
				// ondrag_end callback
				if (false !== _runCallbacks("ondrag_end", pane))
					manualSizePane(pane, newSize, false, true); // true = noAnimation
				hideMasks(true); // true = force hiding all masks even if one is 'sliding'
				if (s.isSliding) // RE-SHOW 'object-masks' so objects won't show through sliding pane
					showMasks( pane, { resizing: true });
			}
		};
	}

	/**
	*	sizeMask
	*
	*	Needed to overlay a DIV over an IFRAME-pane because mask CANNOT be *inside* the pane
	*	Called when mask created, and during livePaneResizing
	*/
,	sizeMask = function () {
		var $M		= $(this)
		,	pane	= $M.data("layoutMask") // eg: "west"
		,	s		= state[pane]
		;
		// only masks over an IFRAME-pane need manual resizing
		if (s.tagName == "IFRAME" && s.isVisible) // no need to mask closed/hidden panes
			$M.css({
				top:	s.offsetTop
			,	left:	s.offsetLeft
			,	width:	s.outerWidth
			,	height:	s.outerHeight
			});
		/* ALT Method...
		var $P = $Ps[pane];
		$M.css( $P.position() ).css({ width: $P[0].offsetWidth, height: $P[0].offsetHeight });
		*/
	}
,	sizeMasks = function () {
		$Ms.each( sizeMask ); // resize all 'visible' masks
	}

	/**
	* @param {string}	pane		The pane being resized, animated or isSliding
	* @param {Object=}	[args]		(optional) Options: which masks to apply, and to which panes
	*/
,	showMasks = function (pane, args) {
		var	c		= _c[pane]
		,	panes	=  ["center"]
		,	z		= options.zIndexes
		,	a		= $.extend({
						objectsOnly:	false
					,	animation:		false
					,	resizing:		true
					,	sliding:		state[pane].isSliding
					},	args )
		,	o, s
		;
		if (a.resizing)
			panes.push( pane );
		if (a.sliding)
			panes.push( _c.oppositeEdge[pane] ); // ADD the oppositeEdge-pane

		if (c.dir === "horz") {
			panes.push("west");
			panes.push("east");
		}

		$.each(panes, function(i,p){
			s = state[p];
			o = options[p];
			if (s.isVisible && ( o.maskObjects || (!a.objectsOnly && o.maskContents) )) {
				getMasks(p).each(function(){
					sizeMask.call(this);
					this.style.zIndex = s.isSliding ? z.pane_sliding+1 : z.pane_normal+1
					this.style.display = "block";
				});
			}
		});
	}

	/**
	* @param {boolean=}	force		Hide masks even if a pane is sliding
	*/
,	hideMasks = function (force) {
		// ensure no pane is resizing - could be a timing issue
		if (force || !state.paneResizing) {
			$Ms.hide(); // hide ALL masks
		}
		// if ANY pane is sliding, then DO NOT remove masks from panes with maskObjects enabled
		else if (!force && !$.isEmptyObject( state.panesSliding )) {
			var	i = $Ms.length - 1
			,	p, $M;
			for (; i >= 0; i--) {
				$M	= $Ms.eq(i);
				p	= $M.data("layoutMask");
				if (!options[p].maskObjects) {
					$M.hide();
				}
			}
		}
	}

	/**
	* @param {string}	pane
	*/
,	getMasks = function (pane) {
		var $Masks	= $([])
		,	$M, i = 0, c = $Ms.length
		;
		for (; i<c; i++) {
			$M = $Ms.eq(i);
			if ($M.data("layoutMask") === pane)
				$Masks = $Masks.add( $M );
		}
		if ($Masks.length)
			return $Masks;
		else
			return createMasks(pane);
	}

	/**
	* createMasks
	*
	* Generates both DIV (ALWAYS used) and IFRAME (optional) elements as masks
	* An IFRAME mask is created *under* the DIV when maskObjects=true, because a DIV cannot mask an applet
	*
	* @param {string}	pane
	*/
,	createMasks = function (pane) {
		var
			$P		= $Ps[pane]
		,	s		= state[pane]
		,	o		= options[pane]
		,	z		= options.zIndexes
		//,	objMask	= o.maskObjects && s.tagName != "IFRAME" // check for option
		,	$Masks	= $([])
		,	isIframe, el, $M, css, i
		;
		if (!o.maskContents && !o.maskObjects) return $Masks;
		// if o.maskObjects=true, then loop TWICE to create BOTH kinds of mask, else only create a DIV
		for (i=0; i < (o.maskObjects ? 2 : 1); i++) {
			isIframe = o.maskObjects && i==0;
			el = document.createElement( isIframe ? "iframe" : "div" );
			$M = $(el).data("layoutMask", pane); // add data to relate mask to pane
			el.className = "ui-layout-mask ui-layout-mask-"+ pane; // for user styling
			css = el.style;
			// styles common to both DIVs and IFRAMES
			css.display		= "block";
			css.position	= "absolute";
			css.background	= "#FFF";
			if (isIframe) { // IFRAME-only props
				el.frameborder = 0;
				el.src		= "about:blank";
				//el.allowTransparency = true; - for IE, but breaks masking ability!
				css.opacity	= 0;
				css.filter	= "Alpha(Opacity='0')";
				css.border	= 0;
			}
			// if pane is an IFRAME, then must mask the pane itself
			if (s.tagName == "IFRAME") {
				// NOTE sizing done by a subroutine so can be called during live-resizing
				css.zIndex	= z.pane_normal+1; // 1-higher than pane
				$N.append( el ); // append to LAYOUT CONTAINER
			}
			// otherwise put masks *inside the pane* to mask its contents
			else {
				$M.addClass("ui-layout-mask-inside-pane");
				css.zIndex	= o.maskZindex || z.content_mask; // usually 1, but customizable
				css.top		= 0;
				css.left	= 0;
				css.width	= "100%";
				css.height	= "100%";
				$P.append( el ); // append INSIDE pane element
			}
			// add to return object
			$Masks = $Masks.add( el );
			// add Mask to cached array so can be resized & reused
			$Ms = $Ms.add( el );
		}
		return $Masks;
	}


	/**
	* Destroy this layout and reset all elements
	*
	* @param {boolean=}	[destroyChildren=false]		Destory Child-Layouts first?
	*/
,	destroy = function (evt_or_destroyChildren, destroyChildren) {
		// UNBIND layout events and remove global object
		$(window).unbind("."+ sID);		// resize & unload
		$(document).unbind("."+ sID);	// keyDown (hotkeys)

		if (typeof evt_or_destroyChildren === "object")
			// stopPropagation if called by trigger("layoutdestroy") - use evtPane utility 
			evtPane(evt_or_destroyChildren);
		else // no event, so transfer 1st param to destroyChildren param
			destroyChildren = evt_or_destroyChildren;

		// need to look for parent layout BEFORE we remove the container data, else skips a level
		//var parentPane = Instance.hasParentLayout ? $.layout.getParentPaneInstance( $N ) : null;

		// reset layout-container
		$N	.clearQueue()
			.removeData("layout")
			.removeData("layoutContainer")
			.removeClass(options.containerClass)
			.unbind("."+ sID) // remove ALL Layout events
		;

		// remove all mask elements that have been created
		$Ms.remove();

		// loop all panes to remove layout classes, attributes and bindings
		$.each(_c.allPanes, function (i, pane) {
			removePane( pane, false, true, destroyChildren ); // true = skipResize
		});

		// do NOT reset container CSS if is a 'pane' (or 'content') in an outer-layout - ie, THIS layout is 'nested'
		var css = "layoutCSS";
		if ($N.data(css) && !$N.data("layoutRole")) // RESET CSS
			$N.css( $N.data(css) ).removeData(css);

		// for full-page layouts, also reset the <HTML> CSS
		if (sC.tagName === "BODY" && ($N = $("html")).data(css)) // RESET <HTML> CSS
			$N.css( $N.data(css) ).removeData(css);

		// trigger plugins for this layout, if there are any
		runPluginCallbacks( Instance, $.layout.onDestroy );

		// trigger state-management and onunload callback
		unload();

		// clear the Instance of everything except for container & options (so could recreate)
		// RE-CREATE: myLayout = myLayout.container.layout( myLayout.options );
		for (var n in Instance)
			if (!n.match(/^(container|options)$/)) delete Instance[ n ];
		// add a 'destroyed' flag to make it easy to check
		Instance.destroyed = true;

		// if this is a child layout, CLEAR the child-pointer in the parent
		/* for now the pointer REMAINS, but with only container, options and destroyed keys
		if (parentPane) {
			var layout	= parentPane.pane.data("parentLayout")
			,	key		= layout.options.instanceKey || 'error';
			// THIS SYNTAX MAY BE WRONG!
			parentPane.children[key] = layout.children[ parentPane.name ].children[key] = null;
		}
		*/

		return Instance; // for coding convenience
	}

	/**
	* Remove a pane from the layout - subroutine of destroy()
	*
	* @see  destroy()
	* @param {(string|Object)}	evt_or_pane			The pane to process
	* @param {boolean=}			[remove=false]		Remove the DOM element?
	* @param {boolean=}			[skipResize=false]	Skip calling resizeAll()?
	* @param {boolean=}			[destroyChild=true]	Destroy Child-layouts? If not passed, obeys options setting
	*/
,	removePane = function (evt_or_pane, remove, skipResize, destroyChild) {
		if (!isInitialized()) return;
		var	pane = evtPane.call(this, evt_or_pane)
		,	$P	= $Ps[pane]
		,	$C	= $Cs[pane]
		,	$R	= $Rs[pane]
		,	$T	= $Ts[pane]
		;
		// NOTE: elements can still exist even after remove()
		//		so check for missing data(), which is cleared by removed()
		if ($P && $.isEmptyObject( $P.data() )) $P = false;
		if ($C && $.isEmptyObject( $C.data() )) $C = false;
		if ($R && $.isEmptyObject( $R.data() )) $R = false;
		if ($T && $.isEmptyObject( $T.data() )) $T = false;

		if ($P) $P.stop(true, true);

		var	o	= options[pane]
		,	s	= state[pane]
		,	d	= "layout"
		,	css	= "layoutCSS"
		,	pC	= children[pane]
		,	hasChildren	= $.isPlainObject( pC ) && !$.isEmptyObject( pC )
		,	destroy		= destroyChild !== undefined ? destroyChild : o.destroyChildren
		;
		// FIRST destroy the child-layout(s)
		if (hasChildren && destroy) {
			$.each( pC, function (key, child) {
				if (!child.destroyed)
					child.destroy(true);// tell child-layout to destroy ALL its child-layouts too
				if (child.destroyed)	// destroy was successful
					delete pC[key];
			});
			// if no more children, remove the children hash
			if ($.isEmptyObject( pC )) {
				pC = children[pane] = null; // clear children hash
				hasChildren = false;
			}
		}

		// Note: can't 'remove' a pane element with non-destroyed children
		if ($P && remove && !hasChildren)
			$P.remove(); // remove the pane-element and everything inside it
		else if ($P && $P[0]) {
			//	create list of ALL pane-classes that need to be removed
			var	root	= o.paneClass // default="ui-layout-pane"
			,	pRoot	= root +"-"+ pane // eg: "ui-layout-pane-west"
			,	_open	= "-open"
			,	_sliding= "-sliding"
			,	_closed	= "-closed"
			,	classes	= [	root, root+_open, root+_closed, root+_sliding,		// generic classes
							pRoot, pRoot+_open, pRoot+_closed, pRoot+_sliding ]	// pane-specific classes
			;
			$.merge(classes, getHoverClasses($P, true)); // ADD hover-classes
			// remove all Layout classes from pane-element
			$P	.removeClass( classes.join(" ") ) // remove ALL pane-classes
				.removeData("parentLayout")
				.removeData("layoutPane")
				.removeData("layoutRole")
				.removeData("layoutEdge")
				.removeData("autoHidden")	// in case set
				.unbind("."+ sID) // remove ALL Layout events
				// TODO: remove these extra unbind commands when jQuery is fixed
				//.unbind("mouseenter"+ sID)
				//.unbind("mouseleave"+ sID)
			;
			// do NOT reset CSS if this pane/content is STILL the container of a nested layout!
			// the nested layout will reset its 'container' CSS when/if it is destroyed
			if (hasChildren && $C) {
				// a content-div may not have a specific width, so give it one to contain the Layout
				$C.width( $C.width() );
				$.each( pC, function (key, child) {
					child.resizeAll(); // resize the Layout
				});
			}
			else if ($C)
				$C.css( $C.data(css) ).removeData(css).removeData("layoutRole");
			// remove pane AFTER content in case there was a nested layout
			if (!$P.data(d))
				$P.css( $P.data(css) ).removeData(css);
		}

		// REMOVE pane resizer and toggler elements
		if ($T) $T.remove();
		if ($R) $R.remove();

		// CLEAR all pointers and state data
		Instance[pane] = $Ps[pane] = $Cs[pane] = $Rs[pane] = $Ts[pane] = false;
		s = { removed: true };

		if (!skipResize)
			resizeAll();
	}


/*
 * ###########################
 *	   ACTION METHODS
 * ###########################
 */

	/**
	* @param {string}	pane
	*/
,	_hidePane = function (pane) {
		var $P	= $Ps[pane]
		,	o	= options[pane]
		,	s	= $P[0].style
		;
		if (o.useOffscreenClose) {
			if (!$P.data(_c.offscreenReset))
				$P.data(_c.offscreenReset, { left: s.left, right: s.right });
			$P.css( _c.offscreenCSS );
		}
		else
			$P.hide().removeData(_c.offscreenReset);
	}

	/**
	* @param {string}	pane
	*/
,	_showPane = function (pane) {
		var $P	= $Ps[pane]
		,	o	= options[pane]
		,	off	= _c.offscreenCSS
		,	old	= $P.data(_c.offscreenReset)
		,	s	= $P[0].style
		;
		$P	.show() // ALWAYS show, just in case
			.removeData(_c.offscreenReset);
		if (o.useOffscreenClose && old) {
			if (s.left == off.left)
				s.left = old.left;
			if (s.right == off.right)
				s.right = old.right;
		}
	}


	/**
	* Completely 'hides' a pane, including its spacing - as if it does not exist
	* The pane is not actually 'removed' from the source, so can use 'show' to un-hide it
	*
	* @param {(string|Object)}	evt_or_pane			The pane being hidden, ie: north, south, east, or west
	* @param {boolean=}			[noAnimation=false]	
	*/
,	hide = function (evt_or_pane, noAnimation) {
		if (!isInitialized()) return;
		var	pane = evtPane.call(this, evt_or_pane)
		,	o	= options[pane]
		,	s	= state[pane]
		,	$P	= $Ps[pane]
		,	$R	= $Rs[pane]
		;
		if (!$P || s.isHidden) return; // pane does not exist OR is already hidden

		// onhide_start callback - will CANCEL hide if returns false
		if (state.initialized && false === _runCallbacks("onhide_start", pane)) return;

		s.isSliding = false; // just in case
		delete state.panesSliding[pane];

		// now hide the elements
		if ($R) $R.hide(); // hide resizer-bar
		if (!state.initialized || s.isClosed) {
			s.isClosed = true; // to trigger open-animation on show()
			s.isHidden  = true;
			s.isVisible = false;
			if (!state.initialized)
				_hidePane(pane); // no animation when loading page
			sizeMidPanes(_c[pane].dir === "horz" ? "" : "center");
			if (state.initialized || o.triggerEventsOnLoad)
				_runCallbacks("onhide_end", pane);
		}
		else {
			s.isHiding = true; // used by onclose
			close(pane, false, noAnimation); // adjust all panes to fit
		}
	}

	/**
	* Show a hidden pane - show as 'closed' by default unless openPane = true
	*
	* @param {(string|Object)}	evt_or_pane			The pane being opened, ie: north, south, east, or west
	* @param {boolean=}			[openPane=false]
	* @param {boolean=}			[noAnimation=false]
	* @param {boolean=}			[noAlert=false]
	*/
,	show = function (evt_or_pane, openPane, noAnimation, noAlert) {
		if (!isInitialized()) return;
		var	pane = evtPane.call(this, evt_or_pane)
		,	o	= options[pane]
		,	s	= state[pane]
		,	$P	= $Ps[pane]
		,	$R	= $Rs[pane]
		;
		if (!$P || !s.isHidden) return; // pane does not exist OR is not hidden

		// onshow_start callback - will CANCEL show if returns false
		if (false === _runCallbacks("onshow_start", pane)) return;

		s.isShowing = true; // used by onopen/onclose
		//s.isHidden  = false; - will be set by open/close - if not cancelled
		s.isSliding = false; // just in case
		delete state.panesSliding[pane];

		// now show the elements
		//if ($R) $R.show(); - will be shown by open/close
		if (openPane === false)
			close(pane, true); // true = force
		else
			open(pane, false, noAnimation, noAlert); // adjust all panes to fit
	}


	/**
	* Toggles a pane open/closed by calling either open or close
	*
	* @param {(string|Object)}	evt_or_pane		The pane being toggled, ie: north, south, east, or west
	* @param {boolean=}			[slide=false]
	*/
,	toggle = function (evt_or_pane, slide) {
		if (!isInitialized()) return;
		var	evt		= evtObj(evt_or_pane)
		,	pane	= evtPane.call(this, evt_or_pane)
		,	s		= state[pane]
		;
		if (evt) // called from to $R.dblclick OR triggerPaneEvent
			evt.stopImmediatePropagation();
		if (s.isHidden)
			show(pane); // will call 'open' after unhiding it
		else if (s.isClosed)
			open(pane, !!slide);
		else
			close(pane);
	}


	/**
	* Utility method used during init or other auto-processes
	*
	* @param {string}	pane   The pane being closed
	* @param {boolean=}	[setHandles=false]
	*/
,	_closePane = function (pane, setHandles) {
		var
			$P	= $Ps[pane]
		,	s	= state[pane]
		;
		_hidePane(pane);
		s.isClosed = true;
		s.isVisible = false;
		if (setHandles) setAsClosed(pane);
	}

	/**
	* Close the specified pane (animation optional), and resize all other panes as needed
	*
	* @param {(string|Object)}	evt_or_pane			The pane being closed, ie: north, south, east, or west
	* @param {boolean=}			[force=false]
	* @param {boolean=}			[noAnimation=false]
	* @param {boolean=}			[skipCallback=false]
	*/
,	close = function (evt_or_pane, force, noAnimation, skipCallback) {
		var	pane = evtPane.call(this, evt_or_pane);
		// if pane has been initialized, but NOT the complete layout, close pane instantly
		if (!state.initialized && $Ps[pane]) {
			_closePane(pane, true); // INIT pane as closed
			return;
		}
		if (!isInitialized()) return;

		var
			$P	= $Ps[pane]
		,	$R	= $Rs[pane]
		,	$T	= $Ts[pane]
		,	o	= options[pane]
		,	s	= state[pane]
		,	c	= _c[pane]
		,	doFX, isShowing, isHiding, wasSliding;

		// QUEUE in case another action/animation is in progress
		$N.queue(function( queueNext ){

			if ( !$P
			||	(!o.closable && !s.isShowing && !s.isHiding)	// invalid request // (!o.resizable && !o.closable) ???
			||	(!force && s.isClosed && !s.isShowing)			// already closed
			) return queueNext();

			// onclose_start callback - will CANCEL hide if returns false
			// SKIP if just 'showing' a hidden pane as 'closed'
			var abort = !s.isShowing && false === _runCallbacks("onclose_start", pane);

			// transfer logic vars to temp vars
			isShowing	= s.isShowing;
			isHiding	= s.isHiding;
			wasSliding	= s.isSliding;
			// now clear the logic vars (REQUIRED before aborting)
			delete s.isShowing;
			delete s.isHiding;

			if (abort) return queueNext();

			doFX		= !noAnimation && !s.isClosed && (o.fxName_close != "none");
			s.isMoving	= true;
			s.isClosed	= true;
			s.isVisible	= false;
			// update isHidden BEFORE sizing panes
			if (isHiding) s.isHidden = true;
			else if (isShowing) s.isHidden = false;

			if (s.isSliding) // pane is being closed, so UNBIND trigger events
				bindStopSlidingEvents(pane, false); // will set isSliding=false
			else // resize panes adjacent to this one
				sizeMidPanes(_c[pane].dir === "horz" ? "" : "center", false); // false = NOT skipCallback

			// if this pane has a resizer bar, move it NOW - before animation
			setAsClosed(pane);

			// CLOSE THE PANE
			if (doFX) { // animate the close
				lockPaneForFX(pane, true);	// need to set left/top so animation will work
				$P.hide( o.fxName_close, o.fxSettings_close, o.fxSpeed_close, function () {
					lockPaneForFX(pane, false); // undo
					if (s.isClosed) close_2();
					queueNext();
				});
			}
			else { // hide the pane without animation
				_hidePane(pane);
				close_2();
				queueNext();
			};
		});

		// SUBROUTINE
		function close_2 () {
			s.isMoving	= false;
			bindStartSlidingEvents(pane, true); // will enable if o.slidable = true

			// if opposite-pane was autoClosed, see if it can be autoOpened now
			var altPane = _c.oppositeEdge[pane];
			if (state[ altPane ].noRoom) {
				setSizeLimits( altPane );
				makePaneFit( altPane );
			}

			if (!skipCallback && (state.initialized || o.triggerEventsOnLoad)) {
				// onclose callback - UNLESS just 'showing' a hidden pane as 'closed'
				if (!isShowing)	_runCallbacks("onclose_end", pane);
				// onhide OR onshow callback
				if (isShowing)	_runCallbacks("onshow_end", pane);
				if (isHiding)	_runCallbacks("onhide_end", pane);
			}
		}
	}

	/**
	* @param {string}	pane	The pane just closed, ie: north, south, east, or west
	*/
,	setAsClosed = function (pane) {
		if (!$Rs[pane]) return; // handles not initialized yet!
		var
			$P		= $Ps[pane]
		,	$R		= $Rs[pane]
		,	$T		= $Ts[pane]
		,	o		= options[pane]
		,	s		= state[pane]
		,	side	= _c[pane].side
		,	rClass	= o.resizerClass
		,	tClass	= o.togglerClass
		,	_pane	= "-"+ pane // used for classNames
		,	_open	= "-open"
		,	_sliding= "-sliding"
		,	_closed	= "-closed"
		;
		$R
			.css(side, sC.inset[side]) // move the resizer
			.removeClass( rClass+_open +" "+ rClass+_pane+_open )
			.removeClass( rClass+_sliding +" "+ rClass+_pane+_sliding )
			.addClass( rClass+_closed +" "+ rClass+_pane+_closed )
		;
		// DISABLE 'resizing' when closed - do this BEFORE bindStartSlidingEvents?
		if (o.resizable && $.layout.plugins.draggable)
			$R
				.draggable("disable")
				.removeClass("ui-state-disabled") // do NOT apply disabled styling - not suitable here
				.css("cursor", "default")
				.attr("title","")
			;

		// if pane has a toggler button, adjust that too
		if ($T) {
			$T
				.removeClass( tClass+_open +" "+ tClass+_pane+_open )
				.addClass( tClass+_closed +" "+ tClass+_pane+_closed )
				.attr("title", o.tips.Open) // may be blank
			;
			// toggler-content - if exists
			$T.children(".content-open").hide();
			$T.children(".content-closed").css("display","block");
		}

		// sync any 'pin buttons'
		syncPinBtns(pane, false);

		if (state.initialized) {
			// resize 'length' and position togglers for adjacent panes
			sizeHandles();
		}
	}

	/**
	* Open the specified pane (animation optional), and resize all other panes as needed
	*
	* @param {(string|Object)}	evt_or_pane			The pane being opened, ie: north, south, east, or west
	* @param {boolean=}			[slide=false]
	* @param {boolean=}			[noAnimation=false]
	* @param {boolean=}			[noAlert=false]
	*/
,	open = function (evt_or_pane, slide, noAnimation, noAlert) {
		if (!isInitialized()) return;
		var	pane = evtPane.call(this, evt_or_pane)
		,	$P	= $Ps[pane]
		,	$R	= $Rs[pane]
		,	$T	= $Ts[pane]
		,	o	= options[pane]
		,	s	= state[pane]
		,	c	= _c[pane]
		,	doFX, isShowing
		;
		// QUEUE in case another action/animation is in progress
		$N.queue(function( queueNext ){

			if ( !$P
			||	(!o.resizable && !o.closable && !s.isShowing)	// invalid request
			||	(s.isVisible && !s.isSliding)					// already open
			) return queueNext();

			// pane can ALSO be unhidden by just calling show(), so handle this scenario
			if (s.isHidden && !s.isShowing) {
				queueNext(); // call before show() because it needs the queue free
				show(pane, true);
				return;
			}

			if (s.autoResize && s.size != o.size) // resize pane to original size set in options
				sizePane(pane, o.size, true, true, true); // true=skipCallback/noAnimation/forceResize
			else
				// make sure there is enough space available to open the pane
				setSizeLimits(pane, slide);

			// onopen_start callback - will CANCEL open if returns false
			var cbReturn = _runCallbacks("onopen_start", pane);

			if (cbReturn === "abort")
				return queueNext();

			// update pane-state again in case options were changed in onopen_start
			if (cbReturn !== "NC") // NC = "No Callback"
				setSizeLimits(pane, slide);

			if (s.minSize > s.maxSize) { // INSUFFICIENT ROOM FOR PANE TO OPEN!
				syncPinBtns(pane, false); // make sure pin-buttons are reset
				if (!noAlert && o.tips.noRoomToOpen)
					alert(o.tips.noRoomToOpen);
				return queueNext(); // ABORT
			}

			if (slide) // START Sliding - will set isSliding=true
				bindStopSlidingEvents(pane, true); // BIND trigger events to close sliding-pane
			else if (s.isSliding) // PIN PANE (stop sliding) - open pane 'normally' instead
				bindStopSlidingEvents(pane, false); // UNBIND trigger events - will set isSliding=false
			else if (o.slidable)
				bindStartSlidingEvents(pane, false); // UNBIND trigger events

			s.noRoom = false; // will be reset by makePaneFit if 'noRoom'
			makePaneFit(pane);

			// transfer logic var to temp var
			isShowing = s.isShowing;
			// now clear the logic var
			delete s.isShowing;

			doFX		= !noAnimation && s.isClosed && (o.fxName_open != "none");
			s.isMoving	= true;
			s.isVisible	= true;
			s.isClosed	= false;
			// update isHidden BEFORE sizing panes - WHY??? Old?
			if (isShowing) s.isHidden = false;

			if (doFX) { // ANIMATE
				// mask adjacent panes with objects
				lockPaneForFX(pane, true);	// need to set left/top so animation will work
					$P.show( o.fxName_open, o.fxSettings_open, o.fxSpeed_open, function() {
					lockPaneForFX(pane, false); // undo
					if (s.isVisible) open_2(); // continue
					queueNext();
				});
			}
			else { // no animation
				_showPane(pane);// just show pane and...
				open_2();		// continue
				queueNext();
			};
		});

		// SUBROUTINE
		function open_2 () {
			s.isMoving	= false;

			// cure iframe display issues
			_fixIframe(pane);

			// NOTE: if isSliding, then other panes are NOT 'resized'
			if (!s.isSliding) { // resize all panes adjacent to this one
				sizeMidPanes(_c[pane].dir=="vert" ? "center" : "", false); // false = NOT skipCallback
			}

			// set classes, position handles and execute callbacks...
			setAsOpen(pane);
		};
	
	}

	/**
	* @param {string}	pane		The pane just opened, ie: north, south, east, or west
	* @param {boolean=}	[skipCallback=false]
	*/
,	setAsOpen = function (pane, skipCallback) {
		var 
			$P		= $Ps[pane]
		,	$R		= $Rs[pane]
		,	$T		= $Ts[pane]
		,	o		= options[pane]
		,	s		= state[pane]
		,	side	= _c[pane].side
		,	rClass	= o.resizerClass
		,	tClass	= o.togglerClass
		,	_pane	= "-"+ pane // used for classNames
		,	_open	= "-open"
		,	_closed	= "-closed"
		,	_sliding= "-sliding"
		;
		$R
			.css(side, sC.inset[side] + getPaneSize(pane)) // move the resizer
			.removeClass( rClass+_closed +" "+ rClass+_pane+_closed )
			.addClass( rClass+_open +" "+ rClass+_pane+_open )
		;
		if (s.isSliding)
			$R.addClass( rClass+_sliding +" "+ rClass+_pane+_sliding )
		else // in case 'was sliding'
			$R.removeClass( rClass+_sliding +" "+ rClass+_pane+_sliding )

		removeHover( 0, $R ); // remove hover classes
		if (o.resizable && $.layout.plugins.draggable)
			$R	.draggable("enable")
				.css("cursor", o.resizerCursor)
				.attr("title", o.tips.Resize);
		else if (!s.isSliding)
			$R.css("cursor", "default"); // n-resize, s-resize, etc

		// if pane also has a toggler button, adjust that too
		if ($T) {
			$T	.removeClass( tClass+_closed +" "+ tClass+_pane+_closed )
				.addClass( tClass+_open +" "+ tClass+_pane+_open )
				.attr("title", o.tips.Close); // may be blank
			removeHover( 0, $T ); // remove hover classes
			// toggler-content - if exists
			$T.children(".content-closed").hide();
			$T.children(".content-open").css("display","block");
		}

		// sync any 'pin buttons'
		syncPinBtns(pane, !s.isSliding);

		// update pane-state dimensions - BEFORE resizing content
		$.extend(s, elDims($P));

		if (state.initialized) {
			// resize resizer & toggler sizes for all panes
			sizeHandles();
			// resize content every time pane opens - to be sure
			sizeContent(pane, true); // true = remeasure headers/footers, even if 'pane.isMoving'
		}

		if (!skipCallback && (state.initialized || o.triggerEventsOnLoad) && $P.is(":visible")) {
			// onopen callback
			_runCallbacks("onopen_end", pane);
			// onshow callback - TODO: should this be here?
			if (s.isShowing) _runCallbacks("onshow_end", pane);

			// ALSO call onresize because layout-size *may* have changed while pane was closed
			if (state.initialized)
				_runCallbacks("onresize_end", pane);
		}

		// TODO: Somehow sizePane("north") is being called after this point???
	}


	/**
	* slideOpen / slideClose / slideToggle
	*
	* Pass-though methods for sliding
	*/
,	slideOpen = function (evt_or_pane) {
		if (!isInitialized()) return;
		var	evt		= evtObj(evt_or_pane)
		,	pane	= evtPane.call(this, evt_or_pane)
		,	s		= state[pane]
		,	delay	= options[pane].slideDelay_open
		;
		// prevent event from triggering on NEW resizer binding created below
		if (evt) evt.stopImmediatePropagation();

		if (s.isClosed && evt && evt.type === "mouseenter" && delay > 0)
			// trigger = mouseenter - use a delay
			timer.set(pane+"_openSlider", open_NOW, delay);
		else
			open_NOW(); // will unbind events if is already open

		/**
		* SUBROUTINE for timed open
		*/
		function open_NOW () {
			if (!s.isClosed) // skip if no longer closed!
				bindStopSlidingEvents(pane, true); // BIND trigger events to close sliding-pane
			else if (!s.isMoving)
				open(pane, true); // true = slide - open() will handle binding
		};
	}

,	slideClose = function (evt_or_pane) {
		if (!isInitialized()) return;
		var	evt		= evtObj(evt_or_pane)
		,	pane	= evtPane.call(this, evt_or_pane)
		,	o		= options[pane]
		,	s		= state[pane]
		,	delay	= s.isMoving ? 1000 : 300 // MINIMUM delay - option may override
		;
		if (s.isClosed || s.isResizing)
			return; // skip if already closed OR in process of resizing
		else if (o.slideTrigger_close === "click")
			close_NOW(); // close immediately onClick
		else if (o.preventQuickSlideClose && s.isMoving)
			return; // handle Chrome quick-close on slide-open
		else if (o.preventPrematureSlideClose && evt && $.layout.isMouseOverElem(evt, $Ps[pane]))
			return; // handle incorrect mouseleave trigger, like when over a SELECT-list in IE
		else if (evt) // trigger = mouseleave - use a delay
			// 1 sec delay if 'opening', else .3 sec
			timer.set(pane+"_closeSlider", close_NOW, max(o.slideDelay_close, delay));
		else // called programically
			close_NOW();

		/**
		* SUBROUTINE for timed close
		*/
		function close_NOW () {
			if (s.isClosed) // skip 'close' if already closed!
				bindStopSlidingEvents(pane, false); // UNBIND trigger events - TODO: is this needed here?
			else if (!s.isMoving)
				close(pane); // close will handle unbinding
		};
	}

	/**
	* @param {(string|Object)}	evt_or_pane		The pane being opened, ie: north, south, east, or west
	*/
,	slideToggle = function (evt_or_pane) {
		var pane = evtPane.call(this, evt_or_pane);
		toggle(pane, true);
	}


	/**
	* Must set left/top on East/South panes so animation will work properly
	*
	* @param {string}	pane	The pane to lock, 'east' or 'south' - any other is ignored!
	* @param {boolean}	doLock  true = set left/top, false = remove
	*/
,	lockPaneForFX = function (pane, doLock) {
		var $P	= $Ps[pane]
		,	s	= state[pane]
		,	o	= options[pane]
		,	z	= options.zIndexes
		;
		if (doLock) {
			showMasks( pane, { animation: true, objectsOnly: true });
			$P.css({ zIndex: z.pane_animate }); // overlay all elements during animation
			if (pane=="south")
				$P.css({ top: sC.inset.top + sC.innerHeight - $P.outerHeight() });
			else if (pane=="east")
				$P.css({ left: sC.inset.left + sC.innerWidth - $P.outerWidth() });
		}
		else { // animation DONE - RESET CSS
			hideMasks();
			$P.css({ zIndex: (s.isSliding ? z.pane_sliding : z.pane_normal) });
			if (pane=="south")
				$P.css({ top: "auto" });
			// if pane is positioned 'off-screen', then DO NOT screw with it!
			else if (pane=="east" && !$P.css("left").match(/\-99999/))
				$P.css({ left: "auto" });
			// fix anti-aliasing in IE - only needed for animations that change opacity
			if (browser.msie && o.fxOpacityFix && o.fxName_open != "slide" && $P.css("filter") && $P.css("opacity") == 1)
				$P[0].style.removeAttribute('filter');
		}
	}


	/**
	* Toggle sliding functionality of a specific pane on/off by adding removing 'slide open' trigger
	*
	* @see  open(), close()
	* @param {string}	pane	The pane to enable/disable, 'north', 'south', etc.
	* @param {boolean}	enable	Enable or Disable sliding?
	*/
,	bindStartSlidingEvents = function (pane, enable) {
		var o		= options[pane]
		,	$P		= $Ps[pane]
		,	$R		= $Rs[pane]
		,	evtName	= o.slideTrigger_open.toLowerCase()
		;
		if (!$R || (enable && !o.slidable)) return;

		// make sure we have a valid event
		if (evtName.match(/mouseover/))
			evtName = o.slideTrigger_open = "mouseenter";
		else if (!evtName.match(/(click|dblclick|mouseenter)/)) 
			evtName = o.slideTrigger_open = "click";

		// must remove double-click-toggle when using dblclick-slide
		if (o.resizerDblClickToggle && evtName.match(/click/)) {
			$R[enable ? "unbind" : "bind"]('dblclick.'+ sID, toggle)
		}

		$R
			// add or remove event
			[enable ? "bind" : "unbind"](evtName +'.'+ sID, slideOpen)
			// set the appropriate cursor & title/tip
			.css("cursor", enable ? o.sliderCursor : "default")
			.attr("title", enable ? o.tips.Slide : "")
		;
	}

	/**
	* Add or remove 'mouseleave' events to 'slide close' when pane is 'sliding' open or closed
	* Also increases zIndex when pane is sliding open
	* See bindStartSlidingEvents for code to control 'slide open'
	*
	* @see  slideOpen(), slideClose()
	* @param {string}	pane	The pane to process, 'north', 'south', etc.
	* @param {boolean}	enable	Enable or Disable events?
	*/
,	bindStopSlidingEvents = function (pane, enable) {
		var	o		= options[pane]
		,	s		= state[pane]
		,	c		= _c[pane]
		,	z		= options.zIndexes
		,	evtName	= o.slideTrigger_close.toLowerCase()
		,	action	= (enable ? "bind" : "unbind")
		,	$P		= $Ps[pane]
		,	$R		= $Rs[pane]
		;
		timer.clear(pane+"_closeSlider"); // just in case

		if (enable) {
			s.isSliding = true;
			state.panesSliding[pane] = true;
			// remove 'slideOpen' event from resizer
			// ALSO will raise the zIndex of the pane & resizer
			bindStartSlidingEvents(pane, false);
		}
		else {
			s.isSliding = false;
			delete state.panesSliding[pane];
		}

		// RE/SET zIndex - increases when pane is sliding-open, resets to normal when not
		$P.css("zIndex", enable ? z.pane_sliding : z.pane_normal);
		$R.css("zIndex", enable ? z.pane_sliding+2 : z.resizer_normal); // NOTE: mask = pane_sliding+1

		// make sure we have a valid event
		if (!evtName.match(/(click|mouseleave)/))
			evtName = o.slideTrigger_close = "mouseleave"; // also catches 'mouseout'

		// add/remove slide triggers
		$R[action](evtName, slideClose); // base event on resize
		// need extra events for mouseleave
		if (evtName === "mouseleave") {
			// also close on pane.mouseleave
			$P[action]("mouseleave."+ sID, slideClose);
			// cancel timer when mouse moves between 'pane' and 'resizer'
			$R[action]("mouseenter."+ sID, cancelMouseOut);
			$P[action]("mouseenter."+ sID, cancelMouseOut);
		}

		if (!enable)
			timer.clear(pane+"_closeSlider");
		else if (evtName === "click" && !o.resizable) {
			// IF pane is not resizable (which already has a cursor and tip) 
			// then set the a cursor & title/tip on resizer when sliding
			$R.css("cursor", enable ? o.sliderCursor : "default");
			$R.attr("title", enable ? o.tips.Close : ""); // use Toggler-tip, eg: "Close Pane"
		}

		// SUBROUTINE for mouseleave timer clearing
		function cancelMouseOut (evt) {
			timer.clear(pane+"_closeSlider");
			evt.stopPropagation();
		}
	}


	/**
	* Hides/closes a pane if there is insufficient room - reverses this when there is room again
	* MUST have already called setSizeLimits() before calling this method
	*
	* @param {string}	pane					The pane being resized
	* @param {boolean=}	[isOpening=false]		Called from onOpen?
	* @param {boolean=}	[skipCallback=false]	Should the onresize callback be run?
	* @param {boolean=}	[force=false]
	*/
,	makePaneFit = function (pane, isOpening, skipCallback, force) {
		var	o	= options[pane]
		,	s	= state[pane]
		,	c	= _c[pane]
		,	$P	= $Ps[pane]
		,	$R	= $Rs[pane]
		,	isSidePane 	= c.dir==="vert"
		,	hasRoom		= false
		;
		// special handling for center & east/west panes
		if (pane === "center" || (isSidePane && s.noVerticalRoom)) {
			// see if there is enough room to display the pane
			// ERROR: hasRoom = s.minHeight <= s.maxHeight && (isSidePane || s.minWidth <= s.maxWidth);
			hasRoom = (s.maxHeight >= 0);
			if (hasRoom && s.noRoom) { // previously hidden due to noRoom, so show now
				_showPane(pane);
				if ($R) $R.show();
				s.isVisible = true;
				s.noRoom = false;
				if (isSidePane) s.noVerticalRoom = false;
				_fixIframe(pane);
			}
			else if (!hasRoom && !s.noRoom) { // not currently hidden, so hide now
				_hidePane(pane);
				if ($R) $R.hide();
				s.isVisible = false;
				s.noRoom = true;
			}
		}

		// see if there is enough room to fit the border-pane
		if (pane === "center") {
			// ignore center in this block
		}
		else if (s.minSize <= s.maxSize) { // pane CAN fit
			hasRoom = true;
			if (s.size > s.maxSize) // pane is too big - shrink it
				sizePane(pane, s.maxSize, skipCallback, true, force); // true = noAnimation
			else if (s.size < s.minSize) // pane is too small - enlarge it
				sizePane(pane, s.minSize, skipCallback, true, force); // true = noAnimation
			// need s.isVisible because new pseudoClose method keeps pane visible, but off-screen
			else if ($R && s.isVisible && $P.is(":visible")) {
				// make sure resizer-bar is positioned correctly
				// handles situation where nested layout was 'hidden' when initialized
				var	pos = s.size + sC.inset[c.side];
				if ($.layout.cssNum( $R, c.side ) != pos) $R.css( c.side, pos );
			}

			// if was previously hidden due to noRoom, then RESET because NOW there is room
			if (s.noRoom) {
				// s.noRoom state will be set by open or show
				if (s.wasOpen && o.closable) {
					if (o.autoReopen)
						open(pane, false, true, true); // true = noAnimation, true = noAlert
					else // leave the pane closed, so just update state
						s.noRoom = false;
				}
				else
					show(pane, s.wasOpen, true, true); // true = noAnimation, true = noAlert
			}
		}
		else { // !hasRoom - pane CANNOT fit
			if (!s.noRoom) { // pane not set as noRoom yet, so hide or close it now...
				s.noRoom = true; // update state
				s.wasOpen = !s.isClosed && !s.isSliding;
				if (s.isClosed){} // SKIP
				else if (o.closable) // 'close' if possible
					close(pane, true, true); // true = force, true = noAnimation
				else // 'hide' pane if cannot just be closed
					hide(pane, true); // true = noAnimation
			}
		}
	}


	/**
	* manualSizePane is an exposed flow-through method allowing extra code when pane is 'manually resized'
	*
	* @param {(string|Object)}	evt_or_pane				The pane being resized
	* @param {number}			size					The *desired* new size for this pane - will be validated
	* @param {boolean=}			[skipCallback=false]	Should the onresize callback be run?
	* @param {boolean=}			[noAnimation=false]
	* @param {boolean=}			[force=false]			Force resizing even if does not seem necessary
	*/
,	manualSizePane = function (evt_or_pane, size, skipCallback, noAnimation, force) {
		if (!isInitialized()) return;
		var	pane = evtPane.call(this, evt_or_pane)
		,	o	= options[pane]
		,	s	= state[pane]
		//	if resizing callbacks have been delayed and resizing is now DONE, force resizing to complete...
		,	forceResize = force || (o.livePaneResizing && !s.isResizing)
		;
		// ANY call to manualSizePane disables autoResize - ie, percentage sizing
		s.autoResize = false;
		// flow-through...
		sizePane(pane, size, skipCallback, noAnimation, forceResize); // will animate resize if option enabled
	}

	/**
	* sizePane is called only by internal methods whenever a pane needs to be resized
	*
	* @param {(string|Object)}	evt_or_pane				The pane being resized
	* @param {number}			size					The *desired* new size for this pane - will be validated
	* @param {boolean=}			[skipCallback=false]	Should the onresize callback be run?
	* @param {boolean=}			[noAnimation=false]
	* @param {boolean=}			[force=false]			Force resizing even if does not seem necessary
	*/
,	sizePane = function (evt_or_pane, size, skipCallback, noAnimation, force) {
		if (!isInitialized()) return;
		var	pane	= evtPane.call(this, evt_or_pane) // probably NEVER called from event?
		,	o		= options[pane]
		,	s		= state[pane]
		,	$P		= $Ps[pane]
		,	$R		= $Rs[pane]
		,	side	= _c[pane].side
		,	dimName	= _c[pane].sizeType.toLowerCase()
		,	skipResizeWhileDragging = s.isResizing && !o.triggerEventsDuringLiveResize
		,	doFX	= noAnimation !== true && o.animatePaneSizing
		,	oldSize, newSize
		;
		// QUEUE in case another action/animation is in progress
		$N.queue(function( queueNext ){
			// calculate 'current' min/max sizes
			setSizeLimits(pane); // update pane-state
			oldSize = s.size;
			size = _parseSize(pane, size); // handle percentages & auto
			size = max(size, _parseSize(pane, o.minSize));
			size = min(size, s.maxSize);
			if (size < s.minSize) { // not enough room for pane!
				queueNext(); // call before makePaneFit() because it needs the queue free
				makePaneFit(pane, false, skipCallback);	// will hide or close pane
				return;
			}

			// IF newSize is same as oldSize, then nothing to do - abort
			if (!force && size === oldSize)
				return queueNext();

			s.newSize = size;

			// onresize_start callback CANNOT cancel resizing because this would break the layout!
			if (!skipCallback && state.initialized && s.isVisible)
				_runCallbacks("onresize_start", pane);

			// resize the pane, and make sure its visible
			newSize = cssSize(pane, size);

			if (doFX && $P.is(":visible")) { // ANIMATE
				var fx		= $.layout.effects.size[pane] || $.layout.effects.size.all
				,	easing	= o.fxSettings_size.easing || fx.easing
				,	z		= options.zIndexes
				,	props	= {};
				props[ dimName ] = newSize +'px';
				s.isMoving = true;
				// overlay all elements during animation
				$P.css({ zIndex: z.pane_animate })
				  .show().animate( props, o.fxSpeed_size, easing, function(){
					// reset zIndex after animation
					$P.css({ zIndex: (s.isSliding ? z.pane_sliding : z.pane_normal) });
					s.isMoving = false;
					delete s.newSize;
					sizePane_2(); // continue
					queueNext();
				});
			}
			else { // no animation
				$P.css( dimName, newSize );	// resize pane
				delete s.newSize;
				// if pane is visible, then 
				if ($P.is(":visible"))
					sizePane_2(); // continue
				else {
					// pane is NOT VISIBLE, so just update state data...
					// when pane is *next opened*, it will have the new size
					s.size = size;				// update state.size
					$.extend(s, elDims($P));	// update state dimensions
				}
				queueNext();
			};

		});

		// SUBROUTINE
		function sizePane_2 () {
			/*	Panes are sometimes not sized precisely in some browsers!?
			 *	This code will resize the pane up to 3 times to nudge the pane to the correct size
			 */
			var	actual	= dimName==='width' ? $P.outerWidth() : $P.outerHeight()
			,	tries	= [{
						   	pane:		pane
						,	count:		1
						,	target:		size
						,	actual:		actual
						,	correct:	(size === actual)
						,	attempt:	size
						,	cssSize:	newSize
						}]
			,	lastTry = tries[0]
			,	thisTry	= {}
			,	msg		= 'Inaccurate size after resizing the '+ pane +'-pane.'
			;
			while ( !lastTry.correct ) {
				thisTry = { pane: pane, count: lastTry.count+1, target: size };

				if (lastTry.actual > size)
					thisTry.attempt = max(0, lastTry.attempt - (lastTry.actual - size));
				else // lastTry.actual < size
					thisTry.attempt = max(0, lastTry.attempt + (size - lastTry.actual));

				thisTry.cssSize = cssSize(pane, thisTry.attempt);
				$P.css( dimName, thisTry.cssSize );

				thisTry.actual	= dimName=='width' ? $P.outerWidth() : $P.outerHeight();
				thisTry.correct	= (size === thisTry.actual);

				// log attempts and alert the user of this *non-fatal error* (if showDebugMessages)
				if ( tries.length === 1) {
					_log(msg, false, true);
					_log(lastTry, false, true);
				}
				_log(thisTry, false, true);
				// after 4 tries, is as close as its gonna get!
				if (tries.length > 3) break;

				tries.push( thisTry );
				lastTry = tries[ tries.length - 1 ];
			}
			// END TESTING CODE

			// update pane-state dimensions
			s.size	= size;
			$.extend(s, elDims($P));

			if (s.isVisible && $P.is(":visible")) {
				// reposition the resizer-bar
				if ($R) $R.css( side, size + sC.inset[side] );
				// resize the content-div
				sizeContent(pane);
			}

			if (!skipCallback && !skipResizeWhileDragging && state.initialized && s.isVisible)
				_runCallbacks("onresize_end", pane);

			// resize all the adjacent panes, and adjust their toggler buttons
			// when skipCallback passed, it means the controlling method will handle 'other panes'
			if (!skipCallback) {
				// also no callback if live-resize is in progress and NOT triggerEventsDuringLiveResize
				if (!s.isSliding) sizeMidPanes(_c[pane].dir=="horz" ? "" : "center", skipResizeWhileDragging, force);
				sizeHandles();
			}

			// if opposite-pane was autoClosed, see if it can be autoOpened now
			var altPane = _c.oppositeEdge[pane];
			if (size < oldSize && state[ altPane ].noRoom) {
				setSizeLimits( altPane );
				makePaneFit( altPane, false, skipCallback );
			}

			// DEBUG - ALERT user/developer so they know there was a sizing problem
			if (tries.length > 1)
				_log(msg +'\nSee the Error Console for details.', true, true);
		}
	}

	/**
	* @see  initPanes(), sizePane(), 	resizeAll(), open(), close(), hide()
	* @param {(Array.<string>|string)}	panes					The pane(s) being resized, comma-delmited string
	* @param {boolean=}					[skipCallback=false]	Should the onresize callback be run?
	* @param {boolean=}					[force=false]
	*/
,	sizeMidPanes = function (panes, skipCallback, force) {
		panes = (panes ? panes : "east,west,center").split(",");

		$.each(panes, function (i, pane) {
			if (!$Ps[pane]) return; // NO PANE - skip
			var 
				o		= options[pane]
			,	s		= state[pane]
			,	$P		= $Ps[pane]
			,	$R		= $Rs[pane]
			,	isCenter= (pane=="center")
			,	hasRoom	= true
			,	CSS		= {}
			//	if pane is not visible, show it invisibly NOW rather than for *each call* in this script
			,	visCSS	= $.layout.showInvisibly($P)

			,	newCenter	= calcNewCenterPaneDims()
			;

			// update pane-state dimensions
			$.extend(s, elDims($P));

			if (pane === "center") {
				if (!force && s.isVisible && newCenter.width === s.outerWidth && newCenter.height === s.outerHeight) {
					$P.css(visCSS);
					return true; // SKIP - pane already the correct size
				}
				// set state for makePaneFit() logic
				$.extend(s, cssMinDims(pane), {
					maxWidth:	newCenter.width
				,	maxHeight:	newCenter.height
				});
				CSS = newCenter;
				s.newWidth	= CSS.width;
				s.newHeight	= CSS.height;
				// convert OUTER width/height to CSS width/height 
				CSS.width	= cssW($P, CSS.width);
				// NEW - allow pane to extend 'below' visible area rather than hide it
				CSS.height	= cssH($P, CSS.height);
				hasRoom		= CSS.width >= 0 && CSS.height >= 0; // height >= 0 = ALWAYS TRUE NOW

				// during layout init, try to shrink east/west panes to make room for center
				if (!state.initialized && o.minWidth > newCenter.width) {
					var
						reqPx	= o.minWidth - s.outerWidth
					,	minE	= options.east.minSize || 0
					,	minW	= options.west.minSize || 0
					,	sizeE	= state.east.size
					,	sizeW	= state.west.size
					,	newE	= sizeE
					,	newW	= sizeW
					;
					if (reqPx > 0 && state.east.isVisible && sizeE > minE) {
						newE = max( sizeE-minE, sizeE-reqPx );
						reqPx -= sizeE-newE;
					}
					if (reqPx > 0 && state.west.isVisible && sizeW > minW) {
						newW = max( sizeW-minW, sizeW-reqPx );
						reqPx -= sizeW-newW;
					}
					// IF we found enough extra space, then resize the border panes as calculated
					if (reqPx === 0) {
						if (sizeE && sizeE != minE)
							sizePane('east', newE, true, true, force); // true = skipCallback/noAnimation - initPanes will handle when done
						if (sizeW && sizeW != minW)
							sizePane('west', newW, true, true, force); // true = skipCallback/noAnimation
						// now start over!
						sizeMidPanes('center', skipCallback, force);
						$P.css(visCSS);
						return; // abort this loop
					}
				}
			}
			else { // for east and west, set only the height, which is same as center height
				// set state.min/maxWidth/Height for makePaneFit() logic
				if (s.isVisible && !s.noVerticalRoom)
					$.extend(s, elDims($P), cssMinDims(pane))
				if (!force && !s.noVerticalRoom && newCenter.height === s.outerHeight) {
					$P.css(visCSS);
					return true; // SKIP - pane already the correct size
				}
				// east/west have same top, bottom & height as center
				CSS.top		= newCenter.top;
				CSS.bottom	= newCenter.bottom;
				s.newSize	= newCenter.height
				// NEW - allow pane to extend 'below' visible area rather than hide it
				CSS.height	= cssH($P, newCenter.height);
				s.maxHeight	= CSS.height;
				hasRoom		= (s.maxHeight >= 0); // ALWAYS TRUE NOW
				if (!hasRoom) s.noVerticalRoom = true; // makePaneFit() logic
			}

			if (hasRoom) {
				// resizeAll passes skipCallback because it triggers callbacks after ALL panes are resized
				if (!skipCallback && state.initialized)
					_runCallbacks("onresize_start", pane);

				$P.css(CSS); // apply the CSS to pane
				if (pane !== "center")
					sizeHandles(pane); // also update resizer length
				if (s.noRoom && !s.isClosed && !s.isHidden)
					makePaneFit(pane); // will re-open/show auto-closed/hidden pane
				if (s.isVisible) {
					$.extend(s, elDims($P)); // update pane dimensions
					if (state.initialized) sizeContent(pane); // also resize the contents, if exists
				}
			}
			else if (!s.noRoom && s.isVisible) // no room for pane
				makePaneFit(pane); // will hide or close pane

			// reset visibility, if necessary
			$P.css(visCSS);

			delete s.newSize;
			delete s.newWidth;
			delete s.newHeight;

			if (!s.isVisible)
				return true; // DONE - next pane

			/*
			* Extra CSS for IE6 or IE7 in Quirks-mode - add 'width' to NORTH/SOUTH panes
			* Normally these panes have only 'left' & 'right' positions so pane auto-sizes
			* ALSO required when pane is an IFRAME because will NOT default to 'full width'
			*	TODO: Can I use width:100% for a north/south iframe?
			*	TODO: Sounds like a job for $P.outerWidth( sC.innerWidth ) SETTER METHOD
			*/
			if (pane === "center") { // finished processing midPanes
				var fix = browser.isIE6 || !browser.boxModel;
				if ($Ps.north && (fix || state.north.tagName=="IFRAME")) 
					$Ps.north.css("width", cssW($Ps.north, sC.innerWidth));
				if ($Ps.south && (fix || state.south.tagName=="IFRAME"))
					$Ps.south.css("width", cssW($Ps.south, sC.innerWidth));
			}

			// resizeAll passes skipCallback because it triggers callbacks after ALL panes are resized
			if (!skipCallback && state.initialized)
				_runCallbacks("onresize_end", pane);
		});
	}


	/**
	* @see  window.onresize(), callbacks or custom code
	* @param {(Object|boolean)=}	evt_or_refresh	If 'true', then also reset pane-positioning
	*/
,	resizeAll = function (evt_or_refresh) {
		var	oldW	= sC.innerWidth
		,	oldH	= sC.innerHeight
		;
		// stopPropagation if called by trigger("layoutdestroy") - use evtPane utility 
		evtPane(evt_or_refresh);

		// cannot size layout when 'container' is hidden or collapsed
		if (!$N.is(":visible")) return;

		if (!state.initialized) {
			_initLayoutElements();
			return; // no need to resize since we just initialized!
		}

		if (evt_or_refresh === true && $.isPlainObject(options.outset)) {
			// update container CSS in case outset option has changed
			$N.css( options.outset );
		}
		// UPDATE container dimensions
		$.extend(sC, elDims( $N, options.inset ));
		if (!sC.outerHeight) return;

		// if 'true' passed, refresh pane & handle positioning too
		if (evt_or_refresh === true) {
			setPanePosition();
		}

		// onresizeall_start will CANCEL resizing if returns false
		// state.container has already been set, so user can access this info for calcuations
		if (false === _runCallbacks("onresizeall_start")) return false;

		var	// see if container is now 'smaller' than before
			shrunkH	= (sC.innerHeight < oldH)
		,	shrunkW	= (sC.innerWidth < oldW)
		,	$P, o, s
		;
		// NOTE special order for sizing: S-N-E-W
		$.each(["south","north","east","west"], function (i, pane) {
			if (!$Ps[pane]) return; // no pane - SKIP
			o = options[pane];
			s = state[pane];
			if (s.autoResize && s.size != o.size) // resize pane to original size set in options
				sizePane(pane, o.size, true, true, true); // true=skipCallback/noAnimation/forceResize
			else {
				setSizeLimits(pane);
				makePaneFit(pane, false, true, true); // true=skipCallback/forceResize
			}
		});

		sizeMidPanes("", true, true); // true=skipCallback/forceResize
		sizeHandles(); // reposition the toggler elements

		// trigger all individual pane callbacks AFTER layout has finished resizing
		$.each(_c.allPanes, function (i, pane) {
			$P = $Ps[pane];
			if (!$P) return; // SKIP
			if (state[pane].isVisible) // undefined for non-existent panes
				_runCallbacks("onresize_end", pane); // callback - if exists
		});

		_runCallbacks("onresizeall_end");
		//_triggerLayoutEvent(pane, 'resizeall');
	}

	/**
	* Whenever a pane resizes or opens that has a nested layout, trigger resizeAll
	*
	* @param {(string|Object)}	evt_or_pane		The pane just resized or opened
	*/
,	resizeChildren = function (evt_or_pane, skipRefresh) {
		var	pane = evtPane.call(this, evt_or_pane);

		if (!options[pane].resizeChildren) return;

		// ensure the pane-children are up-to-date
		if (!skipRefresh) refreshChildren( pane );
		var pC = children[pane];
		if ($.isPlainObject( pC )) {
			// resize one or more children
			$.each( pC, function (key, child) {
				if (!child.destroyed) child.resizeAll();
			});
		}
	}

	/**
	* IF pane has a content-div, then resize all elements inside pane to fit pane-height
	*
	* @param {(string|Object)}	evt_or_panes		The pane(s) being resized
	* @param {boolean=}			[remeasure=false]	Should the content (header/footer) be remeasured?
	*/
,	sizeContent = function (evt_or_panes, remeasure) {
		if (!isInitialized()) return;

		var panes = evtPane.call(this, evt_or_panes);
		panes = panes ? panes.split(",") : _c.allPanes;

		$.each(panes, function (idx, pane) {
			var
				$P	= $Ps[pane]
			,	$C	= $Cs[pane]
			,	o	= options[pane]
			,	s	= state[pane]
			,	m	= s.content // m = measurements
			;
			if (!$P || !$C || !$P.is(":visible")) return true; // NOT VISIBLE - skip

			// if content-element was REMOVED, update OR remove the pointer
			if (!$C.length) {
				initContent(pane, false);	// false = do NOT sizeContent() - already there!
				if (!$C) return;			// no replacement element found - pointer have been removed
			}

			// onsizecontent_start will CANCEL resizing if returns false
			if (false === _runCallbacks("onsizecontent_start", pane)) return;

			// skip re-measuring offsets if live-resizing
			if ((!s.isMoving && !s.isResizing) || o.liveContentResizing || remeasure || m.top == undefined) {
				_measure();
				// if any footers are below pane-bottom, they may not measure correctly,
				// so allow pane overflow and re-measure
				if (m.hiddenFooters > 0 && $P.css("overflow") === "hidden") {
					$P.css("overflow", "visible");
					_measure(); // remeasure while overflowing
					$P.css("overflow", "hidden");
				}
			}
			// NOTE: spaceAbove/Below *includes* the pane paddingTop/Bottom, but not pane.borders
			var newH = s.innerHeight - (m.spaceAbove - s.css.paddingTop) - (m.spaceBelow - s.css.paddingBottom);

			if (!$C.is(":visible") || m.height != newH) {
				// size the Content element to fit new pane-size - will autoHide if not enough room
				setOuterHeight($C, newH, true); // true=autoHide
				m.height = newH; // save new height
			};

			if (state.initialized)
				_runCallbacks("onsizecontent_end", pane);

			function _below ($E) {
				return max(s.css.paddingBottom, (parseInt($E.css("marginBottom"), 10) || 0));
			};

			function _measure () {
				var
					ignore	= options[pane].contentIgnoreSelector
				,	$Fs		= $C.nextAll().not(".ui-layout-mask").not(ignore || ":lt(0)") // not :lt(0) = ALL
				,	$Fs_vis	= $Fs.filter(':visible')
				,	$F		= $Fs_vis.filter(':last')
				;
				m = {
					top:			$C[0].offsetTop
				,	height:			$C.outerHeight()
				,	numFooters:		$Fs.length
				,	hiddenFooters:	$Fs.length - $Fs_vis.length
				,	spaceBelow:		0 // correct if no content footer ($E)
				}
					m.spaceAbove	= m.top; // just for state - not used in calc
					m.bottom		= m.top + m.height;
				if ($F.length)
					//spaceBelow = (LastFooter.top + LastFooter.height) [footerBottom] - Content.bottom + max(LastFooter.marginBottom, pane.paddingBotom)
					m.spaceBelow = ($F[0].offsetTop + $F.outerHeight()) - m.bottom + _below($F);
				else // no footer - check marginBottom on Content element itself
					m.spaceBelow = _below($C);
			};
		});
	}


	/**
	* Called every time a pane is opened, closed, or resized to slide the togglers to 'center' and adjust their length if necessary
	*
	* @see  initHandles(), open(), close(), resizeAll()
	* @param {(string|Object)=}		evt_or_panes	The pane(s) being resized
	*/
,	sizeHandles = function (evt_or_panes) {
		var panes = evtPane.call(this, evt_or_panes)
		panes = panes ? panes.split(",") : _c.borderPanes;

		$.each(panes, function (i, pane) {
			var 
				o	= options[pane]
			,	s	= state[pane]
			,	$P	= $Ps[pane]
			,	$R	= $Rs[pane]
			,	$T	= $Ts[pane]
			,	$TC
			;
			if (!$P || !$R) return;

			var
				dir			= _c[pane].dir
			,	_state		= (s.isClosed ? "_closed" : "_open")
			,	spacing		= o["spacing"+ _state]
			,	togAlign	= o["togglerAlign"+ _state]
			,	togLen		= o["togglerLength"+ _state]
			,	paneLen
			,	left
			,	offset
			,	CSS = {}
			;

			if (spacing === 0) {
				$R.hide();
				return;
			}
			else if (!s.noRoom && !s.isHidden) // skip if resizer was hidden for any reason
				$R.show(); // in case was previously hidden

			// Resizer Bar is ALWAYS same width/height of pane it is attached to
			if (dir === "horz") { // north/south
				//paneLen = $P.outerWidth(); // s.outerWidth || 
				paneLen = sC.innerWidth; // handle offscreen-panes
				s.resizerLength = paneLen;
				left = $.layout.cssNum($P, "left")
				$R.css({
					width:	cssW($R, paneLen) // account for borders & padding
				,	height:	cssH($R, spacing) // ditto
				,	left:	left > -9999 ? left : sC.inset.left // handle offscreen-panes
				});
			}
			else { // east/west
				paneLen = $P.outerHeight(); // s.outerHeight || 
				s.resizerLength = paneLen;
				$R.css({
					height:	cssH($R, paneLen) // account for borders & padding
				,	width:	cssW($R, spacing) // ditto
				,	top:	sC.inset.top + getPaneSize("north", true) // TODO: what if no North pane?
				//,	top:	$.layout.cssNum($Ps["center"], "top")
				});
			}

			// remove hover classes
			removeHover( o, $R );

			if ($T) {
				if (togLen === 0 || (s.isSliding && o.hideTogglerOnSlide)) {
					$T.hide(); // always HIDE the toggler when 'sliding'
					return;
				}
				else
					$T.show(); // in case was previously hidden

				if (!(togLen > 0) || togLen === "100%" || togLen > paneLen) {
					togLen = paneLen;
					offset = 0;
				}
				else { // calculate 'offset' based on options.PANE.togglerAlign_open/closed
					if (isStr(togAlign)) {
						switch (togAlign) {
							case "top":
							case "left":	offset = 0;
											break;
							case "bottom":
							case "right":	offset = paneLen - togLen;
											break;
							case "middle":
							case "center":
							default:		offset = round((paneLen - togLen) / 2); // 'default' catches typos
						}
					}
					else { // togAlign = number
						var x = parseInt(togAlign, 10); //
						if (togAlign >= 0) offset = x;
						else offset = paneLen - togLen + x; // NOTE: x is negative!
					}
				}

				if (dir === "horz") { // north/south
					var width = cssW($T, togLen);
					$T.css({
						width:	width  // account for borders & padding
					,	height:	cssH($T, spacing) // ditto
					,	left:	offset // TODO: VERIFY that toggler  positions correctly for ALL values
					,	top:	0
					});
					// CENTER the toggler content SPAN
					$T.children(".content").each(function(){
						$TC = $(this);
						$TC.css("marginLeft", round((width-$TC.outerWidth())/2)); // could be negative
					});
				}
				else { // east/west
					var height = cssH($T, togLen);
					$T.css({
						height:	height // account for borders & padding
					,	width:	cssW($T, spacing) // ditto
					,	top:	offset // POSITION the toggler
					,	left:	0
					});
					// CENTER the toggler content SPAN
					$T.children(".content").each(function(){
						$TC = $(this);
						$TC.css("marginTop", round((height-$TC.outerHeight())/2)); // could be negative
					});
				}

				// remove ALL hover classes
				removeHover( 0, $T );
			}

			// DONE measuring and sizing this resizer/toggler, so can be 'hidden' now
			if (!state.initialized && (o.initHidden || s.isHidden)) {
				$R.hide();
				if ($T) $T.hide();
			}
		});
	}


	/**
	* @param {(string|Object)}	evt_or_pane
	*/
,	enableClosable = function (evt_or_pane) {
		if (!isInitialized()) return;
		var	pane = evtPane.call(this, evt_or_pane)
		,	$T	= $Ts[pane]
		,	o	= options[pane]
		;
		if (!$T) return;
		o.closable = true;
		$T	.bind("click."+ sID, function(evt){ evt.stopPropagation(); toggle(pane); })
			.css("visibility", "visible")
			.css("cursor", "pointer")
			.attr("title", state[pane].isClosed ? o.tips.Open : o.tips.Close) // may be blank
			.show();
	}
	/**
	* @param {(string|Object)}	evt_or_pane
	* @param {boolean=}			[hide=false]
	*/
,	disableClosable = function (evt_or_pane, hide) {
		if (!isInitialized()) return;
		var	pane = evtPane.call(this, evt_or_pane)
		,	$T	= $Ts[pane]
		;
		if (!$T) return;
		options[pane].closable = false;
		// is closable is disable, then pane MUST be open!
		if (state[pane].isClosed) open(pane, false, true);
		$T	.unbind("."+ sID)
			.css("visibility", hide ? "hidden" : "visible") // instead of hide(), which creates logic issues
			.css("cursor", "default")
			.attr("title", "");
	}


	/**
	* @param {(string|Object)}	evt_or_pane
	*/
,	enableSlidable = function (evt_or_pane) {
		if (!isInitialized()) return;
		var	pane = evtPane.call(this, evt_or_pane)
		,	$R	= $Rs[pane]
		;
		if (!$R || !$R.data('draggable')) return;
		options[pane].slidable = true; 
		if (state[pane].isClosed)
			bindStartSlidingEvents(pane, true);
	}
	/**
	* @param {(string|Object)}	evt_or_pane
	*/
,	disableSlidable = function (evt_or_pane) {
		if (!isInitialized()) return;
		var	pane = evtPane.call(this, evt_or_pane)
		,	$R	= $Rs[pane]
		;
		if (!$R) return;
		options[pane].slidable = false; 
		if (state[pane].isSliding)
			close(pane, false, true);
		else {
			bindStartSlidingEvents(pane, false);
			$R	.css("cursor", "default")
				.attr("title", "");
			removeHover(null, $R[0]); // in case currently hovered
		}
	}


	/**
	* @param {(string|Object)}	evt_or_pane
	*/
,	enableResizable = function (evt_or_pane) {
		if (!isInitialized()) return;
		var	pane = evtPane.call(this, evt_or_pane)
		,	$R	= $Rs[pane]
		,	o	= options[pane]
		;
		if (!$R || !$R.data('draggable')) return;
		o.resizable = true; 
		$R.draggable("enable");
		if (!state[pane].isClosed)
			$R	.css("cursor", o.resizerCursor)
			 	.attr("title", o.tips.Resize);
	}
	/**
	* @param {(string|Object)}	evt_or_pane
	*/
,	disableResizable = function (evt_or_pane) {
		if (!isInitialized()) return;
		var	pane = evtPane.call(this, evt_or_pane)
		,	$R	= $Rs[pane]
		;
		if (!$R || !$R.data('draggable')) return;
		options[pane].resizable = false; 
		$R	.draggable("disable")
			.css("cursor", "default")
			.attr("title", "");
		removeHover(null, $R[0]); // in case currently hovered
	}


	/**
	* Move a pane from source-side (eg, west) to target-side (eg, east)
	* If pane exists on target-side, move that to source-side, ie, 'swap' the panes
	*
	* @param {(string|Object)}	evt_or_pane1	The pane/edge being swapped
	* @param {string}			pane2			ditto
	*/
,	swapPanes = function (evt_or_pane1, pane2) {
		if (!isInitialized()) return;
		var pane1 = evtPane.call(this, evt_or_pane1);
		// change state.edge NOW so callbacks can know where pane is headed...
		state[pane1].edge = pane2;
		state[pane2].edge = pane1;
		// run these even if NOT state.initialized
		if (false === _runCallbacks("onswap_start", pane1)
		 ||	false === _runCallbacks("onswap_start", pane2)
		) {
			state[pane1].edge = pane1; // reset
			state[pane2].edge = pane2;
			return;
		}

		var
			oPane1	= copy( pane1 )
		,	oPane2	= copy( pane2 )
		,	sizes	= {}
		;
		sizes[pane1] = oPane1 ? oPane1.state.size : 0;
		sizes[pane2] = oPane2 ? oPane2.state.size : 0;

		// clear pointers & state
		$Ps[pane1] = false; 
		$Ps[pane2] = false;
		state[pane1] = {};
		state[pane2] = {};
		
		// ALWAYS remove the resizer & toggler elements
		if ($Ts[pane1]) $Ts[pane1].remove();
		if ($Ts[pane2]) $Ts[pane2].remove();
		if ($Rs[pane1]) $Rs[pane1].remove();
		if ($Rs[pane2]) $Rs[pane2].remove();
		$Rs[pane1] = $Rs[pane2] = $Ts[pane1] = $Ts[pane2] = false;

		// transfer element pointers and data to NEW Layout keys
		move( oPane1, pane2 );
		move( oPane2, pane1 );

		// cleanup objects
		oPane1 = oPane2 = sizes = null;

		// make panes 'visible' again
		if ($Ps[pane1]) $Ps[pane1].css(_c.visible);
		if ($Ps[pane2]) $Ps[pane2].css(_c.visible);

		// fix any size discrepancies caused by swap
		resizeAll();

		// run these even if NOT state.initialized
		_runCallbacks("onswap_end", pane1);
		_runCallbacks("onswap_end", pane2);

		return;

		function copy (n) { // n = pane
			var
				$P	= $Ps[n]
			,	$C	= $Cs[n]
			;
			return !$P ? false : {
				pane:		n
			,	P:			$P ? $P[0] : false
			,	C:			$C ? $C[0] : false
			,	state:		$.extend(true, {}, state[n])
			,	options:	$.extend(true, {}, options[n])
			}
		};

		function move (oPane, pane) {
			if (!oPane) return;
			var
				P		= oPane.P
			,	C		= oPane.C
			,	oldPane = oPane.pane
			,	c		= _c[pane]
			//	save pane-options that should be retained
			,	s		= $.extend(true, {}, state[pane])
			,	o		= options[pane]
			//	RETAIN side-specific FX Settings - more below
			,	fx		= { resizerCursor: o.resizerCursor }
			,	re, size, pos
			;
			$.each("fxName,fxSpeed,fxSettings".split(","), function (i, k) {
				fx[k +"_open"]  = o[k +"_open"];
				fx[k +"_close"] = o[k +"_close"];
				fx[k +"_size"]  = o[k +"_size"];
			});

			// update object pointers and attributes
			$Ps[pane] = $(P)
				.data({
					layoutPane:		Instance[pane]	// NEW pointer to pane-alias-object
				,	layoutEdge:		pane
				})
				.css(_c.hidden)
				.css(c.cssReq)
			;
			$Cs[pane] = C ? $(C) : false;

			// set options and state
			options[pane]	= $.extend(true, {}, oPane.options, fx);
			state[pane]		= $.extend(true, {}, oPane.state);

			// change classNames on the pane, eg: ui-layout-pane-east ==> ui-layout-pane-west
			re = new RegExp(o.paneClass +"-"+ oldPane, "g");
			P.className = P.className.replace(re, o.paneClass +"-"+ pane);

			// ALWAYS regenerate the resizer & toggler elements
			initHandles(pane); // create the required resizer & toggler

			// if moving to different orientation, then keep 'target' pane size
			if (c.dir != _c[oldPane].dir) {
				size = sizes[pane] || 0;
				setSizeLimits(pane); // update pane-state
				size = max(size, state[pane].minSize);
				// use manualSizePane to disable autoResize - not useful after panes are swapped
				manualSizePane(pane, size, true, true); // true/true = skipCallback/noAnimation
			}
			else // move the resizer here
				$Rs[pane].css(c.side, sC.inset[c.side] + (state[pane].isVisible ? getPaneSize(pane) : 0));


			// ADD CLASSNAMES & SLIDE-BINDINGS
			if (oPane.state.isVisible && !s.isVisible)
				setAsOpen(pane, true); // true = skipCallback
			else {
				setAsClosed(pane);
				bindStartSlidingEvents(pane, true); // will enable events IF option is set
			}

			// DESTROY the object
			oPane = null;
		};
	}


	/**
	* INTERNAL method to sync pin-buttons when pane is opened or closed
	* Unpinned means the pane is 'sliding' - ie, over-top of the adjacent panes
	*
	* @see  open(), setAsOpen(), setAsClosed()
	* @param {string}	pane   These are the params returned to callbacks by layout()
	* @param {boolean}	doPin  True means set the pin 'down', False means 'up'
	*/
,	syncPinBtns = function (pane, doPin) {
		if ($.layout.plugins.buttons)
			$.each(state[pane].pins, function (i, selector) {
				$.layout.buttons.setPinState(Instance, $(selector), pane, doPin);
			});
	}

;	// END var DECLARATIONS

	/**
	* Capture keys when enableCursorHotkey - toggle pane if hotkey pressed
	*
	* @see  document.keydown()
	*/
	function keyDown (evt) {
		if (!evt) return true;
		var code = evt.keyCode;
		if (code < 33) return true; // ignore special keys: ENTER, TAB, etc

		var
			PANE = {
				38: "north" // Up Cursor	- $.ui.keyCode.UP
			,	40: "south" // Down Cursor	- $.ui.keyCode.DOWN
			,	37: "west"  // Left Cursor	- $.ui.keyCode.LEFT
			,	39: "east"  // Right Cursor	- $.ui.keyCode.RIGHT
			}
		,	ALT		= evt.altKey // no worky!
		,	SHIFT	= evt.shiftKey
		,	CTRL	= evt.ctrlKey
		,	CURSOR	= (CTRL && code >= 37 && code <= 40)
		,	o, k, m, pane
		;

		if (CURSOR && options[PANE[code]].enableCursorHotkey) // valid cursor-hotkey
			pane = PANE[code];
		else if (CTRL || SHIFT) // check to see if this matches a custom-hotkey
			$.each(_c.borderPanes, function (i, p) { // loop each pane to check its hotkey
				o = options[p];
				k = o.customHotkey;
				m = o.customHotkeyModifier; // if missing or invalid, treated as "CTRL+SHIFT"
				if ((SHIFT && m=="SHIFT") || (CTRL && m=="CTRL") || (CTRL && SHIFT)) { // Modifier matches
					if (k && code === (isNaN(k) || k <= 9 ? k.toUpperCase().charCodeAt(0) : k)) { // Key matches
						pane = p;
						return false; // BREAK
					}
				}
			});

		// validate pane
		if (!pane || !$Ps[pane] || !options[pane].closable || state[pane].isHidden)
			return true;

		toggle(pane);

		evt.stopPropagation();
		evt.returnValue = false; // CANCEL key
		return false;
	};


/*
 * ######################################
 *	UTILITY METHODS
 *	called externally or by initButtons
 * ######################################
 */

	/**
	* Change/reset a pane overflow setting & zIndex to allow popups/drop-downs to work
	*
	* @param {Object=}   [el]	(optional) Can also be 'bound' to a click, mouseOver, or other event
	*/
	function allowOverflow (el) {
		if (!isInitialized()) return;
		if (this && this.tagName) el = this; // BOUND to element
		var $P;
		if (isStr(el))
			$P = $Ps[el];
		else if ($(el).data("layoutRole"))
			$P = $(el);
		else
			$(el).parents().each(function(){
				if ($(this).data("layoutRole")) {
					$P = $(this);
					return false; // BREAK
				}
			});
		if (!$P || !$P.length) return; // INVALID

		var
			pane	= $P.data("layoutEdge")
		,	s		= state[pane]
		;

		// if pane is already raised, then reset it before doing it again!
		// this would happen if allowOverflow is attached to BOTH the pane and an element 
		if (s.cssSaved)
			resetOverflow(pane); // reset previous CSS before continuing

		// if pane is raised by sliding or resizing, or its closed, then abort
		if (s.isSliding || s.isResizing || s.isClosed) {
			s.cssSaved = false;
			return;
		}

		var
			newCSS	= { zIndex: (options.zIndexes.resizer_normal + 1) }
		,	curCSS	= {}
		,	of		= $P.css("overflow")
		,	ofX		= $P.css("overflowX")
		,	ofY		= $P.css("overflowY")
		;
		// determine which, if any, overflow settings need to be changed
		if (of != "visible") {
			curCSS.overflow = of;
			newCSS.overflow = "visible";
		}
		if (ofX && !ofX.match(/(visible|auto)/)) {
			curCSS.overflowX = ofX;
			newCSS.overflowX = "visible";
		}
		if (ofY && !ofY.match(/(visible|auto)/)) {
			curCSS.overflowY = ofX;
			newCSS.overflowY = "visible";
		}

		// save the current overflow settings - even if blank!
		s.cssSaved = curCSS;

		// apply new CSS to raise zIndex and, if necessary, make overflow 'visible'
		$P.css( newCSS );

		// make sure the zIndex of all other panes is normal
		$.each(_c.allPanes, function(i, p) {
			if (p != pane) resetOverflow(p);
		});

	};
	/**
	* @param {Object=}   [el]	(optional) Can also be 'bound' to a click, mouseOver, or other event
	*/
	function resetOverflow (el) {
		if (!isInitialized()) return;
		if (this && this.tagName) el = this; // BOUND to element
		var $P;
		if (isStr(el))
			$P = $Ps[el];
		else if ($(el).data("layoutRole"))
			$P = $(el);
		else
			$(el).parents().each(function(){
				if ($(this).data("layoutRole")) {
					$P = $(this);
					return false; // BREAK
				}
			});
		if (!$P || !$P.length) return; // INVALID

		var
			pane	= $P.data("layoutEdge")
		,	s		= state[pane]
		,	CSS		= s.cssSaved || {}
		;
		// reset the zIndex
		if (!s.isSliding && !s.isResizing)
			$P.css("zIndex", options.zIndexes.pane_normal);

		// reset Overflow - if necessary
		$P.css( CSS );

		// clear var
		s.cssSaved = false;
	};

/*
 * #####################
 * CREATE/RETURN LAYOUT
 * #####################
 */

	// validate that container exists
	var $N = $(this).eq(0); // FIRST matching Container element
	if (!$N.length) {
		return _log( options.errors.containerMissing );
	};

	// Users retrieve Instance of a layout with: $N.layout() OR $N.data("layout")
	// return the Instance-pointer if layout has already been initialized
	if ($N.data("layoutContainer") && $N.data("layout"))
		return $N.data("layout"); // cached pointer

	// init global vars
	var 
		$Ps	= {}	// Panes x5		- set in initPanes()
	,	$Cs	= {}	// Content x5	- set in initPanes()
	,	$Rs	= {}	// Resizers x4	- set in initHandles()
	,	$Ts	= {}	// Togglers x4	- set in initHandles()
	,	$Ms	= $([])	// Masks - up to 2 masks per pane (IFRAME + DIV)
	//	aliases for code brevity
	,	sC	= state.container // alias for easy access to 'container dimensions'
	,	sID	= state.id // alias for unique layout ID/namespace - eg: "layout435"
	;

	// create Instance object to expose data & option Properties, and primary action Methods
	var Instance = {
	//	layout data
		options:			options			// property - options hash
	,	state:				state			// property - dimensions hash
	//	object pointers
	,	container:			$N				// property - object pointers for layout container
	,	panes:				$Ps				// property - object pointers for ALL Panes: panes.north, panes.center
	,	contents:			$Cs				// property - object pointers for ALL Content: contents.north, contents.center
	,	resizers:			$Rs				// property - object pointers for ALL Resizers, eg: resizers.north
	,	togglers:			$Ts				// property - object pointers for ALL Togglers, eg: togglers.north
	//	border-pane open/close
	,	hide:				hide			// method - ditto
	,	show:				show			// method - ditto
	,	toggle:				toggle			// method - pass a 'pane' ("north", "west", etc)
	,	open:				open			// method - ditto
	,	close:				close			// method - ditto
	,	slideOpen:			slideOpen		// method - ditto
	,	slideClose:			slideClose		// method - ditto
	,	slideToggle:		slideToggle		// method - ditto
	//	pane actions
	,	setSizeLimits:		setSizeLimits	// method - pass a 'pane' - update state min/max data
	,	_sizePane:			sizePane		// method -intended for user by plugins only!
	,	sizePane:			manualSizePane	// method - pass a 'pane' AND an 'outer-size' in pixels or percent, or 'auto'
	,	sizeContent:		sizeContent		// method - pass a 'pane'
	,	swapPanes:			swapPanes		// method - pass TWO 'panes' - will swap them
	,	showMasks:			showMasks		// method - pass a 'pane' OR list of panes - default = all panes with mask option set
	,	hideMasks:			hideMasks		// method - ditto'
	//	pane element methods
	,	initContent:		initContent		// method - ditto
	,	addPane:			addPane			// method - pass a 'pane'
	,	removePane:			removePane		// method - pass a 'pane' to remove from layout, add 'true' to delete the pane-elem
	,	createChildren:		createChildren	// method - pass a 'pane' and (optional) layout-options (OVERRIDES options[pane].children
	,	refreshChildren:	refreshChildren	// method - pass a 'pane' and a layout-instance
	//	special pane option setting
	,	enableClosable:		enableClosable	// method - pass a 'pane'
	,	disableClosable:	disableClosable	// method - ditto
	,	enableSlidable:		enableSlidable	// method - ditto
	,	disableSlidable:	disableSlidable	// method - ditto
	,	enableResizable:	enableResizable	// method - ditto
	,	disableResizable:	disableResizable// method - ditto
	//	utility methods for panes
	,	allowOverflow:		allowOverflow	// utility - pass calling element (this)
	,	resetOverflow:		resetOverflow	// utility - ditto
	//	layout control
	,	destroy:			destroy			// method - no parameters
	,	initPanes:			isInitialized	// method - no parameters
	,	resizeAll:			resizeAll		// method - no parameters
	//	callback triggering
	,	runCallbacks:		_runCallbacks	// method - pass evtName & pane (if a pane-event), eg: trigger("onopen", "west")
	//	alias collections of options, state and children - created in addPane and extended elsewhere
	,	hasParentLayout:	false			// set by initContainer()
	,	children:			children		// pointers to child-layouts, eg: Instance.children.west.layoutName
	,	north:				false			// alias group: { name: pane, pane: $Ps[pane], options: options[pane], state: state[pane], children: children[pane] }
	,	south:				false			// ditto
	,	west:				false			// ditto
	,	east:				false			// ditto
	,	center:				false			// ditto
	};

	// create the border layout NOW
	if (_create() === 'cancel') // onload_start callback returned false to CANCEL layout creation
		return null;
	else // true OR false -- if layout-elements did NOT init (hidden or do not exist), can auto-init later
		return Instance; // return the Instance object

}


})( jQuery );
// END Layout - keep internal vars internal!



// START Plugins - shared wrapper, no global vars
(function ($) {


/**
 * jquery.layout.state 1.0
 * $Date: 2011-07-16 08:00:00 (Sat, 16 July 2011) $
 *
 * Copyright (c) 2012 
 *   Kevin Dalman (http://allpro.net)
 *
 * Dual licensed under the GPL (http://www.gnu.org/licenses/gpl.html)
 * and MIT (http://www.opensource.org/licenses/mit-license.php) licenses.
 *
 * @requires: UI Layout 1.3.0.rc30.1 or higher
 * @requires: $.ui.cookie (above)
 *
 * @see: http://groups.google.com/group/jquery-ui-layout
 */
/*
 *	State-management options stored in options.stateManagement, which includes a .cookie hash
 *	Default options saves ALL KEYS for ALL PANES, ie: pane.size, pane.isClosed, pane.isHidden
 *
 *	// STATE/COOKIE OPTIONS
 *	@example $(el).layout({
				stateManagement: {
					enabled:	true
				,	stateKeys:	"east.size,west.size,east.isClosed,west.isClosed"
				,	cookie:		{ name: "appLayout", path: "/" }
				}
			})
 *	@example $(el).layout({ stateManagement__enabled: true }) // enable auto-state-management using cookies
 *	@example $(el).layout({ stateManagement__cookie: { name: "appLayout", path: "/" } })
 *	@example $(el).layout({ stateManagement__cookie__name: "appLayout", stateManagement__cookie__path: "/" })
 *
 *	// STATE/COOKIE METHODS
 *	@example myLayout.saveCookie( "west.isClosed,north.size,south.isHidden", {expires: 7} );
 *	@example myLayout.loadCookie();
 *	@example myLayout.deleteCookie();
 *	@example var JSON = myLayout.readState();	// CURRENT Layout State
 *	@example var JSON = myLayout.readCookie();	// SAVED Layout State (from cookie)
 *	@example var JSON = myLayout.state.stateData;	// LAST LOADED Layout State (cookie saved in layout.state hash)
 *
 *	CUSTOM STATE-MANAGEMENT (eg, saved in a database)
 *	@example var JSON = myLayout.readState( "west.isClosed,north.size,south.isHidden" );
 *	@example myLayout.loadState( JSON );
 */

/**
 *	UI COOKIE UTILITY
 *
 *	A $.cookie OR $.ui.cookie namespace *should be standard*, but until then...
 *	This creates $.ui.cookie so Layout does not need the cookie.jquery.js plugin
 *	NOTE: This utility is REQUIRED by the layout.state plugin
 *
 *	Cookie methods in Layout are created as part of State Management 
 */
if (!$.ui) $.ui = {};
$.ui.cookie = {

	// cookieEnabled is not in DOM specs, but DOES works in all browsers,including IE6
	acceptsCookies: !!navigator.cookieEnabled

,	read: function (name) {
		var	c		= document.cookie
		,	cs		= c ? c.split(';') : []
		,	pair	// loop var
		;
		for (var i=0, n=cs.length; i < n; i++) {
			pair = $.trim(cs[i]).split('='); // name=value pair
			if (pair[0] == name) // found the layout cookie
				return decodeURIComponent(pair[1]);
		}
		return null;
	}

,	write: function (name, val, cookieOpts) {
		var	params	= ""
		,	date	= ""
		,	clear	= false
		,	o		= cookieOpts || {}
		,	x		= o.expires  || null
		,	t		= $.type(x)
		;
		if (t === "date")
			date = x;
		else if (t === "string" && x > 0) {
			x = parseInt(x,10);
			t = "number";
		}
		if (t === "number") {
			date = new Date();
			if (x > 0)
				date.setDate(date.getDate() + x);
			else {
				date.setFullYear(1970);
				clear = true;
			}
		}
		if (date)		params += ";expires="+ date.toUTCString();
		if (o.path)		params += ";path="+ o.path;
		if (o.domain)	params += ";domain="+ o.domain;
		if (o.secure)	params += ";secure";
		document.cookie = name +"="+ (clear ? "" : encodeURIComponent( val )) + params; // write or clear cookie
	}

,	clear: function (name) {
		$.ui.cookie.write(name, "", {expires: -1});
	}

};
// if cookie.jquery.js is not loaded, create an alias to replicate it
// this may be useful to other plugins or code dependent on that plugin
if (!$.cookie) $.cookie = function (k, v, o) {
	var C = $.ui.cookie;
	if (v === null)
		C.clear(k);
	else if (v === undefined)
		return C.read(k);
	else
		C.write(k, v, o);
};


// tell Layout that the state plugin is available
$.layout.plugins.stateManagement = true;

//	Add State-Management options to layout.defaults
$.layout.config.optionRootKeys.push("stateManagement");
$.layout.defaults.stateManagement = {
	enabled:		false	// true = enable state-management, even if not using cookies
,	autoSave:		true	// Save a state-cookie when page exits?
,	autoLoad:		true	// Load the state-cookie when Layout inits?
,	animateLoad:	true	// animate panes when loading state into an active layout
,	includeChildren: true	// recurse into child layouts to include their state as well
	// List state-data to save - must be pane-specific
,	stateKeys:	"north.size,south.size,east.size,west.size,"+
				"north.isClosed,south.isClosed,east.isClosed,west.isClosed,"+
				"north.isHidden,south.isHidden,east.isHidden,west.isHidden"
,	cookie: {
		name:	""	// If not specified, will use Layout.name, else just "Layout"
	,	domain:	""	// blank = current domain
	,	path:	""	// blank = current page, "/" = entire website
	,	expires: ""	// 'days' to keep cookie - leave blank for 'session cookie'
	,	secure:	false
	}
};
// Set stateManagement as a layout-option, NOT a pane-option
$.layout.optionsMap.layout.push("stateManagement");

/*
 *	State Management methods
 */
$.layout.state = {

	/**
	 * Get the current layout state and save it to a cookie
	 *
	 * myLayout.saveCookie( keys, cookieOpts )
	 *
	 * @param {Object}			inst
	 * @param {(string|Array)=}	keys
	 * @param {Object=}			cookieOpts
	 */
	saveCookie: function (inst, keys, cookieOpts) {
		var o	= inst.options
		,	sm	= o.stateManagement
		,	oC	= $.extend(true, {}, sm.cookie, cookieOpts || null)
		,	data = inst.state.stateData = inst.readState( keys || sm.stateKeys ) // read current panes-state
		;
		$.ui.cookie.write( oC.name || o.name || "Layout", $.layout.state.encodeJSON(data), oC );
		return $.extend(true, {}, data); // return COPY of state.stateData data
	}

	/**
	 * Remove the state cookie
	 *
	 * @param {Object}	inst
	 */
,	deleteCookie: function (inst) {
		var o = inst.options;
		$.ui.cookie.clear( o.stateManagement.cookie.name || o.name || "Layout" );
	}

	/**
	 * Read & return data from the cookie - as JSON
	 *
	 * @param {Object}	inst
	 */
,	readCookie: function (inst) {
		var o = inst.options;
		var c = $.ui.cookie.read( o.stateManagement.cookie.name || o.name || "Layout" );
		// convert cookie string back to a hash and return it
		return c ? $.layout.state.decodeJSON(c) : {};
	}

	/**
	 * Get data from the cookie and USE IT to loadState
	 *
	 * @param {Object}	inst
	 */
,	loadCookie: function (inst) {
		var c = $.layout.state.readCookie(inst); // READ the cookie
		if (c) {
			inst.state.stateData = $.extend(true, {}, c); // SET state.stateData
			inst.loadState(c); // LOAD the retrieved state
		}
		return c;
	}

	/**
	 * Update layout options from the cookie, if one exists
	 *
	 * @param {Object}		inst
	 * @param {Object=}		stateData
	 * @param {boolean=}	animate
	 */
,	loadState: function (inst, data, opts) {
		if (!$.isPlainObject( data ) || $.isEmptyObject( data )) return;

		// normalize data & cache in the state object
		data = inst.state.stateData = $.layout.transformData( data ); // panes = default subkey

		// add missing/default state-restore options
		var smo = inst.options.stateManagement;
		opts = $.extend({
			animateLoad:		false //smo.animateLoad
		,	includeChildren:	smo.includeChildren
		}, opts );

		if (!inst.state.initialized) {
			/*
			 *	layout NOT initialized, so just update its options
			 */
			// MUST remove pane.children keys before applying to options
			// use a copy so we don't remove keys from original data
			var o = $.extend(true, {}, data);
			//delete o.center; // center has no state-data - only children
			$.each($.layout.config.allPanes, function (idx, pane) {
				if (o[pane]) delete o[pane].children;		   
			 });
			// update CURRENT layout-options with saved state data
			$.extend(true, inst.options, o);
		}
		else {
			/*
			 *	layout already initialized, so modify layout's configuration
			 */
			var noAnimate = !opts.animateLoad
			,	o, c, h, state, open
			;
			$.each($.layout.config.borderPanes, function (idx, pane) {
				o = data[ pane ];
				if (!$.isPlainObject( o )) return; // no key, skip pane

				s	= o.size;
				c	= o.initClosed;
				h	= o.initHidden;
				ar	= o.autoResize
				state	= inst.state[pane];
				open	= state.isVisible;

				// reset autoResize
				if (ar)
					state.autoResize = ar;
				// resize BEFORE opening
				if (!open)
					inst._sizePane(pane, s, false, false, false); // false=skipCallback/noAnimation/forceResize
				// open/close as necessary - DO NOT CHANGE THIS ORDER!
				if (h === true)			inst.hide(pane, noAnimate);
				else if (c === true)	inst.close(pane, false, noAnimate);
				else if (c === false)	inst.open (pane, false, noAnimate);
				else if (h === false)	inst.show (pane, false, noAnimate);
				// resize AFTER any other actions
				if (open)
					inst._sizePane(pane, s, false, false, noAnimate); // animate resize if option passed
			});

			/*
			 *	RECURSE INTO CHILD-LAYOUTS
			 */
			if (opts.includeChildren) {
				var paneStateChildren, childState;
				$.each(inst.children, function (pane, paneChildren) {
					paneStateChildren = data[pane] ? data[pane].children : 0;
					if (paneStateChildren && paneChildren) {
						$.each(paneChildren, function (stateKey, child) {
							childState = paneStateChildren[stateKey];
							if (child && childState)
								child.loadState( childState );
						});
					}
				});
			}
		}
	}

	/**
	 * Get the *current layout state* and return it as a hash
	 *
	 * @param {Object=}		inst	// Layout instance to get state for
	 * @param {object=}		[opts]	// State-Managements override options
	 */
,	readState: function (inst, opts) {
		// backward compatility
		if ($.type(opts) === 'string') opts = { keys: opts };
		if (!opts) opts = {};
		var	sm		= inst.options.stateManagement
		,	ic		= opts.includeChildren
		,	recurse	= ic !== undefined ? ic : sm.includeChildren
		,	keys	= opts.stateKeys || sm.stateKeys
		,	alt		= { isClosed: 'initClosed', isHidden: 'initHidden' }
		,	state	= inst.state
		,	panes	= $.layout.config.allPanes
		,	data	= {}
		,	pair, pane, key, val
		,	ps, pC, child, array, count, branch
		;
		if ($.isArray(keys)) keys = keys.join(",");
		// convert keys to an array and change delimiters from '__' to '.'
		keys = keys.replace(/__/g, ".").split(',');
		// loop keys and create a data hash
		for (var i=0, n=keys.length; i < n; i++) {
			pair = keys[i].split(".");
			pane = pair[0];
			key  = pair[1];
			if ($.inArray(pane, panes) < 0) continue; // bad pane!
			val = state[ pane ][ key ];
			if (val == undefined) continue;
			if (key=="isClosed" && state[pane]["isSliding"])
				val = true; // if sliding, then *really* isClosed
			( data[pane] || (data[pane]={}) )[ alt[key] ? alt[key] : key ] = val;
		}

		// recurse into the child-layouts for each pane
		if (recurse) {
			$.each(panes, function (idx, pane) {
				pC = inst.children[pane];
				ps = state.stateData[pane];
				if ($.isPlainObject( pC ) && !$.isEmptyObject( pC )) {
					// ensure a key exists for this 'pane', eg: branch = data.center
					branch = data[pane] || (data[pane] = {});
					if (!branch.children) branch.children = {};
					$.each( pC, function (key, child) {
						// ONLY read state from an initialize layout
						if ( child.state.initialized )
							branch.children[ key ] = $.layout.state.readState( child );
						// if we have PREVIOUS (onLoad) state for this child-layout, KEEP IT!
						else if ( ps && ps.children && ps.children[ key ] ) {
							branch.children[ key ] = $.extend(true, {}, ps.children[ key ] );
						}
					});
				}
			});
		}

		return data;
	}

	/**
	 *	Stringify a JSON hash so can save in a cookie or db-field
	 */
,	encodeJSON: function (JSON) {
		return parse(JSON);
		function parse (h) {
			var D=[], i=0, k, v, t // k = key, v = value
			,	a = $.isArray(h)
			;
			for (k in h) {
				v = h[k];
				t = typeof v;
				if (t == 'string')		// STRING - add quotes
					v = '"'+ v +'"';
				else if (t == 'object')	// SUB-KEY - recurse into it
					v = parse(v);
				D[i++] = (!a ? '"'+ k +'":' : '') + v;
			}
			return (a ? '[' : '{') + D.join(',') + (a ? ']' : '}');
		};
	}

	/**
	 *	Convert stringified JSON back to a hash object
	 *	@see		$.parseJSON(), adding in jQuery 1.4.1
	 */
,	decodeJSON: function (str) {
		try { return $.parseJSON ? $.parseJSON(str) : window["eval"]("("+ str +")") || {}; }
		catch (e) { return {}; }
	}


,	_create: function (inst) {
		var _	= $.layout.state
		,	o	= inst.options
		,	sm	= o.stateManagement
		;
		//	ADD State-Management plugin methods to inst
		 $.extend( inst, {
		//	readCookie - update options from cookie - returns hash of cookie data
			readCookie:		function () { return _.readCookie(inst); }
		//	deleteCookie
		,	deleteCookie:	function () { _.deleteCookie(inst); }
		//	saveCookie - optionally pass keys-list and cookie-options (hash)
		,	saveCookie:		function (keys, cookieOpts) { return _.saveCookie(inst, keys, cookieOpts); }
		//	loadCookie - readCookie and use to loadState() - returns hash of cookie data
		,	loadCookie:		function () { return _.loadCookie(inst); }
		//	loadState - pass a hash of state to use to update options
		,	loadState:		function (stateData, opts) { _.loadState(inst, stateData, opts); }
		//	readState - returns hash of current layout-state
		,	readState:		function (keys) { return _.readState(inst, keys); }
		//	add JSON utility methods too...
		,	encodeJSON:		_.encodeJSON
		,	decodeJSON:		_.decodeJSON
		});

		// init state.stateData key, even if plugin is initially disabled
		inst.state.stateData = {};

		// autoLoad MUST BE one of: data-array, data-hash, callback-function, or TRUE
		if ( !sm.autoLoad ) return;

		//	When state-data exists in the autoLoad key USE IT,
		//	even if stateManagement.enabled == false
		if ($.isPlainObject( sm.autoLoad )) {
			if (!$.isEmptyObject( sm.autoLoad )) {
				inst.loadState( sm.autoLoad );
			}
		}
		else if ( sm.enabled ) {
			// update the options from cookie or callback
			// if options is a function, call it to get stateData
			if ($.isFunction( sm.autoLoad )) {
				var d = {};
				try {
					d = sm.autoLoad( inst, inst.state, inst.options, inst.options.name || '' ); // try to get data from fn
				} catch (e) {}
				if (d && $.isPlainObject( d ) && !$.isEmptyObject( d ))
					inst.loadState(d);
			}
			else // any other truthy value will trigger loadCookie
				inst.loadCookie();
		}
	}

,	_unload: function (inst) {
		var sm = inst.options.stateManagement;
		if (sm.enabled && sm.autoSave) {
			// if options is a function, call it to save the stateData
			if ($.isFunction( sm.autoSave )) {
				try {
					sm.autoSave( inst, inst.state, inst.options, inst.options.name || '' ); // try to get data from fn
				} catch (e) {}
			}
			else // any truthy value will trigger saveCookie
				inst.saveCookie();
		}
	}

};

// add state initialization method to Layout's onCreate array of functions
$.layout.onCreate.push( $.layout.state._create );
$.layout.onUnload.push( $.layout.state._unload );




/**
 * jquery.layout.buttons 1.0
 * $Date: 2011-07-16 08:00:00 (Sat, 16 July 2011) $
 *
 * Copyright (c) 2012 
 *   Kevin Dalman (http://allpro.net)
 *
 * Dual licensed under the GPL (http://www.gnu.org/licenses/gpl.html)
 * and MIT (http://www.opensource.org/licenses/mit-license.php) licenses.
 *
 * @requires: UI Layout 1.3.0.rc30.1 or higher
 *
 * @see: http://groups.google.com/group/jquery-ui-layout
 *
 * Docs: [ to come ]
 * Tips: [ to come ]
 */

// tell Layout that the state plugin is available
$.layout.plugins.buttons = true;

//	Add buttons options to layout.defaults
$.layout.defaults.autoBindCustomButtons = false;
// Specify autoBindCustomButtons as a layout-option, NOT a pane-option
$.layout.optionsMap.layout.push("autoBindCustomButtons");

/*
 *	Button methods
 */
$.layout.buttons = {

	/**
	* Searches for .ui-layout-button-xxx elements and auto-binds them as layout-buttons
	*
	* @see  _create()
	*
	* @param  {Object}		inst	Layout Instance object
	*/
	init: function (inst) {
		var pre		= "ui-layout-button-"
		,	layout	= inst.options.name || ""
		,	name;
		$.each("toggle,open,close,pin,toggle-slide,open-slide".split(","), function (i, action) {
			$.each($.layout.config.borderPanes, function (ii, pane) {
				$("."+pre+action+"-"+pane).each(function(){
					// if button was previously 'bound', data.layoutName was set, but is blank if layout has no 'name'
					name = $(this).data("layoutName") || $(this).attr("layoutName");
					if (name == undefined || name === layout)
						inst.bindButton(this, action, pane);
				});
			});
		});
	}

	/**
	* Helper function to validate params received by addButton utilities
	*
	* Two classes are added to the element, based on the buttonClass...
	* The type of button is appended to create the 2nd className:
	*  - ui-layout-button-pin		// action btnClass
	*  - ui-layout-button-pin-west	// action btnClass + pane
	*  - ui-layout-button-toggle
	*  - ui-layout-button-open
	*  - ui-layout-button-close
	*
	* @param {Object}			inst		Layout Instance object
	* @param {(string|!Object)}	selector	jQuery selector (or element) for button, eg: ".ui-layout-north .toggle-button"
	* @param {string}   		pane 		Name of the pane the button is for: 'north', 'south', etc.
	*
	* @return {Array.<Object>}	If both params valid, the element matching 'selector' in a jQuery wrapper - otherwise returns null
	*/
,	get: function (inst, selector, pane, action) {
		var $E	= $(selector)
		,	o	= inst.options
		,	err	= o.errors.addButtonError
		;
		if (!$E.length) { // element not found
			$.layout.msg(err +" "+ o.errors.selector +": "+ selector, true);
		}
		else if ($.inArray(pane, $.layout.config.borderPanes) < 0) { // invalid 'pane' sepecified
			$.layout.msg(err +" "+ o.errors.pane +": "+ pane, true);
			$E = $("");  // NO BUTTON
		}
		else { // VALID
			var btn = o[pane].buttonClass +"-"+ action;
			$E	.addClass( btn +" "+ btn +"-"+ pane )
				.data("layoutName", o.name); // add layout identifier - even if blank!
		}
		return $E;
	}


	/**
	* NEW syntax for binding layout-buttons - will eventually replace addToggle, addOpen, etc.
	*
	* @param {Object}			inst		Layout Instance object
	* @param {(string|!Object)}	selector	jQuery selector (or element) for button, eg: ".ui-layout-north .toggle-button"
	* @param {string}			action
	* @param {string}			pane
	*/
,	bind: function (inst, selector, action, pane) {
		var _ = $.layout.buttons;
		switch (action.toLowerCase()) {
			case "toggle":			_.addToggle	(inst, selector, pane); break;	
			case "open":			_.addOpen	(inst, selector, pane); break;
			case "close":			_.addClose	(inst, selector, pane); break;
			case "pin":				_.addPin	(inst, selector, pane); break;
			case "toggle-slide":	_.addToggle	(inst, selector, pane, true); break;	
			case "open-slide":		_.addOpen	(inst, selector, pane, true); break;
		}
		return inst;
	}

	/**
	* Add a custom Toggler button for a pane
	*
	* @param {Object}			inst		Layout Instance object
	* @param {(string|!Object)}	selector	jQuery selector (or element) for button, eg: ".ui-layout-north .toggle-button"
	* @param {string}  			pane 		Name of the pane the button is for: 'north', 'south', etc.
	* @param {boolean=}			slide 		true = slide-open, false = pin-open
	*/
,	addToggle: function (inst, selector, pane, slide) {
		$.layout.buttons.get(inst, selector, pane, "toggle")
			.click(function(evt){
				inst.toggle(pane, !!slide);
				evt.stopPropagation();
			});
		return inst;
	}

	/**
	* Add a custom Open button for a pane
	*
	* @param {Object}			inst		Layout Instance object
	* @param {(string|!Object)}	selector	jQuery selector (or element) for button, eg: ".ui-layout-north .toggle-button"
	* @param {string}			pane 		Name of the pane the button is for: 'north', 'south', etc.
	* @param {boolean=}			slide 		true = slide-open, false = pin-open
	*/
,	addOpen: function (inst, selector, pane, slide) {
		$.layout.buttons.get(inst, selector, pane, "open")
			.attr("title", inst.options[pane].tips.Open)
			.click(function (evt) {
				inst.open(pane, !!slide);
				evt.stopPropagation();
			});
		return inst;
	}

	/**
	* Add a custom Close button for a pane
	*
	* @param {Object}			inst		Layout Instance object
	* @param {(string|!Object)}	selector	jQuery selector (or element) for button, eg: ".ui-layout-north .toggle-button"
	* @param {string}   		pane 		Name of the pane the button is for: 'north', 'south', etc.
	*/
,	addClose: function (inst, selector, pane) {
		$.layout.buttons.get(inst, selector, pane, "close")
			.attr("title", inst.options[pane].tips.Close)
			.click(function (evt) {
				inst.close(pane);
				evt.stopPropagation();
			});
		return inst;
	}

	/**
	* Add a custom Pin button for a pane
	*
	* Four classes are added to the element, based on the paneClass for the associated pane...
	* Assuming the default paneClass and the pin is 'up', these classes are added for a west-pane pin:
	*  - ui-layout-pane-pin
	*  - ui-layout-pane-west-pin
	*  - ui-layout-pane-pin-up
	*  - ui-layout-pane-west-pin-up
	*
	* @param {Object}			inst		Layout Instance object
	* @param {(string|!Object)}	selector	jQuery selector (or element) for button, eg: ".ui-layout-north .toggle-button"
	* @param {string}   		pane 		Name of the pane the pin is for: 'north', 'south', etc.
	*/
,	addPin: function (inst, selector, pane) {
		var	_	= $.layout.buttons
		,	$E	= _.get(inst, selector, pane, "pin");
		if ($E.length) {
			var s = inst.state[pane];
			$E.click(function (evt) {
				_.setPinState(inst, $(this), pane, (s.isSliding || s.isClosed));
				if (s.isSliding || s.isClosed) inst.open( pane ); // change from sliding to open
				else inst.close( pane ); // slide-closed
				evt.stopPropagation();
			});
			// add up/down pin attributes and classes
			_.setPinState(inst, $E, pane, (!s.isClosed && !s.isSliding));
			// add this pin to the pane data so we can 'sync it' automatically
			// PANE.pins key is an array so we can store multiple pins for each pane
			s.pins.push( selector ); // just save the selector string
		}
		return inst;
	}

	/**
	* Change the class of the pin button to make it look 'up' or 'down'
	*
	* @see  addPin(), syncPins()
	*
	* @param {Object}			inst	Layout Instance object
	* @param {Array.<Object>}	$Pin	The pin-span element in a jQuery wrapper
	* @param {string}			pane	These are the params returned to callbacks by layout()
	* @param {boolean}			doPin	true = set the pin 'down', false = set it 'up'
	*/
,	setPinState: function (inst, $Pin, pane, doPin) {
		var updown = $Pin.attr("pin");
		if (updown && doPin === (updown=="down")) return; // already in correct state
		var
			o		= inst.options[pane]
		,	pin		= o.buttonClass +"-pin"
		,	side	= pin +"-"+ pane
		,	UP		= pin +"-up "+	side +"-up"
		,	DN		= pin +"-down "+side +"-down"
		;
		$Pin
			.attr("pin", doPin ? "down" : "up") // logic
			.attr("title", doPin ? o.tips.Unpin : o.tips.Pin)
			.removeClass( doPin ? UP : DN ) 
			.addClass( doPin ? DN : UP ) 
		;
	}

	/**
	* INTERNAL function to sync 'pin buttons' when pane is opened or closed
	* Unpinned means the pane is 'sliding' - ie, over-top of the adjacent panes
	*
	* @see  open(), close()
	*
	* @param {Object}			inst	Layout Instance object
	* @param {string}	pane	These are the params returned to callbacks by layout()
	* @param {boolean}	doPin	True means set the pin 'down', False means 'up'
	*/
,	syncPinBtns: function (inst, pane, doPin) {
		// REAL METHOD IS _INSIDE_ LAYOUT - THIS IS HERE JUST FOR REFERENCE
		$.each(inst.state[pane].pins, function (i, selector) {
			$.layout.buttons.setPinState(inst, $(selector), pane, doPin);
		});
	}


,	_load: function (inst) {
		var	_	= $.layout.buttons;
		// ADD Button methods to Layout Instance
		// Note: sel = jQuery Selector string
		$.extend( inst, {
			bindButton:		function (sel, action, pane) { return _.bind(inst, sel, action, pane); }
		//	DEPRECATED METHODS
		,	addToggleBtn:	function (sel, pane, slide) { return _.addToggle(inst, sel, pane, slide); }
		,	addOpenBtn:		function (sel, pane, slide) { return _.addOpen(inst, sel, pane, slide); }
		,	addCloseBtn:	function (sel, pane) { return _.addClose(inst, sel, pane); }
		,	addPinBtn:		function (sel, pane) { return _.addPin(inst, sel, pane); }
		});

		// init state array to hold pin-buttons
		for (var i=0; i<4; i++) {
			var pane = $.layout.config.borderPanes[i];
			inst.state[pane].pins = [];
		}

		// auto-init buttons onLoad if option is enabled
		if ( inst.options.autoBindCustomButtons )
			_.init(inst);
	}

,	_unload: function (inst) {
		// TODO: unbind all buttons???
	}

};

// add initialization method to Layout's onLoad array of functions
$.layout.onLoad.push(  $.layout.buttons._load );
//$.layout.onUnload.push( $.layout.buttons._unload );



/**
 * jquery.layout.browserZoom 1.0
 * $Date: 2011-12-29 08:00:00 (Thu, 29 Dec 2011) $
 *
 * Copyright (c) 2012 
 *   Kevin Dalman (http://allpro.net)
 *
 * Dual licensed under the GPL (http://www.gnu.org/licenses/gpl.html)
 * and MIT (http://www.opensource.org/licenses/mit-license.php) licenses.
 *
 * @requires: UI Layout 1.3.0.rc30.1 or higher
 *
 * @see: http://groups.google.com/group/jquery-ui-layout
 *
 * TODO: Extend logic to handle other problematic zooming in browsers
 * TODO: Add hotkey/mousewheel bindings to _instantly_ respond to these zoom event
 */

// tell Layout that the plugin is available
$.layout.plugins.browserZoom = true;

$.layout.defaults.browserZoomCheckInterval = 1000;
$.layout.optionsMap.layout.push("browserZoomCheckInterval");

/*
 *	browserZoom methods
 */
$.layout.browserZoom = {

	_init: function (inst) {
		// abort if browser does not need this check
		if ($.layout.browserZoom.ratio() !== false)
			$.layout.browserZoom._setTimer(inst);
	}

,	_setTimer: function (inst) {
		// abort if layout destroyed or browser does not need this check
		if (inst.destroyed) return;
		var o	= inst.options
		,	s	= inst.state
		//	don't need check if inst has parentLayout, but check occassionally in case parent destroyed!
		//	MINIMUM 100ms interval, for performance
		,	ms	= inst.hasParentLayout ?  5000 : Math.max( o.browserZoomCheckInterval, 100 )
		;
		// set the timer
		setTimeout(function(){
			if (inst.destroyed || !o.resizeWithWindow) return;
			var d = $.layout.browserZoom.ratio();
			if (d !== s.browserZoom) {
				s.browserZoom = d;
				inst.resizeAll();
			}
			// set a NEW timeout
			$.layout.browserZoom._setTimer(inst);
		}
		,	ms );
	}

,	ratio: function () {
		var w	= window
		,	s	= screen
		,	d	= document
		,	dE	= d.documentElement || d.body
		,	b	= $.layout.browser
		,	v	= b.version
		,	r, sW, cW
		;
		// we can ignore all browsers that fire window.resize event onZoom
		if ((b.msie && v > 8)
		||	!b.msie
		) return false; // don't need to track zoom

		if (s.deviceXDPI && s.systemXDPI) // syntax compiler hack
			return calc(s.deviceXDPI, s.systemXDPI);
		// everything below is just for future reference!
		if (b.webkit && (r = d.body.getBoundingClientRect))
			return calc((r.left - r.right), d.body.offsetWidth);
		if (b.webkit && (sW = w.outerWidth))
			return calc(sW, w.innerWidth);
		if ((sW = s.width) && (cW = dE.clientWidth))
			return calc(sW, cW);
		return false; // no match, so cannot - or don't need to - track zoom

		function calc (x,y) { return (parseInt(x,10) / parseInt(y,10) * 100).toFixed(); }
	}

};
// add initialization method to Layout's onLoad array of functions
$.layout.onReady.push( $.layout.browserZoom._init );


})( jQuery );
/*
 * JavaScript Load Image 1.2.1
 * https://github.com/blueimp/JavaScript-Load-Image
 *
 * Copyright 2011, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * http://www.opensource.org/licenses/MIT
 */

/*jslint nomen: true */
/*global window, document, URL, webkitURL, Blob, File, FileReader, define */


(function ($) {
    'use strict';

    // Loads an image for a given File object.
    // Invokes the callback with an img or optional canvas
    // element (if supported by the browser) as parameter:
    var loadImage = function (file, callback, options) {
            var img = document.createElement('img'),
                url,
                oUrl;
            img.onerror = callback;
            img.onload = function () {
                if (oUrl && !(options && options.noRevoke)) {
                    loadImage.revokeObjectURL(oUrl);
                }
                callback(loadImage.scale(img, options));
            };
            if ((window.Blob && file instanceof Blob) ||
                // Files are also Blob instances, but some browsers
                // (Firefox 3.6) support the File API but not Blobs:
                    (window.File && file instanceof File)) {
                url = oUrl = loadImage.createObjectURL(file);
            } else {
                url = file;
            }
            if (url) {
                img.src = url;
                return img;
            }
            return loadImage.readFile(file, function (url) {
                img.src = url;
            });
        },
        // The check for URL.revokeObjectURL fixes an issue with Opera 12,
        // which provides URL.createObjectURL but doesn't properly implement it:
        urlAPI = (window.createObjectURL && window) ||
            (window.URL && URL.revokeObjectURL && URL) ||
            (window.webkitURL && webkitURL);

    // Scales the given image (img or canvas HTML element)
    // using the given options.
    // Returns a canvas object if the browser supports canvas
    // and the canvas option is true or a canvas object is passed
    // as image, else the scaled image:
    loadImage.scale = function (img, options) {
        options = options || {};
        var canvas = document.createElement('canvas'),
            width = img.width,
            height = img.height,
            scale = Math.max(
                (options.minWidth || width) / width,
                (options.minHeight || height) / height
            );
        if (scale > 1) {
            width = parseInt(width * scale, 10);
            height = parseInt(height * scale, 10);
        }
        scale = Math.min(
            (options.maxWidth || width) / width,
            (options.maxHeight || height) / height
        );
        if (scale < 1) {
            width = parseInt(width * scale, 10);
            height = parseInt(height * scale, 10);
        }
        if (img.getContext || (options.canvas && canvas.getContext)) {
            canvas.width = width;
            canvas.height = height;
            canvas.getContext('2d')
                .drawImage(img, 0, 0, width, height);
            return canvas;
        }
        img.width = width;
        img.height = height;
        return img;
    };

    loadImage.createObjectURL = function (file) {
        return urlAPI ? urlAPI.createObjectURL(file) : false;
    };

    loadImage.revokeObjectURL = function (url) {
        return urlAPI ? urlAPI.revokeObjectURL(url) : false;
    };

    // Loads a given File object via FileReader interface,
    // invokes the callback with a data url:
    loadImage.readFile = function (file, callback) {
        if (window.FileReader && FileReader.prototype.readAsDataURL) {
            var fileReader = new FileReader();
            fileReader.onload = function (e) {
                callback(e.target.result);
            };
            fileReader.readAsDataURL(file);
            return fileReader;
        }
        return false;
    };

    if (typeof define === 'function' && define.amd) {
        define(function () {
            return loadImage;
        });
    } else {
        $.loadImage = loadImage;
    }
}(this));
/*
 * JavaScript Canvas to Blob 2.0.3
 * https://github.com/blueimp/JavaScript-Canvas-to-Blob
 *
 * Copyright 2012, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * http://www.opensource.org/licenses/MIT
 *
 * Based on stackoverflow user Stoive's code snippet:
 * http://stackoverflow.com/q/4998908
 */

/*jslint nomen: true, regexp: true */
/*global window, atob, Blob, ArrayBuffer, Uint8Array, define */


(function (window) {
    'use strict';
    var CanvasPrototype = window.HTMLCanvasElement &&
            window.HTMLCanvasElement.prototype,
        hasBlobConstructor = window.Blob && (function () {
            try {
                return Boolean(new Blob());
            } catch (e) {
                return false;
            }
        }()),
        hasArrayBufferViewSupport = hasBlobConstructor && window.Uint8Array &&
            (function () {
                try {
                    return new Blob([new Uint8Array(100)]).size === 100;
                } catch (e) {
                    return false;
                }
            }()),
        BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder ||
            window.MozBlobBuilder || window.MSBlobBuilder,
        dataURLtoBlob = (hasBlobConstructor || BlobBuilder) && window.atob &&
            window.ArrayBuffer && window.Uint8Array && function (dataURI) {
                var byteString,
                    arrayBuffer,
                    intArray,
                    i,
                    mimeString,
                    bb;
                if (dataURI.split(',')[0].indexOf('base64') >= 0) {
                    // Convert base64 to raw binary data held in a string:
                    byteString = atob(dataURI.split(',')[1]);
                } else {
                    // Convert base64/URLEncoded data component to raw binary data:
                    byteString = decodeURIComponent(dataURI.split(',')[1]);
                }
                // Write the bytes of the string to an ArrayBuffer:
                arrayBuffer = new ArrayBuffer(byteString.length);
                intArray = new Uint8Array(arrayBuffer);
                for (i = 0; i < byteString.length; i += 1) {
                    intArray[i] = byteString.charCodeAt(i);
                }
                // Separate out the mime component:
                mimeString = dataURI.split(',')[0].split(':')[1].split(';')[0];
                // Write the ArrayBuffer (or ArrayBufferView) to a blob:
                if (hasBlobConstructor) {
                    return new Blob(
                        [hasArrayBufferViewSupport ? intArray : arrayBuffer],
                        {type: mimeString}
                    );
                }
                bb = new BlobBuilder();
                bb.append(arrayBuffer);
                return bb.getBlob(mimeString);
            };
    if (window.HTMLCanvasElement && !CanvasPrototype.toBlob) {
        if (CanvasPrototype.mozGetAsFile) {
            CanvasPrototype.toBlob = function (callback, type) {
                callback(this.mozGetAsFile('blob', type));
            };
        } else if (CanvasPrototype.toDataURL && dataURLtoBlob) {
            CanvasPrototype.toBlob = function (callback, type) {
                callback(dataURLtoBlob(this.toDataURL(type)));
            };
        }
    }
    if (typeof define === 'function' && define.amd) {
        define(function () {
            return dataURLtoBlob;
        });
    } else {
        window.dataURLtoBlob = dataURLtoBlob;
    }
}(this));
/*
 * jQuery File Upload Plugin 5.21
 * https://github.com/blueimp/jQuery-File-Upload
 *
 * Copyright 2010, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * http://www.opensource.org/licenses/MIT
 */

/*jslint nomen: true, unparam: true, regexp: true */
/*global define, window, document, File, Blob, FormData, location */


(function (factory) {
    'use strict';
    if (typeof define === 'function' && define.amd) {
        // Register as an anonymous AMD module:
        define([
            'jquery',
            'jquery.ui.widget'
        ], factory);
    } else {
        // Browser globals:
        factory(window.jQuery);
    }
}(function ($) {
    'use strict';

    // The FileReader API is not actually used, but works as feature detection,
    // as e.g. Safari supports XHR file uploads via the FormData API,
    // but not non-multipart XHR file uploads:
    $.support.xhrFileUpload = !!(window.XMLHttpRequestUpload && window.FileReader);
    $.support.xhrFormDataFileUpload = !!window.FormData;

    // The form.elements propHook is added to filter serialized elements
    // to not include file inputs in jQuery 1.9.0.
    // This hooks directly into jQuery.fn.serializeArray.
    // For more info, see http://bugs.jquery.com/ticket/13306
    $.propHooks.elements = {
        get: function (form) {
            if ($.nodeName(form, 'form')) {
                return $.grep(form.elements, function (elem) {
                    return !$.nodeName(elem, 'input') || elem.type !== 'file';
                });
            }
            return null;
        }
    };

    // The fileupload widget listens for change events on file input fields defined
    // via fileInput setting and paste or drop events of the given dropZone.
    // In addition to the default jQuery Widget methods, the fileupload widget
    // exposes the "add" and "send" methods, to add or directly send files using
    // the fileupload API.
    // By default, files added via file input selection, paste, drag & drop or
    // "add" method are uploaded immediately, but it is possible to override
    // the "add" callback option to queue file uploads.
    $.widget('blueimp.fileupload', {

        options: {
            // The drop target element(s), by the default the complete document.
            // Set to null to disable drag & drop support:
            dropZone: $(document),
            // The paste target element(s), by the default the complete document.
            // Set to null to disable paste support:
            pasteZone: $(document),
            // The file input field(s), that are listened to for change events.
            // If undefined, it is set to the file input fields inside
            // of the widget element on plugin initialization.
            // Set to null to disable the change listener.
            fileInput: undefined,
            // By default, the file input field is replaced with a clone after
            // each input field change event. This is required for iframe transport
            // queues and allows change events to be fired for the same file
            // selection, but can be disabled by setting the following option to false:
            replaceFileInput: true,
            // The parameter name for the file form data (the request argument name).
            // If undefined or empty, the name property of the file input field is
            // used, or "files[]" if the file input name property is also empty,
            // can be a string or an array of strings:
            paramName: undefined,
            // By default, each file of a selection is uploaded using an individual
            // request for XHR type uploads. Set to false to upload file
            // selections in one request each:
            singleFileUploads: true,
            // To limit the number of files uploaded with one XHR request,
            // set the following option to an integer greater than 0:
            limitMultiFileUploads: undefined,
            // Set the following option to true to issue all file upload requests
            // in a sequential order:
            sequentialUploads: false,
            // To limit the number of concurrent uploads,
            // set the following option to an integer greater than 0:
            limitConcurrentUploads: undefined,
            // Set the following option to true to force iframe transport uploads:
            forceIframeTransport: false,
            // Set the following option to the location of a redirect url on the
            // origin server, for cross-domain iframe transport uploads:
            redirect: undefined,
            // The parameter name for the redirect url, sent as part of the form
            // data and set to 'redirect' if this option is empty:
            redirectParamName: undefined,
            // Set the following option to the location of a postMessage window,
            // to enable postMessage transport uploads:
            postMessage: undefined,
            // By default, XHR file uploads are sent as multipart/form-data.
            // The iframe transport is always using multipart/form-data.
            // Set to false to enable non-multipart XHR uploads:
            multipart: true,
            // To upload large files in smaller chunks, set the following option
            // to a preferred maximum chunk size. If set to 0, null or undefined,
            // or the browser does not support the required Blob API, files will
            // be uploaded as a whole.
            maxChunkSize: undefined,
            // When a non-multipart upload or a chunked multipart upload has been
            // aborted, this option can be used to resume the upload by setting
            // it to the size of the already uploaded bytes. This option is most
            // useful when modifying the options object inside of the "add" or
            // "send" callbacks, as the options are cloned for each file upload.
            uploadedBytes: undefined,
            // By default, failed (abort or error) file uploads are removed from the
            // global progress calculation. Set the following option to false to
            // prevent recalculating the global progress data:
            recalculateProgress: true,
            // Interval in milliseconds to calculate and trigger progress events:
            progressInterval: 100,
            // Interval in milliseconds to calculate progress bitrate:
            bitrateInterval: 500,

            // Additional form data to be sent along with the file uploads can be set
            // using this option, which accepts an array of objects with name and
            // value properties, a function returning such an array, a FormData
            // object (for XHR file uploads), or a simple object.
            // The form of the first fileInput is given as parameter to the function:
            formData: function (form) {
                return form.serializeArray();
            },

            // The add callback is invoked as soon as files are added to the fileupload
            // widget (via file input selection, drag & drop, paste or add API call).
            // If the singleFileUploads option is enabled, this callback will be
            // called once for each file in the selection for XHR file uplaods, else
            // once for each file selection.
            // The upload starts when the submit method is invoked on the data parameter.
            // The data object contains a files property holding the added files
            // and allows to override plugin options as well as define ajax settings.
            // Listeners for this callback can also be bound the following way:
            // .bind('fileuploadadd', func);
            // data.submit() returns a Promise object and allows to attach additional
            // handlers using jQuery's Deferred callbacks:
            // data.submit().done(func).fail(func).always(func);
            add: function (e, data) {
                data.submit();
            },

            // Other callbacks:

            // Callback for the submit event of each file upload:
            // submit: function (e, data) {}, // .bind('fileuploadsubmit', func);

            // Callback for the start of each file upload request:
            // send: function (e, data) {}, // .bind('fileuploadsend', func);

            // Callback for successful uploads:
            // done: function (e, data) {}, // .bind('fileuploaddone', func);

            // Callback for failed (abort or error) uploads:
            // fail: function (e, data) {}, // .bind('fileuploadfail', func);

            // Callback for completed (success, abort or error) requests:
            // always: function (e, data) {}, // .bind('fileuploadalways', func);

            // Callback for upload progress events:
            // progress: function (e, data) {}, // .bind('fileuploadprogress', func);

            // Callback for global upload progress events:
            // progressall: function (e, data) {}, // .bind('fileuploadprogressall', func);

            // Callback for uploads start, equivalent to the global ajaxStart event:
            // start: function (e) {}, // .bind('fileuploadstart', func);

            // Callback for uploads stop, equivalent to the global ajaxStop event:
            // stop: function (e) {}, // .bind('fileuploadstop', func);

            // Callback for change events of the fileInput(s):
            // change: function (e, data) {}, // .bind('fileuploadchange', func);

            // Callback for paste events to the pasteZone(s):
            // paste: function (e, data) {}, // .bind('fileuploadpaste', func);

            // Callback for drop events of the dropZone(s):
            // drop: function (e, data) {}, // .bind('fileuploaddrop', func);

            // Callback for dragover events of the dropZone(s):
            // dragover: function (e) {}, // .bind('fileuploaddragover', func);

            // Callback for the start of each chunk upload request:
            // chunksend: function (e, data) {}, // .bind('fileuploadchunksend', func);

            // Callback for successful chunk uploads:
            // chunkdone: function (e, data) {}, // .bind('fileuploadchunkdone', func);

            // Callback for failed (abort or error) chunk uploads:
            // chunkfail: function (e, data) {}, // .bind('fileuploadchunkfail', func);

            // Callback for completed (success, abort or error) chunk upload requests:
            // chunkalways: function (e, data) {}, // .bind('fileuploadchunkalways', func);

            // The plugin options are used as settings object for the ajax calls.
            // The following are jQuery ajax settings required for the file uploads:
            processData: false,
            contentType: false,
            cache: false
        },

        // A list of options that require a refresh after assigning a new value:
        _refreshOptionsList: [
            'fileInput',
            'dropZone',
            'pasteZone',
            'multipart',
            'forceIframeTransport'
        ],

        _BitrateTimer: function () {
            this.timestamp = +(new Date());
            this.loaded = 0;
            this.bitrate = 0;
            this.getBitrate = function (now, loaded, interval) {
                var timeDiff = now - this.timestamp;
                if (!this.bitrate || !interval || timeDiff > interval) {
                    this.bitrate = (loaded - this.loaded) * (1000 / timeDiff) * 8;
                    this.loaded = loaded;
                    this.timestamp = now;
                }
                return this.bitrate;
            };
        },

        _isXHRUpload: function (options) {
            return !options.forceIframeTransport &&
                ((!options.multipart && $.support.xhrFileUpload) ||
                $.support.xhrFormDataFileUpload);
        },

        _getFormData: function (options) {
            var formData;
            if (typeof options.formData === 'function') {
                return options.formData(options.form);
            }
            if ($.isArray(options.formData)) {
                return options.formData;
            }
            if (options.formData) {
                formData = [];
                $.each(options.formData, function (name, value) {
                    formData.push({name: name, value: value});
                });
                return formData;
            }
            return [];
        },

        _getTotal: function (files) {
            var total = 0;
            $.each(files, function (index, file) {
                total += file.size || 1;
            });
            return total;
        },

        _onProgress: function (e, data) {
            if (e.lengthComputable) {
                var now = +(new Date()),
                    total,
                    loaded;
                if (data._time && data.progressInterval &&
                        (now - data._time < data.progressInterval) &&
                        e.loaded !== e.total) {
                    return;
                }
                data._time = now;
                total = data.total || this._getTotal(data.files);
                loaded = parseInt(
                    e.loaded / e.total * (data.chunkSize || total),
                    10
                ) + (data.uploadedBytes || 0);
                this._loaded += loaded - (data.loaded || data.uploadedBytes || 0);
                data.lengthComputable = true;
                data.loaded = loaded;
                data.total = total;
                data.bitrate = data._bitrateTimer.getBitrate(
                    now,
                    loaded,
                    data.bitrateInterval
                );
                // Trigger a custom progress event with a total data property set
                // to the file size(s) of the current upload and a loaded data
                // property calculated accordingly:
                this._trigger('progress', e, data);
                // Trigger a global progress event for all current file uploads,
                // including ajax calls queued for sequential file uploads:
                this._trigger('progressall', e, {
                    lengthComputable: true,
                    loaded: this._loaded,
                    total: this._total,
                    bitrate: this._bitrateTimer.getBitrate(
                        now,
                        this._loaded,
                        data.bitrateInterval
                    )
                });
            }
        },

        _initProgressListener: function (options) {
            var that = this,
                xhr = options.xhr ? options.xhr() : $.ajaxSettings.xhr();
            // Accesss to the native XHR object is required to add event listeners
            // for the upload progress event:
            if (xhr.upload) {
                $(xhr.upload).bind('progress', function (e) {
                    var oe = e.originalEvent;
                    // Make sure the progress event properties get copied over:
                    e.lengthComputable = oe.lengthComputable;
                    e.loaded = oe.loaded;
                    e.total = oe.total;
                    that._onProgress(e, options);
                });
                options.xhr = function () {
                    return xhr;
                };
            }
        },

        _initXHRData: function (options) {
            var formData,
                file = options.files[0],
                // Ignore non-multipart setting if not supported:
                multipart = options.multipart || !$.support.xhrFileUpload,
                paramName = options.paramName[0];
            options.headers = options.headers || {};
            if (options.contentRange) {
                options.headers['Content-Range'] = options.contentRange;
            }
            if (!multipart) {
                options.headers['Content-Disposition'] = 'attachment; filename="' +
                    encodeURI(file.name) + '"';
                options.contentType = file.type;
                options.data = options.blob || file;
            } else if ($.support.xhrFormDataFileUpload) {
                if (options.postMessage) {
                    // window.postMessage does not allow sending FormData
                    // objects, so we just add the File/Blob objects to
                    // the formData array and let the postMessage window
                    // create the FormData object out of this array:
                    formData = this._getFormData(options);
                    if (options.blob) {
                        formData.push({
                            name: paramName,
                            value: options.blob
                        });
                    } else {
                        $.each(options.files, function (index, file) {
                            formData.push({
                                name: options.paramName[index] || paramName,
                                value: file
                            });
                        });
                    }
                } else {
                    if (options.formData instanceof FormData) {
                        formData = options.formData;
                    } else {
                        formData = new FormData();
                        $.each(this._getFormData(options), function (index, field) {
                            formData.append(field.name, field.value);
                        });
                    }
                    if (options.blob) {
                        options.headers['Content-Disposition'] = 'attachment; filename="' +
                            encodeURI(file.name) + '"';
                        formData.append(paramName, options.blob, file.name);
                    } else {
                        $.each(options.files, function (index, file) {
                            // Files are also Blob instances, but some browsers
                            // (Firefox 3.6) support the File API but not Blobs.
                            // This check allows the tests to run with
                            // dummy objects:
                            if ((window.Blob && file instanceof Blob) ||
                                    (window.File && file instanceof File)) {
                                formData.append(
                                    options.paramName[index] || paramName,
                                    file,
                                    file.name
                                );
                            }
                        });
                    }
                }
                options.data = formData;
            }
            // Blob reference is not needed anymore, free memory:
            options.blob = null;
        },

        _initIframeSettings: function (options) {
            // Setting the dataType to iframe enables the iframe transport:
            options.dataType = 'iframe ' + (options.dataType || '');
            // The iframe transport accepts a serialized array as form data:
            options.formData = this._getFormData(options);
            // Add redirect url to form data on cross-domain uploads:
            if (options.redirect && $('<a></a>').prop('href', options.url)
                    .prop('host') !== location.host) {
                options.formData.push({
                    name: options.redirectParamName || 'redirect',
                    value: options.redirect
                });
            }
        },

        _initDataSettings: function (options) {
            if (this._isXHRUpload(options)) {
                if (!this._chunkedUpload(options, true)) {
                    if (!options.data) {
                        this._initXHRData(options);
                    }
                    this._initProgressListener(options);
                }
                if (options.postMessage) {
                    // Setting the dataType to postmessage enables the
                    // postMessage transport:
                    options.dataType = 'postmessage ' + (options.dataType || '');
                }
            } else {
                this._initIframeSettings(options, 'iframe');
            }
        },

        _getParamName: function (options) {
            var fileInput = $(options.fileInput),
                paramName = options.paramName;
            if (!paramName) {
                paramName = [];
                fileInput.each(function () {
                    var input = $(this),
                        name = input.prop('name') || 'files[]',
                        i = (input.prop('files') || [1]).length;
                    while (i) {
                        paramName.push(name);
                        i -= 1;
                    }
                });
                if (!paramName.length) {
                    paramName = [fileInput.prop('name') || 'files[]'];
                }
            } else if (!$.isArray(paramName)) {
                paramName = [paramName];
            }
            return paramName;
        },

        _initFormSettings: function (options) {
            // Retrieve missing options from the input field and the
            // associated form, if available:
            if (!options.form || !options.form.length) {
                options.form = $(options.fileInput.prop('form'));
                // If the given file input doesn't have an associated form,
                // use the default widget file input's form:
                if (!options.form.length) {
                    options.form = $(this.options.fileInput.prop('form'));
                }
            }
            options.paramName = this._getParamName(options);
            if (!options.url) {
                options.url = options.form.prop('action') || location.href;
            }
            // The HTTP request method must be "POST" or "PUT":
            options.type = (options.type || options.form.prop('method') || '')
                .toUpperCase();
            if (options.type !== 'POST' && options.type !== 'PUT' &&
                    options.type !== 'PATCH') {
                options.type = 'POST';
            }
            if (!options.formAcceptCharset) {
                options.formAcceptCharset = options.form.attr('accept-charset');
            }
        },

        _getAJAXSettings: function (data) {
            var options = $.extend({}, this.options, data);
            this._initFormSettings(options);
            this._initDataSettings(options);
            return options;
        },

        // Maps jqXHR callbacks to the equivalent
        // methods of the given Promise object:
        _enhancePromise: function (promise) {
            promise.success = promise.done;
            promise.error = promise.fail;
            promise.complete = promise.always;
            return promise;
        },

        // Creates and returns a Promise object enhanced with
        // the jqXHR methods abort, success, error and complete:
        _getXHRPromise: function (resolveOrReject, context, args) {
            var dfd = $.Deferred(),
                promise = dfd.promise();
            context = context || this.options.context || promise;
            if (resolveOrReject === true) {
                dfd.resolveWith(context, args);
            } else if (resolveOrReject === false) {
                dfd.rejectWith(context, args);
            }
            promise.abort = dfd.promise;
            return this._enhancePromise(promise);
        },

        // Parses the Range header from the server response
        // and returns the uploaded bytes:
        _getUploadedBytes: function (jqXHR) {
            var range = jqXHR.getResponseHeader('Range'),
                parts = range && range.split('-'),
                upperBytesPos = parts && parts.length > 1 &&
                    parseInt(parts[1], 10);
            return upperBytesPos && upperBytesPos + 1;
        },

        // Uploads a file in multiple, sequential requests
        // by splitting the file up in multiple blob chunks.
        // If the second parameter is true, only tests if the file
        // should be uploaded in chunks, but does not invoke any
        // upload requests:
        _chunkedUpload: function (options, testOnly) {
            var that = this,
                file = options.files[0],
                fs = file.size,
                ub = options.uploadedBytes = options.uploadedBytes || 0,
                mcs = options.maxChunkSize || fs,
                slice = file.slice || file.webkitSlice || file.mozSlice,
                dfd = $.Deferred(),
                promise = dfd.promise(),
                jqXHR,
                upload;
            if (!(this._isXHRUpload(options) && slice && (ub || mcs < fs)) ||
                    options.data) {
                return false;
            }
            if (testOnly) {
                return true;
            }
            if (ub >= fs) {
                file.error = 'Uploaded bytes exceed file size';
                return this._getXHRPromise(
                    false,
                    options.context,
                    [null, 'error', file.error]
                );
            }
            // The chunk upload method:
            upload = function (i) {
                // Clone the options object for each chunk upload:
                var o = $.extend({}, options);
                o.blob = slice.call(
                    file,
                    ub,
                    ub + mcs,
                    file.type
                );
                // Store the current chunk size, as the blob itself
                // will be dereferenced after data processing:
                o.chunkSize = o.blob.size;
                // Expose the chunk bytes position range:
                o.contentRange = 'bytes ' + ub + '-' +
                    (ub + o.chunkSize - 1) + '/' + fs;
                // Process the upload data (the blob and potential form data):
                that._initXHRData(o);
                // Add progress listeners for this chunk upload:
                that._initProgressListener(o);
                jqXHR = ((that._trigger('chunksend', null, o) !== false && $.ajax(o)) ||
                        that._getXHRPromise(false, o.context))
                    .done(function (result, textStatus, jqXHR) {
                        ub = that._getUploadedBytes(jqXHR) ||
                            (ub + o.chunkSize);
                        // Create a progress event if upload is done and no progress
                        // event has been invoked for this chunk, or there has been
                        // no progress event with loaded equaling total:
                        if (!o.loaded || o.loaded < o.total) {
                            that._onProgress($.Event('progress', {
                                lengthComputable: true,
                                loaded: ub - o.uploadedBytes,
                                total: ub - o.uploadedBytes
                            }), o);
                        }
                        options.uploadedBytes = o.uploadedBytes = ub;
                        o.result = result;
                        o.textStatus = textStatus;
                        o.jqXHR = jqXHR;
                        that._trigger('chunkdone', null, o);
                        that._trigger('chunkalways', null, o);
                        if (ub < fs) {
                            // File upload not yet complete,
                            // continue with the next chunk:
                            upload();
                        } else {
                            dfd.resolveWith(
                                o.context,
                                [result, textStatus, jqXHR]
                            );
                        }
                    })
                    .fail(function (jqXHR, textStatus, errorThrown) {
                        o.jqXHR = jqXHR;
                        o.textStatus = textStatus;
                        o.errorThrown = errorThrown;
                        that._trigger('chunkfail', null, o);
                        that._trigger('chunkalways', null, o);
                        dfd.rejectWith(
                            o.context,
                            [jqXHR, textStatus, errorThrown]
                        );
                    });
            };
            this._enhancePromise(promise);
            promise.abort = function () {
                return jqXHR.abort();
            };
            upload();
            return promise;
        },

        _beforeSend: function (e, data) {
            if (this._active === 0) {
                // the start callback is triggered when an upload starts
                // and no other uploads are currently running,
                // equivalent to the global ajaxStart event:
                this._trigger('start');
                // Set timer for global bitrate progress calculation:
                this._bitrateTimer = new this._BitrateTimer();
            }
            this._active += 1;
            // Initialize the global progress values:
            this._loaded += data.uploadedBytes || 0;
            this._total += this._getTotal(data.files);
        },

        _onDone: function (result, textStatus, jqXHR, options) {
            if (!this._isXHRUpload(options) || !options.loaded ||
                    options.loaded < options.total) {
                var total = this._getTotal(options.files) || 1;
                // Create a progress event for each iframe load,
                // or if there has been no progress event with
                // loaded equaling total for XHR uploads:
                this._onProgress($.Event('progress', {
                    lengthComputable: true,
                    loaded: total,
                    total: total
                }), options);
            }
            options.result = result;
            options.textStatus = textStatus;
            options.jqXHR = jqXHR;
            this._trigger('done', null, options);
        },

        _onFail: function (jqXHR, textStatus, errorThrown, options) {
            options.jqXHR = jqXHR;
            options.textStatus = textStatus;
            options.errorThrown = errorThrown;
            this._trigger('fail', null, options);
            if (options.recalculateProgress) {
                // Remove the failed (error or abort) file upload from
                // the global progress calculation:
                this._loaded -= options.loaded || options.uploadedBytes || 0;
                this._total -= options.total || this._getTotal(options.files);
            }
        },

        _onAlways: function (jqXHRorResult, textStatus, jqXHRorError, options) {
            // jqXHRorResult, textStatus and jqXHRorError are added to the
            // options object via done and fail callbacks
            this._active -= 1;
            this._trigger('always', null, options);
            if (this._active === 0) {
                // The stop callback is triggered when all uploads have
                // been completed, equivalent to the global ajaxStop event:
                this._trigger('stop');
                // Reset the global progress values:
                this._loaded = this._total = 0;
                this._bitrateTimer = null;
            }
        },

        _onSend: function (e, data) {
            var that = this,
                jqXHR,
                aborted,
                slot,
                pipe,
                options = that._getAJAXSettings(data),
                send = function () {
                    that._sending += 1;
                    // Set timer for bitrate progress calculation:
                    options._bitrateTimer = new that._BitrateTimer();
                    jqXHR = jqXHR || (
                        ((aborted || that._trigger('send', e, options) === false) &&
                        that._getXHRPromise(false, options.context, aborted)) ||
                        that._chunkedUpload(options) || $.ajax(options)
                    ).done(function (result, textStatus, jqXHR) {
                        that._onDone(result, textStatus, jqXHR, options);
                    }).fail(function (jqXHR, textStatus, errorThrown) {
                        that._onFail(jqXHR, textStatus, errorThrown, options);
                    }).always(function (jqXHRorResult, textStatus, jqXHRorError) {
                        that._sending -= 1;
                        that._onAlways(
                            jqXHRorResult,
                            textStatus,
                            jqXHRorError,
                            options
                        );
                        if (options.limitConcurrentUploads &&
                                options.limitConcurrentUploads > that._sending) {
                            // Start the next queued upload,
                            // that has not been aborted:
                            var nextSlot = that._slots.shift(),
                                isPending;
                            while (nextSlot) {
                                // jQuery 1.6 doesn't provide .state(),
                                // while jQuery 1.8+ removed .isRejected():
                                isPending = nextSlot.state ?
                                        nextSlot.state() === 'pending' :
                                        !nextSlot.isRejected();
                                if (isPending) {
                                    nextSlot.resolve();
                                    break;
                                }
                                nextSlot = that._slots.shift();
                            }
                        }
                    });
                    return jqXHR;
                };
            this._beforeSend(e, options);
            if (this.options.sequentialUploads ||
                    (this.options.limitConcurrentUploads &&
                    this.options.limitConcurrentUploads <= this._sending)) {
                if (this.options.limitConcurrentUploads > 1) {
                    slot = $.Deferred();
                    this._slots.push(slot);
                    pipe = slot.pipe(send);
                } else {
                    pipe = (this._sequence = this._sequence.pipe(send, send));
                }
                // Return the piped Promise object, enhanced with an abort method,
                // which is delegated to the jqXHR object of the current upload,
                // and jqXHR callbacks mapped to the equivalent Promise methods:
                pipe.abort = function () {
                    aborted = [undefined, 'abort', 'abort'];
                    if (!jqXHR) {
                        if (slot) {
                            slot.rejectWith(options.context, aborted);
                        }
                        return send();
                    }
                    return jqXHR.abort();
                };
                return this._enhancePromise(pipe);
            }
            return send();
        },

        _onAdd: function (e, data) {
            var that = this,
                result = true,
                options = $.extend({}, this.options, data),
                limit = options.limitMultiFileUploads,
                paramName = this._getParamName(options),
                paramNameSet,
                paramNameSlice,
                fileSet,
                i;
            if (!(options.singleFileUploads || limit) ||
                    !this._isXHRUpload(options)) {
                fileSet = [data.files];
                paramNameSet = [paramName];
            } else if (!options.singleFileUploads && limit) {
                fileSet = [];
                paramNameSet = [];
                for (i = 0; i < data.files.length; i += limit) {
                    fileSet.push(data.files.slice(i, i + limit));
                    paramNameSlice = paramName.slice(i, i + limit);
                    if (!paramNameSlice.length) {
                        paramNameSlice = paramName;
                    }
                    paramNameSet.push(paramNameSlice);
                }
            } else {
                paramNameSet = paramName;
            }
            data.originalFiles = data.files;
            $.each(fileSet || data.files, function (index, element) {
                var newData = $.extend({}, data);
                newData.files = fileSet ? element : [element];
                newData.paramName = paramNameSet[index];
                newData.submit = function () {
                    newData.jqXHR = this.jqXHR =
                        (that._trigger('submit', e, this) !== false) &&
                        that._onSend(e, this);
                    return this.jqXHR;
                };
                result = that._trigger('add', e, newData);
                return result;
            });
            return result;
        },

        _replaceFileInput: function (input) {
            var inputClone = input.clone(true);
            $('<form></form>').append(inputClone)[0].reset();
            // Detaching allows to insert the fileInput on another form
            // without loosing the file input value:
            input.after(inputClone).detach();
            // Avoid memory leaks with the detached file input:
            $.cleanData(input.unbind('remove'));
            // Replace the original file input element in the fileInput
            // elements set with the clone, which has been copied including
            // event handlers:
            this.options.fileInput = this.options.fileInput.map(function (i, el) {
                if (el === input[0]) {
                    return inputClone[0];
                }
                return el;
            });
            // If the widget has been initialized on the file input itself,
            // override this.element with the file input clone:
            if (input[0] === this.element[0]) {
                this.element = inputClone;
            }
        },

        _handleFileTreeEntry: function (entry, path) {
            var that = this,
                dfd = $.Deferred(),
                errorHandler = function (e) {
                    if (e && !e.entry) {
                        e.entry = entry;
                    }
                    // Since $.when returns immediately if one
                    // Deferred is rejected, we use resolve instead.
                    // This allows valid files and invalid items
                    // to be returned together in one set:
                    dfd.resolve([e]);
                },
                dirReader;
            path = path || '';
            if (entry.isFile) {
                if (entry._file) {
                    // Workaround for Chrome bug #149735
                    entry._file.relativePath = path;
                    dfd.resolve(entry._file);
                } else {
                    entry.file(function (file) {
                        file.relativePath = path;
                        dfd.resolve(file);
                    }, errorHandler);
                }
            } else if (entry.isDirectory) {
                dirReader = entry.createReader();
                dirReader.readEntries(function (entries) {
                    that._handleFileTreeEntries(
                        entries,
                        path + entry.name + '/'
                    ).done(function (files) {
                        dfd.resolve(files);
                    }).fail(errorHandler);
                }, errorHandler);
            } else {
                // Return an empy list for file system items
                // other than files or directories:
                dfd.resolve([]);
            }
            return dfd.promise();
        },

        _handleFileTreeEntries: function (entries, path) {
            var that = this;
            return $.when.apply(
                $,
                $.map(entries, function (entry) {
                    return that._handleFileTreeEntry(entry, path);
                })
            ).pipe(function () {
                return Array.prototype.concat.apply(
                    [],
                    arguments
                );
            });
        },

        _getDroppedFiles: function (dataTransfer) {
            dataTransfer = dataTransfer || {};
            var items = dataTransfer.items;
            if (items && items.length && (items[0].webkitGetAsEntry ||
                    items[0].getAsEntry)) {
                return this._handleFileTreeEntries(
                    $.map(items, function (item) {
                        var entry;
                        if (item.webkitGetAsEntry) {
                            entry = item.webkitGetAsEntry();
                            if (entry) {
                                // Workaround for Chrome bug #149735:
                                entry._file = item.getAsFile();
                            }
                            return entry;
                        }
                        return item.getAsEntry();
                    })
                );
            }
            return $.Deferred().resolve(
                $.makeArray(dataTransfer.files)
            ).promise();
        },

        _getSingleFileInputFiles: function (fileInput) {
            fileInput = $(fileInput);
            var entries = fileInput.prop('webkitEntries') ||
                    fileInput.prop('entries'),
                files,
                value;
            if (entries && entries.length) {
                return this._handleFileTreeEntries(entries);
            }
            files = $.makeArray(fileInput.prop('files'));
            if (!files.length) {
                value = fileInput.prop('value');
                if (!value) {
                    return $.Deferred().resolve([]).promise();
                }
                // If the files property is not available, the browser does not
                // support the File API and we add a pseudo File object with
                // the input value as name with path information removed:
                files = [{name: value.replace(/^.*\\/, '')}];
            } else if (files[0].name === undefined && files[0].fileName) {
                // File normalization for Safari 4 and Firefox 3:
                $.each(files, function (index, file) {
                    file.name = file.fileName;
                    file.size = file.fileSize;
                });
            }
            return $.Deferred().resolve(files).promise();
        },

        _getFileInputFiles: function (fileInput) {
            if (!(fileInput instanceof $) || fileInput.length === 1) {
                return this._getSingleFileInputFiles(fileInput);
            }
            return $.when.apply(
                $,
                $.map(fileInput, this._getSingleFileInputFiles)
            ).pipe(function () {
                return Array.prototype.concat.apply(
                    [],
                    arguments
                );
            });
        },

        _onChange: function (e) {
            var that = this,
                data = {
                    fileInput: $(e.target),
                    form: $(e.target.form)
                };
            this._getFileInputFiles(data.fileInput).always(function (files) {
                data.files = files;
                if (that.options.replaceFileInput) {
                    that._replaceFileInput(data.fileInput);
                }
                if (that._trigger('change', e, data) !== false) {
                    that._onAdd(e, data);
                }
            });
        },

        _onPaste: function (e) {
            var cbd = e.originalEvent.clipboardData,
                items = (cbd && cbd.items) || [],
                data = {files: []};
            $.each(items, function (index, item) {
                var file = item.getAsFile && item.getAsFile();
                if (file) {
                    data.files.push(file);
                }
            });
            if (this._trigger('paste', e, data) === false ||
                    this._onAdd(e, data) === false) {
                return false;
            }
        },

        _onDrop: function (e) {
            var that = this,
                dataTransfer = e.dataTransfer = e.originalEvent.dataTransfer,
                data = {};
            if (dataTransfer && dataTransfer.files && dataTransfer.files.length) {
                e.preventDefault();
            }
            this._getDroppedFiles(dataTransfer).always(function (files) {
                data.files = files;
                if (that._trigger('drop', e, data) !== false) {
                    that._onAdd(e, data);
                }
            });
        },

        _onDragOver: function (e) {
            var dataTransfer = e.dataTransfer = e.originalEvent.dataTransfer;
            if (this._trigger('dragover', e) === false) {
                return false;
            }
            if (dataTransfer && $.inArray('Files', dataTransfer.types) !== -1) {
                dataTransfer.dropEffect = 'copy';
                e.preventDefault();
            }
        },

        _initEventHandlers: function () {
            if (this._isXHRUpload(this.options)) {
                this._on(this.options.dropZone, {
                    dragover: this._onDragOver,
                    drop: this._onDrop
                });
                this._on(this.options.pasteZone, {
                    paste: this._onPaste
                });
            }
            this._on(this.options.fileInput, {
                change: this._onChange
            });
        },

        _destroyEventHandlers: function () {
            this._off(this.options.dropZone, 'dragover drop');
            this._off(this.options.pasteZone, 'paste');
            this._off(this.options.fileInput, 'change');
        },

        _setOption: function (key, value) {
            var refresh = $.inArray(key, this._refreshOptionsList) !== -1;
            if (refresh) {
                this._destroyEventHandlers();
            }
            this._super(key, value);
            if (refresh) {
                this._initSpecialOptions();
                this._initEventHandlers();
            }
        },

        _initSpecialOptions: function () {
            var options = this.options;
            if (options.fileInput === undefined) {
                options.fileInput = this.element.is('input[type="file"]') ?
                        this.element : this.element.find('input[type="file"]');
            } else if (!(options.fileInput instanceof $)) {
                options.fileInput = $(options.fileInput);
            }
            if (!(options.dropZone instanceof $)) {
                options.dropZone = $(options.dropZone);
            }
            if (!(options.pasteZone instanceof $)) {
                options.pasteZone = $(options.pasteZone);
            }
        },

        _create: function () {
            var options = this.options;
            // Initialize options set via HTML5 data-attributes:
            $.extend(options, $(this.element[0].cloneNode(false)).data());
            this._initSpecialOptions();
            this._slots = [];
            this._sequence = this._getXHRPromise(true);
            this._sending = this._active = this._loaded = this._total = 0;
            this._initEventHandlers();
        },

        _destroy: function () {
            this._destroyEventHandlers();
        },

        // This method is exposed to the widget API and allows adding files
        // using the fileupload API. The data parameter accepts an object which
        // must have a files property and can contain additional options:
        // .fileupload('add', {files: filesList});
        add: function (data) {
            var that = this;
            if (!data || this.options.disabled) {
                return;
            }
            if (data.fileInput && !data.files) {
                this._getFileInputFiles(data.fileInput).always(function (files) {
                    data.files = files;
                    that._onAdd(null, data);
                });
            } else {
                data.files = $.makeArray(data.files);
                this._onAdd(null, data);
            }
        },

        // This method is exposed to the widget API and allows sending files
        // using the fileupload API. The data parameter accepts an object which
        // must have a files or fileInput property and can contain additional options:
        // .fileupload('send', {files: filesList});
        // The method returns a Promise object for the file upload call.
        send: function (data) {
            if (data && !this.options.disabled) {
                if (data.fileInput && !data.files) {
                    var that = this,
                        dfd = $.Deferred(),
                        promise = dfd.promise(),
                        jqXHR,
                        aborted;
                    promise.abort = function () {
                        aborted = true;
                        if (jqXHR) {
                            return jqXHR.abort();
                        }
                        dfd.reject(null, 'abort', 'abort');
                        return promise;
                    };
                    this._getFileInputFiles(data.fileInput).always(
                        function (files) {
                            if (aborted) {
                                return;
                            }
                            data.files = files;
                            jqXHR = that._onSend(null, data).then(
                                function (result, textStatus, jqXHR) {
                                    dfd.resolve(result, textStatus, jqXHR);
                                },
                                function (jqXHR, textStatus, errorThrown) {
                                    dfd.reject(jqXHR, textStatus, errorThrown);
                                }
                            );
                        }
                    );
                    return this._enhancePromise(promise);
                }
                data.files = $.makeArray(data.files);
                if (data.files.length) {
                    return this._onSend(null, data);
                }
            }
            return this._getXHRPromise(false, data && data.context);
        }

    });

}));
/*
 * jQuery File Upload File Processing Plugin 1.2.1
 * https://github.com/blueimp/jQuery-File-Upload
 *
 * Copyright 2012, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * http://www.opensource.org/licenses/MIT
 */

/*jslint nomen: true, unparam: true, regexp: true */
/*global define, window, document */


(function (factory) {
    'use strict';
    if (typeof define === 'function' && define.amd) {
        // Register as an anonymous AMD module:
        define([
            'jquery',
            'load-image',
            'canvas-to-blob',
            './jquery.fileupload'
        ], factory);
    } else {
        // Browser globals:
        factory(
            window.jQuery,
            window.loadImage
        );
    }
}(function ($, loadImage) {
    'use strict';

    // The File Upload FP version extends the fileupload widget
    // with file processing functionality:
    $.widget('blueimp.fileupload', $.blueimp.fileupload, {

        options: {
            // The list of file processing actions:
            process: [
            /*
                {
                    action: 'load',
                    fileTypes: /^image\/(gif|jpeg|png)$/,
                    maxFileSize: 20000000 // 20MB
                },
                {
                    action: 'resize',
                    maxWidth: 1920,
                    maxHeight: 1200,
                    minWidth: 800,
                    minHeight: 600
                },
                {
                    action: 'save'
                }
            */
            ],

            // The add callback is invoked as soon as files are added to the
            // fileupload widget (via file input selection, drag & drop or add
            // API call). See the basic file upload widget for more information:
            add: function (e, data) {
                $(this).fileupload('process', data).done(function () {
                    data.submit();
                });
            }
        },

        processActions: {
            // Loads the image given via data.files and data.index
            // as img element if the browser supports canvas.
            // Accepts the options fileTypes (regular expression)
            // and maxFileSize (integer) to limit the files to load:
            load: function (data, options) {
                var that = this,
                    file = data.files[data.index],
                    dfd = $.Deferred();
                if (window.HTMLCanvasElement &&
                        window.HTMLCanvasElement.prototype.toBlob &&
                        ($.type(options.maxFileSize) !== 'number' ||
                            file.size < options.maxFileSize) &&
                        (!options.fileTypes ||
                            options.fileTypes.test(file.type))) {
                    loadImage(
                        file,
                        function (img) {
                            if (!img.src) {
                                return dfd.rejectWith(that, [data]);
                            }
                            data.img = img;
                            dfd.resolveWith(that, [data]);
                        }
                    );
                } else {
                    dfd.rejectWith(that, [data]);
                }
                return dfd.promise();
            },
            // Resizes the image given as data.img and updates
            // data.canvas with the resized image as canvas element.
            // Accepts the options maxWidth, maxHeight, minWidth and
            // minHeight to scale the given image:
            resize: function (data, options) {
                var img = data.img,
                    canvas;
                options = $.extend({canvas: true}, options);
                if (img) {
                    canvas = loadImage.scale(img, options);
                    if (canvas.width !== img.width ||
                            canvas.height !== img.height) {
                        data.canvas = canvas;
                    }
                }
                return data;
            },
            // Saves the processed image given as data.canvas
            // inplace at data.index of data.files:
            save: function (data, options) {
                // Do nothing if no processing has happened:
                if (!data.canvas) {
                    return data;
                }
                var that = this,
                    file = data.files[data.index],
                    name = file.name,
                    dfd = $.Deferred(),
                    callback = function (blob) {
                        if (!blob.name) {
                            if (file.type === blob.type) {
                                blob.name = file.name;
                            } else if (file.name) {
                                blob.name = file.name.replace(
                                    /\..+$/,
                                    '.' + blob.type.substr(6)
                                );
                            }
                        }
                        // Store the created blob at the position
                        // of the original file in the files list:
                        data.files[data.index] = blob;
                        dfd.resolveWith(that, [data]);
                    };
                // Use canvas.mozGetAsFile directly, to retain the filename, as
                // Gecko doesn't support the filename option for FormData.append:
                if (data.canvas.mozGetAsFile) {
                    callback(data.canvas.mozGetAsFile(
                        (/^image\/(jpeg|png)$/.test(file.type) && name) ||
                            ((name && name.replace(/\..+$/, '')) ||
                                'blob') + '.png',
                        file.type
                    ));
                } else {
                    data.canvas.toBlob(callback, file.type);
                }
                return dfd.promise();
            }
        },

        // Resizes the file at the given index and stores the created blob at
        // the original position of the files list, returns a Promise object:
        _processFile: function (files, index, options) {
            var that = this,
                dfd = $.Deferred().resolveWith(that, [{
                    files: files,
                    index: index
                }]),
                chain = dfd.promise();
            that._processing += 1;
            $.each(options.process, function (i, settings) {
                chain = chain.pipe(function (data) {
                    return that.processActions[settings.action]
                        .call(this, data, settings);
                });
            });
            chain.always(function () {
                that._processing -= 1;
                if (that._processing === 0) {
                    that.element
                        .removeClass('fileupload-processing');
                }
            });
            if (that._processing === 1) {
                that.element.addClass('fileupload-processing');
            }
            return chain;
        },

        // Processes the files given as files property of the data parameter,
        // returns a Promise object that allows to bind a done handler, which
        // will be invoked after processing all files (inplace) is done:
        process: function (data) {
            var that = this,
                options = $.extend({}, this.options, data);
            if (options.process && options.process.length &&
                    this._isXHRUpload(options)) {
                $.each(data.files, function (index, file) {
                    that._processingQueue = that._processingQueue.pipe(
                        function () {
                            var dfd = $.Deferred();
                            that._processFile(data.files, index, options)
                                .always(function () {
                                    dfd.resolveWith(that);
                                });
                            return dfd.promise();
                        }
                    );
                });
            }
            return this._processingQueue;
        },

        _create: function () {
            this._super();
            this._processing = 0;
            this._processingQueue = $.Deferred().resolveWith(this)
                .promise();
        }

    });

}));
/**
 * pageflow.Failure and subclasses are used in the failures api.
 *
 * Subclasses that represent failures that are can not be retried should
 * override `catRetry` with false.
 * Retryable failures should implement `retryAction`.
 */

pageflow.Failure = pageflow.Object.extend({
  canRetry: true,
  type: 'Failure',

  initialize: function(model) {
    this.model = model;
  },

  retry: function() {
    if (this.canRetry) {
      return this.retryAction();
    }
  },

  retryAction: function() {
    return this.model.save();
  },

  key: function() {
    return this.model.cid + '-' + this.type;
  }
});

/**
 * SavingFailure represents a unsuccessful attempt to save
 * a model on the server.
 */
pageflow.SavingFailure = pageflow.Failure.extend({
  type: 'SavingFailure'
});

/**
 *  OrderingFailure represent a unsuccessful attempt to save
 *  the ordering of a pageflow.orderedCollection.
 */
pageflow.OrderingFailure = pageflow.Failure.extend({
  type: 'OrderingFailure',

  initialize: function(model, collection) {
    pageflow.Failure.prototype.initialize.call(this, model);
    this.collection = collection;
  },

  retryAction: function() {
    return this.collection.saveOrder();
  }
});
/**
 * API to allow access to failure UI and recovery.
 * Global instance at pageflow.failures.
 */

pageflow.FailuresAPI = pageflow.Object.extend({
  initialize: function() {
    this.failures = {};
    this.length = 0;
  },

  watch: function(collection) {
    this.listenTo(collection, 'sync', this.remove);

    this.listenTo(collection, 'error', function(model) {
      if (!model.isNew()) {
        this.add(new pageflow.SavingFailure(model));
      }
    });
  },

  retry: function() {
    _.each(this.failures, function(failure, key) {
      this.remove(key);
      failure.retry();
    }, this);
  },

  isEmpty: function() {
    return _.size(this.failures) === 0;
  },

  add: function(failure) {
    this.failures[failure.key()] = failure;
    this.length = _.size(this.failures);
  },

  remove: function(key) {
    delete this.failures[key];
    this.length = _.size(this.failures);
  },

  count: function() {
    return this.length;
  }
});

_.extend(pageflow.FailuresAPI.prototype, Backbone.Events);
pageflow.FileType = pageflow.Object.extend({
  initialize: function(options) {
    this.model = options.model;

    this.typeName = options.typeName;
    this.collectionName = options.collectionName;
    this.paramKey = options.paramKey;
    this.i18nKey = options.i18nKey;

    this.metaDataAttributes = options.metaDataAttributes || [];

    if (typeof options.matchUpload === 'function') {
      this.matchUpload = options.matchUpload;
    }
    else if (options.matchUpload instanceof RegExp)  {
      this.matchUpload = function(upload) {
        return upload.type.match(options.matchUpload);
      };
    }
    else {
      throw 'matchUpload option of FileType "' + this.collectionName + '" must either be a function or a RegExp.';
    }

    this.setupModelNaming();
  },

  setupModelNaming: function() {
    this.model.prototype.modelName = this.model.prototype.modelName || this.paramKey;
    this.model.prototype.paramRoot = this.model.prototype.paramRoot || this.paramKey;
    this.model.prototype.i18nKey = this.model.prototype.i18nKey || this.i18nKey;
  }
});
pageflow.FileTypes = pageflow.Object.extend({
  initialize: function() {
    this.clientSideConfigs = [];
  },

  register: function(name, config) {
    if (this._setup) {
      throw 'File types already set up. Register file types before initializers run.';
    }

    this.clientSideConfigs[name] = config;
  },

  setup: function(serverSideConfigs) {
    var clientSideConfigs = this.clientSideConfigs;
    this._setup = true;

    this.fileTypes = _.map(serverSideConfigs, function(serverSideConfig) {
      var clientSideConfig = clientSideConfigs[serverSideConfig.collectionName];

      if (!clientSideConfig) {
        throw 'Missing client side config for file type "' + serverSideConfig.collectionName + '"';
      }

      return new pageflow.FileType(_.extend({}, serverSideConfig, clientSideConfig));
    });
  },

  findByUpload: function(upload) {
    var result = this.find(function(fileType) {
      return fileType.matchUpload(upload);
    });

    if (!result) {
      throw(new pageflow.FileTypes.UnmatchedUploadError(upload));
    }

    return result;
  },

  findByCollectionName: function(collectionName) {
    var result = this.find(function(fileType) {
      return fileType.collectionName === collectionName;
    });

    if (!result) {
      throw('Could not find file type by collection name "' + collectionName +'"');
    }

    return result;
  }
});

_.each(['each', 'map', 'reduce', 'first', 'find'], function(method) {
  pageflow.FileTypes.prototype[method] = function() {
    if (!this._setup) {
      throw  'File types are not yet set up.';
    }

    var args = Array.prototype.slice.call(arguments);
    args.unshift(this.fileTypes);
    return _[method].apply(_, args);
  };
});

pageflow.FileTypes.UnmatchedUploadError = pageflow.Object.extend({
  name: 'UnmatchedUploadError',

  initialize: function(upload) {
    this.upload = upload;
    this.message = 'No matching file type found for upload "' + upload.name + '" of type "' + upload.type +'".';
  }
});
pageflow.PageType = pageflow.Object.extend({
  initialize: function(name, options, seed) {
    this.name = name;
    this.options = options;
    this.seed = seed;
  },

  translationKey: function() {
    return this.seed.translation_key;
  },

  thumbnailCandidates: function() {
    return this.seed.thumbnail_candidates;
  },

  pageLinks: function(configuration) {
    if ('pageLinks' in this.options) {
      return this.options.pageLinks(configuration);
    }
  },

  configurationEditorView: function() {
    return this.options.configurationEditorView ||
      pageflow.ConfigurationEditorView.repository[this.name];
  },

  embeddedViews: function() {
    return this.options.embeddedViews;
  },

  createConfigurationEditorView: function(options) {
    var constructor = this.configurationEditorView();
    options.pageType = this.seed;

    return new constructor(_.extend({
      attributeTranslationKeyPrefixes: [
        this.seed.translation_key_prefix + '.page_attributes',
        'pageflow.common_page_attributes'
      ]
    }, options));
  },

  createPageLinkConfigurationEditorView: function(options) {
    var constructor = this.options.pageLinkConfigurationEditorView ||
      pageflow.PageLinkConfigurationEditorView;

    return new constructor(_.extend({
      attributeTranslationKeyPrefixes: [
        this.seed.translation_key_prefix + '.page_link_attributes',
        'pageflow.common_page_link_attributes'
      ]
    }, options));
  }
});
pageflow.PageTypes = pageflow.Object.extend({
  initialize: function() {
    this.clientSideConfigs = {};
  },

  register: function(name, config) {
    if (this._setup) {
      throw 'Page types already set up. Register page types before initializers run.';
    }

    this.clientSideConfigs[name] = config;
  },

  setup: function(serverSideConfigs) {
    var clientSideConfigs = this.clientSideConfigs;
    this._setup = true;

    this.pageTypes = _.map(serverSideConfigs, function(serverSideConfig) {
      var clientSideConfig = clientSideConfigs[serverSideConfig.name] || {};
      return new pageflow.PageType(serverSideConfig.name, clientSideConfig, serverSideConfig);
    });
  },

  findByName: function(name) {
     var result = this.find(function(pageType) {
      return pageType.name === name;
    });

    if (!result) {
      throw('Could not find page type with name "' + name +'"');
    }

    return result;
  }
});

_.each(['each', 'map', 'reduce', 'first', 'find', 'pluck'], function(method) {
  pageflow.PageTypes.prototype[method] = function() {
    if (!this._setup) {
      throw  'Page types are not yet set up.';
    }

    var args = Array.prototype.slice.call(arguments);
    args.unshift(this.pageTypes);
    return _[method].apply(_, args);
  };
});



/**
 * Interface for engines providing editor extensions.
 */

pageflow.EditorApi = pageflow.Object.extend({
  initialize: function() {
    this.sideBarRoutings = [];
    this.mainMenuItems = [];
    this.initializers = [];
    this.fileSelectionHandlers = {};

    /**
     *  Display Backbone/Marionette View inside the main panel
     *  of the editor.
     */
    this.showViewInMainPanel = function(view) {
      pageflow.app.mainRegion.show(view);
    };

    /**
     *  Display the Pageflow-Preview inside the main panel.
     */
    this.showPreview = function() {
      pageflow.app.mainRegion.$el.empty();
    };

    /**
     * Register additional router and controller for sidebar.
     *
     * Supported options:
     * - router: constructor function of Backbone Marionette app router
     * - controller: constructor function of Backbone Marionette controller
     */
    this.registerSideBarRouting = function(options) {
      this.sideBarRoutings.push(options);
    };

    /**
     * Set the name of the help entry that shall be selected by
     * default when the help view is opened. This value is
     * automatically reset when navigation occurs.
     */
    this.setDefaultHelpEntry = function(name) {
      this.nextDefaultHelpEntry = name;
    };

    /** @api private */
    this.applyDefaultHelpEntry = function(name) {
      this.defaultHelpEntry = this.nextDefaultHelpEntry;
      this.nextDefaultHelpEntry = null;
    };

    /**
     * Register additional menu item to be displayed on the root sidebar
     * view.
     *
     * Supported options:
     * - translationKey: for the label
     * - path: route to link to
     * - click: click handler
     */
    this.registerMainMenuItem = function(options) {
      this.mainMenuItems.push(options);
    };

    /**
     * Register a custom initializer which will be run before the boot
     * initializer of the editor.
     */
    this.addInitializer = function(fn) {
      this.initializers.push(fn);
    };

    /**
     * Navigate to the given path.
     */
    this.navigate = function(path, options) {
      editor.navigate(path, options);
    };

    /**
     * Extend the interface of page configuration objects. This is
     * especially convenient to wrap structured data from the page
     * configuration as Backbone objects.
     *
     * Example:
     *
     *     pageflow.editor.registerPageConfigurationMixin({
     *       externalLinks: function() {
     *         return new Backbone.Collection(this.get('external_links'));
     *       }
     *     }
     *
     *     pageflow.pages.get(1).configuration.externalLinks().each(...);
     */
    this.registerPageConfigurationMixin = function(mixin) {
      Cocktail.mixin(pageflow.Configuration, mixin);
    };

    /**
     * File selection handlers let editor extensions use the files view
     * to select files for usage in their custom models.
     *
     * See selectFile method for details how to trigger file selection.
     *
     * Example:
     *
     *     function MyFileSelectionHandler(options) {
     *       this.call = function(file) {
     *         // invoked with the selected file
     *       };
     *
     *       this.getReferer = function() {
     *         // the path to return to when the back button is clicked
     *         // or after file selection
     *         return '/some/path';
     *       }
     *     }
     *
     *     pageflow.editor.registerFileSelectionHandler('my_file_selection_handler', MyFileSelectionHandler);
     */
    this.registerFileSelectionHandler = function(name, handler) {
      this.fileSelectionHandlers[name] = handler;
    };

    /**
     * Trigger selection of the given file type with the given
     * handler. Payload hash is passed to selection handler as options.
     *
     * Example:
     *
     *     pageflow.editor.selectFile('image_files', 'my_file_selection_handler', {some: 'option for handler'});
     */
    this.selectFile = function(fileType, handlerName, payload) {
      this.navigate('/files/' + fileType + '?handler=' + handlerName + '&payload=' + encodeURIComponent(JSON.stringify(payload)), {trigger: true});
    };

    /**
     * Returns a promise which resolves to a page selected by the
     * user.
     *
     * Supported options:
     * - isAllowed: function which given a page returns true or false depending on
     *   whether the page is a valid selection
     */
    this.selectPage = function(options) {
      return pageflow.PageSelectionView.selectPage(options);
    };

    /**
     * Failures API
     *
     * Can watch collections for errors saving models and display the error
     * allong with a retry button.
     *
     *     pageflow.editor.failures.watch(collection);
     *
     * It's possible to add failures to the UI by adding instances of subclasses of pageflow.Failure:
     *
     *     pageflow.editor.failures.add(new pageflow.OrderingFailure(model, collection));
     *
     */
    this.failures = new pageflow.FailuresAPI();

    /**
     * Setup editor integration for page types.
     */
    this.pageTypes = new pageflow.PageTypes();

    /**
     *
     */
    this.fileTypes = new pageflow.FileTypes();

    /** @private */
    this.createFileSelectionHandler = function(handlerName, encodedPayload) {
      /** @private */
      if (!this.fileSelectionHandlers[handlerName]) {
        throw 'Unknown FileSelectionHandler ' + handlerName;
      }

      var payloadJson = JSON.parse(decodeURIComponent(encodedPayload));
      return new this.fileSelectionHandlers[handlerName](payloadJson);
    };
  }
});




























































pageflow.app = new Backbone.Marionette.Application();
pageflow.editor = new pageflow.EditorApi();

pageflow.startEditor = function(options) {
  jQuery(function() {
    $.when(
      $.getJSON('/editor/entries/' + options.entryId + '/seed'),
      pageflow.browser.detectFeatures()
    )
      .done(function(result) {
        pageflow.app.start(result[0]);
      })
      .fail(function() {
        alert('Error while starting editor.');
      });
  });
};
pageflow.reloadStylesheet = function(name) {
  var link = $('head link[data-name=' + name + ']');

  if (!link.data('originalHref')) {
    link.data('originalHref', link.attr('href'));
  }

  link.attr('href', link.data('originalHref') + '&reload=' + new Date().getTime());
};
pageflow.delayedDestroying = {
  initialize: function() {
    this._destroying = false;
  },

  destroyWithDelay: function() {
    var model = this;

    this._destroying = true;
    this.trigger('destroying', this);

    return Backbone.Model.prototype.destroy.call(this, {
      wait: true,
      success: function() {
        model._destroying = false;
      },
      error: function() {
        model._destroying = false;
      }
    });
  },

  isDestroying: function() {
    return this._destroying;
  }
};
pageflow.failureTracking = {
  initialize: function() {
    this._saveFailed = false;

    this.listenTo(this, 'sync', function() {
      this._saveFailed = false;
      this._failureMessage = null;
      this.trigger('change:failed');
    });

    this.listenTo(this, 'error', function(model, xhr) {
      this._saveFailed = true;
      this._failureMessage = this.translateStatus(xhr);
      this.trigger('change:failed');
    });
  },

  isFailed: function() {
    return this._saveFailed;
  },

  getFailureMessage: function() {
    return this._failureMessage;
  },

  translateStatus: function(xhr) {
    if (xhr.status === 401) {
      return 'Sie müssen angemeldet sein, um diese Aktion auszuführen.';
    }
    else if (xhr.status === 403) {
      return 'Sie sind nicht berechtigt diese Aktion auszuführen.';
    }
    else if (xhr.status === 404) {
      return 'Der Datensatz konnte auf dem Server nicht gefunden werden.';
    }
    else if (xhr.status === 409) {
      return 'Die Reportage wurde außerhalb dieses Editors bearbeitet.';
    }
    else if (xhr.status >= 500 && xhr.status < 600) {
      return 'Der Server hat einen internen Fehler gemeldet.';
    }
    else if (xhr.statusText === 'timeout') {
      return 'Der Server ist nicht erreichbar.';
    }
    return '';
  }
};
pageflow.fileWithType = {

};
pageflow.filesCountWatcher = {
  watchFileCollection: function(name, collection) {
    this.watchedFileCollectionNames = this.watchedFileCollectionNames || [];
    this.watchedFileCollectionNames.push(name);

    this.listenTo(collection, 'change:state', function(model) {
      this.updateFilesCounts(name, collection);
    });

    this.listenTo(collection, 'add', function() {
      this.updateFilesCounts(name, collection);
    });

    this.listenTo(collection, 'remove', function() {
      this.updateFilesCounts(name, collection);
    });

    this.updateFilesCounts(name, collection);
  },

  updateFilesCounts: function(name, collection) {
    this.updateFilesCount('uploading', name, collection, function(file) {
      return file.isUploading();
    });

    this.updateFilesCount('confirmable', name, collection, function(file) {
      return file.isConfirmable();
    });

    this.updateFilesCount('pending', name, collection, function(file) {
      return file.isPending();
    });
  },

  updateFilesCount: function(trait, name, collection, filter) {
    this.set(trait + '_' + name + '_count', collection.filter(filter).length);

    this.set(trait + '_files_count', _.reduce(this.watchedFileCollectionNames, function(sum, name) {
      return sum + this.get(trait + '_' + name + '_count');
    }, 0, this));
  }
};
pageflow.persistedPromise = {
  persisted: function() {
    var model = this;

    this._persistedDeferred = this._persistedDeferred || jQuery.Deferred(function(deferred) {
      if (model.isNew()) {
        model.once('change:id', deferred.resolve);
      }
      else {
        deferred.resolve();
      }
    });

    return this._persistedDeferred.promise();
  }
};

Cocktail.mixin(Backbone.Model, pageflow.persistedPromise);
pageflow.polling = {
  togglePolling: function(enabled) {
    if (enabled) {
      this.startPolling();
    }
    else {
      this.stopPolling();
    }
  },

  startPolling: function() {
    if (!this.pollingInterval) {
      this.pollingInterval = setInterval(_.bind(function() {
        this.fetch();
      }, this), 1000);
    }
  },

  stopPolling: function() {
    if (this.pollingInterval) {
      clearInterval(this.pollingInterval);
      this.pollingInterval = null;
    }
  }
};
pageflow.retryable = {
  retry: function(options) {
    options = options ? _.clone(options) : {};
    if (options.parse === void 0) options.parse = true;
    var model = this;
    options.success = function(resp) {
      if (!model.set(model.parse(resp, options), options)) return false;
      model.trigger('sync', model, resp, options);
    };
    options.error = function(resp) {
      model.trigger('error', model, resp, options);
    };
    options.url = this.url() + '/retry';
    return this.sync('post', this, options);
  }
};
pageflow.stageProvider = {
  initialize: function() {
    var finishedStates = [this.readyState];
    var stages = _.result(this, 'stages') || [];

    this.stages = new Backbone.Collection(_.chain(stages).slice().reverse().map(function (options) {
      var name = options.name;

      options.file = this;
      options.finishedStates = finishedStates;

      var fileStage = new pageflow.FileStage({name: name}, options);
      finishedStates = finishedStates.concat(fileStage.nonFinishedStates);

      return fileStage;
    }, this).reverse().value());
  },

  currentStage: function() {
    return this.stages.find(function(stage) {
      return stage.get('active') || stage.get('action_required') || stage.get('failed');
    });
  }
};
pageflow.transientReferences = {
  initialize: function() {
    this.transientReferences = {};
    this.pendingReferences = {};
  },

  getReference: function(attribute, collection) {
    if (typeof collection === 'string') {
      var fileType = pageflow.editor.fileTypes.findByCollectionName(collection);
      collection = pageflow.entry.getFileCollection(fileType);
    }

    return this.transientReferences[attribute] ||
      collection.get(this.get(attribute));
  },

  setReference: function(attribute, record) {
    this._cleanUpReference(attribute);
    this._setReference(attribute, record);
    this._listenForReady(attribute, record);
  },

  unsetReference: function(attribute) {
    this._cleanUpReference(attribute);
    this.set(attribute, null);
  },

  _setReference: function(attribute, record) {
    if (record.isNew()) {
      this.transientReferences[attribute] = record;
      this.set(attribute, null);
      this._setIdOnceSynced(attribute, record);
    }
    else {
      this.set(attribute, record.id);
    }
  },

  _setIdOnceSynced: function(attribute, record) {
    record.once('change:id', function() {
      delete this.transientReferences[attribute];
      this.set(attribute, record.id);
    }, this);
  },

  _listenForReady: function(attribute, record) {
    if (!record.isReady()) {
      this.pendingReferences[attribute] = record;

      this.listenTo(record, 'change:state', function() {
        if (record.isReady()) {
          this._cleanUpReadyListener(attribute);
          this.trigger('change');
        }
      });
    }
  },

  _cleanUpReference: function(attribute) {
    this._cleanUpSaveListener(attribute);
    this._cleanUpReadyListener(attribute);
  },

  _cleanUpSaveListener: function(attribute) {
    if (this.transientReferences[attribute]) {
      this.stopListening(this.transientReferences[attribute], 'change:id');
      delete this.transientReferences[attribute];
    }
  },

  _cleanUpReadyListener: function(attribute) {
    if (this.pendingReferences[attribute]) {
      this.stopListening(this.pendingReferences[attribute], 'change:state');
      delete this.pendingReferences[attribute];
    }
  }
};
pageflow.widgetSubject = {
  initialize: function() {
    this.widgets = pageflow.WidgetsCollection.createForSubject(this);

    if (this.autoSaveWidgets) {
      this.listenTo(this.widgets, 'change:type_name', function() {
        this.saveWidgets();
      });
    }
  },

  widgetsUrlRoot: function() {
    return '/editor/subjects/' + this.collectionName + '/' + this.id;
  },

  fetchWidgets: function() {
    this.widgets.fetch();
  },

  saveWidgets: function(options) {
    var model = this;

    return Backbone.sync('patch', model, _.extend(options || {}, {
      url: this.widgetsUrlRoot() + '/widgets/batch',

      attrs: {
        widgets: model.widgets.map(function(widget) {
          return widget.toJSON();
        })
      },

      success: function(response) {
        model.trigger('sync:widgets', model, response, {});
      }
    }));
  }
};
pageflow.UploadedFile = Backbone.Model.extend({
  mixins: [pageflow.stageProvider, pageflow.retryable],

  urlRoot: function() {
    return this.isNew() ? this.collection.url() : '/editor/files/' + this.fileType().collectionName;
  },

  fileType: function() {
    return this.collection && this.collection.fileType;
  },

  title: function() {
    return this.get('file_name');
  },

  thumbnailFile: function() {
    return this;
  },

  isUploading: function() {
    return this.get('state') === 'uploading';
  },

  isUploaded: function() {
    return this.get('state') !== 'uploading' && this.get('state') !== 'upload_failed';
  },

  isPending: function() {
    return !this.isReady() && !this.isFailed();
  },

  isReady: function() {
    return this.get('state') === this.readyState;
  },

  isFailed: function() {
    return this.get('state') && !!this.get('state').match(/_failed$/);
  },

  isRetryable: function() {
    return !!this.get('retryable');
  },

  isConfirmable: function() {
    return false;
  },

  isPositionable: function() {
    return false;
  },

  cancelUpload: function() {
    if (this.get('state') === 'uploading') {
      this.trigger('uploadCancelled');
      this.destroy();
    }
  },

  uploadFailed: function() {
    this.set('state', 'upload_failed');
    this.unset('uploading_progress');

    this.trigger('uploadFailed');
  },

  destroyUsage: function() {
    var usage = new pageflow.FileUsage({id: this.get('usage_id')});

    usage.destroy();

    this.trigger('destroy', this, this.collection, {});
  }
});
pageflow.HostedFile = pageflow.UploadedFile.extend({
  stages: function() {
    return [
      {
        name: 'uploading',
        activeStates: ['uploading'],
        failedStates: ['upload_failed']
      },
      {
        name: 'uploading_to_s3',
        activeStates: ['uploading_to_s3'],
        failedStates: ['uploading_to_s3_failed']
      }
    ].concat(_.result(this, 'processingStages'));
  },

  processingStages: [],

  readyState: 'uploaded_to_s3'
});
pageflow.EncodedFile = pageflow.HostedFile.extend({
  processingStages: function() {
    var stages = [];

    if (pageflow.config.confirmEncodingJobs) {
      stages.push({
        name: 'fetching_meta_data',
        activeStates: ['waiting_for_meta_data', 'fetching_meta_data'],
        failedStates: ['fetching_meta_data_failed']
      });
    }

    stages.push({
      name: 'encoding',
      actionRequiredStates: ['waiting_for_confirmation'],
      activeStates: ['waiting_for_encoding', 'encoding'],
      failedStates: ['fetching_meta_data_failed', 'encoding_failed']
    });

    return stages;
  },

  readyState: 'encoded',

  isConfirmable: function() {
    return this.get('state') === 'waiting_for_confirmation';
  },

  isPositionable: function() {
    return false;
  }
});
pageflow.Configuration = Backbone.Model.extend({
  modelName: 'page',
  i18nKey: 'pageflow/page',

  mixins: [pageflow.transientReferences],

  defaults: {
    gradient_opacity: 100,
    display_in_navigation: true,
    transition: 'fade',
    text_position: 'left',
    invert: false,
    hide_title: false,
    autoplay: true
  },

  /**
   * Used by views (i.e. FileInputView) to get id which can be used in
   * routes to lookup configuration via its page.
   */
  getRoutableId: function() {
    return this.parent.id;
  },

  getImageFileUrl: function(attribute, options) {
    options = options || {};

    var file = this.getImageFile(attribute);

    if (file && file.isReady()) {
      return file.get(options.styleGroup ? options.styleGroup + '_url' : 'url');
    }

    return '';
  },

  getImageFile: function(attribute) {
    return this.getReference(attribute, pageflow.imageFiles);
  },

  getFilePosition: function(attribute, coord) {
    var propertyName = this._filePositionProperty(attribute, coord);
    return this.has(propertyName) ? this.get(propertyName) : 50;
  },

  setFilePosition: function(attribute, coord, value) {
    var propertyName = this._filePositionProperty(attribute, coord);
    this.set(propertyName, value);
  },

  setFilePositions: function(attribute, x, y) {
    var attributes = {};

    attributes[this._filePositionProperty(attribute, 'x')] = x;
    attributes[this._filePositionProperty(attribute, 'y')] = y;

    this.set(attributes);
  },

  _filePositionProperty: function(attribute, coord) {
    return attribute.replace(/_id$/, '_' + coord);
  },

  getVideoFileSources: function(attribute) {
    var file = this.getVideoFile(attribute);

    if (file && file.isReady()) {
      return file.get('sources') ? this._appendSuffix(file.get('sources')) : '';
    }

    return '';
  },

  getVideoFile: function(attribute) {
    return this.getReference(attribute, pageflow.videoFiles);
  },

  getAudioFileSources: function(attribute) {
    var file = this.getAudioFile(attribute);

    if (file && file.isReady()) {
      return file.get('sources') ? this._appendSuffix(file.get('sources')) : '';
    }

    return '';
  },

  getAudioFile: function(attribute) {
    return this.getReference(attribute, pageflow.audioFiles);
  },

  getVideoPosterUrl: function() {
    var posterFile = this.getReference('poster_image_id', pageflow.imageFiles),
        videoFile = this.getReference('video_file_id', pageflow.videoFiles);

    if (posterFile) {
      return posterFile.get('url');
    }
    else if (videoFile) {
      return videoFile.get('poster_url');
    }

    return null;
  },

  _appendSuffix: function(sources) {
    var parent = this.parent;

    if (!parent || !parent.id) {
      return sources;
    }

    return _.map(sources, function(source) {
      var clone = _.clone(source);
      clone.src = clone.src + '?e=' + parent.id + '&t=' + new Date().getTime();
      return clone;
    });
  }
});
pageflow.Scaffold = pageflow.Object.extend({
  initialize: function(parent, options) {
    this.parent = parent;
    this.options = options || {};
  },

  create: function() {
    var scaffold = this;
    var query = this.options.depth ? '?depth=' + this.options.depth : '';

    this.model = this.build();

    Backbone.sync('create', this.model, {
      url: this.model.url() + '/scaffold' + query,

      success: function(response) {
        scaffold.load(response);
        scaffold.model.trigger('sync', scaffold.model, response, {});
      }
    });
  },

  build: function() {},

  load: function() {}
});
pageflow.AudioFile = pageflow.EncodedFile.extend({
  thumbnailPictogram: 'audio',

  getSources: function(attribute) {
    if (this.isReady()) {
      return this.get('sources') ? this.get('sources') : '';
    }

    return '';
  },
});
pageflow.Chapter = Backbone.Model.extend({
  modelName: 'chapter',
  paramRoot: 'chapter',
  i18nKey: 'pageflow/chapter',

  mixins: [pageflow.failureTracking, pageflow.delayedDestroying],

  initialize: function(attributes, options) {
    this.pages = new pageflow.ChapterPagesCollection({
      pages: options.pages || pageflow.pages,
      chapter: this
    });

    this.listenTo(this, 'change:title', function() {
      this.save();
    });

    this.configuration = new pageflow.ChapterConfiguration(this.get('configuration') || {});

    this.listenTo(this.configuration, 'change', function() {
      this.save();
      this.trigger('change:configuration', this);
    });

    return attributes;
  },

  urlRoot: function() {
    return this.isNew() ? this.collection.url() : '/chapters';
  },

  storylinePosition: function() {
    return (this.storyline && this.storyline.get('position')) || -1;
  },

  addPage: function(attributes) {
    var page = this.buildPage(attributes);
    page.save();

    return page;
  },

  buildPage: function(attributes) {
    var defaults = {
      chapter_id: this.id,
      position: this.pages.length
    };

    return this.pages.addAndReturnModel(_.extend(defaults, attributes));
  },

  toJSON: function() {
    return _.extend(_.clone(this.attributes), {
      configuration: this.configuration.toJSON()
    });
  },

  destroy: function() {
    this.destroyWithDelay();
  }
});
pageflow.ChapterConfiguration = pageflow.Configuration.extend({
  modelName: 'chapter',
  i18nKey: 'pageflow/chapter',

  defaults: {
  }
});
pageflow.ChapterScaffold = pageflow.Scaffold.extend({
  build: function() {
    this.chapter = this.parent.buildChapter(this.options.chapterAttributes);
    this.page = this.chapter.buildPage();

    return this.chapter;
  },

  load: function(response) {
    this.chapter.set(response.chapter);
    this.page.set(response.page);
  }
});
pageflow.EditLock = Backbone.Model.extend({
  paramRoot: 'edit_lock',

  url: function() {
    return pageflow.entry.url() + '/edit_lock?timestamp=' + new Date().getTime();
  },

  toJSON: function() {
    return {
      id: this.id,
      force: this.get('force')
    };
  }
});
pageflow.EditLockContainer = Backbone.Model.extend({
  initialize: function() {
    this.storageKey = 'pageflow.edit_lock.' + pageflow.entry.id;
  },

  acquire: function(options) {
    options = options || {};
    var container = this;

    var lock = new pageflow.EditLock({
      id: options.force ? null : sessionStorage[this.storageKey],
      force: options.force
    });

    lock.save(null, {
      polling: !!options.polling,
      success: function(lock) {
        sessionStorage[container.storageKey] = lock.id;

        container.lock = lock;
        container.trigger('acquired');

        container.startPolling();
      }
    });
  },

  startPolling: function() {
    if (!this.pollingInteval) {
      this.pollingInteval = setInterval(_.bind(function() {
        this.acquire({polling: true});
      }, this), 2000);
    }
  },

  stopPolling: function() {
    if (this.pollingInteval) {
      clearInterval(this.pollingInteval);
      this.pollingInteval = null;
    }
  },

  watchForErrors: function() {
    var container = this;

    $(document).ajaxSend(function(event, xhr) {
      if (container.lock) {
        xhr.setRequestHeader("X-Edit-Lock", container.lock.id);
      }
    });

    $(document).ajaxError(function(event, xhr, settings) {
      switch(xhr.status) {
      case 409:
        container.handleConflict(xhr, settings);
        break;
      case 401:
      case 422:
        container.handleUnauthenticated();
        break;
      default:
        container.handleError();
      }
    });
  },

  release: function() {
    if (this.lock) {
      var promise = this.lock.destroy();
      delete sessionStorage[this.storageKey];
      this.lock = null;
      return promise;
    }
  },

  handleConflict: function(xhr, settings) {
    this.lock = null;
    this.trigger('locked',
                 xhr.responseJSON || {},
                 {
                   context: (settings.url.match(/\/edit_lock/) && !settings.polling) ? 'acquire' : 'other'
                 });

    this.stopPolling();

  },

  handleUnauthenticated: function() {
    this.stopPolling();
    this.trigger('unauthenticated');
  },

  handleError: function() {
  }
});
pageflow.EncodingConfirmation = Backbone.Model.extend({
  paramRoot: 'encoding_confirmation',

  initialize: function() {
    this.videoFiles = new Backbone.Collection();
    this.audioFiles = new Backbone.Collection();

    this.updateEmpty();
    this.watchCollections();
  },

  watchCollections: function() {
    this.listenTo(this.videoFiles, 'add remove', this.check);
    this.listenTo(this.audioFiles, 'add remove', this.check);

    this.listenTo(this.videoFiles, 'reset', this.updateEmpty);
    this.listenTo(this.audioFiles, 'reset', this.updateEmpty);
  },

  check: function() {
    var model = this;

    model.updateEmpty();
    model.set('checking', true);

    model.save({}, {
      url: model.url() + '/check',
      success: function() {
        model.set('checking', false);
      },
      error: function() {
        model.set('checking', false);
      }
    });
  },

  saveAndReset: function() {
    var model = this;

    model.save({}, {
      success: function() {
        model.set('summary_html', '');

        model.videoFiles.reset();
        model.audioFiles.reset();
      }
    });
  },

  updateEmpty: function() {
    this.set('empty', this.videoFiles.length === 0 && this.audioFiles.length === 0);
  },

  url: function() {
    return '/editor/entries/' + pageflow.entry.get('id') + '/encoding_confirmations';
  },

  toJSON: function() {
    return {
      video_file_ids: this.videoFiles.pluck('id'),
      audio_file_ids: this.audioFiles.pluck('id'),
    };
  }
});

pageflow.EncodingConfirmation.createWithPreselection = function(options) {
  var model = new pageflow.EncodingConfirmation();

  if (options.fileId) {
    if (options.fileType === 'video_file') {
      model.videoFiles.add(pageflow.videoFiles.get(options.fileId));
    }
    else {
      model.audioFiles.add(pageflow.audioFiles.get(options.fileId));
    }
  }

  return model;
};
pageflow.Entry = Backbone.Model.extend({
  paramRoot: 'entry',
  urlRoot: '/entries',
  modelName: 'entry',
  i18nKey: 'pageflow/entry',
  collectionName: 'entries',

  autoSaveWidgets: true,

  mixins: [pageflow.filesCountWatcher,
           pageflow.polling,
           pageflow.failureTracking,
           pageflow.widgetSubject],

  initialize: function(attributes, options) {
    options = options || {};

    this.configuration = new pageflow.EntryConfiguration(this.get('configuration') || {});
    this.configuration.parent = this;

    this.files = options.files || pageflow.files;
    this.storylines = options.storylines || pageflow.storylines;
    this.storylines.parentModel = this;
    this.chapters = options.chapters || pageflow.chapters;
    this.chapters.parentModel = this;
    this.pages = pageflow.pages;

    this.imageFiles = pageflow.imageFiles;
    this.videoFiles = pageflow.videoFiles;
    this.audioFiles = pageflow.audioFiles;

    pageflow.editor.fileTypes.each(function(fileType) {
      this.watchFileCollection(fileType.collectionName, this.getFileCollection(fileType));
    }, this);

    this.listenTo(this.storylines, 'sort', function() {
      this.pages.sort();
    });

    this.listenTo(this.chapters, 'sort', function() {
      this.pages.sort();
    });

    this.listenTo(this.configuration, 'change', function() {
      this.trigger('change:configuration');
      this.save();
    });

    this.listenTo(this.configuration, 'change:locale', function() {
      this.once('sync', function() {
        // No other way of updating page templates used in
        // EntryPreviewView at the moment.
        location.reload();
      });
    });
  },

  addStoryline: function(attributes) {
    var storyline = this.buildStoryline(attributes);
    storyline.save();

    return storyline;
  },

  buildStoryline: function(attributes) {
    var defaults = {
      title: '',
    };

    return this.storylines.addAndReturnModel(_.extend(defaults, attributes));
  },

  scaffoldStoryline: function(options) {
    var scaffold = new pageflow.StorylineScaffold(this, options);
    scaffold.create();

    return scaffold;
  },

  addChapterInNewStoryline: function(options) {
    return this.scaffoldStoryline(_.extend({depth: 'chapter'}, options)).chapter;
  },

  addPageInNewStoryline: function(options) {
    return this.scaffoldStoryline(_.extend({depth: 'page'}, options)).page;
  },

  addFileUpload: function(upload) {
    var fileType = pageflow.editor.fileTypes.findByUpload(upload);
    var file = new fileType.model({
      state: 'uploading',
      file_name: upload.name
    });

    this.getFileCollection(fileType).add(file);

    return file;
  },

  addFileUsage: function(file) {
    var fileUsages = new pageflow.FileUsagesCollection([], {
      entry: this
    });

    fileUsages.createForFile(file, { success: function(usage) {
      file.set('usage_id', usage.get('id'));
      this.getFileCollection(file.fileType()).add(file);

      this.trigger('use:file', file);
    }.bind(this)});
  },

  getFileCollection: function(fileType) {
    return this.files[fileType.collectionName];
  },

  pollForPendingFiles: function() {
    this.listenTo(this, 'change:pending_files_count', function(model, value) {
      this.togglePolling(value > 0);
    });

    this.togglePolling(this.get('pending_files_count') > 0);
  },

  parse: function(response, options) {
    if (response) {
      this.set(_.pick(response, 'published', 'published_until', 'password_protected'));

      pageflow.editor.fileTypes.each(function(fileType) {
        this.getFileCollection(fileType).set(response[fileType.collectionName], {add: false, remove: false});
        delete response[fileType.collectionName];
      }, this);
    }

    return response;
  },

  toJSON: function() {
    return this.configuration.toJSON();
  }
});
pageflow.EntryConfiguration = pageflow.Configuration.extend({
  modelName: 'entry',
  i18nKey: 'pageflow/entry'
});
pageflow.EntryConfigurationFileSelectionHandler = function(options) {
  this.call = function(file) {
    pageflow.entry.configuration.setReference(options.attributeName, file);
  };

  this.getReferer = function() {
    return '/meta_data/' + (options.returnToTab || 'general');
  };
};

pageflow.editor.registerFileSelectionHandler('entryConfiguration', pageflow.EntryConfigurationFileSelectionHandler);
pageflow.EntryPublication = Backbone.Model.extend({
  paramRoot: 'entry_publication',

  quota: function() {
    return new Backbone.Model(this.get('quota') || {});
  },

  check: function() {
    var model = this;
    this.set('checking', true);

    this.save({}, {
      url: this.url() + '/check',
      success: function() {
        model.set('checking', false);
      },
      error: function() {
        model.set('checking', false);
      }
    });
  },

  publish: function(attributes) {
    var model = this;

    return this.save(attributes, {
      success: function(model) {
        pageflow.entry.parse(model.get('entry'));
      },

      error: function(model, xhr) {
        model.set(xhr.responseJSON);
      }
    });
  },

  url: function() {
    return '/editor/entries/' + pageflow.entry.get('id') + '/entry_publications';
  }
});
pageflow.FileStage = Backbone.Model.extend({
  initialize: function(attributes,  options) {
    this.file = options.file;

    this.activeStates = options.activeStates || [];
    this.finishedStates = options.finishedStates || [];
    this.failedStates = options.failedStates || [];
    this.actionRequiredStates = options.actionRequiredStates || [];

    this.nonFinishedStates = this.activeStates.concat(this.failedStates, this.actionRequiredStates);

    this.update();
    this.listenTo(this.file, 'change:state', this.update);
    this.listenTo(this.file, 'change:' + this.get('name') + '_progress', this.update);
  },

  update: function() {
    this.updateState();
    this.updateProgress();
    this.updateErrorMessage();
  },

  updateState: function() {
    var state = this.file.get('state');

    this.set('active', this.activeStates.indexOf(state) >= 0);
    this.set('finished', this.finishedStates.indexOf(state) >= 0);
    this.set('failed', this.failedStates.indexOf(state) >= 0);
    this.set('action_required', this.actionRequiredStates.indexOf(state) >= 0);

    if (this.get('active')) {
      this.set('state', 'active');
    }
    else if (this.get('finished')) {
      this.set('state', 'finished');
    }
    else if (this.get('failed')) {
      this.set('state', 'failed');
    }
    else if (this.get('action_required')) {
      this.set('state', 'action_required');
    }
    else {
      this.set('state', 'pending');
    }
  },

  updateProgress: function() {
    this.set('progress', this.file.get(this.get('name') + '_progress'));
  },

  updateErrorMessage: function() {
    var errorMessageAttribute = this.get('name') + '_error_message';
    this.set('error_message', this.file.get(errorMessageAttribute));
  },

  localizedDescription: function() {
    return I18n.t('pageflow.editor.files.stages.' + this.get('name') + '.' + this.get('state'));
  }
});
pageflow.FileUsage = Backbone.Model.extend({
  modelName: 'file_usage',
  paramRoot: 'file_usage',

  urlRoot: function() {
    return this.isNew() ? this.collection.url() : '/editor/file_usages/';
  }
});
pageflow.ImageFile = pageflow.UploadedFile.extend({
  stages: [
    {
      name: 'uploading',
      activeStates: ['uploading'],
      failedStates: ['upload_failed']
    },
    {
      name: 'processing',
      activeStates: ['processing'],
      finishedStates: ['processed'],
      failedStates: ['processing_failed']
    }
  ],

  readyState: 'processed',

  getBackgroundPositioningImageUrl: function() {
    return this.get('url');
  },

  isPositionable: function() {
    return this.isReady();
  }
});
pageflow.OtherEntry = Backbone.Model.extend({
  paramRoot: 'entry',
  urlRoot: '/entries',
  modelName: 'entry',
  i18nKey: 'pageflow/entry',

  initialize: function() {
    this.files = {};
  },

  getFileCollection: function(fileType) {
    if (!this.files[fileType.collectionName]) {
      this.files[fileType.collectionName] = pageflow.FilesCollection.createForFileType(fileType, [], {entry: this});
    }

    return this.files[fileType.collectionName];
  },

  titleOrSlug: function () {
    return this.get('title') || this.get('slug');
  }
});
pageflow.Page = Backbone.Model.extend({
  modelName: 'page',
  paramRoot: 'page',
  i18nKey: 'pageflow/page',

  defaults: function() {
    return {
      template: 'background_image',
      configuration: {},
      active: false,
      perma_id: ''
    };
  },

  mixins: [pageflow.failureTracking, pageflow.delayedDestroying],

  initialize: function() {
    this.configuration = new pageflow.Configuration(this.get('configuration') || {});
    this.configuration.parent = this.configuration.page = this;

    this.listenTo(this.configuration, 'change', function() {
      this.trigger('change:configuration', this);
    });

    this.listenTo(this.configuration, 'change:title', function() {
      this.trigger('change:title');
    });

    this.listenTo(this.configuration, 'change', function() {
      this.save();
    });

    this.listenTo(this, 'change:template', function() {
      this.save();
    });
  },

  urlRoot: function() {
    return this.isNew() ? this.collection.url() : '/pages';
  },

  storylinePosition: function() {
    return (this.chapter && this.chapter.storylinePosition()) || -1;
  },

  chapterPosition: function() {
    return (this.chapter && this.chapter.get('position')) || -1;
  },

  title: function() {
    return this.configuration.get('title') || this.configuration.get('additional_title');
  },

  thumbnailFile: function() {
    var configuration = this.configuration;

    return _.reduce(this.pageType().thumbnailCandidates(), function(result, candidate) {
      return result || configuration.getReference(candidate.attribute, candidate.file_collection);
    }, null);
  },

  pageLinks: function() {
    return this.pageType().pageLinks(this.configuration);
  },

  pageType: function() {
    return pageflow.editor.pageTypes.findByName(this.get('template'));
  },

  toJSON: function() {
    return _.extend(_.clone(this.attributes), {
      configuration: this.configuration.toJSON()
    });
  },

  destroy: function() {
    this.destroyWithDelay();
  }
});

pageflow.Page.linkedPagesLayouts = ['default', 'hero_top_left', 'hero_top_right'];
pageflow.Page.textPositions = ['left', 'right'];

pageflow.Page.scrollIndicatorModes = ['all', 'only_back', 'only_next', 'non'];
pageflow.Page.scrollIndicatorOrientations = ['vertical', 'horizontal'];
pageflow.Page.delayedTextFadeIn = ['no_fade', 'short', 'medium', 'long'];
pageflow.PageConfigurationFileSelectionHandler = function(options) {
  var page = pageflow.pages.get(options.id);

  this.call = function(file) {
    page.configuration.setReference(options.attributeName, file);
  };

  this.getReferer = function() {
    return '/pages/' + page.id + '/' + (options.returnToTab || 'files');
  };
};

pageflow.editor.registerFileSelectionHandler('pageConfiguration', pageflow.PageConfigurationFileSelectionHandler);
pageflow.PageLink = Backbone.Model.extend({
  mixins: [pageflow.transientReferences],

  i18nKey: 'pageflow/page_link',

  targetPage: function() {
    return pageflow.pages.getByPermaId(this.get('target_page_id'));
  },

  label: function() {
    return this.get('label');
  },

  editPath: function() {
    return '/page_links/' + this.id;
  },

  getPageId: function() {
    return this.collection.page.id;
  },

  toSerializedJSON: function() {
    return _.omit(this.attributes, 'highlighted', 'position');
  },

  highlight: function() {
    this.set('highlighted', true);
  },

  resetHighlight: function() {
    this.unset('highlighted');
  },

  remove: function() {
    this.collection.remove(this);
  }
});
pageflow.PageLinkFileSelectionHandler = function(options) {
  var page = pageflow.pages.getByPermaId(options.id.split(':')[0]);
  var pageLink = page.pageLinks().get(options.id);

  this.call = function(file) {
    pageLink.setReference(options.attributeName, file);
  };

  this.getReferer = function() {
    return '/page_links/' + pageLink.id;
  };
};

pageflow.editor.registerFileSelectionHandler('pageLink', pageflow.PageLinkFileSelectionHandler);
pageflow.PreviewEntryData = pageflow.EntryData.extend({
  initialize: function(options) {
    this.storylines = options.storylines;
    this.chapters = options.chapters;
    this.pages = options.pages;
    this.theming = options.theming;
  },

  getThemingOption: function(name) {
    return this.theming.get(name);
  },

  getStorylineConfiguration: function(id) {
    var storyline = this.storylines.get(id);
    return storyline ? storyline.configuration.attributes : {};
  },

  getChapterConfiguration: function(id) {
    var chapter = this.chapters.get(id);
    return chapter ? chapter.configuration.attributes : {};
  },

  getChapterPagePermaIds: function(id) {
    var chapter = this.chapters.get(id);
    return chapter ? chapter.pages.pluck('perma_id') : [];
  },

  getStorylineIdByChapterId: function(id) {
    var chapter = this.chapters.get(id);
    return chapter && chapter.get('storyline_id');
  },

  getChapterIdByPagePermaId: function(permaId) {
    var page = this.pages.getByPermaId(permaId);
    return page && page.get('chapter_id');
  },

  getPageConfiguration: function(permaId) {
    var page = this.pages.getByPermaId(permaId);
    return page ? page.configuration.attributes : {};
  },

  getPagePosition: function(permaId) {
    return this.pages.indexOf(this.pages.getByPermaId(permaId));
  }
});
pageflow.Storyline = Backbone.Model.extend({
  modelName: 'storyline',
  paramRoot: 'storyline',
  i18nKey: 'pageflow/storyline',

  mixins: [pageflow.failureTracking, pageflow.delayedDestroying],

  initialize: function(attributes, options) {
    this.chapters = new pageflow.StorylineChaptersCollection({
      chapters: options.chapters || pageflow.chapters,
      storyline: this
    });

    this.configuration = new pageflow.StorylineConfiguration(this.get('configuration') || {});

    this.listenTo(this.configuration, 'change', function() {
      this.save();
      this.trigger('change:configuration', this);
    });

    this.listenTo(this.configuration, 'change:main', function(model, value) {
      this.trigger('change:main', this, value);
    });
  },

  urlRoot: function() {
    return this.isNew() ? this.collection.url() : '/storylines';
  },

  displayTitle: function() {
    return _([
      this.title() ||
        (!this.isMain() && I18n.t('pageflow.storylines.untitled')),
      this.isMain() && I18n.t('pageflow.storylines.main')
    ]).compact().join(' - ');
  },

  title: function() {
    return this.configuration.get('title');
  },

  isMain: function() {
    return !!this.configuration.get('main');
  },

  lane: function() {
    return this.configuration.get('lane');
  },

  row: function() {
    return this.configuration.get('row');
  },

  parentPagePermaId: function() {
    return this.configuration.get('parent_page_perma_id');
  },

  parentPage: function() {
    return pageflow.pages.getByPermaId(this.parentPagePermaId());
  },

  transitiveChildPages: function() {
    return new pageflow.StorylineTransitiveChildPages(this, pageflow.storylines, pageflow.pages);
  },

  addChapter: function(attributes) {
    var chapter = this.buildChapter(attributes);
    chapter.save();

    return chapter;
  },

  buildChapter: function(attributes) {
    var defaults = {
      storyline_id: this.id,
      title: '',
      position: this.chapters.length
    };

    return this.chapters.addAndReturnModel(_.extend(defaults, attributes));
  },

  scaffoldChapter: function(options) {
    var scaffold = new pageflow.ChapterScaffold(this, options);
    scaffold.create();

    return scaffold;
  },

  toJSON: function() {
    return {
      configuration: this.configuration.toJSON()
    };
  },

  destroy: function() {
    this.destroyWithDelay();
  }
});
pageflow.StorylineConfiguration = pageflow.Configuration.extend({
  modelName: 'storyline',
  i18nKey: 'pageflow/storyline',

  defaults: {
  },

  initialize: function() {
    this.listenTo(this, 'change:main', function(model, value) {
      if (value) {
        this.unset('parent_page_perma_id');
      }
    });
  }
});
pageflow.StorylineOrdering = function(storylines, pages) {
  var storylinesByParent;

  this.watch = function() {
    storylines.on('add change:configuration', function() {
      this.sort();
    }, this);

    pages.on('change:position change:chapter_id', function() {
      this.sort();
    }, this);
  };

  this.sort = function(options) {
    prepare();
    visit(storylinesWithoutParent(), 1, 0);

    storylines.sort(options);
  };

  function visit(storylines, offset, level) {
    return _(storylines).reduce(function(position, storyline, index) {
      storyline.set('position', position);
      storyline.set('level', level);

      return visit(children(storyline), position + 1, level + 1);
    }, offset);
  }

  function storylinesWithoutParent() {
    return storylinesByParent[-1];
  }

  function children(storyline) {
    return storylinesByParent[storyline.cid] || [];
  }

  function prepare() {
    storylinesByParent = _(groupStorylinesByParentStoryline())
      .reduce(function(result, storylines, key) {
        result[key] = storylines.sort(compareStorylines);
        return result;
      }, {});
  }

  function groupStorylinesByParentStoryline() {
    return storylines
      .groupBy(function(storyline) {
        var parentPage = getParentPage(storyline);
        return parentPage && parentPage.chapter ? parentPage.chapter.storyline.cid : -1;
      });
  }

  function compareStorylines(storylineA, storylineB) {
    return compareByMainFlag(storylineA, storylineB) ||
      compareByParentPagePosition(storylineA, storylineB) ||
      compareByLane(storylineA, storylineB) ||
      compareByRow(storylineA, storylineB) ||
      compareByTitle(storylineA, storylineB);
  }

  function compareByMainFlag(storylineA, storylineB) {
    return compare(
      storylineA.isMain() ? -1 : 1,
      storylineB.isMain() ? -1 : 1
    );
  }

  function compareByParentPagePosition(storylineA, storylineB) {
    return compare(
      getParentPagePosition(storylineA),
      getParentPagePosition(storylineB)
    );
  }

  function compareByLane(storylineA, storylineB) {
    return compare(
      storylineA.lane(),
      storylineB.lane()
    );
  }

  function compareByRow(storylineA, storylineB) {
    return compare(
      storylineA.row(),
      storylineB.row()
    );
  }

  function compareByTitle(storylineA, storylineB) {
    return compare(
      storylineA.title(),
      storylineB.title()
    );
  }

  function compare(a, b) {
    if (a > b) {
      return 1;
    }
    else if (a < b) {
      return -1;
    }
    else {
      return 0;
    }
  }

  function getParentPagePosition(storyline) {
    var parentPage = getParentPage(storyline);
    return parentPage && parentPage.get('position');
  }

  function getParentPage(storyline) {
    return pages.getByPermaId(storyline.parentPagePermaId());
  }
};
pageflow.StorylineScaffold = pageflow.Scaffold.extend({
  build: function() {
    this.storyline = this.parent.buildStoryline(this.options.storylineAttributes);
    this.chapter = this.storyline.buildChapter();

    if (this.options.depth === 'page') {
      this.page = this.chapter.buildPage();
    }

    pageflow.editor.trigger('scaffold:storyline', this.storyline);

    return this.storyline;
  },

  load: function(response) {
    this.storyline.set(response.storyline);
    this.chapter.set(response.chapter);

    if (this.page) {
      this.page.set(response.page);
    }
  }
});
pageflow.StorylineTransitiveChildPages = function(storyline, storylines, pages) {
  var isTranstiveChildStoryline;

  this.contain = function(page) {
    if (!isTranstiveChildStoryline) {
      search();
    }

    return !!isTranstiveChildStoryline[page.chapter.storyline.id];
  };

  function search() {
    isTranstiveChildStoryline = storylines.reduce(function(memo, other) {
      var current = other;

      while (current) {
        if (current === storyline || memo[current.id]) {
          memo[other.id] = true;
          return memo;
        }

        current = parentStoryline(current);
      }

      return memo;
    }, {});
  }

  function parentStoryline(storyline) {
    var parentPage = pages.getByPermaId(storyline.parentPagePermaId());
    return parentPage && parentPage.chapter && parentPage.chapter.storyline;
  }
};
pageflow.Theming = Backbone.Model.extend({
  modelName: 'theming',
  i18nKey: 'pageflow/theming',
  collectionName: 'themings',

  mixins: [pageflow.widgetSubject],

  hasHomeButton: function() {
    return this.get('home_button');
  },

  hasOverviewButton: function() {
    return this.get('overview_button');
  },

  supportsEmphasizedPages: function() {
    return this.get('emphasized_pages');
  },

  supportsScrollIndicatorModes: function() {
    return this.get('scroll_indicator_modes');
  }
});
pageflow.VideoFile = pageflow.EncodedFile.extend({
  getBackgroundPositioningImageUrl: function() {
    return this.get('poster_url');
  },

  isPositionable: function() {
    return this.isReady();
  }
});
pageflow.Widget = Backbone.Model.extend({
  paramRoot: 'widget',
  i18nKey: 'pageflow/widget',

  role: function() {
    return this.id;
  },

  urlRoot: function() {
    return this.collection.url();
  },

  toJSON: function() {
    return {
      role: this.role(),
      type_name: this.get('type_name')
    };
  },
});
pageflow.addAndReturnModel = {
  // Backbone's add does not return the added model. push returns the
  // model but does not trigger sort.
  addAndReturnModel: function(model, options) {
    model = this._prepareModel(model, options);
    this.add(model, options);
    return model;
  }
};

Cocktail.mixin(Backbone.Collection, pageflow.addAndReturnModel);
pageflow.orderedCollection = {
  initialize: function() {
    if (this.autoConsolidatePositions !== false) {
      this.listenTo(this, 'remove', function() {
        this.consolidatePositions();
        this.saveOrder();
      });
    }
  },

  consolidatePositions: function() {
    this.each(function(item, index) {
      item.set('position', index);
    });
  },

  saveOrder: function() {
    var parentModel = this.parentModel;
    var collection = this;

    if (collection.isEmpty()) {
      return $.Deferred().resolve().promise();
    }

    return Backbone.sync('patch', parentModel, {
      url: collection.url() + '/order',
      attrs: {ids: collection.pluck('id')},

      success: function(response) {
        parentModel.trigger('sync', parentModel, response, {});
        parentModel.trigger('sync:order', parentModel, response, {});
      },

      error: function(jqXHR,  textStatus, errorThrown) {
        pageflow.editor.failures.add(new pageflow.OrderingFailure(parentModel, collection));
      }
    });
  }
};
/**
 * A partial implementation of a collection that can store records of
 * different model types.  Backbone.Collection tries to merge records
 * if they have the same id.
 */

pageflow.MultiCollection = function() {
  this.records = {};
  this.length = 0;
};

_.extend(pageflow.MultiCollection.prototype, {
  add: function(record) {
    if (!this.records[record.cid]) {
      this.records[record.cid] = record;
      this.length = _.keys(this.records).length;

      this.trigger('add', record);
    }
  },

  remove: function(record) {
    if (this.records[record.cid]) {
      delete this.records[record.cid];
      this.length = _.keys(this.records).length;

      this.trigger('remove', record);
    }
  },

  isEmpty: function() {
    return this.length === 0;
  }
});

_.extend(pageflow.MultiCollection.prototype, Backbone.Events);

pageflow.MultiCollection.extend = Backbone.Collection.extend;
pageflow.SubsetCollection = Backbone.Collection.extend({
  constructor: function(options) {
    var adding = false;

    options = options || {};

    this.filter = options.filter || function(item) { return true; };
    this.parent = options.parent;
    this.parentModel = options.parentModel;

    delete options.filter;
    delete options.parent;

    this.model = this.parent.model;
    this.comparator = options.comparator || this.parent.comparator;

    this.listenTo(this.parent, 'add', function(model, collection, options) {
      if (!adding && this.filter(model)) {
        this.add(model, options);
      }
    });

    this.listenTo(this.parent, 'remove', function(model) {
      this.remove(model);
    });

    this.listenTo(this, 'add', function(model, collection, options) {
      adding = true;
      this.parent.add(model);
      adding = false;
    });

    if (options.watchAttribute) {
      this.listenTo(this.parent, 'change:' + options.watchAttribute, function(model) {
        if (this.filter(model)) {
          this.add(model);
        }
        else {
          this.remove(model);
        }
      });
    }

    this.listenTo(this, 'sort', function() {
      this.parent.sort();
    });

    Backbone.Collection.prototype.constructor.call(this, this.parent.filter(this.filter), options);
  },

  clear: function() {
    this.parent.remove(this.models);
    this.reset();
  },

  url: function() {
    return this.parentModel.url() + _.result(this.parent, 'url');
  }
});
pageflow.ChapterPagesCollection = pageflow.SubsetCollection.extend({
  mixins: [pageflow.orderedCollection],

  constructor: function(options) {
    var chapter = options.chapter;

    pageflow.SubsetCollection.prototype.constructor.call(this, {
      parent: options.pages,
      parentModel: chapter,

      filter: function(item) {
        return !chapter.isNew() && item.get('chapter_id') === chapter.id;
      },

      comparator: function(item) {
        return item.get('position');
      }
    });

    this.each(function(page) {
      page.chapter = chapter;
    });

    this.listenTo(this, 'add', function(model) {
      model.chapter = chapter;
      model.set('chapter_id', chapter.id);

      pageflow.editor.trigger('add:page', model);
    });

    this.listenTo(this, 'remove', function(model) {
      model.chapter = null;
    });

    this.listenTo(chapter, 'destroy', function() {
      this.clear();
    });
  }
});
pageflow.ChaptersCollection = Backbone.Collection.extend({
  model: pageflow.Chapter,

  url:  '/chapters',

  comparator: function(chapter) {
    return chapter.get('position');
  }
});
pageflow.FileUsagesCollection = Backbone.Collection.extend({
  model: pageflow.FileUsage,

  name: 'file_usages',

  initialize: function(models, options) {
    options = options || {};
    this.entry = options.entry;
  },

  url: function() {
    return '/editor/entries/' + this.entry.get('id') + '/file_usages';
  },

  createForFile: function(file, options) {
    return this.create({
      file_id: file.get('id'),
      file_type: file.fileType().typeName
    }, options);
  }
});
pageflow.FilesCollection = Backbone.Collection.extend({
  initialize: function(models, options) {
    options = options || {};

    this.entry = options.entry;
    this.fileType = options.fileType;
    this.name = options.fileType.collectionName;
  },

  comparator: function(file) {
    var fileName = file.get('file_name');
    return (fileName && fileName.toLowerCase) ? fileName.toLowerCase() : fileName;
  },

  url: function() {
    return '/editor/entries/' + this.getEntry().get('id') + '/files/' + this.name;
  },

  getEntry: function() {
    return this.entry || pageflow.entry;
  },

  confirmable: function() {
    return new pageflow.SubsetCollection({
      parent: this,
      watchAttribute: 'state',

      filter: function(item) {
        return item.get('state') === 'waiting_for_confirmation';
      },
    });
  }
});

pageflow.FilesCollection.createForFileTypes = function(fileTypes, files, options) {
  return fileTypes.reduce(function(result, fileType) {
    result[fileType.collectionName] = pageflow.FilesCollection.createForFileType(
      fileType,
      files[fileType.collectionName],
      options
    );
    return result;
  }, {});
};

pageflow.FilesCollection.createForFileType = function(fileType, files, options) {
  return new pageflow.FilesCollection(
    files,
    _.extend({
      fileType: fileType,
      model: fileType.model
    }, options || {})
  );
};
pageflow.PageLinksCollection = Backbone.Collection.extend({
  model: pageflow.PageLink,

  initialize: function(models, options) {
    this.configuration = options.configuration;
    this.page = options.configuration.page;

    this.load();

    this.listenTo(this, 'add remove change', this.save);
    this.listenTo(this.configuration, 'change:page_links', this.load);
  },

  addLink: function(targetPageId) {
    this.addWithPosition(this.defaultPosition(), targetPageId);
  },

  canAddLink: function(targetPageId) {
    return true;
  },

  updateLink: function(link, targetPageId) {
    link.set('target_page_id', targetPageId);
  },

  removeLink: function(link) {
    this.remove(link);
  },

  addWithPosition: function(position, targetPageId) {
    this.add(this.pageLinkAttributes(position, targetPageId));
  },

  removeByPosition: function(position) {
    this.remove(this.findByPosition(position));
  },

  findByPosition: function(position) {
    return this.findWhere({position: position});
  },

  load: function() {
    this.set(this.pageLinksAttributes());
  },

  save: function() {
    this.configuration.set('page_links', this.map(function(pageLink) {
      return pageLink.toSerializedJSON();
    }));
  },

  defaultPosition: function() {
    return Math.max(0, _.max(this.map(function(pageLink) {
      return pageLink.get('position');
    }))) + 1;
  },

  pageLinksAttributes: function() {
    return this.configuration.get('page_links') || [];
  },

  pageLinkAttributes: function(position, targetPageId, id) {
    return {
      id: id || this.getUniqueId(),
      target_page_id: targetPageId,
      position: position
    };
  },

  /** @private */
  getUniqueId: function() {
    var maxId = Math.max(0, _.max(this.map(function(pageLink) {
      return parseInt(pageLink.id.split(':').pop(), 10);
    })));

    return this.configuration.page.get('perma_id') + ':' + (maxId + 1);
  }
});

pageflow.OrderedPageLinksCollection = pageflow.PageLinksCollection.extend({
  comparator: 'position',

  saveOrder: function() {
    this.save();
  }
});
pageflow.OtherEntriesCollection = Backbone.Collection.extend({
  model: pageflow.OtherEntry,
  url: '/editor/entries',

  initialize: function(models, options) {
    options = options || {};
    this.excludeEntry = options.excludeEntry;
  },

  // override parse method to exclude the entry being edited. This is the collection
  // of the "other" entries, after all.
  parse: function(response) {
    var excludeEntry = this.getExcludeEntry(),
        filteredResponse = _.filter(response, function(entry){ return entry.id != excludeEntry.id; });

    return Backbone.Collection.prototype.parse.call(this, filteredResponse);
  },

  getExcludeEntry: function() {
    return this.excludeEntry || pageflow.entry;
  }
});
pageflow.PagesCollection = Backbone.Collection.extend({
  model: pageflow.Page,

  url: '/pages',

  comparator: function(pageA, pageB) {
    if (pageA.storylinePosition() > pageB.storylinePosition()) {
      return 1;
    }
    else if (pageA.storylinePosition() < pageB.storylinePosition()) {
      return -1;
    }
    else if (pageA.chapterPosition() > pageB.chapterPosition()) {
      return 1;
    }
    else if (pageA.chapterPosition() < pageB.chapterPosition()) {
      return -1;
    }
    else if (pageA.get('position') > pageB.get('position')) {
      return 1;
    }
    else if (pageA.get('position') < pageB.get('position')) {
      return -1;
    }
    else {
      return 0;
    }
  },

  getByPermaId: function(permaId) {
    return this.findWhere({perma_id: parseInt(permaId, 10)});
  }
});
pageflow.SavingRecordsCollection = pageflow.MultiCollection.extend({
  watch: function(collection) {
    var that = this;

    this.listenTo(collection, 'request', function(model, xhr) {
      that.add(model);

      xhr.always(function() {
        that.remove(model);
      });
    });
  }
});
pageflow.StorylineChaptersCollection = pageflow.SubsetCollection.extend({
  mixins: [pageflow.orderedCollection],

  constructor: function(options) {
    var storyline = options.storyline;

    pageflow.SubsetCollection.prototype.constructor.call(this, {
      parent: options.chapters,
      parentModel: storyline,

      filter: function(item) {
        return !storyline.isNew() && item.get('storyline_id') === storyline.id;
      },

      comparator: function(item) {
        return item.get('position');
      }
    });

    this.each(function(chapter) {
      chapter.storyline = storyline;
    });

    this.listenTo(this, 'add', function(model) {
      model.storyline = storyline;
      model.set('storyline_id', storyline.id);

      pageflow.editor.trigger('add:chapter', model);
    });

    this.listenTo(this, 'remove', function(model) {
      model.storyline = null;
    });
  }
});
pageflow.StorylinesCollection = Backbone.Collection.extend({
  autoConsolidatePositions: false,

  mixins: [pageflow.orderedCollection],

  model: pageflow.Storyline,

  url: function() {
    return '/entries/' + pageflow.entry.get('id') + '/storylines';
  },

  initialize: function() {
    this.listenTo(this, 'change:main', function(model, value) {
      if (value) {
        this.each(function(storyline) {
          if (storyline.isMain() && storyline !== model) {
            storyline.configuration.unset('main');
          }
        });
      }
    });
  },

  main: function() {
    return this.find(function(storyline) {
      return storyline.configuration.get('main');
    }) || this.first();
  },

  comparator: function(chapter) {
    return chapter.get('position');
  }
});
pageflow.WidgetsCollection = Backbone.Collection.extend({
  model: pageflow.Widget,

  initialize: function(models, options) {
    options = options || {};
    this.subject = options.subject;
  },

  url: function() {
    return this.subject.widgetsUrlRoot() + '/widgets';
  },
});

pageflow.WidgetsCollection.createForSubject = function(subject) {
  return new pageflow.WidgetsCollection([], {subject: subject});
};
pageflow.SidebarRouter = Backbone.Marionette.AppRouter.extend({
  appRoutes: {
    'page_links/:id': 'pageLink',
    'pages/:id': 'page',
    'pages/:id/:tab': 'page',
    'chapters/:id': 'chapter',
    'storylines/:id': 'storyline',

    'files/:collectionName?handler=:handler&payload=:payload': 'files',
    'files/:collectionName': 'files',
    'files': 'files',

    'confirmable_files?type=:type&id=:id': 'confirmableFiles',
    'confirmable_files': 'confirmableFiles',

    'meta_data': 'metaData',
    'meta_data/:tab': 'metaData',
    'publish': 'publish',

    '?storyline=:id': 'index',
    '.*': 'index'
  }
});
pageflow.SidebarController = Backbone.Marionette.Controller.extend({
  initialize: function(options) {
    this.region = options.region;
    this.entry = options.entry;
  },

  index: function(storylineId) {
    this.region.show(new pageflow.EditEntryView({
      model: this.entry,
      storylineId: storylineId
    }));
  },

  files: function(collectionName, handler, payload) {
    this.region.show(new pageflow.FilesView({
      model: this.entry,
      selectionHandler: handler && pageflow.editor.createFileSelectionHandler(handler, payload),
      tabName: collectionName
    }));

    pageflow.editor.setDefaultHelpEntry('pageflow.help_entries.files');
  },

  confirmableFiles: function(preselectedFileType, preselectedFileId) {
    this.region.show(pageflow.ConfirmEncodingView.create({
      model: pageflow.EncodingConfirmation.createWithPreselection({
        fileType: preselectedFileType,
        fileId: preselectedFileId
      })
    }));
  },

  metaData: function(tab) {
    this.region.show(new pageflow.EditMetaDataView({
      model: this.entry,
      tab: tab
    }));
  },

  publish: function() {
    this.region.show(pageflow.PublishEntryView.create({
      model: this.entry,
      entryPublication: new pageflow.EntryPublication()
    }));

    pageflow.editor.setDefaultHelpEntry('pageflow.help_entries.publish');
  },

  storyline: function(id) {
    this.region.show(new pageflow.EditStorylineView({
      model: this.entry.storylines.get(id)
    }));
  },

  chapter: function(id) {
    this.region.show(new pageflow.EditChapterView({
      model: this.entry.chapters.get(id)
    }));
  },

  page: function(id, tab) {
    var page = this.entry.pages.get(id);

    this.region.show(new pageflow.EditPageView({
      model: page,
      tab: tab
    }));

    pageflow.editor.setDefaultHelpEntry(page.pageType().help_entry_translation_key);
  },

  pageLink: function(linkId) {
    var pageId = linkId.split(':')[0];
    var page = pageflow.pages.getByPermaId(pageId);

    this.region.show(new pageflow.EditPageLinkView({
      model: page.pageLinks().get(linkId),
      page: page
    }));
  }
});
(function() { this.JST || (this.JST = {}); this.JST["pageflow/editor/templates/back_button_decorator"] = function(obj){var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('<a class="back">',  I18n.t('pageflow.editor.templates.back_button_decorator.outline') ,'</a>\n<div class="outlet"></div>\n');}return __p.join('');};
}).call(this);
(function() { this.JST || (this.JST = {}); this.JST["pageflow/editor/templates/background_positioning"] = function(obj){var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('<div class="box">\n  <h2>',  I18n.t('pageflow.editor.templates.background_positioning.title') ,'</h2>\n  <p>',  I18n.t('pageflow.editor.templates.background_positioning.help') ,'</p>\n\n  <div class="wrapper">\n  </div>\n\n  <h3>',  I18n.t('pageflow.editor.templates.background_positioning.preview_title') ,'</h3>\n  <div class="previews">\n    <div>\n    </div>\n  </div>\n\n  <div class="footer">\n    <a href="" class="save">',  I18n.t('pageflow.editor.templates.background_positioning.save') ,'</a>\n    <a href="" class="close">',  I18n.t('pageflow.editor.templates.background_positioning.cancel') ,'</a>\n  </div>\n</div>\n');}return __p.join('');};
}).call(this);
(function() { this.JST || (this.JST = {}); this.JST["pageflow/editor/templates/background_positioning_preview"] = function(obj){var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('<div class="image"></div>\n<div class="label"></div>\n');}return __p.join('');};
}).call(this);
(function() { this.JST || (this.JST = {}); this.JST["pageflow/editor/templates/background_positioning_sliders"] = function(obj){var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('<div class="container">\n  <div class="slider horizontal">\n  </div>\n  <div class="slider vertical">\n  </div>\n</div>\n');}return __p.join('');};
}).call(this);
(function() { this.JST || (this.JST = {}); this.JST["pageflow/editor/templates/blank_entry"] = function(obj){var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('<h2>',  I18n.t('pageflow.editor.blank_entry.header') ,'</h2>\n<p>',  I18n.t('pageflow.editor.blank_entry.intro') ,'</p>\n<ol>\n  <li>',  I18n.t('pageflow.editor.blank_entry.create_chapter') ,'</li>\n  <li>',  I18n.t('pageflow.editor.blank_entry.create_page') ,'</li>\n  <li>',  I18n.t('pageflow.editor.blank_entry.edit_page') ,'</li>\n</ol>\n<p>',  I18n.t('pageflow.editor.blank_entry.outro') ,'</p>\n');}return __p.join('');};
}).call(this);
(function() { this.JST || (this.JST = {}); this.JST["pageflow/editor/templates/chapter_item"] = function(obj){var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('<a class="edit_chapter" href="">\n  <span class="pictogram"></span>\n  <span class="number"></span>\n  <span class="title"></span>\n  <span class="failure_icon" title=',  I18n.t('pageflow.editor.templates.chapter_item.save_error') ,' />\n</a>\n\n<ul class="pages outline"></ul>\n\n<a href="" class="add_page">',  I18n.t('pageflow.editor.templates.chapter_item.new_page') ,'</a>\n');}return __p.join('');};
}).call(this);
(function() { this.JST || (this.JST = {}); this.JST["pageflow/editor/templates/confirm_encoding"] = function(obj){var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('<div class="blank_slate">\n  <p>\n      ',  I18n.t('pageflow.editor.templates.confirm_encoding.all_released') ,'\n  </p>\n  <p>\n      ',  I18n.t('pageflow.editor.templates.confirm_encoding.link_to_progress', {
              link: '<a href="#/files/video_files">'+I18n.t('pageflow.editor.templates.confirm_encoding.manage_files')+'</a>'})
        ,'\n  </p>\n</div>\n\n<div class="video_files_panel">\n  <h2>',  I18n.t('pageflow.editor.templates.confirm_encoding.videos_tab') ,'</h2>\n</div>\n\n<div class="audio_files_panel">\n  <h2>',  I18n.t('pageflow.editor.templates.confirm_encoding.audios_tab') ,'</h2>\n</div>\n\n<div class="summary">\n</div>\n<button class="confirm">',  I18n.t('pageflow.editor.templates.confirm_encoding.confirm_button') ,'</button>\n');}return __p.join('');};
}).call(this);
(function() { this.JST || (this.JST = {}); this.JST["pageflow/editor/templates/confirmable_file_item"] = function(obj){var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('<input type="checkbox">\n<label class="file_name"></label>\n<span class="duration"></span>\n\n<div class="actions">\n  <a class="remove" title="',  I18n.t('pageflow.editor.templates.confirmable_file_item.remove') ,'"></a>\n</div>\n');}return __p.join('');};
}).call(this);
(function() { this.JST || (this.JST = {}); this.JST["pageflow/editor/templates/drop_down_button"] = function(obj){var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('<button></button>\n\n<div class="drop_down_button_menu">\n  <ul class="drop_down_button_items" role="menu">\n  </ul>\n</div>\n');}return __p.join('');};
}).call(this);
(function() { this.JST || (this.JST = {}); this.JST["pageflow/editor/templates/drop_down_button_item"] = function(obj){var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('<a href="#"></a>\n');}return __p.join('');};
}).call(this);
(function() { this.JST || (this.JST = {}); this.JST["pageflow/editor/templates/edit_chapter"] = function(obj){var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('<a class="back">',  I18n.t('pageflow.editor.templates.edit_chapter.outline') ,'</a>\n<a class="destroy">',  I18n.t('pageflow.editor.templates.edit_chapter.destroy') ,'</a>\n\n<div class="failure">\n  <p>',  I18n.t('pageflow.editor.templates.edit_chapter.save_error') ,'</p>\n  <p class="message"></p>\n  <a class="retry" href="">',  I18n.t('pageflow.editor.templates.edit_chapter.retry') ,'</a>\n</div>\n\n<div class="form_container"></div>\n');}return __p.join('');};
}).call(this);
(function() { this.JST || (this.JST = {}); this.JST["pageflow/editor/templates/edit_entry"] = function(obj){var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('<a class="close" href="#">',  I18n.t('pageflow.editor.templates.edit_entry.close') ,'</a>\n<a class="publish" href="#">',  I18n.t('pageflow.editor.templates.edit_entry.publish') ,'</a>\n\n<ul class="menu">\n  <li>\n    <a class="edit_entry_meta_data" href="#" data-path="/meta_data">',  I18n.t('pageflow.editor.templates.edit_entry.metadata') ,'</a>\n    <span class="failure_icon" title="',  I18n.t('pageflow.editor.templates.edit_entry.save_error') ,'" />\n  </li>\n  <li>\n    <a class="manage_files" href="#" data-path="/files">',  I18n.t('pageflow.editor.templates.edit_entry.manage_files') ,'</a>\n  </li>\n</ul>\n\n<div class="edit_entry_storylines storyline_picker"></div>\n');}return __p.join('');};
}).call(this);
(function() { this.JST || (this.JST = {}); this.JST["pageflow/editor/templates/edit_meta_data"] = function(obj){var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('<a class="back">',  I18n.t('pageflow.editor.templates.edit_meta_data.outline') ,'</a>\n\n<div class="failure">\n  <p>',  I18n.t('pageflow.editor.templates.edit_meta_data.save_error') ,'</p>\n  <p class="message"></p>\n  <a class="retry" href="">',  I18n.t('pageflow.editor.templates.edit_meta_data.retry') ,'</a>\n</div>\n\n<div class="form_fields"></div>\n');}return __p.join('');};
}).call(this);
(function() { this.JST || (this.JST = {}); this.JST["pageflow/editor/templates/edit_page"] = function(obj){var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('<a class="back">',  I18n.t('pageflow.editor.templates.edit_page.outline') ,'</a>\n<a class="destroy">',  I18n.t('pageflow.editor.templates.edit_page.destroy') ,'</a>\n\n<div class="failure">\n  <p>',  I18n.t('pageflow.editor.templates.edit_page.save_error') ,'</p>\n  <p class="message"></p>\n  <a class="retry" href="">',  I18n.t('pageflow.editor.templates.edit_page.retry') ,'</a>\n</div>\n\n<div class="page_type"></div>\n\n<div class="configuration_container"></div>\n');}return __p.join('');};
}).call(this);
(function() { this.JST || (this.JST = {}); this.JST["pageflow/editor/templates/edit_page_link"] = function(obj){var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('<a class="back">',  I18n.t('pageflow.editor.templates.edit_page_link.back') ,'</a>\n<a class="destroy">',  I18n.t('pageflow.editor.templates.edit_page_link.destroy') ,'</a>\n<div class="form_container"></div>\n');}return __p.join('');};
}).call(this);
(function() { this.JST || (this.JST = {}); this.JST["pageflow/editor/templates/edit_storyline"] = function(obj){var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('<a class="back">',  I18n.t('pageflow.editor.templates.edit_storyline.outline') ,'</a>\n<a class="destroy" data-tooltip-align="bottom right">\n  ',  I18n.t('pageflow.editor.templates.edit_storyline.destroy') ,'\n</a>\n\n<div class="failure">\n  <p>',  I18n.t('pageflow.editor.templates.edit_storyline.save_error') ,'</p>\n  <p class="message"></p>\n  <a class="retry" href="">',  I18n.t('pageflow.editor.templates.edit_storyline.retry') ,'</a>\n</div>\n\n<div class="form_container"></div>\n');}return __p.join('');};
}).call(this);
(function() { this.JST || (this.JST = {}); this.JST["pageflow/editor/templates/edit_widget"] = function(obj){var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('<div class="widget_type">\n</div>\n');}return __p.join('');};
}).call(this);
(function() { this.JST || (this.JST = {}); this.JST["pageflow/editor/templates/edit_widgets"] = function(obj){var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('<ol class="widgets">\n</ol>\n');}return __p.join('');};
}).call(this);
(function() { this.JST || (this.JST = {}); this.JST["pageflow/editor/templates/entry_preview"] = function(obj){var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('<div class="header"></div>\n<div class="overview"></div>\n\n<div class="entry"></div>\n');}return __p.join('');};
}).call(this);
(function() { this.JST || (this.JST = {}); this.JST["pageflow/editor/templates/entry_publication_quota_decorator"] = function(obj){var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('<div class="quota_state">\n</div>\n<div class="outlet">\n</div>\n<div class="exhausted_message">\n</div>\n');}return __p.join('');};
}).call(this);
(function() { this.JST || (this.JST = {}); this.JST["pageflow/editor/templates/explorer_file_item"] = function(obj){var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('<span class="file_thumbnail"></span>\n\n<span class="file_name"></span>\n');}return __p.join('');};
}).call(this);
(function() { this.JST || (this.JST = {}); this.JST["pageflow/editor/templates/file_item"] = function(obj){var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('<span class="file_thumbnail"></span>\n\n<span class="file_name"></span>\n<a class="select">',  I18n.t('pageflow.editor.templates.file_item.select') ,'</a>\n\n<div class="actions">\n  <a class="confirm" title="',  I18n.t('pageflow.editor.templates.file_item.confirm') ,'"></a>\n  <a class="retry" title="',  I18n.t('pageflow.editor.templates.file_item.retry') ,'"></a>\n  <a class="remove" title="',  I18n.t('pageflow.editor.templates.file_item.destroy') ,'"></a>\n  <a class="cancel" title="',  I18n.t('pageflow.editor.templates.file_item.cancel') ,'"></a>\n</div>\n\n<div class="details">\n  <ul class="file_stage_items"></ul>\n\n  <div class="file_meta_data">\n    <table cellpadding="0" cellspacing="0">\n      <tbody>\n        <tr>\n          <th>',  I18n.t('pageflow.editor.templates.file_item.credits') ,'</th>\n          <td><input type="text" class="rights"/></td>\n        </tr>\n      </tbody>\n      <tbody class="attributes">\n      </tbody>\n      <tbody class="downloads">\n        <tr>\n          <th>',  I18n.t('pageflow.editor.templates.file_item.source') ,'</th>\n          <td><a class="original" href="#" download target="_blank">',  I18n.t('pageflow.editor.templates.file_item.download') ,'</a></td>\n        </tr>\n      <tbody>\n    </table>\n  </div>\n</div>\n');}return __p.join('');};
}).call(this);
(function() { this.JST || (this.JST = {}); this.JST["pageflow/editor/templates/file_meta_data_item"] = function(obj){var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('<th></th>\n<td></td>\n');}return __p.join('');};
}).call(this);
(function() { this.JST || (this.JST = {}); this.JST["pageflow/editor/templates/file_stage_item"] = function(obj){var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('<p class="percent"></p>\n<p class="description"></p>\n<p class="error_message"></p>\n');}return __p.join('');};
}).call(this);
(function() { this.JST || (this.JST = {}); this.JST["pageflow/editor/templates/file_thumbnail"] = function(obj){var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('<div class="pictogram"></div>\n');}return __p.join('');};
}).call(this);
(function() { this.JST || (this.JST = {}); this.JST["pageflow/editor/templates/files"] = function(obj){var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('<a class="back">',  I18n.t('pageflow.editor.templates.files.back') ,'</a>\n');}return __p.join('');};
}).call(this);
(function() { this.JST || (this.JST = {}); this.JST["pageflow/editor/templates/files_blank_slate"] = function(obj){var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('<li class="blank_slate">',  I18n.t('pageflow.editor.templates.files_blank_slate.no_files') ,'<li>\n');}return __p.join('');};
}).call(this);
(function() { this.JST || (this.JST = {}); this.JST["pageflow/editor/templates/files_explorer"] = function(obj){var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('<div class="box">\n  <h2>',  I18n.t('pageflow.editor.templates.files_explorer.reuse_files') ,'</h2>\n\n  <div class="panels">\n    <ul class="entries_panel">\n    </ul>\n\n    <div class="files_panel">\n    </div>\n  </div>\n\n  <div class="footer">\n    <button class="ok">',  I18n.t('pageflow.editor.templates.files_explorer.ok') ,'</button>\n    <button class="close">',  I18n.t('pageflow.editor.templates.files_explorer.cancel') ,'</button>\n  </div>\n</div>\n');}return __p.join('');};
}).call(this);
(function() { this.JST || (this.JST = {}); this.JST["pageflow/editor/templates/files_explorer_blank_slate"] = function(obj){var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('<li class="blank_slate">',  I18n.t('pageflow.editor.templates.files_explorer_blank_slate.choose_hint') ,'<li>\n');}return __p.join('');};
}).call(this);
(function() { this.JST || (this.JST = {}); this.JST["pageflow/editor/templates/files_gallery_blank_slate"] = function(obj){var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('<li class="blank_slate">',  I18n.t('pageflow.editor.templates.files_gallery_blank_slate.no_files') ,'<li>\n');}return __p.join('');};
}).call(this);
(function() { this.JST || (this.JST = {}); this.JST["pageflow/editor/templates/help"] = function(obj){var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('<div class="box">\n  <h2>',  I18n.t('pageflow.editor.templates.help.title') ,'</h2>\n\n  <div class="placeholder"></div>\n\n  <div class="footer">\n    <a class="close" href="">',  I18n.t('pageflow.editor.templates.help.close') ,'</a>\n  </div>\n</div>\n');}return __p.join('');};
}).call(this);
(function() { this.JST || (this.JST = {}); this.JST["pageflow/editor/templates/help_button"] = function(obj){var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('',  I18n.t('pageflow.editor.templates.help_button.open_help') ,'\n');}return __p.join('');};
}).call(this);
(function() { this.JST || (this.JST = {}); this.JST["pageflow/editor/templates/inputs/reference"] = function(obj){var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('<label>\n  <span class="name"></span>\n  <span class="inline_help"></span>\n</label>\n<div class="title"></div>\n<a href="" class="unset" title="',  I18n.t('pageflow.editor.templates.inputs.reference.reset') ,'"></a>\n<a href="" class="choose" title="',  I18n.t('pageflow.editor.templates.inputs.reference.edit') ,'"></a>\n');}return __p.join('');};
}).call(this);
(function() { this.JST || (this.JST = {}); this.JST["pageflow/editor/templates/list"] = function(obj){var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('<label>\n  <span class="list_label"></span>\n</label>\n\n<ul class="list_items"></ul>\n');}return __p.join('');};
}).call(this);
(function() { this.JST || (this.JST = {}); this.JST["pageflow/editor/templates/list_blank_slate"] = function(obj){var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('',  I18n.t('pageflow.editor.templates.list_blank_slate.text') ,'\n');}return __p.join('');};
}).call(this);
(function() { this.JST || (this.JST = {}); this.JST["pageflow/editor/templates/list_item"] = function(obj){var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('<span class="list_item_thumbnail"></span>\n<span class="list_item_missing_thumbnail"></span>\n<span class="list_item_type_pictogram type_pictogram"></span>\n\n<div class="list_item_title"></div>\n<div class="list_item_description"></div>\n\n<div class="list_item_buttons">\n  <a class="list_item_edit_button" title="',  I18n.t('pageflow.editor.templates.list_item.edit') ,'"></a>\n  <a class="list_item_remove_button" title="',  I18n.t('pageflow.editor.templates.list_item.remove') ,'"></a>\n</div>\n');}return __p.join('');};
}).call(this);
(function() { this.JST || (this.JST = {}); this.JST["pageflow/editor/templates/loading"] = function(obj){var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('<div class="spinner">\n  <div class="rect1"></div>\n  <div class="rect2"></div>\n  <div class="rect3"></div>\n  <div class="rect4"></div>\n  <div class="rect5"></div>\n</div>\n');}return __p.join('');};
}).call(this);
(function() { this.JST || (this.JST = {}); this.JST["pageflow/editor/templates/locked"] = function(obj){var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('<div class="checking notice">\n  <p>',  I18n.t('pageflow.editor.templates.locked.loading') ,'</p>\n\n  <a class="close" href="#">',  I18n.t('pageflow.editor.templates.locked.close') ,'</a>\n</div>\n\n<div class="error notice">\n  <div class="message"></div>\n\n  <a class="close" href="#">',  I18n.t('pageflow.editor.templates.locked.close') ,'</a>\n  <a class="break" href="#">',  I18n.t('pageflow.editor.templates.locked.open_here') ,'</a>\n</div>\n\n');}return __p.join('');};
}).call(this);
(function() { this.JST || (this.JST = {}); this.JST["pageflow/editor/templates/notifications"] = function(obj){var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('<li class="uploading"><span class="count">0</span>',  I18n.t('pageflow.editor.templates.notification.upload_pending') ,'</li>\n<li class="failed"><span class="count">0</span> <span class="description">',  I18n.t('pageflow.editor.templates.notification.save_error') ,'</span> <a class="retry">',  I18n.t('pageflow.editor.templates.notification.retry') ,'</a></li>\n<li class="saving">',  I18n.t('pageflow.editor.templates.notification.saving') ,'</li>\n<li class="saved">',  I18n.t('pageflow.editor.templates.notification.saved') ,'</li>\n\n<li class="confirmable_files">\n  ',  I18n.t('pageflow.editor.templates.notification.approve_files', {num_files: '<span class="count">0</span>'}) ,'\n  <a href="#/confirmable_files" class="display_confirmable_files">',  I18n.t('pageflow.editor.templates.notification.show') ,'</a>\n</li>\n');}return __p.join('');};
}).call(this);
(function() { this.JST || (this.JST = {}); this.JST["pageflow/editor/templates/other_entries_blank_slate"] = function(obj){var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('',  I18n.t('pageflow.editor.templates.other_entries_blank_slate.none_available') ,'\n');}return __p.join('');};
}).call(this);
(function() { this.JST || (this.JST = {}); this.JST["pageflow/editor/templates/other_entry_item"] = function(obj){var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('<a href="">\n  <span class="title"></span>\n</a>\n');}return __p.join('');};
}).call(this);
(function() { this.JST || (this.JST = {}); this.JST["pageflow/editor/templates/page_item"] = function(obj){var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('<a href="">\n  <span class="type_pictogram"></span>\n  <span class="page_thumbnail"></span>\n  <span class="title"></span>\n  <span class="failure_icon" title="',  I18n.t('pageflow.editor.templates.page_item.save_error') ,'" />\n</a>\n');}return __p.join('');};
}).call(this);
(function() { this.JST || (this.JST = {}); this.JST["pageflow/editor/templates/page_link_item"] = function(obj){var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('<div>\n  <span class="missing_page_thumbnail"></span>\n  <span class="page_thumbnail"></span>\n  <div class="title"></div>\n  <div class="label"></div>\n  <a class="remove" title="',  I18n.t('pageflow.editor.templates.page_link_item.remove') ,'"></a>\n  <a class="edit" title="',  I18n.t('pageflow.editor.templates.page_link_item.edit') ,'"></a>\n<div>\n');}return __p.join('');};
}).call(this);
(function() { this.JST || (this.JST = {}); this.JST["pageflow/editor/templates/page_links"] = function(obj){var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('<label>\n  <span class="name">',  I18n.t('pageflow.editor.templates.page_links.label') ,'</span>\n</label>\n<ul class="links outline"></ul>\n\n<a href="" class="add_link">',  I18n.t('pageflow.editor.templates.page_links.add') ,'</a>\n');}return __p.join('');};
}).call(this);
(function() { this.JST || (this.JST = {}); this.JST["pageflow/editor/templates/page_selection"] = function(obj){var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('<div class="box">\n  <h2>',  I18n.t('pageflow.editor.templates.page_selection.title') ,'</h2>\n\n  <div class="wrapper editor">\n    <div class="storyline_picker">\n    </div>\n  </div>\n\n  <div class="footer">\n    <a href="" class="close">',  I18n.t('pageflow.editor.templates.page_selection.cancel') ,'</a>\n  </div>\n</div>\n');}return __p.join('');};
}).call(this);
(function() { this.JST || (this.JST = {}); this.JST["pageflow/editor/templates/publish_entry"] = function(obj){var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('<div class="files_pending notice">\n  <p>',  I18n.t('pageflow.editor.templates.publish_entry.files_pending_notice') ,'</p>\n  <p><a href="#files">',  I18n.t('pageflow.editor.templates.publish_entry.show_files') ,'</a></p>\n</div>\n\n<div>\n  <div class="published notice">\n    <p>',  I18n.t('pageflow.editor.templates.publish_entry.published_notice') ,'</p>\n    <p><a href="" target="_blank">',  I18n.t('pageflow.editor.templates.publish_entry.view_revisions') ,'</a></p>\n  </div>\n\n  <div class="not_published notice">\n      ',  I18n.t('pageflow.editor.templates.publish_entry.not_published_notice') ,'\n  </div>\n\n  <h2>',  I18n.t('pageflow.editor.templates.publish_entry.publish_current') ,'</h2>\n\n  <div class="radio_input">\n    <input id="publish_entry_forever" type="radio" name="mode" value="publish_forever">\n    <label for="publish_entry_forever">',  I18n.t('pageflow.editor.templates.publish_entry.unlimited') ,'</label>\n  </div>\n\n  <div class="radio_input">\n    <input id="publish_entry_until" type="radio" name="mode" value="publish_until">\n    <label for="publish_entry_until">',  I18n.t('pageflow.editor.templates.publish_entry.until_including') ,'</label>\n  </div>\n\n  <div class="publish_until_fields disabled">\n    <label>\n      ',  I18n.t('pageflow.editor.templates.publish_entry.date') ,'\n      <input type="text" name="publish_until">\n    </label>\n\n    <label>\n      ',  I18n.t('pageflow.editor.templates.publish_entry.time') ,'\n      <input type="text" name="publish_until_time" value="00:00">\n    </label>\n  </div>\n\n  <div class="check_box_input">\n    <input id="publish_password_protected" type="checkbox" name="password_protected" value="1">\n    <label for="publish_password_protected">\n      <span class="name">\n        ',  I18n.t('pageflow.editor.templates.publish_entry.password_protected') ,'\n      </span>\n      <span class="inline_help">\n        ',  I18n.t('pageflow.editor.templates.publish_entry.password_help') ,'\n      </span>\n    </label>\n  </div>\n\n  <div class="password_fields disabled">\n    <label>\n      ',  I18n.t('pageflow.editor.templates.publish_entry.user_name') ,'\n      <input type="text" name="user_name" disabled>\n    </label>\n\n    <label>\n      ',  I18n.t('pageflow.editor.templates.publish_entry.password') ,'\n      <input type="text" name="password">\n    </label>\n\n    <p class="already_published_with_password">\n      ',  I18n.t('pageflow.editor.templates.publish_entry.already_published_with_password_help') ,'\n    </p>\n    <p class="previously_published_with_password">\n      ',  I18n.t('pageflow.editor.templates.publish_entry.previously_published_with_password_help') ,'\n    </p>\n    <p class="already_published_without_password">\n      ',  I18n.t('pageflow.editor.templates.publish_entry.already_published_without_password_help') ,'\n    </p>\n  </div>\n\n  <button class="save" disabled>',  I18n.t('pageflow.editor.templates.publish_entry.publish') ,'</a>\n</div>\n\n<div class="success notice">\n  <p>',  I18n.t('pageflow.editor.templates.publish_entry.publish_success') ,'</p>\n  <p>',  I18n.t('pageflow.editor.templates.publish_entry.published_url_hint') ,'</p>\n  <p><a href="" target="_blank"></a></p>\n</div>\n');}return __p.join('');};
}).call(this);
(function() { this.JST || (this.JST = {}); this.JST["pageflow/editor/templates/select_button"] = function(obj){var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('<button class="">\n  <span class="label">',  I18n.t('pageflow.editor.templates.select_button.select') ,'</span>\n</button>\n\n<div class="dropdown">\n  <ul class="dropdown-menu" role="menu">\n  </ul>\n</div>\n');}return __p.join('');};
}).call(this);
(function() { this.JST || (this.JST = {}); this.JST["pageflow/editor/templates/storyline_outline"] = function(obj){var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('<h2>',  I18n.t('pageflow.editor.templates.storyline_outline.header') ,'</h2>\n<ul class="storyline_outline_chapters chapters"></ul>\n\n<a class="add_chapter" href="">',  I18n.t('pageflow.editor.templates.storyline_outline.new_chapter') ,'</a>\n');}return __p.join('');};
}).call(this);
(function() { this.JST || (this.JST = {}); this.JST["pageflow/editor/templates/storyline_picker"] = function(obj){var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('<div class="storyline_picker_storylines">\n  <div class="storyline_picker_select_region"></div>\n  <a href="" class="add_storyline" title="',  I18n.t('pageflow.editor.templates.storyline_picker.add') ,'"></a>\n  <a href="" class="edit_storyline" title="',  I18n.t('pageflow.editor.templates.storyline_picker.edit') ,'"></a>\n</div>\n\n<div class="storyline_picker_main_region"></div>\n');}return __p.join('');};
}).call(this);
pageflow.dialogView = {
  events: {
    'click .close': function() {
      this.close();
    },

    'click .box': function() {
      return false;
    },

    'click': function() {
      this.close();
    }
  },
};
pageflow.failureIndicatingView = {
  modelEvents: {
    'change:failed': 'updateFailIndicator'
  },

  events: {
    'click .retry': function() {
      pageflow.editor.failures.retry();
      return false;
    }
  },

  onRender: function() {
    this.updateFailIndicator();
  },

  updateFailIndicator: function() {
    this.$el.toggleClass('failed', this.model.isFailed());
    this.$el.find('.failure .message').text(this.model.getFailureMessage());
  }
};
pageflow.loadable = {
  modelEvents: {
    'change:id': function() {
      this.$el.removeClass('creating');
    },

    destroying: function() {
      this.$el.addClass('destroying');
    },

    error: function() {
      this.$el.removeClass('destroying');
    }
  },

  render: function() {
    if (this.model.isNew()) {
      this.$el.addClass('creating');
    }

    if (this.model.isDestroying && this.model.isDestroying()) {
      this.$el.addClass('destroying');
    }
  }
};
pageflow.selectableView = {
  initialize: function() {
    this.selectionAttribute = this.selectionAttribute || this.model.modelName;

    this.listenTo(this.options.selection, 'change:' + this.selectionAttribute, function(selection, selectedModel) {
      this.$el.toggleClass('active', selectedModel === this.model);
    });

    this.$el.toggleClass('active', this.options.selection.get(this.selectionAttribute) === this.model);
  },

  select: function() {
    this.options.selection.set(this.selectionAttribute, this.model);
  },

  onClose: function() {
    if (this.options.selection.get(this.selectionAttribute) === this.model) {
      this.options.selection.set(this.selectionAttribute, null);
    }
  }
};
/**
 * Base thumbnail view for models supporting a `thumbnailFile` method.
 */

pageflow.ModelThumbnailView = Backbone.Marionette.View.extend({
  className: 'model_thumbnail',

  modelEvents: {
    'change:configuration': 'update'
  },

  render: function() {
    this.update();
    return this;
  },

  update: function() {
    var file = this.model && this.model.thumbnailFile();

    if (this.fileThumbnailView && this.currentFileThumbnail == file) {
      return;
    }

    this.currentFileThumbnail = file;

    if (this.fileThumbnailView) {
      this.fileThumbnailView.close();
    }

    this.fileThumbnailView = this.subview(new pageflow.FileThumbnailView({
      model: file,
      className: 'thumbnail file_thumbnail',
      imageUrlPropertyName: this.options.imageUrlPropertyName
    }));

    this.$el.append(this.fileThumbnailView.el);
  }
});
pageflow.FileItemView = Backbone.Marionette.ItemView.extend({
  tagName: 'li',
  template: 'templates/file_item',

  mixins: [pageflow.loadable],

  ui: {
    fileName: '.file_name',

    selectButton: '.select',
    removeButton: '.remove',
    confirmButton: '.confirm',
    cancelButton: '.cancel',
    retryButton: '.retry',

    thumbnail: '.file_thumbnail',
    stageItems: '.file_stage_items',

    rights: 'input.rights',
    metaData: 'tbody.attributes',
    downloads: 'tbody.downloads',
    downloadLink: 'a.original'
  },

  events: {
    'click .select': function() {
      this.options.selectionHandler.call(this.model);
      pageflow.editor.navigate(this.options.selectionHandler.getReferer(), {trigger: true});
      return false;
    },

    'click .cancel': 'cancel',

    'click .confirm': 'confirm',

    'click .remove': 'destroy',

    'click .retry': 'retry',

    'click .file_thumbnail': 'toggleExpanded',

    'change': 'save'
  },

  modelEvents: {
    'change': 'update'
  },

  onRender: function() {
    this.update();

    this.subview(new pageflow.FileThumbnailView({
      el: this.ui.thumbnail,
      model: this.model
    }));

    this.subview(new pageflow.CollectionView({
      el: this.ui.stageItems,
      collection: this.model.stages,
      itemViewConstructor: pageflow.FileStageItemView
    }));

    _.each(this.metaDataViews(), function(view) {
      this.ui.metaData.append(this.subview(view).el);
    }, this);
  },

  update: function() {
    this.$el.attr('data-id', this.model.id);
    this.ui.fileName.text(this.model.get('file_name') || '(Unbekannt)');

    this.ui.rights.val(this.model.get('rights'));
    this.ui.rights.attr('placeholder', pageflow.entry.get('default_file_rights'));

    this.ui.downloadLink.attr('href', this.model.get('original_url'));
    this.ui.downloads.toggle(this.model.isUploaded());

    this.ui.selectButton.toggle(!!this.options.selectionHandler);

    this.ui.cancelButton.toggle(this.model.isUploading());
    this.ui.confirmButton.toggle(this.model.isConfirmable());
    this.ui.removeButton.toggle(!this.model.isUploading());
    this.ui.retryButton.toggle(this.model.isRetryable());

    this.updateToggleTitle();
  },

  save: function() {
    this.model.save({
      rights: this.ui.rights.val()
    });
  },

  metaDataViews: function() {
    var model = this.model;

    return _.map(this.options.metaDataAttributes, function(attribute) {
      return new pageflow.FileMetaDataItemView({
        model: model,
        attribute: attribute
      });
    });
  },

  toggleExpanded: function() {
    this.$el.toggleClass('expanded');
    this.updateToggleTitle();
  },

  updateToggleTitle: function() {
    this.ui.thumbnail.attr('title', this.$el.hasClass('expanded') ? 'Details ausblenden' : 'Details einblenden');
  },

  destroy: function() {
    if (confirm("Datei wirklich wirklich löschen?")) {
      this.model.destroyUsage();
    }
  },

  cancel: function() {
    this.model.cancelUpload();
  },

  confirm: function() {
    pageflow.editor.navigate('/confirmable_files?type=' + this.model.modelName + '&id=' + this.model.id, {trigger: true});
  },

  retry: function() {
    this.model.retry();
  }
});
pageflow.ChapterItemView = Backbone.Marionette.ItemView.extend({
  tagName: 'li',
  template: 'templates/chapter_item',

  ui: {
    title: '> a > .title',
    number: '> a > .number',
    pages: 'ul.pages'
  },

  modelEvents: {
    change: 'update'
  },

  onRender: function() {
    var collectionView = this.options.sortable ? pageflow.SortableCollectionView : pageflow.CollectionView;

    this.subview(new collectionView({
      el: this.ui.pages,
      collection: this.model.pages,
      itemViewConstructor: this.options.pageItemView || pageflow.NavigatablePageItemView,
      itemViewOptions: this.options.pageItemViewOptions,
      connectWith: 'ul.pages'
    }));

    this.update();
  },

  update: function() {
    this.ui.title.text(this.model.get('title') || I18n.t('pageflow.editor.views.chapter_item_view.unnamed'));
    this.ui.number.text(I18n.t('pageflow.editor.views.chapter_item_view.chapter') + ' ' + (this.model.get('position') + 1));
  }
});
pageflow.PageItemView = Backbone.Marionette.ItemView.extend({
  tagName: 'li',
  template: 'templates/page_item',

  ui: {
    title: '.title',
    pictogram: '.type_pictogram',
    pageThumbnail: '.page_thumbnail'
  },

  modelEvents: {
    'change:title': 'update',
    'change:active': 'update'
  },

  onRender: function() {
    this.subview(new pageflow.PageThumbnailView({
      el: this.ui.pageThumbnail,
      model: this.model
    }));

    this.update();
  },

  update: function() {
    this.$el.attr('data-id', this.model.id);
    this.$el.attr('data-perma-id', this.model.get('perma_id'));

    this.$el.toggleClass('active', this.model.get('active'));
    this.$el.toggleClass('disabled',
                         !!(this.options.isDisabled && this.options.isDisabled(this.model)));
    this.$el.toggleClass('display_in_navigation', !!this.model.configuration.get('display_in_navigation'));
    this.$el
      .removeClass(pageflow.editor.pageTypes.pluck('name').join(' '))
      .addClass(this.model.get('template'));

    this.ui.pictogram.attr('title', this._getPictogramTitle());
    this.ui.title.text(this.model.title() || I18n.t('pageflow.editor.views.page_item_view.unnamed'));
  },

  _getPictogramTitle: function() {
    var result = I18n.t(this.model.pageType().translationKey());
    result += ' Seite';

    if (this.options.displayInNavigationHint && !this.model.configuration.get('display_in_navigation')) {
      result += ' (nicht in Navigationsleiste)';
    }

    return result;
  }
});
pageflow.ReferenceInputView = Backbone.Marionette.ItemView.extend({
  mixins: [pageflow.inputView],

  template: 'pageflow/editor/templates/inputs/reference',
  className: 'reference_input',

  ui: {
    title: '.title',
    unsetButton: '.unset'
  },

  events: {
    'click .choose': function() {
      var view = this;

      this.choose().then(function(site) {
        view.model.set(view.options.propertyName, site.get('perma_id'));
      });

      return false;
    },

    'click .unset': function() {
      this.model.unset(this.options.propertyName);
      return false;
    }
  },

  initialize: function() {
    this.listenTo(this.model, 'change:' + this.options.propertyName, this.update);
  },

  onRender: function() {
    this.update();
    this.listenTo(this.model, 'change:' + this.options.propertyName, this.update);
  },

  choose: function() {
    throw 'Not implemented: Override ReferenceInputView#choose to return a promise';
  },

  getTarget: function() {
    throw 'Not implemented: Override ReferenceInputView#getTarget';
  },

  createThumbnailView: function(target) {
    return new pageflow.ModelThumbnailView({
      model: target
    });
  },

  update: function() {
    var target = this.getTarget(this.model.get(this.options.propertyName));

    this.ui.title.text(target ? target.title() : I18n.t('pageflow.editor.views.inputs.reference_input_view.none'));
    this.ui.unsetButton.toggle(!!target);

    if (this.thumbnailView) {
      this.thumbnailView.close();
    }

    this.thumbnailView = this.subview(this.createThumbnailView(target));

    this.ui.title.before(this.thumbnailView.el);
  }
});
pageflow.ConfigurationEditorView.register('audio', {
  configure: function() {
    this.tab('general', function() {
      this.group('general');

      this.input('additional_title', pageflow.TextInputView);
      this.input('additional_description', pageflow.TextAreaInputView, {size: 'short'});
    });

    this.tab('files', function() {
      this.input('audio_file_id', pageflow.FileInputView, {collection: pageflow.audioFiles});
      this.input('background_image_id', pageflow.FileInputView, {collection: pageflow.imageFiles});
      this.input('thumbnail_image_id', pageflow.FileInputView, {
        collection: pageflow.imageFiles,
        positioning: false
      });
    });

    this.tab('options', function() {
      this.input('autoplay', pageflow.CheckBoxInputView);
      this.group('options', {canPauseAtmo: true});
    });
  }
});
pageflow.ConfigurationEditorView.register('audio_loop', {
  configure: function() {
    this.tab('general', function() {
      this.group('general');
    });

    this.tab('files', function() {
      this.input('audio_file_id', pageflow.FileInputView, {collection: pageflow.audioFiles});
      this.input('background_image_id', pageflow.FileInputView, {collection: pageflow.imageFiles});
      this.input('thumbnail_image_id', pageflow.FileInputView, {
        collection: pageflow.imageFiles,
        positioning: false
      });
    });

    this.tab('options', function() {
      this.group('options');
    });
  }
});
pageflow.ConfigurationEditorView.register('background_image', {
  configure: function() {
    this.tab('general', function() {
      this.group('general');
    });

    this.tab('files', function() {
      this.input('background_image_id', pageflow.FileInputView, {collection: pageflow.imageFiles});
      this.input('thumbnail_image_id', pageflow.FileInputView, {
        collection: pageflow.imageFiles,
        positioning: false
      });
    });

    this.tab('options', function() {
      this.group('options');
    });
  }
});
pageflow.ConfigurationEditorView.register('background_video', {
  configure: function() {
    this.tab('general', function() {
      this.group('general');
    });

    this.tab('files', function() {
      this.input('video_file_id', pageflow.FileInputView, {collection: pageflow.videoFiles});
      this.input('poster_image_id', pageflow.FileInputView, {collection: pageflow.imageFiles});
      this.input('thumbnail_image_id', pageflow.FileInputView, {
        collection: pageflow.imageFiles,
        positioning: false
      });
      this.input('mobile_poster_image_id', pageflow.FileInputView, {
        collection: pageflow.imageFiles,
        imagePositioning: false
      });
    });

    this.tab('options', function() {
      this.group('options');
    });
  }
});
pageflow.ConfigurationEditorTabView.groups.define('general', function() {
  this.input('title', pageflow.TextInputView, {required: true});
  this.input('hide_title', pageflow.CheckBoxInputView);
  this.input('tagline', pageflow.TextInputView);
  this.input('subtitle', pageflow.TextInputView);
  this.input('text', pageflow.TextAreaInputView);
  this.input('text_position', pageflow.SelectInputView, {values: pageflow.Page.textPositions});
  this.input('gradient_opacity', pageflow.SliderInputView);
  this.input('invert', pageflow.CheckBoxInputView);
});
pageflow.ConfigurationEditorTabView.groups.define('options', function(options) {
  this.input('display_in_navigation', pageflow.CheckBoxInputView);

  if (pageflow.theming.supportsEmphasizedPages()) {
    this.input('emphasize_in_navigation', pageflow.CheckBoxInputView);
  }

  this.group('page_transitions');

  if (pageflow.features.isEnabled('delayed_text_fade_in')) {
    this.input('delayed_text_fade_in', pageflow.SelectInputView, {values: pageflow.Page.delayedTextFadeIn});
  }

  this.input('description', pageflow.TextAreaInputView, {size: 'short', disableLinks: true});

  if (pageflow.features.isEnabled('atmo')) {
    this.input('atmo_audio_file_id', pageflow.FileInputView, {
      collection: pageflow.audioFiles
    });

    if (options.canPauseAtmo) {
      this.input('atmo_during_playback', pageflow.SelectInputView, {
        values: pageflow.Atmo.duringPlaybackModes
      });
    }
  }

  if (pageflow.theming.supportsScrollIndicatorModes()) {
    this.input('scroll_indicator_mode', pageflow.SelectInputView, {
      values: pageflow.Page.scrollIndicatorModes
    });

    this.input('scroll_indicator_orientation', pageflow.SelectInputView, {
      values: pageflow.Page.scrollIndicatorOrientations
    });
  }
});
pageflow.ConfigurationEditorTabView.groups.define('page_link', function() {
  this.input('label', pageflow.TextInputView);
  this.input('target_page_id', pageflow.PageLinkInputView);
  this.input('page_transition', pageflow.SelectInputView, {
    translationKeyPrefix: 'pageflow.page_transitions',
    includeBlank: true,
    blankTranslationKey: 'pageflow.editor.views.edit_page_link_view.default_page_transition',
    values: pageflow.pageTransitions.names()
  });
});
pageflow.ConfigurationEditorTabView.groups.define('page_transitions', function() {
  this.input('transition', pageflow.SelectInputView, {
    translationKeyPrefix: 'pageflow.page_transitions',
    values: pageflow.pageTransitions.names()
  });
});
pageflow.ConfigurationEditorView.register('video', {
  configure: function() {
    this.tab('general', function() {
      this.group('general');

      this.input('additional_title', pageflow.TextInputView);
      this.input('additional_description', pageflow.TextAreaInputView, {size: 'short'});
    });

    this.tab('files', function() {
      this.input('video_file_id', pageflow.FileInputView, {
        collection: pageflow.videoFiles,
        positioning: false
      });
      this.input('poster_image_id', pageflow.FileInputView, {
        collection: pageflow.imageFiles,
        positioning: false
      });
      this.input('thumbnail_image_id', pageflow.FileInputView, {
        collection: pageflow.imageFiles,
        positioning: false
      });
      this.input('mobile_poster_image_id', pageflow.FileInputView, {
        collection: pageflow.imageFiles,
        imagePositioning: false
      });
    });

    this.tab('options', function() {
      this.input('autoplay', pageflow.CheckBoxInputView);

      if (pageflow.features.isEnabled('auto_change_page')) {
        this.input('auto_change_page_on_ended', pageflow.CheckBoxInputView);
      }

      this.group('options', {canPauseAtmo: true});
    });
  }
});
pageflow.BackButtonDecoratorView = Backbone.Marionette.Layout.extend({
  template: 'templates/back_button_decorator',
  className: 'back_button_decorator',

  events: {
    'click a.back': 'goBack'
  },

  regions: {
    outlet: '.outlet'
  },

  onRender: function() {
    this.outlet.show(this.options.view);
  },

  goBack: function() {
    editor.navigate('/', {trigger: true});
  }
});
pageflow.BackgroundPositioningPreviewView = Backbone.Marionette.ItemView.extend({
  template: 'templates/background_positioning_preview',
  className: 'preview',

  modelEvents: {
    change: 'update'
  },

  ui: {
    image: '.image',
    label: '.label'
  },

  onRender: function() {
    this.update();
  },

  update: function() {
    var ratio = this.options.ratio;
    var max = this.options.maxSize;
    var width = ratio > 1 ? max : max * ratio;
    var height = ratio > 1 ? max / ratio : max;

    this.ui.image.css({
      width: width + 'px',
      height: height + 'px',
      backgroundImage: this.imageValue(),
      backgroundPosition: this.model.getFilePosition(this.options.propertyName, 'x') + '% ' +
        this.model.getFilePosition(this.options.propertyName, 'y') + '%'
    });

    this.ui.label.text(this.options.label);
  },

  imageValue: function() {
    var file = this.model.getReference(this.options.propertyName, this.options.filesCollection);
    return file ? 'url("' + file.getBackgroundPositioningImageUrl()  + '")' : 'none';
  }
});
pageflow.BackgroundPositioningSlidersView = Backbone.Marionette.ItemView.extend({
  template: 'templates/background_positioning_sliders',
  className: '',

  ui: {
    container: '.container',

    sliderHorizontal: '.horizontal.slider',
    sliderVertical: '.vertical.slider'
  },

  events: {
    'mousedown img': function(event) {
      var view = this;
      view.saveFromEvent(event);

      function onMove(event) {
        view.saveFromEvent(event);
      }

      function onUp() {
        $('.background_positioning.dialog')
          .off('mousemove', onMove)
          .off('mouseup', onUp);
      }

      $('.background_positioning.dialog')
        .on('mousemove', onMove)
        .on('mouseup', onUp);
    },

    'dragstart img': function(event) {
      event.preventDefault();
    }
  },

  onRender: function() {
    var view = this;
    var file = this.model.getReference(this.options.propertyName, this.options.filesCollection),
        image = $('<img />').attr('src', file.getBackgroundPositioningImageUrl());

    this.ui.container.append(image);

    this.ui.sliderVertical.slider({
      orientation: 'vertical',
      step: 0.01,
      value: 100 - this.model.getFilePosition(this.options.propertyName, 'y'),

      change: function() {
        view.save();
      },

      slide: function(event, ui) {
        view.save({y: ui.value});
      }
    });

    this.ui.sliderHorizontal.slider({
      orientation: 'horizontal',
      step: 0.01,
      value: this.model.getFilePosition(this.options.propertyName, 'x'),

      change: function() {
        view.save();
      },

      slide: function(event, ui) {
        view.save({y: ui.value});
      }
    });
  },

  onShow: function() {
  },

  saveFromEvent: function(event) {
    var x = event.pageX - this.ui.container.offset().left;
    var y = event.pageY - this.ui.container.offset().top;

    this.ui.sliderHorizontal.slider('value', x / this.ui.container.width() * 100);
    this.ui.sliderVertical.slider('value', (1 - y / this.ui.container.height()) * 100);
    this.save();
  },

  save: function(options) {
    options = options || {};

    var x = x in options ? options.x : this.ui.sliderHorizontal.slider('value');
    var y = y in options ? options.y : 100 - this.ui.sliderVertical.slider('value');

    this.model.setFilePosition(this.options.propertyName, 'x', x);
    this.model.setFilePosition(this.options.propertyName, 'y', y);
  }
});
pageflow.BackgroundPositioningView = Backbone.Marionette.ItemView.extend({
  template: 'templates/background_positioning',
  className: 'background_positioning dialog',

  mixins: [pageflow.dialogView],

  ui: {
    previews: '.previews > div',
    wrapper: '.wrapper',
  },

  previews: {
    ratio16to9: 16 / 9,
    ratio16to9Portrait: 9 / 16,
    ratio4to3: 4 / 3,
    ratio4to3Portrait: 3 / 4,
    banner: 5 / 1
  },

  events: {
    'click .save': function() {
      this.save();
      this.close();
    }
  },

  initialize: function() {
    this.transientModel = this.model.clone();
  },

  onRender: function() {
    this.ui.wrapper.append(this.subview(new pageflow.BackgroundPositioningSlidersView({
      model: this.transientModel,
      propertyName: this.options.propertyName,
      filesCollection: this.options.filesCollection
    })).el);

    this.createPreviews();
  },

  save: function() {
    this.model.setFilePositions(
      this.options.propertyName,
      this.transientModel.getFilePosition(this.options.propertyName, 'x'),
      this.transientModel.getFilePosition(this.options.propertyName, 'y')
    );
  },

  createPreviews: function() {
    var view = this;

    _.each(view.previews, function(ratio, name) {
      view.ui.previews.append(view.subview(new pageflow.BackgroundPositioningPreviewView({
        model: view.transientModel,
        propertyName: view.options.propertyName,
        filesCollection: view.options.filesCollection,
        ratio: ratio,
        maxSize: 200,
        label: I18n.t('pageflow.editor.templates.background_positioning.previews.' + name)
      })).el);
    });
  }
});

pageflow.BackgroundPositioningView.open = function(options) {
  pageflow.app.dialogRegion.show(new pageflow.BackgroundPositioningView(options).render());
};
pageflow.BlankEntryView = Backbone.Marionette.ItemView.extend({
  template: 'templates/blank_entry',
  className: 'blank_entry'
});
pageflow.ConfirmEncodingView = Backbone.Marionette.ItemView.extend({
  template: 'templates/confirm_encoding',
  className: 'confirm_encoding',

  ui: {
    blankSlate: '.blank_slate',
    videoFilesPanel: '.video_files_panel',
    audioFilesPanel: '.audio_files_panel',

    summary: '.summary',
    confirmButton: 'button'
  },

  events: {
    'click button': function() {
      this.model.saveAndReset();
    }
  },

  initialize: function() {
    this.confirmableVideoFiles = pageflow.videoFiles.confirmable();
    this.confirmableAudioFiles = pageflow.audioFiles.confirmable();
  },

  onRender: function() {
    this.listenTo(this.model, 'change', this.updateSummary);

    this.listenTo(this.confirmableAudioFiles, 'add remove', this.updateBlankSlate);
    this.listenTo(this.confirmableVideoFiles, 'add remove', this.updateBlankSlate);

    this.ui.videoFilesPanel.append(this.subview(new pageflow.CollectionView({
      tagName: 'ul',
      className: 'confirmable_files',
      collection: this.confirmableVideoFiles,
      itemViewConstructor: pageflow.ConfirmableFileItemView,
      itemViewOptions: {
        selectedFiles: this.model.videoFiles
      }
    })).el);

    this.ui.audioFilesPanel.append(this.subview(new pageflow.CollectionView({
      tagName: 'ul',
      className: 'confirmable_files',
      collection: this.confirmableAudioFiles,
      itemViewConstructor: pageflow.ConfirmableFileItemView,
      itemViewOptions: {
        selectedFiles: this.model.audioFiles
      }
    })).el);

    this.update();
  },

  update: function() {
    this.updateBlankSlate();
    this.updateSummary();
  },

  updateBlankSlate: function() {
    this.ui.blankSlate.toggle(!this.confirmableVideoFiles.length && !this.confirmableAudioFiles.length);
    this.ui.videoFilesPanel.toggle(!!this.confirmableVideoFiles.length);
    this.ui.audioFilesPanel.toggle(!!this.confirmableAudioFiles.length);
  },

  updateSummary: function(enabled) {
    this.ui.summary.html(this.model.get('summary_html'));
    this.ui.confirmButton.toggleClass('checking', !!this.model.get('checking'));

    if (this.model.get('empty') || this.model.get('exceeding') || this.model.get('checking')) {
      this.ui.confirmButton.attr('disabled', true);
    }
    else {
      this.ui.confirmButton.removeAttr('disabled');
    }
  }
});

pageflow.ConfirmEncodingView.create = function(options) {
  return new pageflow.BackButtonDecoratorView({
    view: new pageflow.ConfirmEncodingView(options)
  });
};
pageflow.ConfirmableFileItemView = Backbone.Marionette.ItemView.extend({
  tagName: 'li',
  template: 'templates/confirmable_file_item',

  ui: {
    fileName: '.file_name',
    duration: '.duration',

    label: 'label',
    checkBox: 'input',
    removeButton: '.remove',
  },

  events: {
    'click .remove': 'destroy',

    'change input': 'updateSelection'
  },

  onRender: function() {
    this.ui.label.attr('for', this.cid);
    this.ui.checkBox.attr('id', this.cid);
    this.ui.checkBox.prop('checked', this.options.selectedFiles.contains(this.model));

    this.ui.fileName.text(this.model.get('file_name') || '(Unbekannt)');
    this.ui.duration.text(this.model.get('duration') || '-');
  },

  destroy: function() {
    if (confirm("Datei wirklich wirklich löschen?")) {
      this.model.destroyUsage();
    }
  },

  updateSelection: function() {
    if (this.ui.checkBox.is(':checked')) {
      this.options.selectedFiles.add(this.model);
    }
    else {
      this.options.selectedFiles.remove(this.model);
    }
  },
});
pageflow.DisabledAtmoIndicatorView = Backbone.Marionette.View.extend({
  className: 'disabled_atmo_indicator',

  events: {
    'click': function() {
      pageflow.atmo.enable();
    }
  },

  initialize: function() {
    this.listenTo(pageflow.events, 'atmo:disabled', function() {
      this.$el.show();
    });

    this.listenTo(pageflow.events, 'atmo:enabled', function() {
      this.$el.hide();
    });

    this.$el.toggle(pageflow.atmo.disabled);
  },

  render: function() {
    this.$el.attr('title', I18n.t('pageflow.editor.atmo.disabled'));

    return this;
  }
});
/** @api private */

pageflow.DropDownButtonItemView = Backbone.Marionette.ItemView.extend({
  template: 'pageflow/editor/templates/drop_down_button_item',
  tagName: 'li',
  className: 'drop_down_button_item',

  ui: {
    link: '> a'
  },

  events: {
    'click > a': function() {
      if (!this.model.get('disabled')) {
        this.model.selected();
      }

      return false;
    }
  },

  modelEvents: {
    change: 'update'
  },

  onRender: function() {
    this.update();
  },

  update: function() {
    this.ui.link.text(this.model.get('label'));
    this.$el.toggleClass('is_disabled', !!this.model.get('disabled'));
  }
});
/**
 * A button that displays a drop down menu on hover.
 *
 * @option label [String]
 * @options items [Backbone.Collection] The `label` attribute is used
 *   as text for the item. Items can be disabled by setting the
 *   `disabled` property to `true`. On click a `selected` method is
 *   called on the item model.
 */

pageflow.DropDownButtonView = Backbone.Marionette.ItemView.extend({
  template: 'pageflow/editor/templates/drop_down_button',
  className: 'drop_down_button',

  ui: {
    button: '> button',
    menu: '.drop_down_button_menu',
    items: '.drop_down_button_items'
  },

  events: {
    'mouseenter': function() {
      this.positionMenu();
      this.showMenu();
    },

    'mouseleave': function() {
      this.hideMenu();
    }
  },

  onRender: function() {
    var view = this;

    this.ui.button.text(this.options.label);

    this.subview(new pageflow.CollectionView({
      el: this.ui.items,
      collection: this.options.items,
      itemViewConstructor: pageflow.DropDownButtonItemView
    }));

    this.ui.menu.on({
      'mouseenter': function() {
        view.showMenu();
      },

      'mouseleave': function() {
        view.hideMenu();
      }
    });

    this.ui.menu.appendTo('#editor_menu_container');
  },

  onClose: function() {
    this.ui.menu.remove();
  },

  positionMenu: function() {
    var offset = this.$el.offset();

    this.ui.menu.css({
      top: offset.top + this.$el.height(),
      left: offset.left
    });
  },

  showMenu: function() {
    clearTimeout(this.hideMenuTimeout);
    this.ui.menu.addClass('is_visible');
  },

  hideMenu: function() {
    this.hideMenuTimeout = setTimeout(_.bind(function() {
      if (!this.isClosed) {
        this.ui.menu.removeClass('is_visible');
      }
    }, this), 500);
  }
});
pageflow.EditChapterView = Backbone.Marionette.Layout.extend({
  template: 'templates/edit_chapter',
  className: 'edit_chapter',

  mixins: [pageflow.failureIndicatingView],

  regions: {
    formContainer: '.form_container'
  },

  events: {
    'click a.back': 'goBack',
    'click a.destroy': 'destroy'
  },

  onRender: function() {
    var configurationEditor = new pageflow.ConfigurationEditorView({
      model: this.model.configuration
    });

    this.configure(configurationEditor);
    this.formContainer.show(configurationEditor);
  },

  configure: function(configurationEditor) {
    var view = this;

    configurationEditor.tab('general', function() {
      this.input('title', pageflow.TextInputView, {
        model: view.model
      });

      if (pageflow.features.isEnabled('chapter_hierachy')) {
        this.input('display_parent_page_button', pageflow.CheckBoxInputView);
      }
    });
  },

  destroy: function() {
    if (confirm(I18n.t('pageflow.editor.views.edit_chapter_view.confirm_destroy'))) {
      this.model.destroy();
      this.goBack();
    }
  },

  goBack: function() {
    editor.navigate('/', {trigger: true});
  }
});
pageflow.EditEntryView = Backbone.Marionette.ItemView.extend({
  template: 'templates/edit_entry',

  mixins: [pageflow.failureIndicatingView],

  ui: {
    publicationStateButton: 'a.publication_state',
    menu: '.menu',
    storylines: '.edit_entry_storylines'
  },

  events: {
    'click a.close': function() {
      $.when(pageflow.editLock.release()).then(function() {
        window.location = '/admin/entries/' + pageflow.entry.id;
      });
    },

    'click a.publish': function() {
      editor.navigate('/publish', {trigger: true});
      return false;
    },

    'click .menu a': function(event) {
      editor.navigate($(event.target).data('path'), {trigger: true});
      return false;
    }
  },

  onRender: function() {
    this._addMenuItems();

    this.subview(new pageflow.StorylinePickerView({
      el: this.ui.storylines,
      navigatable: true,
      editable: true,
      displayInNavigationHint: true,
      rememberLastSelection: true,
      storylineId: this.options.storylineId
    }));
  },

  _addMenuItems: function() {
    var view = this;

    _.each(pageflow.editor.mainMenuItems, function(options) {
      var item = $('<li><a href="#"></a></li>');
      var link = item.find('a');

      if (options.path) {
        link.data('path', options.path);
      }
      link.text(I18n.t(options.translationKey));

      if (options.click) {
        $(link).click(options.click);
      }


      view.ui.menu.append(item);
    });
  }
});
/*global editor*/


pageflow.EditMetaDataView = Backbone.Marionette.Layout.extend({
  template: 'templates/edit_meta_data',
  className: 'edit_meta_data',

  mixins: [pageflow.failureIndicatingView],

  regions: {
    formContainer: '.form_fields'
  },

  events: {
    'click a.back': 'goBack'
  },

  onRender: function() {
    var entry = this.model;

    var configurationEditor = new pageflow.ConfigurationEditorView({
      model: entry.configuration,
      tab: this.options.tab
    });

    configurationEditor.tab('general', function() {
      this.input('title', pageflow.TextInputView, {
        placeholder: entry.attributes.entry_title
      });
      this.input('locale', pageflow.SelectInputView, {
        values: pageflow.config.availablePublicLocales,
        texts: _.map(pageflow.config.availablePublicLocales, function(locale) {
          return I18n.t('pageflow.public._language', {locale: locale});
        })
      });

      this.input('credits', pageflow.TextAreaInputView);

      this.input('author', pageflow.TextInputView, {
        placeholder: pageflow.config.defaultAuthorMetaTag
      });
      this.input('publisher', pageflow.TextInputView, {
        placeholder: pageflow.config.defaultPublisherMetaTag
      });
      this.input('keywords', pageflow.TextInputView, {
        placeholder: pageflow.config.defaultKeywordsMetaTag
      });
    });

    configurationEditor.tab('widgets', function() {
      this.input('manual_start', pageflow.CheckBoxInputView);
      this.input('emphasize_chapter_beginning', pageflow.CheckBoxInputView);
      this.input('emphasize_new_pages', pageflow.CheckBoxInputView);
      this.input('home_button_enabled', pageflow.CheckBoxInputView, {
        disabled: !pageflow.theming.hasHomeButton(),
        displayUncheckedIfDisabled: true
      });
      this.input('overview_button_enabled', pageflow.CheckBoxInputView, {
        disabled: !pageflow.theming.hasOverviewButton(),
        displayUncheckedIfDisabled: true
      });
      if (pageflow.theming.hasHomeButton()) {
        this.input('home_url', pageflow.TextInputView, {
          placeholder: pageflow.theming.get('pretty_url'),
          visibleBinding: 'home_button_enabled'
        });
      }
      this.view(pageflow.EditWidgetsView, {
        model: entry,
        widgetTypes: pageflow.editor.widgetTypes
      });
    });

    configurationEditor.tab('social', function() {
      this.input('share_image_id', pageflow.FileInputView, {
        collection: pageflow.imageFiles,
        fileSelectionHandler: 'entryConfiguration'
      });
      this.input('summary', pageflow.TextAreaInputView, {
        disableRichtext: true,
        disableLinks: true
      });
      this.input('share_url', pageflow.TextInputView, {
        placeholder: pageflow.entry.get('pretty_url')
      });
    });

    this.formContainer.show(configurationEditor);
  },

  goBack: function() {
    editor.navigate('/', {trigger: true});
  }
});
pageflow.EditPageLinkView = Backbone.Marionette.Layout.extend({
  template: 'pageflow/editor/templates/edit_page_link',

  regions: {
    formContainer: '.form_container'
  },

  ui: {
    backButton: 'a.back'
  },

  events: {
    'click a.back': 'goBack',

    'click a.destroy': 'destroy'
  },

  onRender: function() {
    var configurationEditor = this.options.page.pageType().createPageLinkConfigurationEditorView({
      model: this.model,
      page: this.options.page
    });

    this.formContainer.show(configurationEditor);

    this.highlight();
  },

  highlight: function() {
    this.model.highlight();

    this.listenTo(this, 'close', function() {
      this.model.resetHighlight();
    });
  },

  destroy: function() {
    if (confirm(I18n.t('pageflow.internal_links.editor.views.edit_page_link_view.confirm_destroy'))) {
      this.model.remove();
      this.goBack();
    }
  },

  goBack: function() {
    pageflow.editor.navigate('/pages/' + this.options.page.id + '/links', {trigger: true});
  }
});
pageflow.EditPageView = Backbone.Marionette.Layout.extend({
  template: 'templates/edit_page',
  className: 'edit_page',

  mixins: [pageflow.failureIndicatingView],

  regions: {
    pageTypeContainer: '.page_type',
    configurationContainer: '.configuration_container'
  },

  events: {
    'click a.back': 'goBack',
    'click a.destroy': 'destroy'
  },

  modelEvents: {
    'change:template': 'load'
  },

  onRender: function() {
    this.pageTypeContainer.show(new pageflow.ExtendedSelectInputView({
      model: this.model,
      propertyName: 'template',
      collection: pageflow.editor.pageTypes.pluck('seed'),
      valueProperty: 'name',
      translationKeyProperty: 'translation_key',
      groupTranslationKeyProperty: 'category_translation_key',
      descriptionTranslationKeyProperty: 'description_translation_key',

      pictogramClass: 'type_pictogram',

      helpLinkClicked: function(value) {
        var pageType = pageflow.editor.pageTypes.findByName(value);
        pageflow.app.trigger('toggle-help', pageType.seed.help_entry_translation_key);
      }
    }));

    this.load();
    this.model.trigger('edit', this.model);
  },

  load: function() {
    var configurationEditor = this.model.pageType().createConfigurationEditorView({
      model: this.model.configuration,
      tab: this.options.tab
    });

    this.configurationContainer.show(configurationEditor);
  },

  destroy: function() {
    if (confirm(I18n.t('pageflow.editor.views.edit_page_view.confirm_destroy'))) {
      this.model.destroy();
      this.goBack();
    }
  },

  goBack: function() {
    editor.navigate('/', {trigger: true});
  }
});
pageflow.EditStorylineView = Backbone.Marionette.Layout.extend({
  template: 'templates/edit_storyline',
  className: 'edit_storyline',

  mixins: [pageflow.failureIndicatingView, pageflow.tooltipContainer],

  regions: {
    formContainer: '.form_container'
  },

  ui: {
    destroyButton: 'a.destroy'
  },

  events: {
    'click a.back': 'goBack',
    'click a.destroy': 'destroy'
  },

  onRender: function() {
    var configurationEditor = new pageflow.ConfigurationEditorView({
      model: this.model.configuration,
      attributeTranslationKeyPrefixes: ['pageflow.storyline_attributes']
    });

    this.configure(configurationEditor, this.model.transitiveChildPages());
    this.formContainer.show(configurationEditor);

    this.updateDestroyButton();
  },

  updateDestroyButton: function() {
    var disabled = (this.model.chapters.length > 0);

    this.ui.destroyButton.toggleClass('faded', disabled);

    if (disabled) {
      this.ui.destroyButton.attr('data-tooltip', 'pageflow.editor.views.edit_storyline_view.cannot_destroy');
    }
    else {
      this.ui.destroyButton.removeAttr('data-tooltip');
    }
  },

  configure: function(configurationEditor, storylineChildPages) {
    configurationEditor.tab('general', function() {
      this.input('title', pageflow.TextInputView);
      this.input('main', pageflow.CheckBoxInputView, {
        disabled: true,
        visibleBinding: 'main'
      });
      this.input('page_transition', pageflow.SelectInputView, {
        translationKeyPrefix: 'pageflow.page_transitions',
        includeBlank: true,
        blankTranslationKey: 'pageflow.editor.views.edit_storyline_view.default_parent_page_transition',
        values: pageflow.pageTransitions.names()
      });
      this.input('main', pageflow.CheckBoxInputView, {
        visibleBinding: 'main',
        visible: function(isMain) {
          return !isMain;
        }
      });
      this.input('parent_page_perma_id', pageflow.PageLinkInputView, {
        visibleBinding: 'main',
        visible: function(isMain) {
          return !isMain && pageflow.storylines.length > 1;
        },
        isAllowed: function(page) {
          return !storylineChildPages.contain(page);
        }
      });
      this.input('scroll_successor_id', pageflow.PageLinkInputView);

      if (pageflow.features.isEnabled('chapter_hierachy')) {
        this.input('navigation_bar_mode', pageflow.SelectInputView, {
          values: pageflow.ChapterFilter.strategies
        });
      }
    });
  },

  destroy: function() {
    if (this.model.chapters.length) {
      return;
    }

    if (confirm(I18n.t('pageflow.editor.views.edit_storyline_view.confirm_destroy'))) {
      this.model.destroy();
      this.goBack();
    }
  },

  goBack: function() {
    editor.navigate('/?storyline=' + this.model.id, {trigger: true});
  }
});
pageflow.EditWidgetView = Backbone.Marionette.Layout.extend({
  template: 'templates/edit_widget',
  tagName: 'li',
  className: 'edit_widget',

  regions: {
    widgetTypeContainer: '.widget_type'
  },

  ui: {
    role: 'h2'
  },

  onRender: function() {
    var widgetTypes = this.options.widgetTypes[this.model.role()] || [];

    this.widgetTypeContainer.show(new pageflow.SelectInputView({
      model: this.model,
      propertyName: 'type_name',
      label: I18n.t('pageflow.widgets.roles.' + this.model.role()),
      collection: widgetTypes,
      valueProperty: 'name',
      translationKeyProperty: 'translationKey',
      includeBlank: true
    }));

    this.$el.toggle(widgetTypes.length > 1);
  }
});
pageflow.EditWidgetsView = Backbone.Marionette.Layout.extend({
  template: 'templates/edit_widgets',

  ui: {
    widgets: '.widgets'
  },

  onRender: function() {
    this.subview(new pageflow.CollectionView({
      el: this.ui.widgets,
      collection: this.model.widgets,
      itemViewConstructor: pageflow.EditWidgetView,
      itemViewOptions: {
        widgetTypes: this.options.widgetTypes
      }
    }).render());

    this.model.fetchWidgets();
  }
});
pageflow.EditorView = Backbone.View.extend({
  scrollNavigationKeys: _.values({
    pageUp: 33,
    pageDown: 34,
    end: 35,
    home: 36,
    left: 37,
    up: 38,
    right: 39,
    down: 40
  }),

  events: {
    'click a': function(event) {
      // prevent default for all links
      if (!$(event.currentTarget).attr('target') &&
          !$(event.currentTarget).attr('download') &&
          !$(event.currentTarget).attr('href')) {
        return false;
      }
    },

    'keydown sidebar': function(event) {
      this.preventScrollingPreviewWhileFocusInSidebar(event);
    }
  },

  initialize: function() {
    $(window).on('beforeunload', function(event) {
      if (pageflow.entry.get('uploading_files_count') > 0)  {
        return I18n.t('pageflow.editor.views.editor_views.files_pending_warning');
      }
    });
  },

  render: function() {
    this.$el.layout({
      minSize: 300,
      togglerTip_closed: I18n.t('pageflow.editor.views.editor_views.show_editor'),
      togglerTip_open: I18n.t('pageflow.editor.views.editor_views.hide_editor'),
      resizerTip: I18n.t('pageflow.editor.views.editor_views.resize_editor'),
      enableCursorHotkey: false,
      fxName: 'none',

      onresize: function() {
        pageflow.app.trigger('resize');
      }
    });

    new pageflow.UploaderView().render();

    this.$el.append(new pageflow.LockedView({
      model: pageflow.editLock
    }).render().el);

    this.$el.append(new pageflow.HelpView().render().el);
  },

  preventScrollingPreviewWhileFocusInSidebar: function(event) {
    if (this.scrollNavigationKeys.indexOf(event.which) >= 0) {
      event.stopPropagation();
    }
  }
});
pageflow.BackgroundImageEmbeddedView = Backbone.Marionette.View.extend({
  modelEvents: {
    'change': 'update'
  },

  render: function() {
    this.update();
    return this;
  },

  update: function() {
    this.$el.css({
      backgroundImage: this.imageValue(),
      backgroundPosition: this.model.getFilePosition(this.options.propertyName, 'x') + '% ' +
        this.model.getFilePosition(this.options.propertyName, 'y') + '%'
    });

    if (this.options.dataSizeAttributes) {
      var imageFile = this.model.getImageFile(this.options.propertyName);

      if (imageFile && imageFile.isReady()) {
        this.$el.attr('data-width',  imageFile.get('width'));
        this.$el.attr('data-height',  imageFile.get('height'));
      }
      else {
        this.$el.attr('data-width', '16');
        this.$el.attr('data-height', '9');
      }
      this.$el.css({backgroundPosition:'0 0'});
    }
  },

  imageValue: function() {
    var url = this.model.getImageFileUrl(this.options.propertyName, {
      styleGroup: this.$el.data('styleGroup')
    });

    return url ? 'url("' + url  + '")' : 'none';
  }
});
pageflow.LazyVideoEmbeddedView = Backbone.Marionette.View.extend({
  modelEvents: {
    'change': 'update'
  },

  render: function() {
    this.videoPlayer = this.$el.data('videoPlayer');

    this.videoPlayer.ready(_.bind(function() {
      this.videoPlayer.src(this.model.getVideoFileSources(this.options.propertyName));
    }, this));

    this.update();
    return this;
  },

  update: function() {
    if (this.videoPlayer.isPresent() && this.model.hasChanged(this.options.propertyName)) {
      var paused = this.videoPlayer.paused();

      this.videoPlayer.src(this.model.getVideoFileSources(this.options.propertyName));

      if (!paused) {
        this.videoPlayer.play();
      }
    }

    if (this.options.dataSizeAttributes) {
      var videoFile = this.model.getVideoFile(this.options.propertyName);

      if (videoFile && videoFile.isReady()) {
        this.$el.attr('data-width', videoFile.get('width'));
        this.$el.attr('data-height', videoFile.get('height'));
      }
      else {
        this.$el.attr('data-width', '16');
        this.$el.attr('data-height', '9');
      }
    }
  }
});
pageflow.EntryPreviewView = Backbone.Marionette.ItemView.extend({
  template: 'templates/entry_preview',
  className: 'container',

  ui: {
    header: '> .header',
    entry: '> .entry',
    overview: '> .overview'
  },

  initialize: function() {
    this.widgets = $();
    this.debouncedFetchWidgets = _.debounce(this.fetchWidgets, 200);
  },

  onRender: function() {
    this.pageViews = this.subview(new pageflow.CollectionView({
      el: this.ui.entry,
      collection: this.model.pages,
      itemViewConstructor: pageflow.PagePreviewView,
      blankSlateViewConstructor: pageflow.BlankEntryView
    }));

    this.ui.entry.append($('#indicators_seed > *'));

    this.update();

    this.listenTo(pageflow.entry, 'sync:order sync:widgets', this.update);
    this.listenTo(pageflow.entry, 'change:configuration', function() {
      pageflow.entry.once('sync', this.update, this);
    });

    this.listenTo(pageflow.storylines, 'sync', this.update);
    this.listenTo(pageflow.chapters, 'sync', this.update);
    this.listenTo(pageflow.pages, 'sync', this.update);

    this.listenTo(pageflow.audioFiles, 'sync', this.update);
    this.listenTo(pageflow.imageFiles, 'sync', this.update);
    this.listenTo(pageflow.videoFiles, 'sync', this.update);
  },

  onShow: function() {
    var slideshow = pageflow.Slideshow.setup({
      element: this.ui.entry,
      enabledFeatureNames: pageflow.entry.get('enabled_feature_names'),
      simulateHistory: true
    });

    this.listenTo(this.model.pages, 'add', function() {
      slideshow.update();
    });

    this.listenTo(this.model.pages, 'remove', function() {
      slideshow.update();
    });

    this.listenTo(this.model.pages, 'edit', function(model) {
      slideshow.goTo(this.pageViews.itemViews.findByModel(model).$el);
    });

    this.listenTo(pageflow.app, 'resize', function() {
      slideshow.triggerResizeHooks();
      this.updateSimulatedMediaQueryClasses();
    });

    this.updateSimulatedMediaQueryClasses();
  },

  updateSimulatedMediaQueryClasses: function() {
    var width = this.$el.width();
    var portrait = this.$el.width() < this.$el.height();

    $('html')
      .toggleClass('simulate_mobile', width <= 900)
      .toggleClass('simulate_phone', width <= 700)
      .toggleClass('simulate_desktop', width > 700)
      .toggleClass('simulate_narrow_desktop', width <= 1200)
      .toggleClass('simulate_wide_desktop', width > 1600)
      .toggleClass('simulate_pad_portrait', width <= 768 && portrait)
      .toggleClass('simulate_phone_portrait', width <= 500 && portrait);
  },

  update: function() {
    this.debouncedFetchWidgets();

    this.$el.toggleClass('emphasize_chapter_beginning', !!this.model.configuration.get('emphasize_chapter_beginning'));
  },

  fetchWidgets: function() {
    var view = this;

    $.ajax(this.model.url() + '/partials').success(function(response) {
      var partials = $('<div />').html(response);

      view.ui.header.replaceWith(partials.find('> .header'));
      view.ui.overview.replaceWith(partials.find('> .overview'));
      view.bindUIElements();

      view.updateWidgets(partials);

      view.ui.header.header({
        slideshow: pageflow.slides
      });
      view.ui.overview.overview();
    });
  },

  updateWidgets: function(partials) {
    var widgets = partials.find('[data-widget]');
    this.updatePresentWidgetsCssClasses(widgets);

    this.widgets.remove();
    this.widgets = widgets;
    this.ui.entry.before(this.widgets);

    pageflow.widgetTypes.enhance(this.$el);
  },

  updatePresentWidgetsCssClasses: function(newWidgets) {
    var previousClasses = this.widgetNames(this.widgets);
    var newClasses = this.widgetNames(newWidgets);

    this.$el.addClass('widgets_present');
    this.$el.removeClass(_.difference(previousClasses, newClasses).join(' '));
    this.$el.addClass(newClasses.join(' '));
  },

  widgetNames: function(widgets) {
    return widgets.map(function() {
      return 'widget_' + $(this).data('widget') + '_present';
    }).get();
  }
});
pageflow.EntryPublicationQuotaDecoratorView = Backbone.Marionette.Layout.extend({
  template: 'templates/entry_publication_quota_decorator',
  className: 'quota_decorator',

  regions: {
    outlet: '.outlet'
  },

  ui: {
    state: '.quota_state',
    exhaustedMessage: '.exhausted_message'
  },

  modelEvents: {
    'change:exceeding change:checking change:quota': 'update'
  },

  onRender: function() {
    this.model.check();
  },

  update: function() {
    var view = this;

    if (this.model.get('checking')) {
      view.ui.state.text(I18n.t('pageflow.editor.quotas.loading'));
      view.ui.exhaustedMessage.hide().html('');
      view.outlet.close();
    }
    else {
      if (view.model.get('exceeding')) {
        view.ui.state.hide();
        view.ui.exhaustedMessage.show().html(view.model.get('exhausted_html'));
        view.outlet.close();
      }
      else {
        if (view.model.quota().get('state_description')) {
          view.ui.state.text(view.model.quota().get('state_description'));
          view.ui.state.show();
        }
        else {
          view.ui.state.hide();
        }

        view.outlet.show(view.options.view);
      }
    }
  }
});
pageflow.ExplorerFileItemView = Backbone.Marionette.ItemView.extend({
  tagName: 'li',
  template: 'templates/explorer_file_item',

  mixins: [pageflow.loadable, pageflow.selectableView],

  selectionAttribute: 'file',

  ui: {
    fileName: '.file_name',

    thumbnail: '.file_thumbnail'
  },

  events: {
    'click': function() {
      if (!this.$el.hasClass('disabled')) {
        this.select();
      }
    }
  },

  modelEvents: {
    'change': 'update'
  },

  onRender: function() {
    this.update();

    this.subview(new pageflow.FileThumbnailView({
      el: this.ui.thumbnail,
      model: this.model
    }));
  },

  update: function() {
    if (this.isDisabled()) {
      this.$el.addClass('disabled');
    }

    this.$el.attr('data-id', this.model.id);
    this.ui.fileName.text(this.model.get('file_name') || '(Unbekannt)');
  },

  isDisabled: function() {
    return (this.options.disabledIds && _.contains(this.options.disabledIds, this.model.get('id')));
  }
});
pageflow.FileMetaDataItemView = Backbone.Marionette.ItemView.extend({
  tagName: 'tr',
  template: 'templates/file_meta_data_item',

  ui: {
    label: 'th',
    value: 'td'
  },

  onRender: function() {
    this.update();
    this.listenTo(this.model, 'change:' + this.options.attribute, this.update);
  },

  update: function() {
    this.ui.label.text(I18n.t('activerecord.attributes.' + this.model.i18nKey + '.' + this.options.attribute));
    this.ui.value.text(this.model.get(this.options.attribute));
  }
});
pageflow.FileStageItemView = Backbone.Marionette.ItemView.extend({
  tagName: 'li',
  className: 'file_stage_item',
  template: 'templates/file_stage_item',

  ui: {
    description: '.description',
    percent: '.percent',
    errorMessage: '.error_message'
  },

  modelEvents: {
    'change': 'update'
  },

  onRender: function() {
    this.update();
    this.$el.addClass(this.model.get('name'));
  },

  update: function() {
    this.ui.description.text(this.model.localizedDescription());

    if (typeof this.model.get('progress') === 'number' &&
        this.model.get('active')) {
      this.ui.percent.text(this.model.get('progress') + '%');
    }
    else {
      this.ui.percent.text('');
    }

    this.ui.errorMessage
      .toggle(!!this.model.get('error_message'))
      .text(this._translatedErrorMessage());

    this.$el.toggleClass('active', this.model.get('active'));
    this.$el.toggleClass('finished', this.model.get('finished'));
    this.$el.toggleClass('failed', this.model.get('failed'));
    this.$el.toggleClass('action_required', this.model.get('action_required'));
  },

  _translatedErrorMessage: function() {
    return this.model.get('error_message') &&
      I18n.t(this.model.get('error_message'), {
        defaultValue: this.model.get('error_message')
      });
  }
});
pageflow.FileThumbnailView = Backbone.Marionette.ItemView.extend({
  className: 'file_thumbnail',
  template: 'templates/file_thumbnail',

  modelEvents: {
    'change:state': 'update'
  },

  ui: {
    pictogram: '.pictogram'
  },

  onRender: function() {
    this.update();
  },

  update: function() {
    if (this.model) {
      var stage = this.model.currentStage();

      if (stage) {
        this.setStageClassName(stage.get('name'));
        this.ui.pictogram.toggleClass('action_required', stage.get('action_required'));
        this.ui.pictogram.toggleClass('failed', stage.get('failed'));
      }
      else {
        this.ui.pictogram.removeClass(this.model.stages.pluck('name').join(' '));
      }

      this.ui.pictogram.addClass(this.model.thumbnailPictogram);
      this.$el.css('background-image', this._imageUrl() ? 'url(' + this._imageUrl() + ')' : '');
      this.$el
        .removeClass('empty')
        .toggleClass('always_picogram', !!this.model.thumbnailPictogram)
        .toggleClass('ready', this.model.isReady());
    }
    else {
      this.$el.css('background-image', '');
      this.$el.removeClass('ready');
      this.ui.pictogram.addClass('empty');
    }
  },

  setStageClassName: function(name) {
    if (!this.$el.hasClass(name)) {
      this.ui.pictogram.removeClass('empty');
      this.ui.pictogram.removeClass(this.model.stages.pluck('name').join(' '));
      this.ui.pictogram.addClass(name);
    }
  },

  _imageUrl: function() {
    return this.model.get(this.options.imageUrlPropertyName || 'thumbnail_url');
  }
});
pageflow.FilesExplorerView = Backbone.Marionette.ItemView.extend({
  template: 'templates/files_explorer',
  className: 'files_explorer editor dialog',

  mixins: [pageflow.dialogView],

  ui: {
    entriesPanel: '.entries_panel',
    filesPanel: '.files_panel',
    okButton: '.ok'
  },

  events: {
    'click .ok': function() {
      if (this.options.callback) {
        this.options.callback(this._selectedFile());
      }
      this.close();
    }
  },

  initialize: function() {
    this.selection = new Backbone.Model();
    this.listenTo(this.selection, 'change:entry', function() {
      this.tabsView.refresh();
    });

    // check if the OK button should be enabled.
    this.listenTo(this.selection, 'change', function(selection, options) {
      this.ui.okButton.prop('disabled', !this._selectedFile());
    });
  },

  onRender: function() {
    this.subview(new pageflow.OtherEntriesCollectionView({
      el: this.ui.entriesPanel,
      selection: this.selection
    }));

    this.tabsView = new pageflow.TabsView({
      model: this.model,
      i18n: 'pageflow.editor.files.tabs',
      defaultTab: this.options.tabName
    });

    pageflow.editor.fileTypes.each(function(fileType) {
      this.tab(fileType);
    }, this);

    this.ui.filesPanel.append(this.subview(this.tabsView).el);

    this.ui.okButton.prop('disabled', true);
  },

  tab: function(fileType) {
    this.tabsView.tab(fileType.collectionName, _.bind(function() {
      var collection = this._collection(fileType);
      var disabledIds = pageflow.entry.getFileCollection(fileType).pluck('id');

      return new pageflow.CollectionView({
        tagName: 'ul',
        className: 'files_gallery',
        collection: collection,
        itemViewConstructor: pageflow.ExplorerFileItemView,
        itemViewOptions: {
          selection: this.selection,
          disabledIds: disabledIds
        },
        blankSlateViewConstructor: this._blankSlateConstructor()
      });
    }, this));
  },

  _collection: function(fileType) {
    var collection,
        entry = this.selection.get('entry');

    if (entry) {
      collection = entry.getFileCollection(fileType);
      collection.fetch();
    } else {
      collection = new Backbone.Collection();
    }
    return collection;
  },

  _blankSlateConstructor: function() {
    return Backbone.Marionette.ItemView.extend({
      template: this.selection.get('entry') ? 'templates/files_gallery_blank_slate' : 'templates/files_explorer_blank_slate'
    });
  },

  _selectedFile: function() {
    return this.selection.get('file');
  }
});

pageflow.FilesExplorerView.open = function(options) {
  pageflow.app.dialogRegion.show(new pageflow.FilesExplorerView(options));
};
pageflow.FilesView = Backbone.Marionette.ItemView.extend({
  template: 'templates/files',
  className: 'manage_files',

  events: {
    'click a.back': 'goBack',

    'file-selected': 'updatePage'
  },

  onRender: function() {
    this.addFileModel = new Backbone.Model({
      label: I18n.t('pageflow.editor.views.files_view.add'),
      options: [
        {
          label: I18n.t('pageflow.editor.views.files_view.upload'),
          handler: this.upload.bind(this)
        },
        {
          label: I18n.t('pageflow.editor.views.files_view.reuse'),
          handler: function() {
            pageflow.FilesExplorerView.open({
              callback: pageflow.entry.addFileUsage.bind(pageflow.entry)
            });
          }
        }
      ]
    });

    this.$el.append(this.subview(new pageflow.SelectButtonView({model: this.addFileModel })).el);

    this.tabsView = new pageflow.TabsView({
      model: this.model,
      i18n: 'pageflow.editor.files.tabs',
      defaultTab: this.options.tabName
    });

    pageflow.editor.fileTypes.each(function(fileType) {
      this.tab(fileType);
    }, this);

    this.$el.append(this.subview(this.tabsView).el);
  },

  tab: function(fileType) {
    this.tabsView.tab(fileType.collectionName, _.bind(function() {
      return this.subview(new pageflow.CollectionView({
        tagName: 'ul',
        className: 'files expandable',
        collection: pageflow.entry.getFileCollection(fileType),
        itemViewConstructor: pageflow.FileItemView,
        itemViewOptions: {
          metaDataAttributes: fileType.metaDataAttributes,
          selectionHandler: this.options.tabName === fileType.collectionName && this.options.selectionHandler
        },
        blankSlateViewConstructor: Backbone.Marionette.ItemView.extend({
          template: 'templates/files_blank_slate'
        })
      }));
    }, this));

    this.listenTo(this.model, 'change:uploading_' + fileType.collectionName +'_count', function(model, value) {
      this.tabsView.toggleSpinnerOnTab(fileType.collectionName, value > 0);
    });
  },

  goBack: function() {
    if (this.options.selectionHandler) {
      editor.navigate(this.options.selectionHandler.getReferer(), {trigger: true});
    }
    else {
      editor.navigate('/', {trigger: true});
    }
  },

  upload: function() {
    pageflow.app.trigger('request-upload');
  }
});
pageflow.HelpButtonView = Backbone.Marionette.ItemView.extend({
  template: 'templates/help_button',
  className: 'help_button',

  events: {
    'click': function() {
      pageflow.app.trigger('toggle-help');
    }
  }
});
pageflow.HelpView = Backbone.Marionette.ItemView.extend({
  template: 'templates/help',
  className: 'help',

  ui: {
    placeholder: '.placeholder',
    sections: 'section',
    menuItems: 'li'
  },

  events: {
    'click .close': function() {
      this.toggle();
    },

    'click .expandable > a': function(event) {
      $(event.currentTarget).parents('.expandable').toggleClass('expanded');
    },

    'click a': function(event) {
      var link = $(event.currentTarget);

      if (link.attr('href').indexOf('#') === 0) {
        this.showSection(link.attr('href').substring(1),
                         {scrollIntoView: !link.parents('nav').length});
      }

      return false;
    },

    'click .box': function() {
      return false;
    },

    'click': function() {
      this.toggle();
    }
  },

  initialize: function() {
    this.listenTo(pageflow.app, 'toggle-help', function(name) {
      this.toggle();
      this.showSection(name ||
                       pageflow.editor.defaultHelpEntry ||
                       this.defaultHelpEntry(),
                       {scrollIntoView: true});
    });
  },

  onRender: function() {
    this.ui.placeholder.replaceWith($('#help_entries_seed').html());
    this.bindUIElements();
  },

  toggle: function() {
    this.$el.toggle();
  },

  defaultHelpEntry: function() {
    return this.ui.sections.first().data('name');
  },

  showSection: function(name, options) {
    this.ui.menuItems.each(function() {
      var menuItem = $(this);
      var active = (menuItem.find('a').attr('href') === '#' + name);
      menuItem.toggleClass('active', active);

      if (active) {
        menuItem.parents('.expandable').addClass('expanded');

        if (options.scrollIntoView) {
          menuItem[0].scrollIntoView();
        }
      }
    });

    this.ui.sections.each(function() {
      var section = $(this);
      section.toggle(section.data('name') === name);
    });
  }
});
pageflow.PageLinkInputView = pageflow.ReferenceInputView.extend({
  choose: function() {
    return pageflow.editor.selectPage({
      isAllowed: this.options.isAllowed
    });
  },

  getTarget: function(permaId) {
    return pageflow.pages.getByPermaId(permaId);
  }
});
/** @api private */

pageflow.ListItemView = Backbone.Marionette.ItemView.extend({
  template: 'pageflow/editor/templates/list_item',

  tagName: 'li',
  className: 'list_item',

  ui: {
    thumbnail: '.list_item_thumbnail',
    typePictogram: '.list_item_type_pictogram',
    title: '.list_item_title',
    description: '.list_item_description',
    editButton: '.list_item_edit_button',
    removeButton: '.list_item_remove_button'
  },

  events: {
    'click .list_item_edit_button': function() {
      this.options.onEdit(this.model);
      return false;
    },

    'click .list_item_remove_button': function() {
      this.options.onRemove(this.model);
      return false;
    },

    'mouseenter': function() {
      if (this.options.highlight) {
        this.model.highlight();
      }
    },

    'mouseleave': function() {
      if (this.options.highlight) {
        this.model.resetHighlight();
      }
    }
  },

  modelEvents: {
    'change': 'update'
  },

  onRender: function() {
    this.subview(new pageflow.ModelThumbnailView({
      el: this.ui.thumbnail,
      model: this.model
    }));

    if (this.options.typeName) {
      this.$el.addClass(this.typeName());
    }

    this.ui.editButton.toggleClass('is_available', !!this.options.onEdit);
    this.ui.removeButton.toggleClass('is_available', !!this.options.onRemove);

    this.update();
  },

  update: function() {
    this.ui.typePictogram.attr('title', this.typeDescription());

    this.ui.title.text(this.model.title() || I18n.t('pageflow.editor.views.page_link_item_view.unnamed'));

    this.ui.description.text(this.description());
    this.ui.description.toggle(!!this.description());

    this.$el.toggleClass('is_invalid', !!this.getOptionResult('isInvalid'));
  },

  onClose: function() {
    if (this.options.highlight) {
      this.model.resetHighlight();
    }
  },

  description: function() {
    return this.getOptionResult('description');
  },

  typeName: function() {
    return this.getOptionResult('typeName');
  },

  typeDescription: function() {
    return this.getOptionResult('typeDescription');
  },

  getOptionResult: function(name) {
    return typeof this.options[name]  === 'function' ?
      this.options[name](this.model) :
      this.options[name];
  }
});
/**
 * A generic list view with items consisting of a thumbnail, text and
 * possibly some buttons or a navigation arrow.
 *
 * Models inside the collection must implement the following methods:
 *
 * - `title` - A text for the list item.
 * - `thumbnailFile` - The file to use as thumbnail for the list item.
 *
 * @option collection [Backbone.Collection]
 * @option highlight [Boolean]
 * @option sortable [Boolean]
 * @option label [String]
 * @option itemDescription [String|Function]
 * @option itemTypeName [String|Function]
 * @option itemTypeDescription [String|Function]
 * @option itemIsInvalid [String|Function]
 * @option onEdit [Function]
 * @option onRemove [Function]
 */

pageflow.ListView = Backbone.Marionette.ItemView.extend({
  template: 'pageflow/editor/templates/list',
  className: 'list',

  ui: {
    label: '.list_label',
    items: '.list_items'
  },

  onRender: function() {
    var collectionViewConstructor = this.options.sortable ?
      pageflow.SortableCollectionView :
      pageflow.CollectionView;

    this.subview(new collectionViewConstructor({
      el: this.ui.items,
      collection: this.collection,

      itemViewConstructor: pageflow.ListItemView,

      itemViewOptions: _.extend({
        description: this.options.itemDescription,
        typeName: this.options.itemTypeName,
        typeDescription: this.options.itemTypeDescription,
        isInvalid: this.options.itemIsInvalid
      }, _(this.options).pick('onEdit', 'onDelete', 'highlight')),

      blankSlateViewConstructor: Backbone.Marionette.ItemView.extend({
        tagName: 'li',
        className: 'list_blank_slate',
        template: 'pageflow/editor/templates/list_blank_slate'
      })
    }));

    this.ui.label.text(this.options.label);

    this.$el.toggleClass('with_type_pictogram', !!this.options.itemTypeName);
  }
});
pageflow.LoadingView = Backbone.Marionette.ItemView.extend({
  template: 'pageflow/editor/templates/loading',
  className: 'loading',
  tagName: 'li'
});
pageflow.LockedView = Backbone.Marionette.ItemView.extend({
  template: 'templates/locked',
  className: 'locked checking',

  ui: {
    breakButton: '.break',
    message: '.error .message'
  },

  events: {
    'click .close': 'goBack',

    'click .break': 'breakLock'
  },

  modelEvents: {
    acquired: 'hide',

    locked: 'show',

    unauthenticated: 'goBack'
  },

  breakLock: function() {
    this.model.acquire({force: true});
  },

  goBack: function() {
    window.location = "/admin/entries/" + pageflow.entry.id;
  },

  show: function(info, options) {
    var key = info.error + '.' + options.context;

    this.ui.message.html(I18n.t('pageflow.edit_locks.errors.' + key + '_html', {user_name: info.held_by}));
    this.ui.message.attr('data-error', key);

    this.ui.breakButton.text(I18n.t('pageflow.edit_locks.break_action.acquire'));

    this.$el.removeClass('checking');
    this.$el.show();
  },

  hide: function() {
    this.ui.message.attr('data-error', null);

    this.$el.removeClass('checking');
    this.$el.hide();
  }
});
pageflow.NavigatableChapterItemView = pageflow.ChapterItemView.extend({
  mixins: [pageflow.loadable, pageflow.failureIndicatingView],

  events: {
    'click a.add_page': function() {
      this.model.addPage();
    },

    'click a.edit_chapter': function() {
      if (!this.model.isNew() && !this.model.isDestroying()) {
        editor.navigate('/chapters/' + this.model.get('id'), {trigger: true});
      }
      return false;
    }
  }
});
pageflow.NavigatablePageItemView = pageflow.PageItemView.extend({
  mixins: [pageflow.loadable, pageflow.failureIndicatingView],
  className: 'draggable',

  events: {
    'click': function() {
      if (!this.model.isNew() && !this.model.isDestroying()) {
        editor.navigate('/pages/' + this.model.get('id'), {trigger: true});
      }
      return false;
    }
  }
});
pageflow.NotificationsView = Backbone.Marionette.ItemView.extend({
  className: 'notifications',
  tagName: 'ul',
  template: 'templates/notifications',

  ui: {
    failedCount: '.failed .count',
    uploadingCount: '.uploading .count',
    confirmableFilesCount: '.confirmable_files .count',
  },

  events: {
    'click .retry': function() {
      pageflow.editor.failures.retry();
    }
  },

  onRender: function() {
    this.listenTo(pageflow.entry, 'change:uploading_files_count', this.notifyUploadCount);
    this.listenTo(pageflow.entry, 'change:confirmable_files_count', this.notifyConfirmableFilesCount);

    this.listenTo(pageflow.savingRecords, 'add', this.update);
    this.listenTo(pageflow.savingRecords, 'remove', this.update);

    this.listenTo(pageflow.editor.failures, 'add', this.update);
    this.listenTo(pageflow.editor.failures, 'remove', this.update);

    this.update();
    this.notifyConfirmableFilesCount();
  },

  update: function() {
    this.$el.toggleClass('failed', !pageflow.editor.failures.isEmpty());
    this.$el.toggleClass('saving', !pageflow.savingRecords.isEmpty());
    this.ui.failedCount.text(pageflow.editor.failures.count());
  },

  notifyUploadCount: function(model, uploadCount) {
    this.$el.toggleClass('uploading', uploadCount > 0);
    this.ui.uploadingCount.text(uploadCount);
  },

  notifyConfirmableFilesCount: function() {
    var confirmableFilesCount = pageflow.entry.get('confirmable_files_count');

    this.$el.toggleClass('has_confirmable_files', confirmableFilesCount > 0);
    this.ui.confirmableFilesCount.text(confirmableFilesCount);
  }
});
pageflow.OtherEntriesCollectionView = Backbone.Marionette.View.extend({
  initialize: function() {
    this.otherEntries = new pageflow.OtherEntriesCollection();

    this.listenTo(this.otherEntries, 'sync', function() {
      if (this.otherEntries.length === 1) {
        this.options.selection.set('entry', this.otherEntries.first());
      }
    });
  },

  render: function() {
    this.subview(new pageflow.CollectionView({
      el: this.el,
      collection: this.otherEntries,
      itemViewConstructor: pageflow.OtherEntryItemView,
      itemViewOptions: {
        selection: this.options.selection
      },
      blankSlateViewConstructor: Backbone.Marionette.ItemView.extend({
        template: 'templates/other_entries_blank_slate',
        tagName: 'li',
        className: 'blank_slate'
      }),
      loadingViewConstructor: pageflow.LoadingView
    }));

    this.otherEntries.fetch();

    return this;
  }
});
pageflow.OtherEntryItemView = Backbone.Marionette.ItemView.extend({
  template: 'templates/other_entry_item',
  className: 'other_entry_item',
  tagName: 'li',

  mixins: [pageflow.selectableView],

  ui: {
    title: '.title'
  },

  events: {
    'click': 'select'
  },

  onRender: function() {
    this.ui.title.text(this.model.titleOrSlug());
  }
});
pageflow.PageLinkConfigurationEditorView = pageflow.ConfigurationEditorView.extend({
  configure: function() {
    this.tab('general', function() {
      this.group('page_link');
    });
  }
});
pageflow.PageLinkItemView = Backbone.Marionette.ItemView.extend({
  template: 'pageflow/editor/templates/page_link_item',

  tagName: 'li',
  className: 'page_link',

  ui: {
    thumbnail: '.page_thumbnail',
    title: '.title',
    label: '.label',
    editButton: '.edit',
    removeButton: '.remove'
  },

  events: {
    'click .edit': function() {
      pageflow.editor.navigate(this.model.editPath(), {trigger: true});
      return false;
    },

    'mouseenter': function() {
      this.model.highlight(true);
    },

    'mouseleave': function() {
      this.model.resetHighlight(false);
    },

    'click .remove': function() {
      if (confirm(I18n.t('pageflow.internal_links.editor.views.edit_page_link_view.confirm_destroy'))) {
        this.model.remove();
      }
    }
  },

  onRender: function() {
    var page = this.model.targetPage();

    if (page) {
      this.subview(new pageflow.PageThumbnailView({
        el: this.ui.thumbnail,
        model: page
      }));

      this.$el.addClass(page.get('template'));
      this.ui.title.text(page.title() || I18n.t('pageflow.editor.views.page_link_item_view.unnamed'));
    }
    else {
      this.ui.title.text(I18n.t('pageflow.editor.views.page_link_item_view.no_page'));
    }

    this.ui.label.text(this.model.label());
    this.ui.label.toggle(!!this.model.label());
    this.ui.editButton.toggle(!!this.model.editPath());

    this.$el.toggleClass('dangling', !page);
  },
});
pageflow.PageLinksView = Backbone.Marionette.ItemView.extend({
  template: 'pageflow/editor/templates/page_links',
  className: 'page_links',

  ui: {
    links: 'ul.links',
    addButton: '.add_link'
  },

  events: {
    'click .add_link': function() {
      var view = this;

      pageflow.editor.selectPage().then(function(page) {
        view.model.pageLinks().addLink(page.get('perma_id'));
      });

      return false;
    }
  },

  onRender: function() {
    var pageLinks = this.model.pageLinks();
    var collectionViewConstructor = pageLinks.saveOrder ? pageflow.SortableCollectionView : pageflow.CollectionView;

    this.subview(new collectionViewConstructor({
      el: this.ui.links,
      collection: pageLinks,
      itemViewConstructor: pageflow.PageLinkItemView,
      itemViewOptions: {
        pageLinks: pageLinks
      }
    }));

    this.listenTo(pageLinks, 'add remove', function() {
      this.updateAddButton(pageLinks);
    });

    this.updateAddButton(pageLinks);
  },

  updateAddButton: function(pageLinks) {
    this.ui.addButton.css('display', pageLinks.canAddLink() ? 'inline-block' : 'none');
  }
});
pageflow.PagePreviewView = Backbone.Marionette.View.extend({
  tagName: 'section',
  className: 'page',

  modelEvents: {
    'change:template': 'updateTemplate',

    'change:configuration': 'update',

    'change:position': 'updateChapterBeginningClass',

    'change:id': function() {
      this.$el.attr('data-id', this.model.id);
      this.$el.attr('data-perma-id', this.model.get('perma_id'));
      this.$el.attr('id', this.model.get('perma_id'));
    }
  },

  events: {
    pageactivate: function() {
      this.model.set('active', true);
    },

    pagedeactivate: function() {
      this.model.set('active', false);
    }
  },

  render: function() {
    this.$el.html(this.pageTemplate());

    this.$el.attr('data-id', this.model.id);
    this.$el.attr('data-perma-id', this.model.get('perma_id'));
    this.$el.attr('id', this.model.get('perma_id'));
    this.$el.attr('data-chapter-id', this.model.get('chapter_id'));

    this.$el.data('template', this.model.get('template'));
    this.$el.data('configuration', this.model.get('configuration'));

    this.$el.on('pageenhanced', _.bind(function() {
      this.update();
      this.initEmbeddedViews();

      this.$el.page('reactivate');
    }, this));

    return this;
  },

  updateTemplate: function() {
    this.$el.page('cleanup');

    this.$el.html(this.pageTemplate());
    this.$el.data('template', this.model.get('template'));

    this.$el.page('reinit');
  },

  update: function() {
    this.$el.page('update', this.model.configuration);

    pageflow.events.trigger('page:update', this.model);

    this.refreshScroller();
    this.ensureTargetBlankForContentLinks();
    this.updateChapterBeginningClass();
  },

  updateChapterBeginningClass: function() {
    var chapterBeginning = this.model.get('position') === 0;
    this.$el.toggleClass('chapter_beginning', chapterBeginning);
  },

  pageTypeHooks: function() {
    return pageflow.pageType.get(this.model.get('template'));
  },

  pageTemplate: function() {
    return this._unescape($('script[data-template="' + this.model.get('template') + '_page"]').html());
  },

  refreshScroller: function() {
    this.$el.page('refreshScroller');
  },

  ensureTargetBlankForContentLinks: function() {
    pageflow.links.ensureTargetBlankForContentLinks(this.el);
  },

  initEmbeddedViews: function() {
    var view = this;

    if (view.embeddedViews) {
      view.embeddedViews.call('close');
    }

    view.embeddedViews = new Backbone.ChildViewContainer();

    _.each(view.embeddedViewDefinitions(), function(item, selector) {
      view.$(selector).each(function() {
        view.embeddedViews.add(new item.view(_.extend(item.options || {}, {
          el: this,
          model: view.model.configuration,
          container: view
        })).render());
      });
    });
  },

  embeddedViewDefinitions: function() {
    return _.extend(
      {},
      this.pageTypeHooks().embeddedEditorViews() || {},
      this.model.pageType().embeddedViews()
    );
  },

  _unescape: function(text) {
    return $('<div/>').html(text).text();
  }
});
pageflow.PageSelectionView = Backbone.Marionette.ItemView.extend({
  template: 'templates/page_selection',
  className: 'page_selection dialog',

  mixins: [pageflow.dialogView],

  ui: {
    storylines: '.storyline_picker',
    chapters: '.chapters',
  },

  events: {
    'click ul.pages li': function(event) {
      this.options.onSelect(pageflow.pages.get($(event.currentTarget).data('id')));
      this.close();
    }
  },

  onRender: function() {
    var options = this.options;

    this.subview(new pageflow.StorylinePickerView({
      el: this.ui.storylines,
      pageItemViewOptions: {
        isDisabled: function(page) {
          return options.isAllowed && !options.isAllowed(page);
        }
      }
    }));
  }
});

pageflow.PageSelectionView.selectPage = function(options) {
  return $.Deferred(function(deferred) {
    var view = new pageflow.PageSelectionView({
      model: pageflow.entry,
      onSelect: deferred.resolve,
      isAllowed: options && options.isAllowed
    });

    view.on('close', function() {
      deferred.reject();
    });

    pageflow.app.dialogRegion.show(view.render());
  }).promise();
};
pageflow.PageThumbnailView = pageflow.ModelThumbnailView.extend({
  className: 'model_thumbnail page_thumbnail'
});
pageflow.PublishEntryView = Backbone.Marionette.ItemView.extend({
  template: 'templates/publish_entry',
  className: 'publish_entry',

  ui: {
    publishUntilFields: '.publish_until_fields',
    publishUntilField: 'input[name=publish_until]',
    publishUntilTimeField: 'input[name=publish_until_time]',
    publishUntilRadioBox: '#publish_entry_until',
    publishForeverRadioBox: 'input[value=publish_forever]',
    passwordProtectedCheckBox: 'input[name=password_protected]',
    passwordFields: '.password_fields',
    userNameField: 'input[name=user_name]',
    passwordField: 'input[name=password]',
    alreadyPublishedWithPassword: '.already_published_with_password',
    previouslyPublishedWithPassword: '.previously_published_with_password',
    alreadyPublishedWithoutPassword: '.already_published_without_password',
    revisionsLink: '.published.notice a',
    publishedNotice: '.published.notice',
    saveButton: 'button.save',
    successNotice: '.success',
    successLink: '.success a'
  },

  events: {
    'click button.save': 'save',

    'click input#publish_entry_forever': 'enablePublishForever',

    'click input#publish_entry_until': 'enablePublishUntilFields',

    'focus .publish_until_fields input':  'enablePublishUntilFields',

    'change .publish_until_fields input':  'checkForm',

    'click input#publish_password_protected': 'togglePasswordFields',

    'keyup input[name=password]': 'checkForm',

    'change input[name=password]': 'checkForm'
  },

  modelEvents: {
    'change': 'update',

    'change:published': function(model, value) {
      if (value) {
        this.ui.publishedNotice.effect('highlight', {
          duration: 'slow'
        });
      }
    }
  },

  onRender: function() {
    this.ui.publishUntilField.datepicker({
      dateFormat: 'dd.mm.yy',
      constrainInput: true,
      defaultDate: new Date(),
      minDate: new Date()
    });

    this.update();
  },

  update: function() {
    this.$el.toggleClass('files_pending', this.model.get('uploading_files_count') > 0 || this.model.get('pending_files_count') > 0);
    this.$el.toggleClass('published', this.model.get('published'));

    this.ui.revisionsLink.attr('href', '/admin/entries/' + this.model.id);
    this.ui.successLink.attr('href', this.model.get('pretty_url'));
    this.ui.successLink.text(this.model.get('pretty_url'));

    var publishedUntil = new Date(this.model.get('published_until'));
    if (publishedUntil > new Date()) {
      this.ui.publishUntilField.datepicker('setDate', publishedUntil);
      this.ui.publishUntilTimeField.val(timeStr(publishedUntil));
    }
    else {
      this.ui.publishUntilField.datepicker('setDate', oneYearFromNow());
    }

    this.ui.userNameField.val(pageflow.account.get('name'));

    if (this.model.get('password_protected')) {
      this.ui.passwordProtectedCheckBox.prop('checked', true);
      this.togglePasswordFields();
    }
    else {
      this.ui.passwordField.val(this.randomPassword());
    }

    this.ui.alreadyPublishedWithPassword.toggle(this.model.get('published') && this.model.get('password_protected'));
    this.ui.previouslyPublishedWithPassword.toggle(!this.model.get('published') && this.model.get('password_protected'));
    this.ui.alreadyPublishedWithoutPassword.toggle(this.model.get('published') && !this.model.get('password_protected'));

    // Helpers
    function timeStr(date) {
      return twoDigits(date.getHours()) + ':' + twoDigits(date.getMinutes());

      function twoDigits(val) {
        return ("0" + val).slice(-2);
      }
    }

    function oneYearFromNow() {
      var date = new Date();
      date.setFullYear(date.getFullYear() + 1);
      return date;
    }
  },

  save: function() {
    var publishedUntil = null;

    if (this.$el.hasClass('publishing')) {
      return;
    }

    if (this.ui.publishUntilRadioBox.is(':checked')) {
      publishedUntil = this.ui.publishUntilField.datepicker('getDate');
      setTime(publishedUntil, this.ui.publishUntilTimeField.val());

      if (!this.checkPublishUntilTime()) {
        alert('Bitte legen Sie einen gültigen Depublikationszeitpunkt fest.');
        this.ui.publishUntilTimeField.focus();
        return;
      }

      if (!publishedUntil || !checkDate(publishedUntil)) {
        alert('Bitte legen Sie ein Depublikationsdatum fest.');
        this.ui.publishUntilField.focus();
        return;
      }
    }

    var that = this;

    this.options.entryPublication.publish({
      published_until: publishedUntil,
      password_protected: this.ui.passwordProtectedCheckBox.is(':checked'),
      password: this.ui.passwordField.val()
    })
      .fail(function() {
        alert('Beim Veröffentlichen ist ein Fehler aufgetreten');
      })
      .always(function() {
        if (that.isClosed) { return; }

        that.$el.removeClass('publishing');
        that.$el.addClass('succeeded');
        that.$('input').removeAttr('disabled');

        var publishedMessage = that.options.entryPublication.get('published_message_html');
        if (publishedMessage) {
          that.ui.successNotice.append(publishedMessage);
        }

        that.enableSave();
      });

    this.$el.addClass('publishing');
    this.$('input').attr('disabled', '1');
    this.disableSave();

    // Helpers
    function setTime(date, time) {
      date.setHours.apply(date, parseTime(time));
    }

    function parseTime(str) {
      return str.split(':').map(function(number) { return parseInt(number, 10); });
    }

    function checkDate(date) {
      if ( Object.prototype.toString.call(date) === "[object Date]" ) {
        if ( isNaN( date.getTime() ) ) {
          return false;
        }
        return true;
      }
      return false;
    }
  },

  enableSave: function() {
    this.ui.saveButton.removeAttr('disabled');
  },

  disableSave: function() {
    this.ui.saveButton.attr('disabled', true);
  },

  enablePublishUntilFields: function() {
    this.ui.publishForeverRadioBox[0].checked = false;
    this.ui.publishUntilRadioBox[0].checked = true;

    this.ui.publishUntilFields.removeClass('disabled');
    this.checkForm();
  },

  disablePublishUntilFields: function() {
    this.ui.publishUntilRadioBox[0].checked = false;
    this.ui.publishUntilFields.addClass('disabled');
    this.checkForm();

    if (!this.checkPublishUntilTime()) {
      this.ui.publishUntilTimeField.val('00:00');
    }

    this.ui.publishUntilTimeField.removeClass('invalid');
    this.ui.publishUntilField.removeClass('invalid');
  },

  enablePublishForever: function() {
    this.disablePublishUntilFields();
    this.ui.publishForeverRadioBox[0].checked = true;
    this.enableSave();
  },

  checkForm: function() {
    if (_.all([this.checkPublishUntil(), this.checkPassword()])) {
      this.enableSave();
    }
    else{
      this.disableSave();
    }
  },

  checkPublishUntil: function() {
    return (this.ui.publishForeverRadioBox.is(':checked') ||
      (this.ui.publishUntilRadioBox.is(':checked') &&
       _.all([this.checkPublishUntilDate(),
              this.checkPublishUntilTime()])));
  },

  checkPublishUntilDate: function() {
    if (this.ui.publishUntilField.datepicker('getDate')) {
      this.ui.publishUntilField.removeClass('invalid');
      return true;
    }
    else {
      this.ui.publishUntilField.addClass('invalid');
      return false;
    }
  },

  checkPublishUntilTime: function() {
    if (!this.ui.publishUntilTimeField.val().match(/^([01]?[0-9]|2[0-3]):[0-5][0-9]$/)) {
      this.ui.publishUntilTimeField.addClass('invalid');
      return false;
    }
    this.ui.publishUntilTimeField.removeClass('invalid');
    return true;
  },

  togglePasswordFields: function() {
    this.ui.passwordFields.toggleClass('disabled', !this.ui.passwordProtectedCheckBox.is(':checked'));
    this.checkForm();
  },

  checkPassword: function() {
    if (this.ui.passwordField.val().length === 0 &&
        !this.model.get('password_protected') &&
        this.ui.passwordProtectedCheckBox.is(':checked')) {
      this.ui.passwordField.addClass('invalid');
      return false;
    }
    else {
      this.ui.passwordField.removeClass('invalid');
      return true;
    }
  },

  randomPassword: function() {
    var possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";

    return _(10).times(function() {
      return possible.charAt(Math.floor(Math.random() * possible.length));
    }).join('');
  }
});

pageflow.PublishEntryView.create = function(options) {
  return new pageflow.BackButtonDecoratorView({
    view: new pageflow.EntryPublicationQuotaDecoratorView({
      model: options.entryPublication,
      view: new pageflow.PublishEntryView(options)
    })
  });
};
pageflow.ScrollingView = Backbone.Marionette.View.extend({

  events: {
    scroll: function() {
      if (this._isChapterView()) {
        this.scrollpos = this.$el.scrollTop();
      }
    }
  },

  initialize: function() {
    this.scrollpos = 0;

    this.listenTo(this.options.region, 'show', function() {
      if (this._isChapterView()) {
        this.$el.scrollTop(this.scrollpos);
      }
    });
  },

  _isChapterView: function() {
    return !Backbone.history.getFragment();
  }
});
pageflow.SelectButtonView = Backbone.Marionette.ItemView.extend({
  template: 'templates/select_button',
  className: 'select_button',

  ui: {
    button: 'button',
    label: 'button .label',
    menu: '.dropdown-menu',
    dropdown: '.dropdown'
  },

  events: {
    'click .dropdown-menu li': function(e, x) {
      e.preventDefault();
      var index = getClickedIndex(e.target);

      this.model.get('options')[index].handler();

      function getClickedIndex(target) {
        var $target = $(target),
            index = parseInt($target.data('index'), 10);

        if (isNaN(index)) {
          index = parseInt($target.find('a').data('index'), 10);
        }

        return index;
      }
    }
  },

  onRender: function() {
    this.ui.label.text(this.model.get('label'));
    this.model.get('options').forEach(this.addOption.bind(this));
  },

  addOption: function(option, index) {
    this.ui.menu.append('<li><a href="#" data-index="'+ index +'">' + option.label + '</a></li>');
  }
});
pageflow.StorylineOutlineView = Backbone.Marionette.Layout.extend({
  template: 'templates/storyline_outline',
  className: 'storyline_outline',

  ui: {
    chapters: 'ul.storyline_outline_chapters'
  },

  events: {
    'click a.add_chapter': function() {
      this.model.scaffoldChapter();
    }
  },

  onRender: function() {
    this.ui.chapters.toggleClass('outline navigatable', !!this.options.navigatable);

    var collectionView = this.options.sortable ? pageflow.SortableCollectionView : pageflow.CollectionView;

    new collectionView({
      el: this.ui.chapters,
      collection: this.model.chapters,
      itemViewConstructor: this.options.navigatable ? pageflow.NavigatableChapterItemView : pageflow.ChapterItemView,
      itemViewOptions: {
        sortable: this.options.sortable,
        pageItemView: this.options.navigatable ? pageflow.NavigatablePageItemView : pageflow.PageItemView,
        pageItemViewOptions: _.extend({
          displayInNavigationHint: this.options.displayInNavigationHint
        }, this.options.pageItemViewOptions || {})
      }
    }).render();
  }
});
pageflow.StorylinePickerView = Backbone.Marionette.Layout.extend({
  template: 'templates/storyline_picker',
  className: 'storyline_picker',

  regions: {
    selectRegion: '.storyline_picker_select_region',
    mainRegion: '.storyline_picker_main_region'
  },

  ui: {
    storylines: '.storyline_picker_storylines'
  },

  events: {
    'click .add_storyline': function() {
      var storyline = pageflow.entry.scaffoldStoryline({
        depth: 'page'
      }).storyline;

      this.listenToOnce(storyline, 'sync', function() {
        this.updateSelect();
        this.model.set('storyline_id', storyline.id);
      });

      return false;
    },

    'click .edit_storyline': function() {
      pageflow.editor.navigate('storylines/' + this.model.get('storyline_id'), {trigger: true});
      return false;
    }
  },

  initialize: function() {
    this.model = new Backbone.Model({
      storyline_id: this.defaultStorylineId()
    });

    this.listenTo(pageflow.storylines, 'add sort remove', this.updateSelect);
    this.listenTo(this.model, 'change', this.load);
  },

  onRender: function() {
    this.$el.toggleClass('editable', !!this.options.editable);
    this.ui.storylines.toggle(!!pageflow.features.isEnabled('storylines'));

    this.updateSelect();
    this.load();
  },

  updateSelect: function() {
    this.selectRegion.show(new pageflow.SelectInputView({
      model: this.model,
      label: I18n.t('pageflow.editor.views.storylines_picker_view.label'),
      propertyName: 'storyline_id',
      values: pageflow.storylines.pluck('id'),
      texts: pageflow.storylines.map(function(storyline) {
        return this.indentation(storyline) + storyline.displayTitle();
      }, this),
      groups: pageflow.storylines.reduce(function(result, storyline) {
        if (storyline.isMain() || storyline.parentPage()) {
          result.push(_.last(result));
        }
        else {
          result.push(I18n.t('pageflow.editor.views.storylines_picker_view.without_parent_page'));
        }
        return result;
      }, [])
    }));
  },

  load: function() {
    var storyline = pageflow.storylines.get(this.model.get('storyline_id'));

    this.saveRememberedStorylineId(storyline.id);

    this.mainRegion.show(new pageflow.StorylineOutlineView({
      model: storyline,
      navigatable: this.options.navigatable,
      sortable: this.options.editable,
      chapterItemView: this.options.chapterItemView,
      pageItemView: this.options.pageItemView,
      pageItemViewOptions: this.options.pageItemViewOptions,
      displayInNavigationHint: this.options.displayInNavigationHint
    }));
  },

  defaultStorylineId: function() {
    var storyline =
      pageflow.storylines.get(this.options.storylineId) ||
      pageflow.storylines.get(this.rememberedStorylineId()) ||
      pageflow.storylines.first();

    return storyline.id;
  },

  rememberedStorylineId: function() {
    if (this.options.rememberLastSelection) {
      return pageflow.StorylinePickerView._rememberedStorylineId;
    }
  },

  saveRememberedStorylineId: function(id) {
    if (this.options.rememberLastSelection) {
      pageflow.StorylinePickerView._rememberedStorylineId = id;
    }
  },

  indentation: function(storyline) {
    return _(storyline.get('level') || 0).times(function() {
      return '\u00A0\u00A0\u00A0';
    }).join('');
  }
});
pageflow.UploaderView = Backbone.Marionette.View.extend({
  el: 'form#upload',

  ui: {
    input: 'input#image_file_attachment',
    authToken: 'input[name="authenticity_token"]'
  },

  initialize: function() {
    this.listenTo(pageflow.app, 'request-upload', this.openFileDialog);
  },

  render: function() {
    var that = this;

    this.bindUIElements();

    this.$el.fileupload({
      acceptFileTypes: /(\.|\/)(bmp|gif|jpe?g|png|ti?f|wmv|mp4|mpg|mov|asf|asx|avi|m?v|mpeg|qt|3g2|3gp|3ivx|divx|3vx|vob|flv|dvx|xvid|mkv)$/i,
      dataType: 'json',

      add: function(event, data) {
        try {
          data.record = pageflow.entry.addFileUpload(data.files[0]);
          var xhr = data.submit();

          that.listenTo(data.record, 'uploadCancelled', function() {
            xhr.abort();
          });
        }
        catch(e) {
          if (e instanceof pageflow.FileTypes.UnmatchedUploadError) {
            pageflow.app.trigger('error', e);
          }
          else {
            throw(e);
          }
        }
      },

      progress: function(event, data) {
        data.record.set('uploading_progress', parseInt(data.loaded / data.total * 100, 10));
      },

      submit: function(event, data) {
        var record = data.record;

        this.action = record.url();

        data.paramName = record.modelName + '[attachment]';
        data.formData = {
          authenticity_token: that.ui.authToken.attr('value')
        };
      },

      done: function(event, data) {
        data.record.unset('uploading_progress');
        data.record.set(data.result);
      },

      fail: function(event, data) {
        if (data.errorThrown !== 'abort') {
          data.record.uploadFailed();
        }
      },

      always: function(event, data) {
        that.stopListening(data.record);
      }
    });

    return this;
  },

  openFileDialog: function() {
    this.$('input:file').click();
  }
});
pageflow.app.addInitializer(function(options) {
  pageflow.config = options.config;
});
pageflow.app.addInitializer(function(options) {
  pageflow.seed = options.common;
});
pageflow.app.addInitializer(function(options) {
  pageflow.features.enable('editor', options.entry.enabled_feature_names);
});
pageflow.app.addInitializer(function(options) {
  pageflow.Audio.setup({
    getSources: function(audioFileId) {
      var file = pageflow.audioFiles.get(audioFileId);
      return file ? file.getSources() : '';
    }
  });
});
pageflow.app.addInitializer(function() {
  Backbone.history.on('route', function() {
    pageflow.editor.applyDefaultHelpEntry();
  });
});
pageflow.app.addInitializer(function(options) {
  pageflow.editor.fileTypes.register('image_files', {
    model: pageflow.ImageFile,
    metaDataAttributes: ['dimensions'],
    matchUpload: /^image/
  });

  pageflow.editor.fileTypes.register('video_files', {
    model: pageflow.VideoFile,
    metaDataAttributes: ['format', 'dimensions', 'duration'],
    matchUpload: /^video/
  });

  pageflow.editor.fileTypes.register('audio_files', {
    model: pageflow.AudioFile,
    metaDataAttributes: ['format', 'duration'],
    matchUpload: /^audio/
  });

  pageflow.editor.fileTypes.setup(options.config.fileTypes);
});
pageflow.app.addInitializer(function(options) {
  pageflow.editor.widgetTypes = options.widget_types;
});
pageflow.app.addInitializer(function(options) {
  pageflow.files = pageflow.FilesCollection.createForFileTypes(pageflow.editor.fileTypes, options.files);

  pageflow.imageFiles = pageflow.files.image_files;
  pageflow.videoFiles = pageflow.files.video_files;
  pageflow.audioFiles = pageflow.files.audio_files;

  pageflow.pages = new pageflow.PagesCollection(options.pages);
  pageflow.chapters = new pageflow.ChaptersCollection(options.chapters);
  pageflow.storylines = new pageflow.StorylinesCollection(options.storylines);
  pageflow.entry = new pageflow.Entry(options.entry);
  pageflow.theming = new pageflow.Theming(options.theming);
  pageflow.account = new Backbone.Model(options.account);

  pageflow.entryData = new pageflow.PreviewEntryData({
    storylines: pageflow.storylines,
    chapters: pageflow.chapters,
    pages: pageflow.pages,
    theming: pageflow.theming
  });

  pageflow.storylineOrdering = new pageflow.StorylineOrdering(pageflow.storylines, pageflow.pages);
  pageflow.storylineOrdering.sort({silent: true});
  pageflow.storylineOrdering.watch();

  pageflow.pages.sort();

  // TODO
  pageflow.storylines.on('sort', _.debounce(function() {
    pageflow.storylines.saveOrder();
  }, 100));

  pageflow.editor.failures.watch(pageflow.entry);
  pageflow.editor.failures.watch(pageflow.pages);
  pageflow.editor.failures.watch(pageflow.chapters);

  pageflow.savingRecords = new pageflow.SavingRecordsCollection();
  pageflow.savingRecords.watch(pageflow.pages);
  pageflow.savingRecords.watch(pageflow.chapters);
});
pageflow.app.addInitializer(function(options) {
  pageflow.editor.pageTypes.setup(options.page_types);
});
pageflow.app.addInitializer(function(options) {
  var KEY_A = 65;
  var KEY_X = 88;

  $(document).on('keydown', function(event) {
    if (event.altKey && event.which === KEY_A) {
      if (pageflow.features.isEnabled('atmo')) {
        if (pageflow.atmo.disabled) {
          pageflow.atmo.enable();
        }
        else {
          pageflow.atmo.disable();
        }
      }
    }
    else if (event.altKey && event.which === KEY_X) {
      pageflow.editor.navigate('pages/' + pageflow.slides.currentPage().data('id'), {trigger: true});
    }
  });
});
pageflow.app.addInitializer(function(options) {
  pageflow.editLock = new pageflow.EditLockContainer();

  pageflow.editLock.watchForErrors();
  pageflow.editLock.acquire();
});
pageflow.app.addInitializer(function(options) {
  pageflow.entry.pollForPendingFiles();
});
pageflow.app.addInitializer(function(options) {
  pageflow.entry.on('change:pending_files_count', function(model, value) {
    if (value < pageflow.entry.previous('pending_files_count')) {
      pageflow.reloadStylesheet('entry');
    }
  });

  pageflow.entry.on('use:file', function() {
    pageflow.reloadStylesheet('entry');
  });
});
pageflow.app.addInitializer(function() {
  _.each(pageflow.editor.sideBarRoutings, function(options) {
    new options.router({
      controller: new options.controller({
        region: pageflow.app.sidebarRegion,
        entry: pageflow.entry
      })
    });
  });

  window.editor = new pageflow.SidebarRouter({
    controller: new pageflow.SidebarController({
      region: pageflow.app.sidebarRegion,
      entry: pageflow.entry
    })
  });
});
pageflow.app.addInitializer(function() {
  pageflow.app.on('error', function(e) {
    alert(I18n.t(e.name, {
      scope: 'pageflow.editor.errors',
      defaultValue: I18n.t('pageflow.editor.errors.unknown')
    }));
  });
});
pageflow.app.addInitializer(function(/* args */) {
  var context = this;
  var args = arguments;

  _.each(pageflow.editor.initializers, function(fn) {
    fn.call(context, args);
  });
});
pageflow.app.addInitializer(function(options) {
  new pageflow.EditorView({
    el: $('body')
  }).render();

  new pageflow.ScrollingView({
    el: $('sidebar .scrolling'),
    region: pageflow.app.sidebarRegion
  }).render();

  pageflow.app.previewRegion.show(new pageflow.EntryPreviewView({
    model: pageflow.entry
  }));

  pageflow.app.indicatorsRegion.show(new pageflow.DisabledAtmoIndicatorView().render());
  pageflow.app.notificationsRegion.show(new pageflow.NotificationsView().render());
  pageflow.app.helpButtonRegion.show(new pageflow.HelpButtonView().render());

  Backbone.history.start({root: options.root});
});

pageflow.app.addRegions({
  previewRegion: '#entry_preview',
  mainRegion: '#main_content',
  indicatorsRegion: '#editor_indicators',
  sidebarRegion: 'sidebar .container',
  dialogRegion: '.dialog_container',
  notificationsRegion: 'sidebar .notifications_container',
  helpButtonRegion: 'sidebar .help_button_container'
});



pageflow.beforeAfter = {};

pageflow.ConfigurationEditorView.register('before_after', {
  configure: function() {
    this.tab('general', function() {
      this.group('general');

      this.input('control_bar_text', pageflow.TextInputView, {
        placeholder: I18n.t('pageflow.public.before_after.start', {
          locale: pageflow.entry.configuration.get('locale')
        })
      });
      this.input('additional_title', pageflow.TextInputView);
      this.input('additional_description', pageflow.TextAreaInputView, {size: 'short'});
    });

    this.tab('files', function() {
      this.input('before_image_id', pageflow.FileInputView, {
        collection: pageflow.imageFiles,
        imagePositioning: false
      });
      this.input('after_image_id', pageflow.FileInputView, {
        collection: pageflow.imageFiles,
        imagePositioning: false
      });
      this.input('thumbnail_image_id', pageflow.FileInputView, {
        collection: pageflow.imageFiles,
        imagePositioning: false
      });
    });

    this.tab('options', function() {
      this.group('options');
    });
  }
});
pageflow.beforeAfter.BeforeAfterEmbeddedView = Backbone.Marionette.View.extend({
  modelEvents: {
    'change': 'update'
  },

  render: function() {
    this.beforeImageView = new pageflow.BackgroundImageEmbeddedView({
      el: this.$el.find('.before_image'),
      model: this.model,
      propertyName: 'before_image_id',
      dataSizeAttributes: true
    });

    this.afterImageView = new pageflow.BackgroundImageEmbeddedView({
      el: this.$el.find('.after_image'),
      model: this.model,
      propertyName: 'after_image_id',
      dataSizeAttributes: true
    });

    this.update();
    return this;
  },

  update: function() {
    this.beforeImageView.update();
    this.afterImageView.update();
    this.$el.before_after();
    this.$el.before_after('refresh');
  }
});



pageflow.textPage = pageflow.textPage || {};

pageflow.ConfigurationEditorView.register('text_page', {
  configure: function () {
    this.tab('header', function () {
      this.input('text_coverage', pageflow.SelectInputView, {values: pageflow.textPage.textCoverageOptions});
      this.input('title', pageflow.TextInputView, {required: true});
      this.input('hide_title', pageflow.CheckBoxInputView);
      this.input('tagline', pageflow.TextInputView);
      this.input('subtitle', pageflow.TextInputView);
      this.input('text_position', pageflow.SelectInputView, {values: pageflow.textPage.titlePositions});
      this.input('background_image_id', pageflow.FileInputView, {
        collection: pageflow.imageFiles,
        fileSelectionHandlerOptions: {
          returnToTab: 'header'
        }
      });
      this.input('gradient_opacity', pageflow.SliderInputView);
      this.input('invert', pageflow.CheckBoxInputView);
    });

    this.tab('content', function () {
      this.input('text_title', pageflow.TextInputView);
      this.input('text', pageflow.TextAreaInputView);
      this.input('invert_text', pageflow.CheckBoxInputView);

      this.input('text_image_id', pageflow.FileInputView, {
        collection: pageflow.imageFiles,
        positioning: false,
        fileSelectionHandlerOptions: {
          returnToTab: 'content'
        },
      });
      this.input('image_description', pageflow.TextInputView);
      this.input('sticky_inline_image', pageflow.CheckBoxInputView);
      this.input('prevent_fullscreen', pageflow.CheckBoxInputView);
      this.input('inline_text_position', pageflow.SelectInputView, {values: pageflow.textPage.inlineTextPositions});
    });

    this.tab('options', function () {
      this.input('topasset_parallax', pageflow.CheckBoxInputView);
      this.input('topasset_dim', pageflow.CheckBoxInputView);
      this.input('thumbnail_image_id', pageflow.FileInputView, {
        collection: pageflow.imageFiles,
        imagePositioning: false,
        fileSelectionHandlerOptions: {
          returnToTab: 'options'
        }
      });
      this.group('options');
    });
  }
});
pageflow.textPage.ContentImageEmbeddedView = Backbone.Marionette.View.extend({
  modelEvents: {
    'change': 'update'
  },

  render: function() {
    this.img = this.$el.find('img');
    this.text = this.$el.find('.inline-image-text');

    this.update();
    return this;
  },

  update: function() {

    var image = this.model.getImageFileUrl(this.options.imagePropertyName);
    var description = this.model.get(this.options.descriptionPropertyName);

    this.$el.toggleClass('no_image_assigned', !image);

    if (this.img) {
      if(!this.img || this.img.length === 0) {
        this.img = $('<img/>');
        this.$el.prepend(this.img);
      }
      if(this.text) {
        this.text.remove();
        this.text = null;
      }

      this.img.attr('src', image);
      this.img.attr('title', description);
    }
    else {
      if (description && !this.defaultImage) {
        this.defaultImage = $('<div/>').addClass('default-image');
        this.$el.prepend(this.defaultImage);
      }
      else if(this.defaultImage) {
        this.defaultImage.remove();
        this.defaultImage = null;
      }

      if (this.img) {
        this.img.remove();
        this.img = null;
      }
    }

    if (description) {
      if(!this.text) {
        this.text = $('<div/>')
          .addClass('inline_image_text')
          .append($('<span/>'));
        this.$el.append(this.text);
      }

      this.text.find('span').html(description);
    }
    else if (this.text) {
      this.text.remove();
      this.text = null;
    }

  }
});








pageflow.embeddedVideo = pageflow.embeddedVideo || {};
pageflow.embeddedVideo.EmbeddedVideo = Backbone.Model.extend({
  modelName: 'embedded_video',
  paramRoot: 'embedded_video',

  initialize: function() {
    this.listenTo(this, 'sync', function() {
      if (this.isProcessing() && !this.pollingInterval) {
        this.pollUntilValidated();
      }
    });
  },

  urlRoot: function() {
    return '/embedded_video/embedded_videos';
  },

  isProcessed: function() {
    return this.get('state') === 'processed';
  },

  isProcessing: function() {
    return this.get('state') === 'processing';
  },

  isFailed: function() {
    return this.get('state') === 'processing_failed';
  },

  pollUntilValidated: function() {
    var model = this;

    if (model.isProcessed()) {
      return;
    }

    model.pollingInterval = setInterval(poll, 1000);

    function stopPolling() {
      if (model.pollingInterval) {
        clearInterval(model.pollingInterval);
        model.pollingInterval = null;
      }
    }

    function poll() {
      model.fetch({
        success: function() {
          if (!model.isProcessing()) {
            stopPolling();
          }
        }
      });
    }
  }
});
pageflow.embeddedVideo.EmbeddedVideosCollection = Backbone.Collection.extend({
  model: pageflow.embeddedVideo.EmbeddedVideo,

  name: 'embedded_videos',

  getOrFetch: function(id, options) {
    options = options || {};
    var model = this.get(id);

    if (model) {
      if (options.success) {
        options.success(model);
      }
    }
    else {
      model = new pageflow.embeddedVideo.EmbeddedVideo({id: id});
      this.add(model);
      model.fetch(options);
    }

    return model;
  }
});
pageflow.embeddedVideo.VideoUrlInputView = pageflow.UrlInputView.extend({
  template: 'pageflow/embedded_video/editor/templates/url_input',

  regions: {
    statusContainer: '.status_container'
  },

  onLoad: function() {
    this.listenTo(this.model, 'change:' + this.options.propertyName, function() {
      this.updateValidationStatus();
    });

    this.updateValidationStatus();
  },

  updateValidationStatus: function() {
    var embeddedVideo = this.getEmbeddedVideo();

    if (embeddedVideo) {
      this.statusContainer.show(new pageflow.embeddedVideo.EmbeddedVideoStatusView({
        model: embeddedVideo
      }));
    }
    else {
      this.statusContainer.close();
    }
  },

  getEmbeddedVideo: function() {
    if (this.model.has(this.options.propertyName)) {
      return pageflow.embeddedVideo.embeddedVideos.getOrFetch(this.model.get(this.options.propertyName));
    }
  }
});
(function() { this.JST || (this.JST = {}); this.JST["pageflow/embedded_video/editor/templates/embedded_video_status"] = function(obj){var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('<p class="processing state validation pending">URL wird validiert...</p>\n<p class="failed state validation failed">Die URL ist ungültig.</p>\n');}return __p.join('');};
}).call(this);
(function() { this.JST || (this.JST = {}); this.JST["pageflow/embedded_video/editor/templates/url_input"] = function(obj){var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('<label>\n  <span class="name"></span>\n  <span class="inline_help"></span>\n</label>\n<input type="text" />\n<div class="validation"></div>\n<div class="status_container"></div>\n');}return __p.join('');};
}).call(this);
pageflow.ConfigurationEditorView.register('embedded_video', {
  configure: function() {
    var supportedHosts = this.options.pageType.supportedHosts;

    this.tab('general', function() {
      this.group('general');
    });

    this.tab('topic', function() {
      this.input('embedded_video_id', pageflow.UrlInputView, {
        supportedHosts: supportedHosts,
        displayPropertyName: 'display_embedded_video_url',
        required: true,
        permitHttps: true
      });
      this.input('video_caption', pageflow.TextInputView);
      this.input('full_width', pageflow.CheckBoxInputView);
      this.input('background_image_id', pageflow.FileInputView, {collection: pageflow.imageFiles});
      this.input('thumbnail_image_id', pageflow.FileInputView, {
        collection: pageflow.imageFiles,
        imagePositioning: false
      });
    });

    this.tab('options', function() {
      this.group('options');
    });
  }
});
pageflow.embeddedVideo.embeddedVideos = new pageflow.embeddedVideo.EmbeddedVideosCollection();










pageflow.internalLinks = pageflow.internalLinks || {};
pageflow.internalLinks.pageConfigurationMixin = {
  internalLinksList: function() {
    this._internalLinksList = this._internalLinksList ||
      new pageflow.internalLinks.ListPageLinksCollection(null, {
        configuration: this
      });

    return this._internalLinksList;
  },

  internalLinksGrid: function() {
    this._internalLinksGrid = this._internalLinksGrid ||
      new pageflow.internalLinks.GridPageLinksCollection(null, {
        configuration: this
      });

    return this._internalLinksGrid;
  }
};
pageflow.internalLinks.PageLink = Backbone.Model.extend({
  i18nKey: 'pageflow/internal_links/page_link',

  targetPage: function() {
    return pageflow.pages.getByPermaId(this.get('target_page_id'));
  },

  label: function() {
    return this.get('label');
  },

  editPath: function() {
    return '/internal_links_pages/' + this.getRoutableId() + '/page_links/' + this.id;
  },

  getRoutableId: function() {
    return this.collection.page.id;
  },

  toSerializedJSON: function() {
    return _.omit(this.attributes, 'highlighted');
  },

  highlight: function() {
    this.set('highlighted', true);
  },

  resetHighlight: function() {
    this.unset('highlighted');
  },

  remove: function() {
    this.collection.remove(this);
  }
});
pageflow.internalLinks.PageLinksCollection = Backbone.Collection.extend({
  model: pageflow.internalLinks.PageLink,

  comparator: 'position',

  initialize: function(models, options) {
    this.configuration = options.configuration;
    this.page = options.configuration.page;

    this.load();

    this.listenTo(this, 'add remove change', this.save);
    this.listenTo(this.configuration, 'change:internal_links', this.load);
  },

  addLink: function(targetPageId) {
    this.addWithPosition(this.defaultPosition(), targetPageId);
  },

  canAddLink: function(targetPageId) {
    return true;
  },

  updateLink: function(link, targetPageId) {
    link.set('target_page_id', targetPageId);
  },

  removeLink: function(link) {
    this.remove(link);
  },

  addWithPosition: function(position, targetPageId) {
    this.add(this.pageLinkAttributes(position, targetPageId));
  },

  removeByPosition: function(position) {
    this.remove(this.findByPosition(position));
  },

  findByPosition: function(position) {
    return this.findWhere({position: position});
  },

  load: function() {
    this.set(this.pageLinksAttributes() ||
             this.legacyPageLinksAttributes());
  },

  save: function(referenceKey, pageId) {
    this.configuration.set('internal_links', this.map(function(pageLink) {
      return pageLink.toSerializedJSON();
    }));
  },

  pageLinksAttributes: function() {
    if (this.configuration.has('internal_links')) {
      return this.configuration.get('internal_links') || [];
    }
  },

  legacyPageLinksAttributes: function() {
    return _(this.configuration.get('linked_page_ids') || {}).reduce(function(result, pageId, position) {
      var page = pageflow.pages.getByPermaId(pageId);

      if (page) {
        result.push(this.pageLinkAttributes(parseInt(position, 10) - 1,
                                            pageId,
                                            this.configuration.page.id + ':' + position));
      }

      return result;
    }, [], this);
  },

  pageLinkAttributes: function(position, targetPageId, id) {
    return {
      id: id || this.getUniqueId(),
      target_page_id: targetPageId,
      position: position
    };
  },

  getUniqueId: function() {
    var maxId = Math.max(0, _.max(this.map(function(pageLink) {
      return parseInt(pageLink.id.split(':').pop(), 10);
    })));

    return this.configuration.page.id + ':' + (maxId + 1);
  }
});

pageflow.internalLinks.GridPageLinksCollection = pageflow.internalLinks.PageLinksCollection.extend({
  canAddLink: function() {
    return this.defaultPosition() !== undefined;
  },

  defaultPosition: function() {
    var collection = this;

    return _.chain(25)
      .times(function(index) {
        return index;
      })
      .find(function(position) {
        return !collection.findWhere({position: position});
      })
      .value();
  }
});

pageflow.internalLinks.ListPageLinksCollection = pageflow.internalLinks.PageLinksCollection.extend({
  defaultPosition: function() {
    return Math.max(0, _.max(this.map(function(pageLink) {
      return pageLink.get('position');
    }))) + 1;
  },

  saveOrder: function() {
  }
});
(function() { this.JST || (this.JST = {}); this.JST["pageflow/internal_links/editor/templates/edit_page_link"] = function(obj){var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('<a class="back">',  I18n.t('pageflow.internal_links.editor.templates.edit_page_link.back') ,'</a>\n<a class="destroy">',  I18n.t('pageflow.internal_links.editor.templates.edit_page_link.destroy') ,'</a>\n<div class="form_container"></div>\n');}return __p.join('');};
}).call(this);
(function() { this.JST || (this.JST = {}); this.JST["pageflow/internal_links/editor/templates/grid_item_embedded"] = function(obj){var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('<a class="edit" href="" title="',  I18n.t('pageflow.internal_links.editor.templates.embedded.grid_page_link.edit') ,'"></a>\n<a class="set" href="" title="',  I18n.t('pageflow.internal_links.editor.templates.embedded.grid_page_link.set') ,'"></a>\n<div class="placeholder"></div>\n<span class="title"></span>\n');}return __p.join('');};
}).call(this);
(function() { this.JST || (this.JST = {}); this.JST["pageflow/internal_links/editor/templates/list_item_embedded"] = function(obj){var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('<a class="edit" href="" title="',  I18n.t('pageflow.internal_links.editor.templates.list_item_embedded.edit') ,'"></a>\n\n<a class="page_link" href="#">\n  <div class="details">\n    <p class="page_description"></p>\n  </div>\n</a>\n');}return __p.join('');};
}).call(this);
pageflow.internalLinks.EditPageLinkView = Backbone.Marionette.Layout.extend({
  template: 'pageflow/internal_links/editor/templates/edit_page_link',

  regions: {
    formContainer: '.form_container'
  },

  ui: {
    backButton: 'a.back'
  },

  events: {
    'click a.back': 'goBack',

    'click a.destroy': 'destroy'
  },

  onRender: function() {
    var configurationEditor = new pageflow.ConfigurationEditorView({
      model: this.model,
      attributeTranslationKeyPrefixes: [
        'pageflow.internal_links.page_link_attributes',
        'pageflow.common_page_link_attributes'
      ]
    });

    this.configure(configurationEditor);
    this.formContainer.show(configurationEditor);

    this.highlight();
  },

  highlight: function() {
    var page = this.model.collection.page;

    this.model.highlight();
    page.set('internal_links_editable', true);

    this.listenTo(this, 'close', function() {
      this.model.resetHighlight();
      page.unset('internal_links_editable');
    });
  },

  configure: function(configurationEditor) {
    configurationEditor.tab('general', function() {
      this.input('label', pageflow.TextInputView);
      this.input('target_page_id', pageflow.PageLinkInputView);
      this.input('page_transition', pageflow.SelectInputView, {
        translationKeyPrefix: 'pageflow.page_transitions',
        includeBlank: true,
        blankTranslationKey: 'pageflow.internal_links.editor.views.edit_page_link_view.default_page_transition',
        values: pageflow.pageTransitions.names()
      });
      this.input('description', pageflow.TextAreaInputView, {
        size: 'short'
      });
    });
  },

  destroy: function() {
    if (confirm(I18n.t('pageflow.internal_links.editor.views.edit_page_link_view.confirm_destroy'))) {
      this.model.remove();
      this.goBack();
    }
  },

  goBack: function() {
    pageflow.editor.navigate('/pages/' + this.options.page.id + '/links', {trigger: true});
  }
});
pageflow.internalLinks.EditableLinksModeView = Backbone.Marionette.View.extend({
  render: function() {
    this.model.set('internal_links_editable', true);
    return this;
  },

  onClose: function() {
    this.model.unset('internal_links_editable');
  }
});
pageflow.internalLinks.GridConfigurationEditorView = pageflow.ConfigurationEditorView.extend({
  configure: function() {
    this.tab('general', function() {
      this.group('general');
    });

    this.tab('files', function() {
      this.input('background_image_id', pageflow.FileInputView, {collection: pageflow.imageFiles});
      this.input('thumbnail_image_id', pageflow.FileInputView, {
        collection: pageflow.imageFiles,
        positioning: false
      });
    });

    this.tab('links', function() {
      this.view(pageflow.internalLinks.EditableLinksModeView, {
        model: this.model.page
      });

      this.input('linked_pages_layout', pageflow.SelectInputView, {values: pageflow.Page.linkedPagesLayouts});
      this.view(pageflow.PageLinksView, {
        model: this.model.page
      });
    });

    this.tab('options', function() {
      this.group('options');
    });
  }
});
pageflow.internalLinks.GridItemEmbeddedView = Backbone.Marionette.ItemView.extend({
  template: 'pageflow/internal_links/editor/templates/grid_item_embedded',

  modelEvents: {
    'change': 'update'
  },

  ui: {
    title: '.title'
  },

  events: {
    'click .edit': function() {
      pageflow.editor.navigate(this.pageLink().editPath(), {trigger: true});
      return false;
    },

    'click .set': function() {
      var view = this;

      pageflow.editor.selectPage().then(function(page) {
        view.setTargetPage(page.get('perma_id'));
      });
    },

    'click .thumbnail': function () {
      if (!this.$el.hasClass('editable')) {
        var pageLink = this.pageLink();

        pageflow.slides.goToByPermaId(pageLink.get('target_page_id'), {
          transition: pageLink.get('page_transition')
        });
      }

      return false;
    },

    'mousedown': function() {
      if (this.$el.hasClass('editable') && !this.$el.hasClass('unassigned')) {
        return false;
      }
    }
  },

  initialize: function() {
    this.pageLinks = this.model.page.pageLinks();
  },

  onRender: function() {
    var view = this;

    this.$el.droppable({
      tolerance: 'pointer',

      accept: function() {
        return view.$el.hasClass('editable') && view.$el.hasClass('unassigned');
      },

      activate: function() {
        view.$el.addClass('droppable');
      },

      deactivate: function() {
        view.$el.removeClass('droppable over');
      },

      over: function() {
        view.$el.addClass('over');
      },

      out: function() {
        view.$el.removeClass('over');
      },

      drop: function(event, ui) {
        view.$el.removeClass('droppable over');
        view.movePageLinkFrom(ui.draggable.data('referenceKey'));
      }
    });

    this.$el.draggable({
      disabled: true,

      helper: 'clone',

      revert: function(droppable) {
        if (droppable) {
          view.resetPageLink();
        }

        return !droppable;
      },

      start: function() {
        view.$el.addClass('dragged');
      },

      stop: function() {
        view.$el.removeClass('dragged');
      },

      revertDuration: 200
    });

    this.listenTo(this.model.page, 'change:' + 'internal_links_editable', function() {
      view.updateClassNames();
      view.updateDraggable();
      view.options.container.refreshScroller();
    });

    this.update();
  },

  update: function() {
    var targetPage = this.targetPage();
    var pageLink = this.pageLink();

    this.$el.attr('data-page-transition', pageLink ? pageLink.get('page_transition') : null);

    this.updateTexts();
    this.updateCurrentPageLink();
    this.updateThumbnailView();
    this.updateClassNames();
    this.updateDraggable();
  },

  updateCurrentPageLink: function() {
    var pageLink = this.pageLink();

    if (this.currentPageLink !== pageLink) {
      if (this.currentPageLink) {
        this.stopListening(this.currentPageLink, 'change');
      }

      this.currentPageLink = pageLink;

      if (pageLink) {
        this.listenTo(pageLink, 'change', function() {
          this.updateClassNames();
          this.updateThumbnailView();
        });
      }
    }
  },

  updateTexts: function() {
    var targetPage = this.targetPage();
    var pageLink = this.pageLink();

    if (pageLink && pageLink.get('description')) {
      this.ui.title.html(pageLink.get('description'));
    }
    else {
      this.ui.title.html(targetPage ? targetPage.configuration.get('description') : '');
    }
  },

  updateThumbnailView: function() {
    var targetPage = this.targetPage();

    if (this.currentLinkedPage !== targetPage) {
      if (this.currentLinkedPage) {
        this.stopListening(this.currentLinkedPage, 'change:highlighted');
        this.stopListening(this.currentLinkedPage.configuration, 'change:description');
      }

      this.currentLinkedPage = targetPage;

      if (this.thumbnailView) {
        this.thumbnailView.close();
      }

      if (targetPage) {
        this.thumbnailView = this.subview(new pageflow.PageThumbnailView({
          model: targetPage,
          imageUrlPropertyName: 'link_thumbnail_url'
        }));

        this.$el.append(this.thumbnailView.el);

        this.listenTo(targetPage, 'change:highlighted', this.updateClassNames);
        this.listenTo(targetPage.configuration, 'change:description', this.updateTitle);
      }
    }
  },

  updateClassNames: function() {
    var editable = this.model.page.get('internal_links_editable');
    var targetPage = this.targetPage();

    this.$el.toggleClass('title_hover', !editable);
    this.$el.toggleClass('editable', !!editable);
    this.$el.toggleClass('empty', !targetPage && !editable);
    this.$el.toggleClass('no_page', !targetPage);
    this.$el.toggleClass('unassigned', !this.currentPageLink);
    this.$el.toggleClass('highlighted', !!(this.currentPageLink && this.currentPageLink.get('highlighted')));
  },

  updateDraggable: function() {
    this.$el.draggable('option', 'disabled', !this.$el.hasClass('editable') || this.$el.hasClass('unassigned'));
  },

  setTargetPage: function(pagePermaId) {
    this.pageLinks.addWithPosition(this.position(), pagePermaId);
  },

  movePageLinkFrom: function(position) {
    this.pageLinks.findByPosition(position).set('position', this.position());
  },

  resetPageLink: function() {
    this.pageLinks.removeByPosition(this.position());
  },

  targetPage: function() {
    var pageLink = this.pageLink();
    return pageLink && pageLink.targetPage();
  },

  pageLink: function() {
    return this.pageLinks.findByPosition(this.position());
  },

  position: function() {
    return this.$el.data('referenceKey');
  }
});
pageflow.internalLinks.ListConfigurationEditorView = pageflow.ConfigurationEditorView.extend({
  configure: function() {
    this.tab('general', function() {
      this.group('general');
    });

    this.tab('files', function() {
      this.input('background_image_id', pageflow.FileInputView, {collection: pageflow.imageFiles});
      this.input('thumbnail_image_id', pageflow.FileInputView, {
        collection: pageflow.imageFiles,
        positioning: false
      });
    });

    this.tab('links', function() {
      this.view(pageflow.internalLinks.EditableLinksModeView, {
        model: this.model.page
      });

      this.view(pageflow.PageLinksView, {
        model: this.model.page
      });
    });

    this.tab('options', function() {
      this.group('options');
    });
  }
});
pageflow.internalLinks.ListEmbeddedView = Backbone.Marionette.View.extend({
  render: function() {
    this.subview(new pageflow.CollectionView({
      el: this.$el.find('ul'),
      collection: this.model.internalLinksList(),
      itemViewConstructor: pageflow.internalLinks.ListItemEmbeddedView,
      itemViewOptions: {
        page: this.model.page
      }
    }));

    this.listenTo(this.model.page.pageLinks(), 'add remove', function() {
      this.refreshScroller();
    });

    this.refreshScroller();

    return this;
  },

  refreshScroller: function() {
  }
});
pageflow.internalLinks.ListItemEmbeddedView = Backbone.Marionette.ItemView.extend({
  template: 'pageflow/internal_links/editor/templates/list_item_embedded',

  tagName: 'li',

  modelEvents: {
    'change': 'update'
  },

  ui: {
    description: '.page_description',
    link: '.page_link'
  },

  events: {
    'click .edit': function() {
      pageflow.editor.navigate(this.model.editPath(), {trigger: true});
      return false;
    },

    'click': function() {
      if (this.$el.hasClass('editable')) {
        return false;
      }
    }
  },

  onRender: function() {
    this.listenTo(this.options.page, 'change:internal_links_editable', function() {
      this.updateClassNames();
    });

    this.update();
  },

  update: function() {
    var targetPage = this.targetPage();

    if (!('currentTargetPage' in this) || this.currentTargetPage !== targetPage) {
      if (this.currentTargetPage) {
        this.stopListening(this.currentTargetPage.configuration, 'change:description');
      }

      this.currentTargetPage = targetPage;

      this.ui.link.attr('data-page', targetPage ? targetPage.get('perma_id') : null);

      this.updateThumbnail();

      if (targetPage) {
        this.listenTo(targetPage.configuration, 'change:description', this.updateTexts);
      }
    }

    this.updatePageTransition();
    this.updateClassNames();
    this.updateTexts();
  },

  updatePageTransition: function() {
    this.ui.link.attr('data-page-transition', this.model.get('page_transition'));
  },

  updateTexts: function() {
    var targetPage = this.targetPage();

    if (this.model.get('description')) {
      this.ui.description.html(this.model.get('description'));
    }
    else {
      this.ui.description.html(targetPage ? targetPage.configuration.get('description') : '');
    }
  },

  updateThumbnail: function() {
    var targetPage = this.targetPage();

    if (this.thumbnailView) {
      this.thumbnailView.close();
    }

    this.thumbnailView = this.subview(new pageflow.PageThumbnailView({
      model: targetPage,
      imageUrlPropertyName: 'link_thumbnail_url'
    }));

    this.ui.link.prepend(this.thumbnailView.el);
  },

  updateClassNames: function() {
    var editable = this.options.page.get('internal_links_editable');
    var targetPage = this.targetPage();

    this.$el.toggleClass('editable', !!editable);
    this.$el.toggleClass('empty', !targetPage && !editable);
    this.$el.toggleClass('unassigned', !targetPage);
    this.$el.toggleClass('highlighted', !!this.model.get('highlighted'));
  },

  targetPage: function() {
    return this.model.targetPage();
  }
});
pageflow.internalLinks.PageLinkEmbeddedView = Backbone.Marionette.ItemView.extend({
  modelEvents: {
    'change': 'update'
  },

  ui: {
    title: '.title',
    description: '.description'
  },

  events: {
    'click .reset': function() {
      this.setTargetPage(null);
    },

    'click .set': function() {
      var view = this;

      pageflow.editor.selectPage().then(function(page) {
        view.setTargetPage(page.get('perma_id'));
      });
    },

    'click .thumbnail': function () {
      if (!this.$el.hasClass('editable')) {
        pageflow.slides.goToById(this.targetPage().id);
      }

      return false;
    },

    'mousedown': function() {
      if (this.$el.hasClass('editable') && !this.$el.hasClass('unassigned')) {
        return false;
      }
    }
  },

  onRender: function() {
    var view = this;

    this.listenTo(this.model.page, 'change:' + this.options.propertyName + '_editable', function() {
      view.updateClassName();
      view.updateDraggable();
      view.options.container.refreshScroller();
    });

    this.update();
  },

  update: function() {
    var targetPage = this.targetPage();

    this.$el.data('permaId', targetPage ? targetPage.get('perma_id') : null);

    this.updateTexts();
    this.updateThumbnailView();
    this.updateClassNames();
  },

  updateTexts: function() {
    var targetPage = this.targetPage();

    this.ui.title.html(targetPage ? targetPage.configuration.get('description') : '');
  },

  updateThumbnailView: function() {
    var targetPage = this.targetPage();

    if (this.currentLinkedPage !== targetPage) {
      if (this.currentLinkedPage) {
        this.stopListening(this.currentLinkedPage, 'change:highlighted');
        this.stopListening(this.currentLinkedPage.configuration, 'change:description');
      }

      this.currentLinkedPage = targetPage;

      if (this.thumbnailView) {
        this.thumbnailView.close();
      }

      if (targetPage) {
        this.thumbnailView = this.subview(new pageflow.PageThumbnailView({
          model: targetPage,
          imageUrlPropertyName: 'link_thumbnail_url'
        }));

        this.$el.append(this.thumbnailView.el);

        this.listenTo(targetPage, 'change:highlighted', this.updateClassName);
        this.listenTo(targetPage.configuration, 'change:description', this.updateTitle);
      }
    }
  },

  updateClassNames: function() {
    var editable = this.model.page.get(this.options.propertyName + '_editable');
    var targetPage = this.targetPage();

    this.$el.toggleClass('title_hover', !editable);
    this.$el.toggleClass('editable', !!editable);
    this.$el.toggleClass('empty', !targetPage && !editable);
    this.$el.toggleClass('unassigned', !targetPage);
    this.$el.toggleClass('highlighted', !!targetPage && !!targetPage.get('highlighted'));
  }
});
pageflow.internalLinks.SideBarRouter = Backbone.Marionette.AppRouter.extend({
  appRoutes: {
    'internal_links_pages/:pageId/page_links/:id': 'pageLink'
  }
});
pageflow.internalLinks.SideBarController = Backbone.Marionette.Controller.extend({
  initialize: function(options) {
    this.region = options.region;
  },

  pageLink: function(pageId, linkId) {
    var page = pageflow.pages.get(pageId);

    this.region.show(new pageflow.internalLinks.EditPageLinkView({
      model: page.pageLinks().get(linkId),
      page: page
    }));
  }
});
pageflow.editor.pageTypes.register('internal_links_grid', {
  configurationEditorView: pageflow.internalLinks.GridConfigurationEditorView,

  embeddedViews: {
    'nav li': {
      view: pageflow.internalLinks.GridItemEmbeddedView,
      options: {propertyName: 'linked_page_ids'}
    },

    '.background_image': {
      view: pageflow.BackgroundImageEmbeddedView,
      options: {propertyName: 'background_image_id'}
    }
  },

  pageLinks: function(configuration) {
    return configuration.internalLinksGrid();
  }
});

pageflow.editor.pageTypes.register('internal_links_list', {
  configurationEditorView: pageflow.internalLinks.ListConfigurationEditorView,

  embeddedViews: {
    'nav': {
      view: pageflow.internalLinks.ListEmbeddedView
    },

    '.background_image': {
      view: pageflow.BackgroundImageEmbeddedView,
      options: {propertyName: 'background_image_id'}
    }
  },

  pageLinks: function(configuration) {
    return configuration.internalLinksList();
  }
});

pageflow.editor.registerPageConfigurationMixin(pageflow.internalLinks.pageConfigurationMixin);

pageflow.editor.registerSideBarRouting({
  router: pageflow.internalLinks.SideBarRouter,
  controller: pageflow.internalLinks.SideBarController
});











pageflow.externalLinks = pageflow.externalLinks || {};

pageflow.externalLinks.selectSite = function() {
  return pageflow.externalLinks.SiteSelectionView.selectSite();
};
pageflow.externalLinks.pageConfigurationMixin = {
  externalSiteReferences: function() {
    var configuration = this;

    this._externalSiteReferences = this._externalSiteReferences || create();
    return this._externalSiteReferences;

    function create() {
      var collection = new pageflow.externalLinks.SiteReferencesCollection();

      pageflow.externalLinks.sites.ensureFetched().then(function() {
        collection.add(siteReferenceAttributes());

        configuration.listenTo(collection, 'add remove sort', function() {
          configuration.set('linked_external_site_perma_ids', _.map(collection.pluck('site'), function(site) {
            return site.get('perma_id');
          }));
        });
      });

      return collection;
    }

    function siteReferenceAttributes() {
      return _.compact(_.map(referencedSitePermaIds(), function(permaId) {
        var site = pageflow.externalLinks.sites.getByPermaId(permaId);

        return site && {
          site: site
        };
      }));
    }

    function referencedSitePermaIds() {
      return configuration.get('linked_external_site_perma_ids') || [];
    }
  }
};
pageflow.externalLinks.Site = Backbone.Model.extend({
  modelName: 'site',
  paramRoot: 'site',
  i18nKey: 'pageflow/external_links/site',

  mixins: [pageflow.failureTracking, pageflow.transientReferences],

  defaults: {
    'open_in_new_tab': true
  },

  initialize: function(attributes, options) {
    this.listenTo(this, 'change', function() {
      this.save();
    });
  },

  urlRoot: function() {
    return this.isNew() ? this.collection.url() : '/external_links/sites';
  },

  thumbnailFile: function() {
    return this.getReference('thumbnail', pageflow.imageFiles);
  },

  title: function() {
    return this.get('title');
  }
});
pageflow.externalLinks.SiteFileSelectionHandler = function(options) {
  this.call = function(file) {
    pageflow.externalLinks.sites.ensureFetched().then(function() {
      var site = pageflow.externalLinks.sites.get(options.id);
      site.setReference(options.attributeName, file);
    });
  };

  this.getReferer = function() {
    var query = (options.pageId && options.returnTo) ? '/?page=' + options.pageId + '&return_to=' + options.returnTo : '';
    return '/external_links/sites/' + options.id + query;
  };
};
pageflow.externalLinks.SiteReference = Backbone.Model.extend({
  modelName: 'siteReference',

  initialize: function() {
    this.listenTo(this.get('site'), 'destroy', this.destroy);
  }
});
pageflow.externalLinks.SiteSelectionHandler = function(options) {
  this.call = function(site) {
    options.page.configuration.externalSiteReferences().add({
      site: site
    });
  };
};
pageflow.externalLinks.SiteReferencesCollection = Backbone.Collection.extend({
  model: pageflow.externalLinks.SiteReference,

  comparator: function(chapter) {
    return chapter.get('position');
  },

  saveOrder: function() {
    // no op
  }
});
pageflow.externalLinks.SitesCollection = Backbone.Collection.extend({
  model: pageflow.externalLinks.Site,

  url: function() {
    return '/external_links/entries/' + pageflow.entry.get('id') + '/sites';
  },

  getByPermaId: function(permaId) {
    return this.findWhere({perma_id: permaId});
  },

  ensureFetched: function(callback) {
    var collection = this;

    this.fetchedPromise = this.fetchedPromise || new $.Deferred(function(deferred) {
      collection.once('sync', deferred.resolve);
      collection.fetch();
    }).promise();

    return this.fetchedPromise;
  }
});
pageflow.externalLinks.SidebarRouter = Backbone.Marionette.AppRouter.extend({
  appRoutes: {
    'external_links/sites': 'sites',
    'external_links/sites?page=:page_id': 'sites',
    'external_links/sites/:id': 'site',
    'external_links/sites/:id/?page=:page_id&return_to=:return_to': 'site',
  }
});
pageflow.externalLinks.SidebarController = Backbone.Marionette.Controller.extend({
  initialize: function(options) {
    this.region = options.region;
  },

  sites: function(pageId) {
    var page = pageflow.pages.get(pageId);
    var referer = page ? '/pages/' + page.id + '/links ' : '/';

    this.region.show(new pageflow.BackButtonDecoratorView({
      referer: referer,
      view: new pageflow.externalLinks.SitesView({
        selectionHandler: page && new pageflow.externalLinks.SiteSelectionHandler({
          page: page
        }),
        page: page,
        referer: referer
      })
    }));
  },

  site: function(id, pageId, returnTo) {
    var page = pageflow.pages.get(pageId);
    var region = this.region;

    pageflow.externalLinks.sites.ensureFetched().then(function() {
      region.show(new pageflow.externalLinks.EditSiteView({
        model: pageflow.externalLinks.sites.get(id),
        page: page,
        returnTo: returnTo
      }));
    });
  }
});
(function() { this.JST || (this.JST = {}); this.JST["pageflow/external_links/editor/templates/edit_site"] = function(obj){var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('<a class="back">',  I18n.t('pageflow.external_links.editor.templates.edit_site.back') ,'</a>\n<a class="destroy">',  I18n.t('pageflow.external_links.editor.templates.edit_site.destroy') ,'</a>\n\n<div class="failure">\n  <p>',  I18n.t('pageflow.external_links.editor.templates.edit_site.failure') ,'</p>\n  <p class="message"></p>\n  <a class="retry" href="">',  I18n.t('pageflow.external_links.editor.templates.edit_site.retry') ,'</a>\n</div>\n\n<div class="form_container"></div>\n');}return __p.join('');};
}).call(this);
(function() { this.JST || (this.JST = {}); this.JST["pageflow/external_links/editor/templates/embedded/list_item"] = function(obj){var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('<div class="link-thumbnail"></div>\n<div class="link-details">\n  <p class="link-title"></p>\n  <p class="link-description"></p>\n</div>\n<div class="tooltip">\n  ',  I18n.t('pageflow.external_links.editor.templates.embedded.list_item.open_in_new_tab_message') ,'\n  <span target="_blank">',  I18n.t('pageflow.external_links.editor.templates.embedded.list_item.open_in_new_tab') ,'</span>\n</div>\n');}return __p.join('');};
}).call(this);
(function() { this.JST || (this.JST = {}); this.JST["pageflow/external_links/editor/templates/inputs/site_reference"] = function(obj){var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('<label>\n  <span class="name"></span>\n  <span class="inline_help"></span>\n</label>\n<ul class="sites outline"></ul>\n\n<a href="" class="add_reference">',  I18n.t('pageflow.external_links.editor.templates.inputs.site_reference.add') ,'</a>\n');}return __p.join('');};
}).call(this);
(function() { this.JST || (this.JST = {}); this.JST["pageflow/external_links/editor/templates/site_item"] = function(obj){var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('<a href="">\n  <span class="thumbnail"></span>\n  <span class="title"></span>\n  <span class="failure_icon" title="',  I18n.t('pageflow.external_links.editor.templates.site_item.failure') ,'" />\n</a>\n<a class="select">',  I18n.t('pageflow.external_links.editor.templates.site_item.select') ,'</a>\n');}return __p.join('');};
}).call(this);
(function() { this.JST || (this.JST = {}); this.JST["pageflow/external_links/editor/templates/site_reference_item"] = function(obj){var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('<a href="">\n  <span class="thumbnail"></span>\n  <span class="title"></span>\n  <a class="edit" title="',  I18n.t('pageflow.external_links.editor.templates.site_reference_item.edit') ,'"></a>\n  <a class="remove" title="',  I18n.t('pageflow.external_links.editor.templates.site_reference_item.remove') ,'"></a>\n</a>\n');}return __p.join('');};
}).call(this);
(function() { this.JST || (this.JST = {}); this.JST["pageflow/external_links/editor/templates/site_selection"] = function(obj){var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('<div class="box">\n  <h2>',  I18n.t('pageflow.external_links.editor.templates.site_selection.title') ,'</h2>\n\n  <div class="wrapper editor">\n    <ul class="external_sites">\n    </ul>\n  </div>\n\n  <div class="footer">\n    <a href="" class="close">',  I18n.t('pageflow.external_links.editor.templates.site_selection.cancel') ,'</a>\n  </div>\n</div>\n');}return __p.join('');};
}).call(this);
(function() { this.JST || (this.JST = {}); this.JST["pageflow/external_links/editor/templates/sites"] = function(obj){var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('<a class="add" href="">',  I18n.t('pageflow.external_links.editor.templates.sites.add') ,'</a>\n');}return __p.join('');};
}).call(this);
(function() { this.JST || (this.JST = {}); this.JST["pageflow/external_links/editor/templates/sites_blank_slate"] = function(obj){var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('<li class="blank_slate">',  I18n.t('pageflow.external_links.editor.templates.sites_blank_slate.text') ,'<li>\n');}return __p.join('');};
}).call(this);
pageflow.ConfigurationEditorView.register('external_links', {
  configure: function() {
    this.tab('general', function() {
      this.group('general');
    });

    this.tab('files', function() {
      this.input('background_image_id', pageflow.FileInputView, {collection: pageflow.imageFiles});
      this.input('thumbnail_image_id', pageflow.FileInputView, {
        collection: pageflow.imageFiles,
        imagePositioning: false
      });
    });

    this.tab('links', function() {
      this.input('linked_external_site_perma_ids', pageflow.externalLinks.SiteReferencesInputView);
    });

    this.tab('options', function() {
      this.group('options');
    });
  }
});
pageflow.externalLinks.EditSiteView = Backbone.Marionette.Layout.extend({
  template: 'pageflow/external_links/editor/templates/edit_site',
  className: 'edit_external_site',

  mixins: [pageflow.failureIndicatingView],

  regions: {
    formContainer: '.form_container'
  },

  ui: {
    backButton: 'a.back'
  },

  events: {
    'click a.back': 'goBack',
    'click a.destroy': 'destroy',
  },

  onRender: function() {
    var options = this.options;
    var configurationEditor = new pageflow.ConfigurationEditorView({
      model: this.model
    });

    configurationEditor.tab('general', function() {
      this.input('url', pageflow.TextInputView, {
        required: true
      });
      this.input('open_in_new_tab', pageflow.CheckBoxInputView);
      this.input('thumbnail', pageflow.FileInputView, {
        collection: pageflow.imageFiles,
        fileSelectionHandler: 'externalLinks.site',
        fileSelectionHandlerOptions: {
          pageId: options.page && options.page.id,
          returnTo: options.returnTo
        },
        imagePositioning: false
      });
      this.input('title', pageflow.TextInputView, {
        required: true
      });
      this.input('description', pageflow.TextAreaInputView, {
        size: 'short',
        disableLinks: true
      });
    });

    if (this.options.returnTo === 'page' && this.options.page) {
      this.ui.backButton.text(I18n.t('pageflow.external_links.editor.views.edit_site.back'));
    }

    this.formContainer.show(configurationEditor);
  },

  destroy: function() {
    if (confirm(I18n.t('pageflow.external_links.editor.views.edit_site.confirm_destroy'))) {
      this.model.destroy();
      this.goBack();
    }
  },

  goBack: function() {
    if (this.options.returnTo === 'page' && this.options.page) {
      pageflow.editor.navigate('/pages/' + this.options.page.id + '/links', {trigger: true});
    }
    else {
      var query = this.options.page ? '?page=' + this.options.page.id : '';
      pageflow.editor.navigate('/external_links/sites' + query, {trigger: true});
    }
  }
});
pageflow.externalLinks.ListEmbeddedView = Backbone.Marionette.View.extend({
  render: function() {
    this.subview(new pageflow.CollectionView({
      el: this.$el.find('div'),
      collection: this.model.externalSiteReferences(),
      itemViewConstructor: pageflow.externalLinks.ListItemEmbeddedView
    }));

    this.listenTo(this.model.externalSiteReferences(), 'add remove', function() {
      this.refreshScroller();
    });

    this.listenTo(pageflow.externalLinks.sites, 'change', function() {
      this.$el.data('scroller').updateHeight();
    });

    this.refreshScroller();

    return this;
  },

  refreshScroller: function() {
    this.$el.data('scroller').refresh();
    this.$el.data('scroller').checkDisable();
    this.$el.data('scroller').updateHeight();
  }
});
pageflow.externalLinks.ListItemEmbeddedView = Backbone.Marionette.ItemView.extend({
  template: 'pageflow/external_links/editor/templates/embedded/list_item',

  tagName: 'a',
  className: 'link-item',

  ui: {
    title: '.link-title',
    description: '.link-description',
    thumbnail: '.link-thumbnail',
    tooltip: '.tooltip'
  },

  events: {
    'click': function(event) {
      if (event.currentTarget.target) {
        event.stopPropagation();
      }
      else {
        this.ui.tooltip.show();
        return false;
      }
    },

    'mouseleave': function() {
      this.ui.tooltip.hide();
    },

    'click .tooltip': function() {
      window.open(this.$el.attr('href'), '_blank');
      this.ui.tooltip.hide();
      return false;
    }
  },

  onRender: function() {
    this.listenTo(this.model.get('site'), 'change', this.update);
    this.update();
  },

  update: function() {
    var site = this.model.get('site');

    this.ui.title.text(site.get('title'));
    this.ui.description.html(site.get('description'));
    this.ui.tooltip.hide();

    this.$el.toggleClass('no_text', blank(site.get('title')) && blank(site.get('description')));

    this.$el.attr('href', site.get('url'));
    this.$el.attr('target', site.get('open_in_new_tab') ? '_blank' : null);

    this.updateThumbnailView(site);

    function blank(text) {
      return !text || text.replace(/\s+/g, '').replace(/&nbsp;/g, '') === '';
    }
  },

  updateThumbnailView: function(site) {
    var thumbnail = site.thumbnailFile();

    if (this.currentThumbnail !== thumbnail) {
      this.currentThumbnail = thumbnail;

      if (this.thumbnailView) {
        this.thumbnailView.close();
      }

      if (thumbnail) {
        this.thumbnailView = this.subview(new pageflow.FileThumbnailView({
          model: thumbnail,
          imageUrlPropertyName: 'link_thumbnail_url'
        }));

        this.ui.thumbnail.append(this.thumbnailView.el);
      }
    }
  },
});
pageflow.externalLinks.SiteReferenceInputView = pageflow.ReferenceInputView.extend({
  choose: function() {
    return pageflow.externalLinks.selectSite();
  },

  getTarget: function(permaId) {
    return pageflow.externalLinks.sites.getByPermaId(permaId);
  }
});
pageflow.externalLinks.SiteReferencesInputView = Backbone.Marionette.ItemView.extend({
  mixins: [pageflow.inputView],

  template: 'pageflow/external_links/editor/templates/inputs/site_reference',
  className: 'external_links_site_references_input',

  ui: {
    sites: 'ul.sites'
  },

  events: {
    'click .add_reference': function() {
      pageflow.editor.navigate(
        '/external_links/sites?page=' + this.model.page.id,
        {trigger: true}
      );
      return false;
    }
  },

  onRender: function() {
    this.subview(new pageflow.SortableCollectionView({
      el: this.ui.sites,
      collection: this.model.externalSiteReferences(),
      itemViewConstructor: pageflow.externalLinks.SiteReferenceItemView,
      itemViewOptions: {
        page: this.model.page
      }
    }));
  }
});
pageflow.externalLinks.SiteItemView = Backbone.Marionette.ItemView.extend({
  tagName: 'li',
  template: 'pageflow/external_links/editor/templates/site_item',

  mixins: [pageflow.loadable],

  ui: {
    title: '.title',
    selectButton: '.select',
    thumbnail: '.thumbnail'
  },

  events: {
    'click': function() {
      if (!this.model.isNew() && this.options.navigatable) {
        var query = this.options.page ? '/?page=' + this.options.page.id + '&return_to=sites' : '';
        pageflow.editor.navigate('/external_links/sites/' + this.model.get('id') + query, {trigger: true});
      }
      return false;
    },

    'click .select': function() {
      if (this.options.selectionHandler) {
        this.options.selectionHandler.call(this.model);

        if (this.options.referer) {
          pageflow.editor.navigate(this.options.referer, {trigger: true});
        }
      }
      return false;
    }
  },

  onRender: function() {
    this.update();

    this.subview(new pageflow.FileThumbnailView({
      el: this.ui.thumbnail,
      model: this.model.getReference('thumbnail', pageflow.imageFiles)
    }));
  },

  update: function() {
    this.$el.toggleClass('navigatable', !!this.options.navigatable);

    this.ui.title.text(this.model.get('title') || I18n.t('pageflow.external_links.editor.views.site_item_view.unknown'));
    this.ui.selectButton.toggle(!!this.options.selectionHandler);
  }
});
pageflow.externalLinks.SiteReferenceItemView = Backbone.Marionette.ItemView.extend({
  template: 'pageflow/external_links/editor/templates/site_reference_item',

  tagName: 'li',
  className: 'external_links_site_reference',

  ui: {
    thumbnail: '.thumbnail',
    title: '.title'
  },

  events: {
    'click .remove': function() {
      this.model.destroy();
      return false;
    },

    'click .edit': function() {
      pageflow.editor.navigate('/external_links/sites/' + this.model.get('site').id + '/?page=' + this.options.page.id + '&return_to=page', {trigger: true});
      return false;
    }
  },

  onRender: function() {
    this.subview(new pageflow.FileThumbnailView({
      el: this.ui.thumbnail,
      model: this.model.get('site').thumbnailFile()
    }));

    this.ui.title.text(this.model.get('site').get('title') || I18n.t('pageflow.external_links.editor.views.site_item_reference_view.unknown'));
  },
});
pageflow.externalLinks.SiteSelectionView = Backbone.Marionette.ItemView.extend({
  className: 'external_site_selection dialog',
  template: 'pageflow/external_links/editor/templates/site_selection',

  mixins: [pageflow.dialogView],

  ui: {
    items: 'ul'
  },

  onRender: function() {
    var view = this;

    pageflow.externalLinks.sites.ensureFetched();

    this.subview(new pageflow.CollectionView({
      el: this.ui.items,
      collection: pageflow.externalLinks.sites,
      itemViewConstructor: pageflow.externalLinks.SiteItemView,
      itemViewOptions: {
        selectionHandler: function() {
          view.options.onSelect(this);
          view.close();
        }
      },
      blankSlateViewConstructor: Backbone.Marionette.ItemView.extend({
        template: 'pageflow/external_links/editor/templates/sites_blank_slate'
      })
    }));
  }
});

pageflow.externalLinks.SiteSelectionView.selectSite = function() {
  return $.Deferred(function(deferred) {
    var view = new pageflow.externalLinks.SiteSelectionView({
      onSelect: deferred.resolve
    });

    view.on('close', function() {
      deferred.reject();
    });

    pageflow.app.dialogRegion.show(view.render());
  }).promise();
};
pageflow.externalLinks.SitesView = Backbone.Marionette.ItemView.extend({
  className: 'manage_external_sites',
  template: 'pageflow/external_links/editor/templates/sites',

  events: {
    'click .add': function() {
      var site = pageflow.externalLinks.sites.create({title: ''});
      var options = this.options;

      site.once('sync', function() {
        var query = options.page ? '/?page=' + options.page.id + '&return_to=sites' : '';
        pageflow.editor.navigate('external_links/sites/' + site.id + query, {trigger: true});
      });
    }
  },

  onRender: function() {
    pageflow.externalLinks.sites.ensureFetched();

    this.$el.append(this.subview(new pageflow.CollectionView({
      tagName: 'ul',
      className: 'external_sites',
      collection: pageflow.externalLinks.sites,
      itemViewConstructor: pageflow.externalLinks.SiteItemView,
      itemViewOptions: {
        navigatable: true,
        selectionHandler: this.options.selectionHandler,
        referer: this.options.referer,
        page: this.options.page
      },
      blankSlateViewConstructor: Backbone.Marionette.ItemView.extend({
        template: 'pageflow/external_links/editor/templates/sites_blank_slate'
      })
    })).el);
  }
});
pageflow.editor.registerPageConfigurationMixin(pageflow.externalLinks.pageConfigurationMixin);

pageflow.editor.registerSideBarRouting({
  router: pageflow.externalLinks.SidebarRouter,
  controller: pageflow.externalLinks.SidebarController
});

pageflow.editor.registerFileSelectionHandler('externalLinks.site', pageflow.externalLinks.SiteFileSelectionHandler);

pageflow.editor.registerMainMenuItem({
  translationKey: 'pageflow.external_links.manage_sites',
  path: '/external_links/sites'
});

pageflow.editor.addInitializer(function() {
  pageflow.externalLinks.sites = new pageflow.externalLinks.SitesCollection();
  pageflow.externalLinks.sites.ensureFetched();
});











pageflow.linkmapPage = pageflow.linkmapPage || {};

pageflow.linkmapPage.areaTypesFor = function(pageConfiguration) {
  return new Backbone.Collection(_([
    pageflow.linkmapPage.PageLinkAreaType,
    pageflow.linkmapPage.AudioFileAreaType,
    pageflow.linkmapPage.ExternalLinkAreaType,
    pageflow.linkmapPage.TextOnlyAreaType
  ]).map(function(constructor) {
    return new constructor({}, {
      pageConfiguration: pageConfiguration
    });
  }));
};
pageflow.linkmapPage.Area = Backbone.Model.extend({
  modelName: 'area',
  i18nKey: 'pageflow/linkmap_page/area',

  mixins: [pageflow.transientReferences],

  target: function() {
    // This should eventually be replaces with some sort of
    // polymorphic lookup for referenceable objects i.e.
    //
    //     pageflow.xxx.getPolymorphic(this.get('target_type'), this.get('target_id'));
    //
    if (this.get('target_type') === 'audio_file') {
      return pageflow.audioFiles.get(this.get('target_id'));
    }
    else if (this.get('target_type') === 'page') {
      return pageflow.pages.getByPermaId(this.get('target_id'));
    }
    else if (this.get('target_type') === 'external_site') {
      return pageflow.externalLinks.sites.getByPermaId(this.get('target_id'));
    }
  },

  targetPage: function() {
    return this.get('target_type') === 'page' ? this.target() : null;
  },

  title: function() {
    var target = this.target();
    return target ? target.title() : null;
  },

  thumbnailFile: function() {
    if (this.get('target_type') === 'text_only') {
      return this.textOnlyAreaPlaceholderFile();
    }

    var target = this.target();
    return target ? target.thumbnailFile() : null;
  },

  textOnlyAreaPlaceholderFile: function() {
    if (!pageflow.linkmapPage.Area.textOnlyAreaPlaceholderFile) {
      var file = new pageflow.AudioFile({
        state: 'encoded'
      });

      file.thumbnailPictogram = 'text_only';
      pageflow.linkmapPage.Area.textOnlyAreaPlaceholderFile = file;
    }

    return pageflow.linkmapPage.Area.textOnlyAreaPlaceholderFile;
  },

  label: function() {
    return this.get('name');
  },

  highlight: function() {
    this.set('highlighted', true);
  },

  resetHighlight: function() {
    this.unset('highlighted');
  },

  editPath: function() {
    var areaIndex = this.collection.indexOf(this);
    return '/linkmap_pages/' + this.getRoutableId() + '/areas/' + areaIndex;
  },

  getRoutableId: function() {
    return this.collection.page.id;
  },

  remove: function() {
    this.collection.remove(this);
  }
});
pageflow.linkmapPage.AreaFileSelectionHandler = function(options) {
  var page = pageflow.pages.get(options.id);
  var area = page.configuration.linkmapAreas(options.areasPropertyName).at(parseInt(options.areaIndex, 10));

  this.call = function(file) {
    area.setReference(options.attributeName, file);
  };

  this.getReferer = function() {
    return '/linkmap_pages/' + options.id + '/areas/' + options.areaIndex;
  };
};
pageflow.linkmapPage.AudioFileAreaType = Backbone.Model.extend({
  defaults: function() {
    return {
      label: I18n.t('pageflow.linkmap_page.editor.area_types.audio_file')
    };
  },

  initialize: function(attributes, options) {
    this.pageId = options.pageConfiguration.getRoutableId();
  },

  selected: function() {
    pageflow.editor.selectFile('audio_files', 'linkmapPage.newArea', {
      id: this.pageId
    });
  }
});
pageflow.linkmapPage.ExternalLinkAreaType = Backbone.Model.extend({
  defaults: function() {
    return {
      label: I18n.t('pageflow.linkmap_page.editor.area_types.external_site'),
    };
  },

  initialize: function(attributes, options) {
    this.areas = options.pageConfiguration.linkmapAreas();
  },

  selected: function() {
    var areas = this.areas;

    pageflow.externalLinks.selectSite().then(function(site) {
      areas.addExternalSite(site.get('perma_id'));
    });
  }
});
pageflow.linkmapPage.NewAreaFileSelectionHandler = function(options) {
  var page = pageflow.pages.get(options.id);

  this.call = function(file) {
    page.configuration.linkmapAreas().addAudioFile(file.id);
  };

  this.getReferer = function() {
    return '/pages/' + options.id + '/areas';
  };
};
pageflow.linkmapPage.pageConfigurationMixin = {
  linkmapPageLinks: function() {
    this._linkmapPageLinks = this._linkmapPageLinks || new pageflow.linkmapPage.PageLinksCollection({
      areas: this.linkmapAreas()
    });

    return this._linkmapPageLinks;
  },

  linkmapAreas: function() {
    var configuration = this;

    this._linkmapAreas = this._linkmapAreas || create();
    return this._linkmapAreas;

    function create() {
      var collection = new pageflow.linkmapPage.AreasCollection(
        configuration.get('linkmap_areas'),
        {
          page: configuration.page
        }
      );

      configuration.listenTo(collection, 'add remove change', function() {
        configuration.set('linkmap_areas', collection.map(function(area) {
          return _.omit(area.attributes, 'highlighted');
        }));
      });

      return collection;
    }
  }
};
pageflow.linkmapPage.PageLinkAreaType = Backbone.Model.extend({
  defaults: function() {
    return {
      label: I18n.t('pageflow.linkmap_page.editor.area_types.page')
    };
  },

  initialize: function(attributes, options) {
    this.areas = options.pageConfiguration.linkmapAreas();

    this.listenTo(this.areas, 'add remove', function() {
      this.updateDisabled();
    });

    this.updateDisabled();
  },

  updateDisabled: function() {
    this.set('disabled', !this.areas.canAddLink());
  },

  selected: function() {
    var areas = this.areas;

    pageflow.editor.selectPage().then(function(page) {
      areas.addLink(page.get('perma_id'));
    });
  }
});
pageflow.linkmapPage.TextOnlyAreaType = Backbone.Model.extend({
  defaults: function() {
    return {
      label: I18n.t('pageflow.linkmap_page.editor.area_types.text_only')
    };
  },

  initialize: function(attributes, options) {
    this.pageConfiguration = options.pageConfiguration;
  },

  selected: function() {
    this.pageConfiguration.linkmapAreas().addTextOnly();
  }
});
pageflow.linkmapPage.AreasCollection = Backbone.Collection.extend({
  model: pageflow.linkmapPage.Area,

  initialize: function(models, options) {
    this.page = options.page;
    this.defaultPosition = {
      left: 10,
      top: 10
    };
  },

  /**
   * @param [Object, Function] value
   */
  setDefaultPosition: function(value) {
    this.defaultPosition = value;
  },

  canAddLink: function() {
    return true;
  },

  addLink: function(targetPageId) {
    this.addWithPosition({
      target_type: 'page',
      target_id: targetPageId
    });
  },

  addAudioFile: function(audioFileId) {
    this.addWithPosition({
      target_type: 'audio_file',
      target_id: audioFileId
    });
  },

  addExternalSite: function(siteId) {
    this.addWithPosition({
      target_type: 'external_site',
      target_id: siteId
    });
  },

  addTextOnly: function() {
    this.addWithPosition({
      target_type: 'text_only'
    });
  },

  addWithPosition: function(attributes) {
    this.add(_.extend(
      {width: 7, height: 7},
      _.result(this, 'defaultPosition'),
      attributes
    ));
  }
});
pageflow.linkmapPage.PageLinksCollection = pageflow.SubsetCollection.extend({
  constructor: function(options) {
    this.areas = options.areas;

    pageflow.SubsetCollection.prototype.constructor.call(this, {
      parent: options.areas,

      filter: function(area) {
        return area.get('target_type') === 'page';
      }
    });
  },

  canAddLink: function() {
    return this.areas.canAddLink();
  },

  addLink: function(targetPageId) {
    this.areas.addLink(targetPageId);
  },

  updateLink: function(link, targetPageId) {
    link.set({target_id: targetPageId});
  },

  removeLink: function(link) {
    this.remove(link);
  },
});
pageflow.linkmapPage.SideBarRouter = Backbone.Marionette.AppRouter.extend({
  appRoutes: {
    'linkmap_pages/:pageId/areas/:index': 'area'
  }
});
pageflow.linkmapPage.SideBarController = Backbone.Marionette.Controller.extend({
  initialize: function(options) {
    this.region = options.region;
  },

  area: function(pageId, areaIndex) {
    var page = pageflow.pages.get(pageId);

    this.region.show(new pageflow.linkmapPage.EditAreaView({
      model: page.configuration.linkmapAreas().at(parseInt(areaIndex, 10)),
      page: page,
      areaIndex: areaIndex
    }));
  }
});
(function() { this.JST || (this.JST = {}); this.JST["pageflow/linkmap_page/editor/templates/edit_area"] = function(obj){var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('<a class="back">',  I18n.t('pageflow.linkmap_page.editor.templates.edit_area.back') ,'</a>\n<a class="destroy">',  I18n.t('pageflow.linkmap_page.editor.templates.edit_area.destroy') ,'</a>\n<div class="form_container"></div>\n');}return __p.join('');};
}).call(this);
(function() { this.JST || (this.JST = {}); this.JST["pageflow/linkmap_page/editor/templates/embedded/area_item"] = function(obj){var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('<div class="background_image visited_image" data-style-group="panorama"></div>\n<div class="background_image hover_image" data-style-group="panorama"></div>\n<div class="linkmap_marker"></div>\n<span class="area_type_pictogram"></span>\n<div class="linkmap_description">\n  <div class="link_title"></div>\n  <div class="link_description"></div>\n</div>\n<a class="toggle_marker" href="" title="',  I18n.t('pageflow.linkmap_page.editor.templates.embedded.area_item.toggle_marker') ,'">\n<a class="edit" href="" title="',  I18n.t('pageflow.linkmap_page.editor.templates.embedded.area_item.edit') ,'">\n</a>\n');}return __p.join('');};
}).call(this);
pageflow.linkmapPage.AreasListView = Backbone.Marionette.View.extend({
  className: 'linkmap_page_areas_list',

  render: function() {
    this.appendSubview(new pageflow.ListView({
      label: I18n.t('pageflow.linkmap_page.editor.views.areas_list.label'),
      collection: this.model.linkmapAreas(),
      highlight: true,

      onEdit: function(model) {
        pageflow.editor.navigate(model.editPath(), {trigger: true});
      },

      itemDescription: function(area) {
        return area.label();
      },

      itemTypeName: function(area) {
        return {
          'audio_file': 'audio',
          'page': 'internal_links_list',
          'external_site': 'external_links',
          'text_only': 'text_only'
        }[area.get('target_type')];
      },

      itemTypeDescription: function(area) {
        return I18n.t('pageflow.linkmap_page.editor.area_types.' + area.get('target_type'));
      },

      itemIsInvalid: function(area) {
        return !area.target() && area.get('target_type') !== 'text_only';
      },
    }));

    this.appendSubview(new pageflow.DropDownButtonView({
      sortable: true,
      label: I18n.t('pageflow.linkmap_page.editor.views.areas_list.add'),
      items: pageflow.linkmapPage.areaTypesFor(this.model)
    }));

    return this;
  }
});
pageflow.linkmapPage.ConfigurationEditorView = pageflow.ConfigurationEditorView.extend({
  configure: function() {
    this.tab('general', function() {
      this.input('title', pageflow.TextInputView, {required: true});
      this.input('tagline', pageflow.TextInputView);
      this.input('subtitle', pageflow.TextInputView);
      this.input('text', pageflow.TextAreaInputView);
      this.input('text_position', pageflow.SelectInputView, {values: pageflow.Page.textPositions});
      this.input('gradient_opacity', pageflow.SliderInputView);
      this.input('invert', pageflow.CheckBoxInputView);
    });

    this.tab('files', function() {
      this.input('background_type', pageflow.SelectInputView, {
        values: ['image', 'video', 'hover_video'],
        ensureValueDefined: true
      });

      this.input('panorama_image_id', pageflow.FileInputView, {
        collection: pageflow.imageFiles,
        positioning: true,
        visibleBinding: 'background_type',
        visible: function(backgroundType) {
          return _(['image', 'hover_video']).contains(backgroundType);
        }
      });

      this.input('panorama_video_id', pageflow.FileInputView, {
        collection: pageflow.videoFiles,
        positioning: true,
        visibleBinding: 'background_type',
        visibleBindingValue: 'video'
      });

      this.input('panorama_image_id', pageflow.FileInputView, {
        attributeTranslationKeyPrefixes: ['pageflow.linkmap_page.page_attributes.video_type'],
        collection: pageflow.imageFiles,
        positioning: false,
        visibleBinding: 'background_type',
        visibleBindingValue: 'video'
      });

      this.input('hover_image_id', pageflow.FileInputView, {
        collection: pageflow.imageFiles,
        positioning: false,
        visibleBinding: 'background_type',
        visible: function(backgroundType) {
          return _(['image', 'video']).contains(backgroundType);
        }
      });

      this.input('panorama_video_id', pageflow.FileInputView, {
        attributeTranslationKeyPrefixes: ['pageflow.linkmap_page.page_attributes.hover_video_type'],
        collection: pageflow.videoFiles,
        positioning: false,
        visibleBinding: 'background_type',
        visibleBindingValue: 'hover_video'
      });

      this.input('hover_image_id', pageflow.FileInputView, {
        attributeTranslationKeyPrefixes: ['pageflow.linkmap_page.page_attributes.hover_video_type'],
        collection: pageflow.imageFiles,
        positioning: false,
        visibleBinding: 'background_type',
        visibleBindingValue: 'hover_video'
      });

      this.input('visited_image_id', pageflow.FileInputView, {
        collection: pageflow.imageFiles,
        positioning: false
      });

      this.input('thumbnail_image_id', pageflow.FileInputView, {
        collection: pageflow.imageFiles,
        positioning: false
      });
    });

    this.tab('areas', function() {
      this.view(pageflow.linkmapPage.AreasListView, {
        model: this.model
      });

      this.view(pageflow.linkmapPage.EditableAreasModeView, {
        model: this.model.page
      });
    });

    this.tab('options', function() {
      this.group('options', {canPauseAtmo: true});
      this.input('limit_scrolling', pageflow.CheckBoxInputView);
      this.input('add_environment', pageflow.CheckBoxInputView);
      this.input('margin_scrolling_disabled', pageflow.CheckBoxInputView);
    });
  }
});
pageflow.linkmapPage.EditAreaView = Backbone.Marionette.Layout.extend({
  template: 'pageflow/linkmap_page/editor/templates/edit_area',

  regions: {
    formContainer: '.form_container'
  },

  ui: {
    backButton: 'a.back'
  },

  events: {
    'click a.back': 'goBack',

    'click a.destroy': 'destroy'
  },

  onRender: function() {
    var view = this;
    var area = this.model;
    var areaCollection = this.model.collection;
    var configurationEditor = new pageflow.ConfigurationEditorView({
      model: this.model
    });

    this.configure(configurationEditor);

    this.formContainer.show(configurationEditor);
    this.model.set('highlighted', true);
    this.model.collection.page.set('areas_editable', true);

    this.on('close', function() {
      area.unset('highlighted');
      areaCollection.page.unset('areas_editable');
    });
  },

  configure: function(configurationEditor) {
    var view = this;

    configurationEditor.tab('general', function() {
      this.input('name', pageflow.TextInputView);

      this.input('target_type', pageflow.SelectInputView, {
        values: ['page', 'external_site', 'audio_file', 'text_only'],
        ensureValueDefined: true
      });

      this.input('target_id', pageflow.PageLinkInputView, {
        visibleBinding: 'target_type',
        visibleBindingValue: 'page'
      });

      this.input('page_transition', pageflow.SelectInputView, {
        translationKeyPrefix: 'pageflow.page_transitions',
        includeBlank: true,
        blankTranslationKey: 'pageflow.linkmap_page.default_page_transition',
        values: pageflow.pageTransitions.names(),
        visibleBinding: 'target_type',
        visibleBindingValue: 'page'
      });

      this.input('target_id', pageflow.externalLinks.SiteReferenceInputView, {
        visibleBinding: 'target_type',
        visibleBindingValue: 'external_site'
      });

      this.input('target_id', pageflow.FileInputView, {
        collection: 'audio_files',
        fileSelectionHandler: 'linkmapPage.area',
        fileSelectionHandlerOptions: {
          areaIndex: view.options.areaIndex,
        },
        visibleBinding: 'target_type',
        visibleBindingValue: 'audio_file'
      });

      this.input('link_title', pageflow.TextInputView);
      this.input('link_description', pageflow.TextAreaInputView, {size: 'short'});
    });

    configurationEditor.tab('appearance', function() {
      this.input('marker', pageflow.SelectInputView, {values: pageflow.linkmapPage.toggleMarkerOptions});
      this.input('inverted', pageflow.CheckBoxInputView, {
        visibleBinding: 'target_type',
        visible: function(value) {
          return value !== 'text_only';
        }
      });
    });
  },

  destroy: function() {
    if (confirm(I18n.t('pageflow.linkmap_page.editor.views.edit_area_view.confirm_destroy'))) {
      this.model.remove();
      this.goBack();
    }
  },

  goBack: function() {
    pageflow.editor.navigate('/pages/' + this.options.page.id + '/areas', {trigger: true});
  }
});
pageflow.linkmapPage.EditableAreasModeView = Backbone.Marionette.View.extend({
  render: function() {
    this.model.set('areas_editable', true);
    return this;
  },

  onClose: function() {
    this.model.unset('areas_editable');
  }
});
pageflow.linkmapPage.AreaItemEmbeddedView = Backbone.Marionette.ItemView.extend({
  template: 'pageflow/linkmap_page/editor/templates/embedded/area_item',

  className: 'hover_area',

  ui: {
    hoverImage: '.hover_image',
    visitedImage: '.visited_image'
  },

  events: {
    'click .edit': function() {
      pageflow.editor.navigate(this.model.editPath(), {trigger: true});
      return false;
    },

    'click': function() {
      if (this.$el.is('.editable .hover_area')) {
        return false;
      }
    },

    'click .toggle_marker': function() {
      if (this.model.get('marker') === 'dynamic_marker') {
        this.model.set('marker', 'no_marker');
      }
      else {
        this.model.set('marker', 'dynamic_marker');
      }
    }
  },

  modelEvents: {
    change: 'update'
  },

  onRender: function() {
    this.setupImageViews();
    this.setupDraggableAndResizable();
    this.setupAudioPlayer();
    this.listenToEditable();

    this.update();
  },

  setupImageViews: function() {
    var hoverImageView = new pageflow.BackgroundImageEmbeddedView({
      el: this.ui.hoverImage,
      model: this.options.pageConfiguration,
      propertyName: 'hover_image_id'
    }).render();

    var visitedImageView = new pageflow.BackgroundImageEmbeddedView({
      el: this.ui.visitedImage,
      model: this.options.pageConfiguration,
      propertyName: 'visited_image_id'
    }).render();
  },

  setupDraggableAndResizable: function() {
    var that = this;
    var scroller = this.options.container.$('.scroller');

    this.$el.resizable({
      handles: 'n, e, s, w, ne, se, sw, nw',

      start: function() {
        that.$el.addClass('hover editing');
        scroller.scroller('disable');

      },

      stop: function(event, ui) {
        that.$el.removeClass('hover editing');
        savePositionAndSize();
        scroller.scroller('enable');
      }
    });

    this.$el.draggable({
      iframeFix: true,

      start: function() {
        that.$el.addClass('hover editing');
        scroller.scroller('disable');
      },

      drag: function(event, ui) {
        that.$el.linkmapAreaClip(ui.position);
      },

      stop: function(event, ui) {
        that.$el.removeClass('hover editing');
        scroller.scroller('enable');
        savePositionAndSize();
      }
    }).css('position', 'absolute');

    if (!this.options.page.get('areas_editable')) {
      this.$el.resizable('disable');
      this.$el.draggable('disable');
    }

    function savePositionAndSize() {
      var element = that.$el;

      that.model.set({
        left: parseInt(element.css('left'), 10) / (element.parent().width() / 100),
        top: parseInt(element.css('top'), 10) / (element.parent().height() / 100),
        width: parseInt(element.css('width'), 10) / (element.parent().width() / 100),
        height: parseInt(element.css('height'), 10) / (element.parent().height() / 100)
      });
    }
  },

  setupAudioPlayer: function() {
    this.$el.linkmapAudioPlayerControls();
  },

  listenToEditable: function() {
    this.listenTo(this.options.page, 'change:areas_editable', function(model, editable) {
      if (editable) {
        this.$el.resizable('enable');
        this.$el.draggable('enable');
      }
      else {
        this.$el.resizable('disable');
        this.$el.draggable('disable');
      }
    });
  },

  update: function() {
    var audioFileId = this.model.get('target_id');

    this.$el.attr('data-audio-file', audioFileId ? audioFileId + '.' + this.cid : '');
    this.$el.attr('data-target-type', this.model.get('target_type'));
    this.$el.attr('data-target-id', this.model.get('target_id'));
    this.$el.attr('data-page-transition', this.model.get('page_transition'));

    this.$el.toggleClass('highlighted', !!this.model.get('highlighted'));

    this.$el.attr('data-width', this.model.get('width'));
    this.$el.attr('data-height', this.model.get('height'));

    this.$el.css('left', this.model.get('left') + '%');
    this.$el.css('top', this.model.get('top') + '%');
    this.$el.css('width', this.model.get('width') + '%');
    this.$el.css('height', this.model.get('height') + '%');

    this.$el.toggleClass('portrait', this.$el.width() <= this.$el.height());
    this.$el.toggleClass('landscape', this.$el.width() > this.$el.height());

    _(['page', 'audio_file', 'external_site', 'text_only']).each(function(type) {
      this.$el.toggleClass(type + '_area', this.model.get('target_type') === type);
    }, this);

    var linkmapMarker = this.$el.find('.linkmap_marker');
    var margin = 32;

    if (this.$el.width() <= this.$el.height()) {
      linkmapMarker.css({
        'width': this.$el.width() - margin,
        'height': this.$el.width() - margin,
      });
    }
    else {
      linkmapMarker.css({
        'width': this.$el.height() - margin,
        'height': this.$el.height() - margin,
      });
    }

    var marker = this.model.get('marker');
    var element = this.$el;
    var that = this;

    var linkTitle = this.$el.find('.link_title');
    var linkDescription = this.$el.find('.link_description');

    linkTitle.html(this.model.get('link_title'));
    linkDescription.html(this.model.get('link_description'));

    _.forEach(pageflow.linkmapPage.toggleMarkerOptions, function(option) {
      element.toggleClass(option, that.model.get('marker') === option);
    });

    element.toggleClass('inverted', !!this.model.get('inverted'));
  }
});
pageflow.linkmapPage.AreasEmbeddedView = Backbone.Marionette.View.extend({
  render: function() {
    this.subview(new pageflow.CollectionView({
      el: this.$el,
      collection: this.model.linkmapAreas(this.options.propertyName),
      itemViewConstructor: pageflow.linkmapPage.AreaItemEmbeddedView,
      itemViewOptions: {
        pageConfiguration: this.model,
        page: this.model.page,
        container: this.options.container
      }
    }));

    this.listenTo(this.model.page, 'change:areas_editable', function() {
      this.updateClassName();
    });

    return this;
  },

  updateClassName: function() {
    var editable = this.model.page.get('areas_editable');

    this.$el.toggleClass('editable', !!editable);
  }
});
pageflow.linkmapPage.PanoramaEmbeddedView = Backbone.Marionette.View.extend({
  render: function() {
    this.listenTo(this.model.page, 'change:' + this.options.disableMarginScrollingPropertyName, function(model, disabled) {
      if (disabled) {
        this.$el.linkmapLookaround('disable');
      }
      else {
        this.$el.linkmapLookaround('enable');
      }
    });

    return this;
  }
});
pageflow.editor.pageTypes.register('linkmap_page', {
  configurationEditorView: pageflow.linkmapPage.ConfigurationEditorView,

  embeddedViews: {
    '.scroller': {
      view: pageflow.linkmapPage.PanoramaEmbeddedView,
      options: {
        disableMarginScrollingPropertyName: 'areas_editable'
      }
    },

    '.panorama_image': {
      view: pageflow.BackgroundImageEmbeddedView,
      options: {
        propertyName: 'panorama_image_id',
        dataSizeAttributes : true
      }
    },

    '.panorama_video': {
      view: pageflow.LazyVideoEmbeddedView,
      options: {
        propertyName: 'panorama_video_id',
        dataSizeAttributes: true
      }
    },

    '.linkmap_areas': {
      view: pageflow.linkmapPage.AreasEmbeddedView
    },

    '.fixed_background': {
      view: pageflow.BackgroundImageEmbeddedView,
      options: {propertyName: 'fixed_background_image_id'}
    }
  },

  pageLinks: function(configuration) {
    return configuration.linkmapPageLinks();
  }
});

pageflow.editor.registerPageConfigurationMixin(pageflow.linkmapPage.pageConfigurationMixin);

pageflow.editor.registerFileSelectionHandler('linkmapPage.area', pageflow.linkmapPage.AreaFileSelectionHandler);
pageflow.editor.registerFileSelectionHandler('linkmapPage.newArea', pageflow.linkmapPage.NewAreaFileSelectionHandler);

pageflow.editor.registerSideBarRouting({
  router: pageflow.linkmapPage.SideBarRouter,
  controller: pageflow.linkmapPage.SideBarController
});








pageflow.chart = pageflow.chart || {};
pageflow.chart.ScrapedSite = Backbone.Model.extend({
  modelName: 'scraped_site',
  paramRoot: 'scraped_site',

  initialize: function() {
    this.listenTo(this, 'sync', function() {
      if (this.isProcessing() && !this.pollingInterval) {
        this.pollUntilScraped();
      }
    });
  },

  urlRoot: function() {
    return '/chart/scraped_sites';
  },

  isProcessed: function() {
    return this.get('state') === 'processed';
  },

  isProcessing: function() {
    return this.get('state') === 'processing';
  },

  isFailed: function() {
    return this.get('state') === 'processing_failed';
  },

  pollUntilScraped: function() {
    var model = this;

    if (model.isProcessed()) {
      return;
    }

    model.pollingInterval = setInterval(poll, 1000);

    function stopPolling() {
      if (model.pollingInterval) {
        clearInterval(model.pollingInterval);
        model.pollingInterval = null;
      }
    }

    function poll() {
      model.fetch({
        success: function() {
          if (!model.isProcessing()) {
            stopPolling();
          }
        }
      });
    }
  }
});
pageflow.chart.ScrapedSitesCollection = Backbone.Collection.extend({
  model: pageflow.chart.ScrapedSite,

  name: 'scraped_sites',

  getOrFetch: function(id, options) {
    options = options || {};
    var model = this.get(id);

    if (model) {
      if (options.success) {
        options.success(model);
      }
    }
    else {
      model = new pageflow.chart.ScrapedSite({id: id});
      this.add(model);
      model.fetch(options);
    }

    return model;
  }
});
pageflow.chart.ScrapedUrlInputView = pageflow.UrlInputView.extend({
  template: 'pageflow/chart/editor/templates/url_input',

  regions: {
    statusContainer: '.status_container'
  },

  onLoad: function() {
    this.listenTo(this.model, 'change:' + this.options.propertyName, function() {
      this.updateScrapingStatus();
    });

    this.updateScrapingStatus();
  },

  transformPropertyValue: function(url) {
    return $.Deferred(function(deferred) {
      pageflow.chart.scrapedSites.create(
        {
          url: url
        },
        {
          success: function(scrapedSite) {
            deferred.resolve(scrapedSite.id);
          }
        }
      );
    }).promise();
  },

  updateScrapingStatus: function() {
    var scrapedSite = this.getScrapedSite();

    if (scrapedSite) {
      this.statusContainer.show(new pageflow.chart.ScrapedSiteStatusView({
        model: scrapedSite
      }));
    }
    else {
      this.statusContainer.close();
    }
  },

  getScrapedSite: function() {
    if (this.model.has(this.options.propertyName)) {
      return pageflow.chart.scrapedSites.getOrFetch(this.model.get(this.options.propertyName));
    }
  }
});
(function() { this.JST || (this.JST = {}); this.JST["pageflow/chart/editor/templates/datawrapper_ad"] = function(obj){var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('<form action="https://datawrapper.de/chart/create" method="POST" target="_blank">\n  <input type="hidden" name="theme" value="pageflow" />\n  <input type="submit" value="',  I18n.t('pageflow.chart.editor.templates.datawrapper_ad.create_chart') ,'" />\n</form>\n');}return __p.join('');};
}).call(this);
(function() { this.JST || (this.JST = {}); this.JST["pageflow/chart/editor/templates/scraped_site_status"] = function(obj){var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('<p class="processing state validation pending">',  I18n.t('pageflow.chart.editor.templates.scraped_site_status.pending') ,'</p>\n<p class="failed state validation failed">',  I18n.t('pageflow.chart.editor.templates.scraped_site_status.failed') ,'</p>\n');}return __p.join('');};
}).call(this);
(function() { this.JST || (this.JST = {}); this.JST["pageflow/chart/editor/templates/url_input"] = function(obj){var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('<label>\n  <span class="name"></span>\n  <span class="inline_help"></span>\n</label>\n<input type="text" />\n<div class="validation"></div>\n<div class="status_container"></div>\n');}return __p.join('');};
}).call(this);
pageflow.ConfigurationEditorView.register('chart', {
  configure: function() {
    var supportedHosts = this.options.pageType.supportedHosts;

    this.tab('general', function() {
      this.group('general');
    });

    this.tab('files', function() {
      this.input('scraped_site_id', pageflow.chart.ScrapedUrlInputView, {
        supportedHosts: supportedHosts,
        displayPropertyName: 'display_scraped_site_url',
        required: true
      });
      this.view(pageflow.chart.DatawrapperAdView);
      this.input('full_width', pageflow.CheckBoxInputView);
      this.input('background_image_id', pageflow.FileInputView, {collection: pageflow.imageFiles});
      this.input('thumbnail_image_id', pageflow.FileInputView, {
        collection: pageflow.imageFiles,
        imagePositioning: false
      });
    });

    this.tab('options', function() {
      this.group('options');
    });
  }
});
pageflow.chart.DatawrapperAdView = Backbone.Marionette.ItemView.extend({
  template: 'pageflow/chart/editor/templates/datawrapper_ad',
  className: 'datawrapper_ad'
});
pageflow.chart.IframeEmbeddedView = Backbone.Marionette.View.extend({
  modelEvents: {
    'change': 'update'
  },

  render: function() {
    this.updateScrapedSite();
    return this;
  },

  update: function() {
    if (this.model.hasChanged(this.options.propertyName)) {
      this.updateScrapedSite();
    }
  },

  updateScrapedSite: function() {
    var view = this;

    if (this.scrapedSite) {
      this.stopListening(this.scrapedSite);
    }

    var scrapedSiteId = this.model.get(this.options.propertyName);

    if (scrapedSiteId) {
      this.scrapedSite = pageflow.chart.scrapedSites.getOrFetch(scrapedSiteId, {
        success: function(scrapedSite) {
          view.updateAttributes(scrapedSite);
        }
      });

      this.listenTo(this.scrapedSite, 'change', this.updateAttributes);
    }
  },

  updateAttributes: function(scrapedSite) {
    scrapedSite = scrapedSite || this.scrapedSite;

    if (scrapedSite && scrapedSite.isProcessed()) {
      this.$el.attr('src', scrapedSite.get('html_file_url'));
      this.$el.attr('data-use-custom-theme', scrapedSite.get('use_custom_theme'));
    }
    else {
      this.$el.attr('src', '');
    }
  }
});
pageflow.chart.ScrapedSiteStatusView = Backbone.Marionette.ItemView.extend({
  template: 'pageflow/chart/editor/templates/scraped_site_status',
  className: 'scraped_site_status',

  modelEvents: {
    change: 'update'
  },

  onRender: function() {
    this.update();
  },

  update: function() {
    this.$el.toggleClass('processed', this.model.isProcessed());
    this.$el.toggleClass('failed', this.model.isFailed());
    this.$el.toggleClass('processing', this.model.isProcessing());
  }
});
pageflow.chart.scrapedSites = new pageflow.chart.ScrapedSitesCollection();












pageflow.ready.then(function() {
  _.extend(pageflow.Configuration.prototype.defaults, {gradient_opacity: 0});
});
